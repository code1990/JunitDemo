>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
第1章 引论
1．1 本书讨论的内容
1．2 数学知识复习
1．2．1 指数
1．2．2 对数
1．2．3 级数
1．2．4 模运算
1. 2．5 证明方法
1．3 递归简论
总结
练习
参考文献
第2章 算法分析
2．1 数学基础
2．2 模型
2．3 要分析的问题
2．4 运行时间计算
2．4．1 一个简单的例子
2．4．2 一般法则
2．4．3 最大子序列和问题的解
.2．4．4 运行时间中的对数
2．4．5 检验你的分析
2．4．6 分析结果的准确性
总结
练习
参考文献
第3章 表、栈和队列
3．1 抽象数据类型(adt)
3．2 表adt
3．2．1 表的简单数组实现
3．2．2 链表
3．2．3 程序设计细节
3．2．4 常见的错误
3．2．5 双链表
3．2．6 循环链表
3．2．7 例子
3．2．8 链表的游标实现
3．3 栈adt
3．3．1 栈模型
3．3．2 栈的实现
3．3．3 应用
3．4 队列adt
3．4．1 队列模型
3．4．2 队列的数组实现
3．4．3 队列的应用
总结
练习
第4章 树
4．1 预备知识
4．1．1 树的实现
4．1．2 树的遍历及应用
4．2 二叉树
4．2．1 实现
4．2．2 表达式树
4．3 查找树adt--二叉查找树
4．3．1 makeempty
4．3．2 find
4．3．3 findmin和findmax
4．3．4 insert
4．3．5 delere
4．3．6 平均情形分析
4．4 avl树
4．4．1 单旋转
4．4．2 双旋转
4．5 伸展树
4．5．1 一个简单的想法
4．5．2 展开
4．6 树的遍历
4．7 b-树
总结
练习
参考文献
第5章 散列
5．1 一般想法
5．2 散列函数
5．3 分离链接法
5．4 开放定址法
5．4．1 线性探测法
5．4．2 平方探测法
5．4．3 双散列
5．5 再散列
5．6 可扩散列
总结
练习
参考文献
第6章 优先队列(堆)
6．1 模型
6．2 一些简单的实现
6．3 二叉堆
6．3．1 结构性质
6．3．2 堆序性质
6．3．3 基本的堆操作
6．3．4 其他的堆操作
6．4 优先队列的应用
6．4．1 选择问题
6．4．2 事件模拟
6．5 d-堆
6．6 左式堆
6．6．1 左式堆的性质
6．6．2 左式堆的操作
6．7 斜堆
6．8 二项队列
6．8．1 二项队列结构
6．8．2 二项队列操作
6．8．3 二项队列的实现
总结
练习
参考文献
第7章 排序
7．1 预备知识
7．2 插入排序
7．2．1 算法
7．2．2 插入排序的分析
7．3 一些简单排序算法的下界
7. 4 希尔排序
7．4．1 希尔排序的最坏情形分析
7．5 堆排序
7．5．1 堆排序的分析
7．6 归并排序
7．6．1 归并排序的分析
7．7 快速排序
7．7．1 选取枢纽元
7．7．2 分割策略
7．7．3 小数组
7．7．4 实际的快速排序例程
7．7．5 快速排序的分析
7．7．6 选择的线性期望时间算法
7．8 大型结构的排序
7．9 排序的一般下界
7．9．1 决策树
7．10 桶式排序
7．11 外部排序
7．11．1 为什么需要新的算法
7．11．2 外部排序模型
7．11．3 简单算法
7．11．4 多路合并
7．11．5 多相合并
7．11．6 替换选择
总结
练习
参考文献
第8章 不相交集adt
8．1 等价关系
8．2 动态等价性问题
8．3 基本数据结构
8．4 灵巧求并算法
8．5 路径压缩
8．6 按秩求并和路径压缩的最坏情形
8．6．1 union／find算法分析
8．7 一个应用
总结
练习
参考文献
第9章 图论算法
9．1 若干定义
9．1．1 图的表示
9．2 拓扑排序
9．3 最短路径算法
9．3．1 无权最短路径
9．3．2 dijkstra算法
9．3．3 具有负边值的图
9．3．4 无圈图
9．3．5 所有点对最短路径
9．4 网络流问题
9．4．1 一个简单的最大流算法
9．5 最小生成树
9．5．1 prim算法
9．5．2 kruskal算法
9．6 深度优先搜索的应用
9．6．1 无向图
9．6．2 双连通性
9．6．3 欧拉回路
9．6．4 有向图
9．6．5 查找强分支
9．7 np-完全性介绍
9．7．1 难与易
9．7．2 np类
9．7．3 np-完全问题
总结
练习
参考文献
第10章 算法设计技巧
10．1 贪婪算法
10．1．1 一个简单的调度问题
10．1．2 huffman编码
10．1．3 近似装箱问题
10．2 分治算法
10．2．1 分治算法的运行时间
10．2．2 最近点问题
10．2．3 选择问题
10．2．4 一些运算问题的理论改进
10．3 动态规划
10．3．1 用一个表代替递归
10．3．2 矩阵乘法的顺序安排
10．3．3 最优二叉查找树
10．3．4 所有点对最短路径
10．4 随机化算法
10．4．1 随机数发生器
10．4．2 跳跃表
10．4．3 素性测试
10．5 回溯算法
10．5．1 收费公路重建问题
10．5．2 博弈
总结
练习
参考文献
第11章 摊还分析
11．1 一个无关的智力问题
11．2 二项队列
11．3 斜堆
11．4 斐波那契堆
11．4．1 切除左式堆中的节点
11．4．2 二项队列的懒惰合并
11．4．3 斐波那契堆操作
11．4．4 时间界的证明
11. 5 伸展树
总结
练习
参考文献
第12章 高级数据结构及其实现
12．1 自顶向下伸展树
12．2 红黑树
12．2．1 自底向上插入
12．2．2 自顶向下红黑树
12．2．3 自顶向下删除
12．3 确定性跳跃表
12．4 aa-树
12．5 treap树
12．6 k-d树
12．7 配对堆
总结
练习
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C陷阱与缺陷
第0章　导读
第1章　词法“陷阱”
1.1　=不同于==
1.2　& 和 | 不同于&& 和 ||
1.3　词法分析中的“贪心法”
1.4　整型常量
1.5　字符与字符串
第2章　语法“陷阱”
2.1　理解函数声明
2.2　运算符的优先级问题
2.3　注意作为语句结束标志的分号
2.4　switch语句
2.5　函数调用
2.6　“悬挂”else引发的问题
第3章　语义“陷阱”
3.1　指针与数组
3.2　非数组的指针
3.3　作为参数的数组声明
3.4　避免“举隅法”
3.5　空指针并非空字符串
3.6　边界计算与不对称边界
3.7　求值顺序
3.8　运算符&&、|| 和 !
3.9　整数溢出
3.10　为函数main提供返回值
第4章　连接
4.1　什么是连接器
4.2　声明与定义
4.3　命名冲突与static修饰符
4.4　形参、实参与返回值
4.5　检查外部类型
4.6　头文件
第5章　库函数
5.1　返回整数的getchar函数
5.2　更新顺序文件
5.3　缓冲输出与内存分配
5.4　使用errno检测错误
5.5　库函数signal
第6章　预处理器
6.1　不能忽视宏定义中的空格
6.2　宏并不是函数
6.3　宏并不是语句
6.4　宏并不是类型定义
第7章　可移植性缺陷
7.1　应对C语言标准变更
7.2　标识符名称的限制
7.3　整数的大小
7.4　字符是有符号整数还是无符号整数
7.5　移位运算符
7.6　内存位置0
7.7　除法运算时发生的截断
7.8　随机数的大小
7.9　大小写转换
7.10　首先释放，然后重新分配
7.11　可移植性问题的一个例子
第8章　建议与答案
8.1　建议
8.2　答案
附录A　PRINTF，VARARGS与STDARG
附录B　Koenig和Moo夫妇访谈
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C陷阱与缺陷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计语言
出版者的话
专家指导委员会
中文版序
译者序
校译者简介
序
第1版序
引言
第1章 导言
1.1 入门
1.2 变量与算术表态式
1.3 for语句
1.4 符号常量
1.5 字符输入/输出
1.6 数组
1.7 函数
1.8 参数——传值调用
1.9 字符数组
1.10 外部变量与作用域
第2章 类型、运算符与表达式
2.1 变量名
2.2 数据类型及长度
2.3 常量
2.4 声明
2.5 算术运算符
2.6 关系运算符与逻辑运算符
2.7 类型转换
2.8 自增运算符与自减运算符
2.9 按位运算符
2.10 赋值运算符与表达式
2.11 条件表达式
2.12 运算符优先级与求值次序
第3章 控制流
3.1 语句与程序块
3.2 if-else语句
3.3 else-if语句
3.4 switch语句
3.5 whil循环与for特环
3.6 do-while循环
3.7 break语句与continue语句
3.8 goto语句与标号
第4章 涵数与程序结构
第5章 指针与数组
第6章 结构
第7章 输入与输出
第8章 UNIX系统接口
附录A 参考手册
附录B 标准库
附录C 变更小结
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>现代编译原理
第一部分 编译基本原理
第1章 绪论
1.1 模块与接口
1.2 工具和软件
1.3 树语言的数据结构
程序设计：直线式程序解释器
推荐阅读
习题
第2章 词法分析
2.1 词法单词
2.2 正则表达式
2.3 有限自动机
2.4 非确定有限自动机
2.4.1 将正则表达式转换为NFA
2.4.2 将NFA转换为DFA
2.5 Lex：词法分析器的生成器
程序设计：词法分析
推荐阅读
习题
第3章 语法分析
3.1 上下文无关文法
3.1.1 推导
3.1.2 语法分析树
3.1.3 二义性文法
3.1.4 文件结束符
3.2 预测分析
3.2.1 FIRST集合和FOLLOW集合
3.2.2 构造一个预测分析器
3.2.3 消除左递归
3.2.4 提取左因子
3.2.5 错误恢复
3.3 LR分析
3.3.1 LR分析引擎
3.3.2 LR(0)分析器生成器
3.3.3 SLR分析器的生成
3.3.4 LR(1)项和LR(1)分析表
3.3.5 LALR(1)分析表
3.3.6 各类文法的层次
3.3.7 二义性文法的LR分析
3.4 使用分析器的生成器
3.4.1 冲突
3.4.2 优先级指导
3.4.3 语法和语义
3.5 错误恢复
3.5.1 用error符号恢复
3.5.2 全局错误修复
程序设计：语法分析
推荐阅读
习题
第4章 抽象语法
4.1 语义动作
4.1.1 递归下降
4.1.2 Yacc生成的分析器
4.1.3 语义动作的解释器
4.2 抽象语法分析树
4.2.1 位置
4.2.2 Tiger的抽象语法
程序设计：抽象语法
推荐阅读
习题
第5章 语义分析
5.1 符号表
5.1.1 多个符号表
5.1.2 高效的命令式风格符号表
5.1.3 高效的函数式符号表
5.1.4 Tiger编译器的符号
5.1.5 函数式风格的符号表
5.2 Tiger编译器的绑定
5.3 表达式的类型检查
5.4 声明的类型检查
5.4.1 变量声明
5.4.2 类型声明
5.4.3 函数声明
5.4.4 递归声明
程序设计：类型检查
习题
第6章 活动记录
6.1 栈帧
6.1.1 帧指针
6.1.2 寄存器
6.1.3 参数传递
6.1.4 返回地址
6.1.5 栈帧内的变量
6.1.6 静态链
6.2 Tiger编译器的栈帧
6.2.1 栈帧描述的表示
6.2.2 局部变量
6.2.3 计算逃逸变量
6.2.4 临时变量和标号
6.2.5 两层抽象
6.2.6 管理静态链
6.2.7 追踪层次信息
程序设计：栈帧
推荐阅读
习题
第7章 翻译成中间代码
7.1 中间表示树
7.2 翻译为树中间语言
7.2.1 表达式的种类
7.2.2 简单变量
7.2.3 追随静态链
7.2.4 数组变量
7.2.5 结构化的左值
7.2.6 下标和域选择
7.2.7 关于安全性的劝告
7.2.8 算术操作
7.2.9 条件表达式
7.2.10 字符串
7.2.11 记录和数组的创建
7.2.12 while循环
7.2.13 for循环
7.2.14 函数调用
7.3 声明
7.3.1 变量定义
7.3.2 函数定义
7.3.3 片段
程序设计：翻译成树
习题
第8章 基本块和轨迹
8.1 规范树
8.1.1 ESEQ的转换
8.1.2 一般重写规则
8.1.3 将CALL移到顶层
8.1.4 线性语句表
8.2 处理条件分支
8.2.1 基本块
8.2.2 轨迹
8.2.3 完善
8.2.4 最优轨迹
推荐阅读
习题
第9章 指令选择
9.1 指令选择算法
9.1.1 Maximal Munch算法
9.1.2 动态规划
9.1.3 树文法
9.1.4 快速匹配
9.1.5 覆盖算法的效率
9.2 CISC机器
9.3 Tiger编译器的指令选择
9.3.1 抽象的汇编语言指令
9.3.2 生成汇编指令
9.3.3 过程调用
9.3.4 无帧指针的情形
程序设计：指令选择
推荐阅读
习题
第10章 活跃分析
10.1 数据流方程的解
10.1.1 活跃性计算
10.1.2 集合的表示
10.1.3 时间复杂度
10.1.4 最小不动点
10.1.5 静态活跃性与动态活跃性
10.1.6 冲突图
10.2 Tiger编译器的活跃分析
10.2.1 图
10.2.2 控制流图
10.2.3 活跃分析
程序设计：构造流图
程序设计：活跃分析模块
习题
第11章 寄存器分配
11.1 通过简化进行着色
11.2 合并
11.3 预着色的结点
11.3.1 机器寄存器的临时副本
11.3.2 调用者保护的寄存器和被调用者保护的寄存器
11.3.3 含预着色结点的例子
11.4 图着色的实现
11.4.1 传送指令工作表的管理
11.4.2 数据结构
11.4.3 程序代码
11.5 针对树的寄存器分配
程序设计：图着色
推荐阅读
习题
第12章 整合为一体
程序设计：过程入口/出口
程序设计：创建一个可运行的编译器
第二部分 高级主题
第13章 垃圾收集
13.1 标记-清扫式收集
13.2 引用计数
13.3 复制式收集
13.4 分代收集
13.5 增量式收集
13.6 Baker算法
13.7 编译器接口
13.7.1 快速分配
13.7.2 数据布局的描述
13.7.3 导出指针
程序设计：描述字
程序设计：垃圾收集
推荐阅读
习题
第14章 面向对象的语言
14.1 类
14.2 数据域的单继承性
14.3 多继承性
14.4 测试类成员关系
14.5 私有域和私有方法
14.6 无类语言
14.7 向对象程序的优化
程序设计：OBJECT Tiger
推荐阅读
习题
第15章 函数式程序设计语言
15.1 一个简单的函数式语言
15.2 闭包
15.3 不变的变量
15.3.1 基于延续的……I/O226
15.3.2 语言上的变化
15.3.3 纯函数式语言的优化
15.4 内联扩展
15.5 闭包变换
15.6 高效的尾递归
15.7 懒惰计算
15.7.1 传名调用计算
15.7.2 按需调用
15.7.3 懒惰程序的计算
15.7.4 懒惰函数式程序的优化
15.7.5 严格性分析
推荐阅读
程序设计：编译函数式语言
习题
第16章 多态类型
16.1 参数多态性
16.1.1 显式带类型的多态语言
16.1.2 多态类型的检查
16.2 类型推论
16.2.1 一个隐式类型的多态语言
16.2.2 类型推论算法
16.2.3 递归的数据类型
16.2.4 Hindley Milner类型的能力
16.3 多态变量的表示
16.3.1 多态函数的扩展
16.3.2 完全的装箱转换
16.3.3 基于强制的表示分析
16.3.4 将类型作为运行时参数传递
16.4 静态重载的解决方法
推荐阅读
习题
第17章 数据流分析
17.1 流分析使用的中间表示
17.2 各种数据流分析
17.2.1 到达定值
17.2.2 可用表达式
17.2.3 到达表达式
17.2.4 活跃分析
17.3 使用数据流分析结果的几种转换
17.3.1 公共子表达式删除
17.3.2 常数传播
17.3.3 复写传播
17.3.4 死代码删除
17.4 加快数据流分析
17.4.1 位向量
17.4.2 基本块
17.4.3 结点排序
17.4.4 使用-定值链和定值-使用链
17.4.5 工作表算法
17.4.6 增量式数据流分析
17.5 别名分析
17.5.1 基于类型的别名分析
17.5.2 基于流的别名分析
17.5.3 使用可能别名信息
17.5.4 严格的纯函数式语言中的别名分析
推荐阅读
习题
第18章 循环优化
18.1 必经结点
18.1.1 寻找必经结点的算法
18.1.2 直接必经结点
18.1.3 循环
18.1.4 循环前置结点
18.2 循环不变量计算
18.3 归纳变量
18.3.1 发现归纳变量
18.3.2 强度削弱
18.3.3 删除
18.3.4 重写比较
18.4 数组边界检查
18.5 循环展开
推荐阅读
习题
第19章 静态单赋值形式
19.1 转化为SSA形式
19.1.1 插入Φ函数的标准
19.1.2 必经结点边界
19.1.3 插入Φ函数
19.1.4 变量重命名
19.1.5 边分割
19.2 必经结点树的高效计算
19.2.1 深度优先生成树
19.2.2 半必经结点
19.2.3 Lengauer Tarjan算法
19.3 使用SSA的优化算法
19.3.1 死代码删除
19.3.2 简单的常数传播
19.3.3 条件常数传播
19.3.4 保持必经结点性质
19.4 数组、指针和存储器
19.5 控制依赖图
19.6 从SSA形式转变回来
19.7 函数式中间形式
推荐阅读
习题
第20章 流水和调度
20.1 没有资源约束时的循环调度
20.2 有资源约束的循环流水
20.2.1 模调度
20.2.2 寻找最小的启动间距
20.2.3 其他控制流
20.2.4 编译器应该调度指令吗
20.3 分支预测
20.3.1 静态分支预测
20.3.2 编译器应该预测分支吗
推荐阅读
习题
第21章 存储层次
21.1 cache的组织结构
21.2 cache块对齐
21.3 预取
21.4 循环交换
21.5 分块
21.6 垃圾收集和存储层次
推荐阅读
习题
附录 Tiger语言参考手册
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>现代编译原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
一 胎膜
二 降落伞
三 坠毁
四 呼叫
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C标准库
第0章　简介. 1
0.1　背景知识1
0.2　C 标准的内容 3
0.3　库的使用7
0.4　库的实现9
0.5　库的测试13
0.6　参考文献15
0.7　习题15
第1章　(assert.h)17
1.1　背景知识17
1.2　C 标准的内容18
1.3　(assert.h) 的使用18
1.4　(assert.h) 的实现20
1.5　(assert.h) 的测试22
1.6　参考文献23
1.7　习题23
第2章　(ctype.h) 25
2.1　背景知识25
2.2　C 标准的内容28
2.3　(ctype.h) 的使用 30
2.4　(ctype.h) 的实现 34
2.5　(ctype.h) 的测试 42
2.6　参考文献45
2.7　习题45
第3章　(errno.h) 47
3.1　背景知识47
3.2　C 标准的内容50
3.3　(errno.h) 的使用 50
3.4　(errno.h) 的实现 51
3.5　(errno.h) 的测试 55
3.6　参考文献55
3.7　习题55
第4章　(float.h)57
4.1　背景知识57
4.2　C 标准的内容59
4.3　(float.h) 的使用.62
4.4　(float.h) 的实现.64
4.5　(float.h) 的测试.69
4.6　参考文献71
4.7　习题72
第5章　(limits.h)73
5.1　背景知识73
5.2　C 标准的内容74
5.3　(limits.h) 的使用75
5.4　(limits.h) 的实现77
5.5　(limits.h) 的测试79
5.6　参考文献80
5.7　习题80
第6章　(locale.h)81
6.1　背景知识81
6.2　C 标准的内容84
6.3　(locale.h) 的使用87
6.4　(locale.h) 的实现94
6.5　(locale.h) 的测试 123
6.6　参考文献.123
6.7　习题123
第7章　(math.h)127
7.1　背景知识.127
7.2　C 标准的内容 130
7.3　(math.h) 的使用 135
7.4　(math.h) 的实现 137
7.5　(math.h) 的测试 171
7.6　参考文献.177
7.7　习题177
第8章　(setjmp.h).. 181
8.1　背景知识.181
8.2　C 标准的内容 184
8.3　(setjmp.h) 的使用 185
8.4　(setjmp.h) 的实现 187
8.5 (setjmp.h) 的测试191
8.6 参考文献 192
8.7 习题 192
第9章　(signal.h) 193
9.1　背景知识.193
9.2　C 标准的内容 195
9.3　(signal.h) 的使用 197
9.4　(signal.h) 的实现 199
9.5　(signal.h) 的测试 203
9.6　参考文献.203
9.7　习题203
第10章　(stdarg.h) 205
10.1　背景知识205
10.2　C 标准的内容 207
10.3　(stdarg.h) 的使用 208
10.4　(stdarg.h) 的实现 211
10.5　(stdarg.h) 的测试 212
10.6　参考文献212
10.7　习题.214
第11章　(stddef.h) 215
11.1　背景知识 215
11.2　C 标准的内容 217
11.3　(stddef.h) 的使用 217
11.4　(stddef.h) 的实现 222
11.5　(stddef.h) 的测试 223
11.6　参考文献 223
11.7　习题223
第12章　(stdio.h) 225
12.1　背景知识225
12.2　C 标准的内容 233
12.3　(stdio.h) 的使用 252
12.4　(stdio.h) 的实现 274
12.5　(stdio.h) 的测试 323
12.6　参考文献325
12.7　习题.325
第13章　(stdlib.h) 331
13.1　背景知识331
13.2　C 标准的内容 332
13.3　(stdlib.h) 的使用 342
13.4　(stdlib.h) 的实现 351
13.5　(stdlib.h) 的测试 379
13.6　参考文献379
13.7　习题.382
第14章　(string.h) 385
14.1　背景知识385
14.2　C 标准的内容 386
14.3　(string.h) 的使用 392
14.4　(string.h) 的实现 396
14.5　(string.h) 的测试 409
14.6　参考文献409
14.7　习题.409
第15章　(time.h) 413
15.1　背景知识413
15.2　C 标准的内容 414
15.3　(time.h) 的使用 418
15.4　(time.h) 的实现 422
15.5　(time.h) 的测试440
15.6　参考文献441
15.7　习题.441
附录A　接口 443
附录B　名字 451
附录C　术语... 461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C标准库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法精解
1. 前言
2. 第1部分 预备知识
3. 第1章 概述
4. 数据结构简介
5. 算法简介
6. 小酌软件工程
7. 如何使用本书
8. 第2章 指针操作
9. 指针基础
10. 存储空间分配
11. 数据集合与指针的算术运算
12. 作为函数参数的指针
13. 泛型指针与类型转换
14. 函数指针
15. 问与答
16. 相关主题
17. 第3章 递归
18. 基本递归
19. 尾递归
20. 问与答
21. 相关主题
22. 第4章 算法分析
23. 最坏情况分析
24. O表示法
25. 计算的复杂度
26. 实例分析：插入排序
27. 问与答
28. 相关主题
29. 第2部分 数据结构
30. 第5章 链表
31. 单链表介绍
32. 单链表接口的定义
33. 单链表的实现与分析
34. 使用链表的例子：页帧管理
35. 双向链表介绍
36. 双向链表接口的定义
37. 双向链表的实现与分析
38. 循环链表介绍
39. 循环链表接口的定义
40. 循环链表的实现与分析
41. 使用循环链表的例子：第二次机会页面置换法
42. 问与答
43. 相关主题
44. 第6章 栈和队列
45. 栈的描述
46. 栈的接口定义
47. 栈的实现与分析
48. 队列的描述
49. 队列的接口定义
50. 队列的实现与分析
51. 队列示例：事件处理
52. 问与答
53. 相关主题
54. 第7章 集合
55. 集合介绍
56. 集合的性质
57. 集合接口的定义
58. 集合抽象数据类型的实现和分析
59. Set示例：集合覆盖
60. 问与答
61. 相关主题
62. 第8章 哈希表
63. 链式哈希表的描述
64. 链式哈希表的接口定义
65. 链式哈希表的实现与分析
66. 链式哈希表的例子：符号表
67. 开地址哈希表的描述
68. 开地址哈希函数的接口定义
69. 开地址哈希表的实现与分析
70. 问与答
71. 相关主题
72. 第9章 树
73. 二叉树介绍
74. 二叉树的接口定义
75. 二叉树的实现与分析
76. 二叉树示例：表达式处理
77. 二叉搜索树介绍
78. 二叉搜索树的接口定义
79. 二叉搜索树的实现与分析
80. 问与答
81. 相关主题
82. 第10章 堆和优先队列
83. 堆的描述
84. 堆的接口定义
85. 堆的实现与分析
86. 优先队列的描述
87. 优先队列的接口定义
88. 优先队列的实现与分析
89. 优先队列的示例：包裹分拣
90. 问与答
91. 相关主题
92. 第11章 图
93. 图的描述
94. 图的接口定义
95. 图的实现与分析
96. 关于图的应用举例：计算网络跳数
97. 关于图的应用举例：拓扑排序
98. 问与答
99. 相关主题
100. 第3部分 算法
101. 第12章 排序和搜索
102. 插入排序的描述
103. 插入排序的接口定义
104. 插入排序的实现与分析
105. 快速排序的描述
106. 快速排序的接口定义
107. 快速排序的实现与分析
108. 快速排序的例子：目录列表
109. 归并排序的描述
110. 归并排序的接口定义
111. 归并排序的实现与分析
112. 计数排序的描述
113. 计数排序的接口定义
114. 计数排序的实现与分析
115. 基数排序的描述
116. 基数排序的接口定义
117. 基数排序的实现与分析
118. 二分查找的描述
119. 二分查找的接口定义
120. 二分查找的实现与分析
121. 二分查找的例子：拼写检查器
122. 问与答
123. 相关主题
124. 第13章 数值计算
125. 多项式插值法
126. 多项式插值的接口定义
127. 多项式插值的实现与分析
128. 最小二乘估计法
129. 最小二乘估计的接口定义
130. 最小二乘估计的实现和分析
131. 方程求解介绍
132. 方程求解的接口定义
133. 方程求解的实现与分析
134. 问与答
135. 相关主题
136. 第14章 数据压缩
137. 位操作的描述
138. 位操作的接口定义
139. 位操作的实现与分析
140. 霍夫曼编码的描述
141. 霍夫曼编码的接口定义
142. 霍夫曼编码的分析与实现
143. 霍夫曼编码的例子：网络优化
144. LZ77的描述
145. LZ77的接口定义
146. LZ77的实现与分析
147. 问与答
148. 相关主题
149. 第15章 数据加密
150. DES算法介绍
151. DES的接口定义
152. DES算法的实现和分析
153. DES应用举例：分组加密模式
154. RSA算法介绍
155. RSA的接口定义
156. RSA算法的实现与分析
157. 问与答
158. 相关主题
159. 第16章 图算法
160. 最小生成树的描述
161. 最小生成树的接口定义
162. 最小生成树的实现与分析
163. 最短路径的描述
164. 最短路径的接口定义
165. 最短路径的实现与分析
166. 最短路径的例子：路由表
167. 旅行商问题的描述
168. 旅行商问题的接口定义
169. 旅行商问题的实现与分析
170. 问与答
171. 相关主题
172. 第17章 几何算法
173. 测试线段是否相交
174. 测试线段是否相交的标准方法
175. 检测线段是否相交的接口定义
176. 检测线段是否相交的实现与分析
177. 凸包简介
178. Jarvis’s March
179. 凸包的接口定义
180. 凸包的实现与分析
181. 球面弧长
182. 求解球面弧长的接口定义
183. 求解球面弧长的实现和分析
184. 球面弧长的应用举例：地球上两点之间的近似距离
185. 问与答
186. 相关主题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C专家编程
第1章 C：穿越时空的迷雾
1.1 C语言的史前阶段
1.2 C语言的早期体验
1.3 标准I/O库和C预处理器
1.4 K&R C
1.5 今日之ANSI C
1.6 它很棒，但它符合标准吗
1.7 编译限制
1.8 ANSI C标准的结构
1.9 阅读ANSI C标准，寻找乐趣和裨益
1.10 “安静的改变”究竟有多少安静
1.11 轻松一下——由编译器定义的Pragmas效果
第2章 这不是Bug，而是语言特性
2.1 这关语言特性何事，在Fortran里这就是Bug呀
2.2 多做之过
2.3 误做之过
2.4 少做之过
2.5 轻松一下——有些特性确实就是Bug
2.6 参考文献
第3章 分析C语言的声明
3.1 只有编译器才会喜欢的语法
3.2 声明是如何形成的
3.3 优先级规则
3.4 通过图表分析C语言的声明
3.5 typedef可以成为你的朋友
3.6 typedef int x[10]和#define x int[10]的区别
3.7 typedef struct foo{ ... foo; }的含义
3.8 理解所有分析过程的代码段
3.9 轻松一下——驱动物理实体的软件
第4章 令人震惊的事实：数组和指针并不相同
4.1 数组并非指针
4.2 我的代码为什么无法运行
4.3 什么是声明，什么是定义
4.4 使声明与定义相匹配
4.5 数组和指针的其他区别
4.6 轻松一下——回文的乐趣
第5章 对链接的思考
5.1 函数库、链接和载入
5.2 动态链接的优点
5.3 函数库链接的5个特殊秘密
5.4 警惕Interpositioning
5.5 产生链接器报告文件
5.6 轻松一下——看看谁在说话：挑战Turing测验
第6章 运动的诗章：运行时数据结构
6.1 a.out及其传说
6.2 段
6.3 操作系统在a.out文件里干了些什么
6.4 C语言运行时系统在a.out里干了些什么
6.5 当函数被调用时发生了什么：过程活动记录
6.6 auto和static关键字
6.7 控制线程
6.8 setjmp和longjmp
6.9 UNIX中的堆栈段
6.10 MS-DOS中的堆栈段
6.11 有用的C语言工具
6.12 轻松一下——卡耐基-梅隆大学的编程难题
6.13 只适用于高级学员阅读的材料
第7章 对内存的思考
7.1 Intel 80x86系列
7.2 Intel 80x86内存模型以及它的工作原理
7.3 虚拟内存
7.4 Cache存储器
7.5 数据段和堆
7.6 内存泄漏
7.7 总线错误
7.8 轻松一下——“Thing King”和“页面游戏”
第8章 为什么程序员无法分清万圣节和圣诞节
8.1 Portzebie度量衡系统
8.2 根据位模式构筑图形
8.3 在等待时类型发生了变化
8.4 原型之痛
8.5 原型在什么地方会失败
8.6 不需要按回车键就能得到一个字符
8.7 用C语言实现有限状态机
8.8 软件比硬件更困难
8.9 如何进行强制类型转换，为何要进行类型强制转换
8.10 轻松一下——国际C语言混乱代码大赛
第9章 再论数组
9.1 什么时候数组与指针相同
9.2 为什么会发生混淆
9.3 为什么C语言把数组形参当作指针
9.4 数组片段的下标
9.5 数组和指针可交换性的总结
9.6 C语言的多维数组
9.7 轻松一下——软件/硬件平衡
第10章 再论指针
10.1 多维数组的内存布局
10.2 指针数组就是Iliffe向量
10.3 在锯齿状数组上使用指针
10.4 向函数传递一个一维数组
10.5 使用指针向函数传递一个多维数组
10.6 使用指针从函数返回一个数组
10.7 使用指针创建和使用动态数组
10.8 轻松一下——程序检验的限制
第11章 你懂得C，所以C++不在话下
11.1 初识OOP
11.2 抽象——取事物的本质特性
11.3 封装——把相关的类型、数据和函数组合在一起
11.4 展示一些类——用户定义类型享有和预定义类型一样的权限
11.5 访问控制
11.6 声明
11.7 如何调用成员函数
11.8 继承——复用已经定义的操作
11.9 多重继承——从两个或更多的基类派生
11.10 重载——作用于不同类型的同一操作具有相同的名字
11.11 C++如何进行操作符重载
11.12 C++的输入/输出(I/O)
11.13 多态——运行时绑定
11.14 解释
11.15 C++如何表现多态
11.16 新奇玩意——多态
11.17 C++的其他要点
11.18 如果我的目标是那里，我不会从这里起步
11.19 它或许过于复杂，但却是惟一可行的方案
11.20 轻松一下——死亡计算机协会
11.21 更多阅读材料
附录A 程序员工作面试的秘密
附录B 术语表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C专家编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高质量程序设计指南
第1章  高质量软件开发之道	11.1  软件质量基本概念	11.1.1  如何理解软件的质量	11.1.2  提高软件质量的基本方法	31.1.3  “零缺陷”理念	41.2  细说软件质量属性	41.2.1  正确性	41.2.2  健壮性	51.2.3  可靠性	51.2.4  性能	61.2.5  易用性	71.2.6  清晰性	71.2.7  安全性	71.2.8  可扩展性	81.2.9  兼容性	81.2.10  可移植性	81.3  人们关注的不仅仅是质量	91.3.1  质量、生产率和成本之间的关系	91.3.2  软件过程改进的基本概念	111.4  高质量软件开发的基本方法	131.4.1  建立软件过程规范	131.4.2  复用	151.4.3  分而治之	161.4.4  优化与折中	171.4.5  技术评审	181.4.6  测试	191.4.7  质量保证	211.4.8  改错	221.5  关于软件开发的一些常识和思考	241.5.1  有最好的编程语言吗	241.5.2  编程是一门艺术吗	241.5.3  编程时应该多使用技巧吗	241.5.4  换更快的计算机还是换更快的算法	251.5.5  错误是否应该分等级	251.5.6  一些错误的观念	251.6  小结	26第2章  编程语言发展简史	272.1  编程语言大事记	272.2  Ada的故事	302.3  C/C++发展简史	312.4  Borland与Microsoft之争	322.5  Java阵营与Microsoft的较量	332.6  小结	36第3章  程序的基本概念	373.1  程序设计语言	373.2  语言实现	383.3  程序库	403.4  开发环境	403.5  程序的工作原理	413.6  良好的编程习惯	42第4章  C++/C程序设计入门	454.1  C++/C程序的基本概念	454.1.1  启动函数main()	454.1.2  命令行参数	474.1.3  内部名称	484.1.4  连接规范	494.1.5  变量及其初始化	514.1.6  C Runtime Library	524.1.7  编译时和运行时的不同	524.1.8  编译单元和独立编译技术	544.2  基本数据类型和内存映像	544.3  类型转换	564.3.1  隐式转换	564.3.2  强制转换	584.4  标识符	604.5  转义序列	614.6  运算符	624.7  表达式	634.8  基本控制结构	654.9  选择（判断）结构	654.9.1  布尔变量与零值比较	664.9.2  整型变量与零值比较	674.9.3  浮点变量与零值比较	674.9.4  指针变量与零值比较	694.9.5  对if语句的补充说明	704.9.6  switch结构	704.10   循环（重复）结构	714.10.1  for语句的循环控制变量	724.10.2  循环语句的效率	734.11  结构化程序设计原理	784.12  goto/continue/break语句	794.13  示例	80第5章  C++/C常量	855.1  认识常量	855.1.1  字面常量	855.1.2  符号常量	865.1.3  契约性常量	875.1.4  枚举常量	875.2  正确定义符号常量	875.3  const与#define的比较	885.4  类中的常量	895.5  实际应用中如何定义常量	90第6章  C++/C函数设计基础	956.1  认识函数	956.2  函数原型和定义	966.3  函数调用方式	976.4  认识函数堆栈	996.5  函数调用规范	1006.6  函数连接规范	1016.7  参数传递规则	1026.8  返回值的规则	1046.9  函数内部实现的规则	1076.10  存储类型及作用域规则	1096.10.1  存储类型	1096.10.2  作用域规则	1106.10.3  连接类型	1116.11  递归函数	1136.12  使用断言	1166.13  使用const提高函数的健壮性	1186.13.1  用const修饰函数的参数	1186.13.2  用const修饰函数的返回值	119第7章  C++/C指针、数组和字符串	1217.1  指针	1217.1.1  指针的本质	1217.1.2  指针的类型及其支持的运算	1237.1.3  指针传递	1257.2  数组	1267.2.1  数组的本质	1267.2.2  二维数组	1287.2.3  数组传递	1297.2.4  动态创建、初始化和删除数组的方法	1317.3  字符数组、字符指针和字符串	1337.3.1  字符数组、字符串和‘\0’的关系	1337.3.2  字符指针的误区	1347.3.3  字符串拷贝和比较	1347.4  函数指针	1357.5  引用和指针的比较	137第8章  C++/C高级数据类型	1418.1  结构（Struct）	1418.1.1  关键字struct与class的困惑	1418.1.2  使用struct	1428.1.3  位域	1458.1.4  成员对齐	1478.2  联合（Union）	1598.3  枚举（Enum）	1618.4  文件	163第9章  C++/C编译预处理	1659.1  文件包含	1659.1.1  内部包含卫哨和外部包含卫哨	1659.1.2  头文件包含的合理顺序	1669.2  宏定义	1669.3  条件编译	1699.3.1  #if、#elif和#else	1699.3.2  #ifdef 和 #ifndef	1709.4  #error	1719.5  #pragma	1719.6  #和##运算符	1719.7  预定义符号常量	172第10章  C++/C文件结构和程序版式	17510.1  程序文件的目录结构	17510.2  文件的结构	17610.2.1  头文件的用途和结构	17610.2.2  版权和版本信息	17710.2.3  源文件结构	17810.3  代码的版式	17810.3.1  适当的空行	17810.3.2  代码行及行内空格	17910.3.3  长行拆分	18010.3.4  对齐与缩进	18110.3.5  修饰符的位置	18210.3.6  注释风格	18210.3.7  ADT/UDT版式	183第11章  C++/C应用程序命名规则	18511.1  共性规则	18511.2  简单的Windows应用程序命名	186第12章  C++面向对象程序设计方法概述	18912.1  漫谈面向对象	18912.2  对象的概念	19012.3  信息隐藏与类的封装	19112.4  类的继承特性	19512.5  类的组合特性	20012.6  动态特性	20112.6.1  虚函数	20212.6.2  抽象基类	20212.6.3  动态绑定	20512.6.4  运行时多态	20712.6.5  多态数组	20812.7  C++对象模型	21512.7.1  对象的内存映像	21512.7.2  隐含成员	22412.7.3  C++编译器如何处理成员函数	22512.7.4  C++编译器如何处理静态成员	22512.8  小结	226第13章  对象的初始化、拷贝和析构	22913.1  构造函数与析构函数的起源	22913.2  为什么需要构造函数和析构函数	23013.3  构造函数的成员初始化列表	23213.4  对象的构造和析构次序	23413.5  构造函数和析构函数的调用时机	23513.6  构造函数和赋值函数的重载	23613.7  示例：类String的构造函数和析构函数	23813.8  何时应该定义拷贝构造函数和拷贝赋值函数	23913.9  示例：类String的拷贝构造函数和拷贝赋值函数	24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数	24213.11  如何实现派生类的基本函数	243第14章  C++函数的高级特性	24714.1  函数重载的概念	24714.1.1  重载的起源	24714.1.2  重载是如何实现的	24714.1.3  当心隐式类型转换导致重载函数产生二义性	24914.2  成员函数的重载、覆盖与隐藏	25014.2.1  重载与覆盖	25014.2.2  令人迷惑的隐藏规则	25114.2.3  摆脱隐藏	25314.3  参数的默认值	25414.4  运算符重载	25514.4.1  基本概念	25514.4.2  运算符重载的特殊性	25614.4.3  不能重载的运算符	25714.4.4  重载++和--	25714.5  函数内联	25914.5.1  用函数内联取代宏	25914.5.2  内联函数的编程风格	26014.5.3  慎用内联	26114.6  类型转换函数	26114.7  const成员函数	264第15章  C++异常处理和RTTI	26715.1  为什么要使用异常处理	26715.2  C++异常处理	26815.2.1  异常处理的原理	26815.2.2  异常类型和异常对象	26915.2.3  异常处理的语法结构	27015.2.4  异常的类型匹配规则	27215.2.5  异常说明及其冲突	27215.2.6  当异常抛出时局部对象如何释放	27315.2.7  对象构造和析构期间的异常	27315.2.8  如何使用好异常处理技术	27515.2.9  C++的标准异常	27815.3  虚函数面临的难题	27815.4  RTTI及其构成	28015.4.1  起源	28015.4.2  typeid运算符	28115.4.3  dynamic_cast<>运算符	28315.4.4  RTTI的魅力与代价	285第16章  内存管理	28716.1  内存分配方式	28716.2  常见的内存错误及其对策	28816.3  指针参数是如何传递内存的	28916.4  free和delete把指针怎么啦	29116.5  动态内存会被自动释放吗	29216.6  杜绝“野指针”	29216.7  有了malloc/free为什么还要new/delete	29316.8  malloc/free的使用要点	29516.9  new有3种使用方式	29616.9.1  plain new/delete	29616.9.2  nothrow new/delete	29716.9.3  placement new/delete	29716.10  new/delete的使用要点	30016.11  内存耗尽怎么办	30116.12  用对象模拟指针	30216.13  泛型指针auto_ptr	30516.14  带有引用计数的智能指针	30616.15  智能指针作为容器元素	310第17章  学习和使用STL	32317.1  STL简介	32317.2  STL头文件的分布	32417.2.1  容器类	32417.2.2  泛型算法	32517.2.3  迭代器	32517.2.4  数学运算库	32517.2.5  通用工具	32517.2.6  其他头文件	32617.3  容器设计原理	32617.3.1  内存映像	32617.3.2  存储方式和访问方式	32717.3.3  顺序容器和关联式容器的比较	32817.3.4  如何遍历容器	33117.3.5  存储空间重分配问题	33217.3.6  什么样的对象才能作为STL容器的元素	33317.4  迭代器	33417.4.1  迭代器的本质	33417.4.2  迭代器失效及其危险性	33817.5  存储分配器	34617.6  适配器	34717.7  泛型算法	35017.8  一些特殊的容器	35417.8.1  string类	35417.8.2  bitset并非set	35517.8.3  节省存储空间的vector<bool>	35717.8.4  空容器	35817.9  STL容器特征总结	36017.10  STL使用心得	362附录A  C++/C试题	365附录B  C++/C试题答案与评分标准	369附录C  大学十年	375附录D  《大学十年》后记	393附录E  术语与缩写解释	395参考文献	397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高质量程序设计指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和指针
第1章 快速上手
1.1 简介
1.1.1 空白和注释
1.1.2 预处理指令
1.1.3 main函数
1.1.4 read_column_numbers函数
1.1.5 rearrange函数
1.2 补充说明
1.3 编译
1.4 总结
1.5 警告的总结
1.6 编程提示的总结
1.7 问题
1.8 编程练习
第2章 基本概念
2.1 环境
2.1.1 翻译
2.1.2 执行
2.2 词法规则
2.2.1 字符
2.2.2 注释
2.2.3 自由形式的源代码
2.2.4 标识符
2.2.5 程序的形式
2.3 程序风格
2.4 总结
2.5 警告的总结
2.6 编程提示的总结
2.7 问题
2.8 编程练习
第3章 数据
第4章 语句
第5章 操作符和表达式
第6章 指针
第7章 函数
第8章 数组
第9章 字符串、字符和字节
第10章 结构和联合
第11章 动态内存分配
第12章 使用结构和指针
第13章 高级指针话题
第14章 预处理器
第15章 输入/输出函数
第16章 标准函数库
第17章 经典抽象数据类型
第18章 运行时环境
附录 部分问题答案
索引
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和指针
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第1章 绪论
1.1 计算机与算法
1.2 复杂度度量
1.3 复杂度分析
1.4*递归
1.5 抽象数据类型
第2章 向量
2.1 从数组到向量
2.2 接口
2.3 构造与析构
2.4 动态空间管理
2.5 常规向量
2.6 有序向量
2.7*排序与下界
2.8 排序器
第3章 列表
3.1 从向量到列表
3.2 接口
3.3 列表
3.4 有序列表
3.5 排序器
第4章 栈与队列
4.1 栈
4.2 栈与递归
4.3 栈的典型应用
4.4*试探回溯法
4.5 队列
4.6 队列应用
第5章 二叉树
5.1 二叉树及其表示
5.2 编码树
5.3 二叉树的实现
5.4 遍历
5.5 Huffmann 编码
第6章 图
6.1 概述
6.2 抽象数据类型
6.3 邻接矩阵
6.4 邻接表
6.5 图遍历算法概述
6.6 广度优先搜索
6.7 深度优先搜索
6.8 拓扑排序
6.9*双连通域分解
6.10 优先级搜索
6.11 最小支撑树
6.12 最短路径
第7章 搜索树
7.1 查找
7.2 二叉搜索树
7.3 平衡二叉搜索树
7.4 AVL 树
第8章 高级搜索树 高级搜索树
8.1 伸展树
8.2 B—树
8.3*红黑树
8.4*kd—树
第9章 词典
9.1 词典 ADTADTADT
9.2*跳转表
9.3 散列表
9.4*散列应用
第10章 优先级队列
10.1 优先级队列 ADT
10.2 堆
10.3*左式堆
第11章 串
11.1 串及匹配
11.2 蛮力算法
11.3 KMP算法
11.4*BM 算法
11.5*Karp—Rabin算法
第12章 排序
12.1 快速排序
12.2*选取与中位数
12.3*希尔排序
附录
参考文献
插图索引
表格索引
算法索引
代码索引
关键词索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C Primer Plus
第1章 概览
1.1 C语言的起源
1.2 使用C语言的理由
1.3 C语言的发展方向
1.4 计算机工作的基本原理
1.5 高级计算机语言和编译器
1.6 使用C语言的7个步骤
1.7 编程机制
1.8 语言标准
1.9 本书的组织结构
1.10 本书体例
1.11 总结
1.12 复习题
1.13 编程练习
第2章 C语言概述
2.1 C语言的一个简单实例
2.2 实例说明
2.3 一个简单程序的结构
2.4 使程序可读的技巧
2.5 更进一步
2.6 多个函数
2.7 调试
2.8 关键字和保留标识符
2.9 关键概念
2.10 总结
2.11 复习题
2.12 编程练习
第3章 数据和C
3.1 示例程序
3.2 变量与常量数据
3.3 数据：数据类型关键字
3.4 C数据类型
3.5 使用数据类型
3.6 参数和易犯的错误
3.7 另一个例子：转义序列
3.8 关键概念
3.9 总结
3.10 复习题
3.11 编程练习
第4章 字符串和格式化输入/输出
4.1 前导程序
4.2 字符串简介
4.3 常量和C预处理器
4.4 研究和利用printf（）和scanf（）
4.5 关键概念
4.6 总结
4.7 复习题
4.8 编程练习
第5章 运算符、表达式和语句
5.1 循环简介
5.2 基本运算符
5.3 其他运算符
5.4 表达式和语句
5.5 类型转换
5.6 带有参数的函数
5.7 一个示例程序
5.8 关键概念
5.9 总结
5.10 复习题
5.11 编程练习
第6章 C控制语句：循环
6.1 再探while循环
6.2 while语句
6.4 不确定循环与计数循环
6.5 for循环
6.6 更多赋值运算符：+=、-=、*=、/=和%=
6.7 逗号运算符
6.8 退出条件循环：do while
6.9 选择哪种循环
6.10 嵌套循环
6.11 数组
6.12 使用函数返回值的循环例子
6.13 关键概念
6.14 总结
6.15 复习题
6.16 编程练习
第7章 C控制语句：分支和跳转
7.1 if语句
7.2 在if语句中添加else关键字
7.3 获得逻辑性
7.4 一个统计字数的程序
7.5 条件运算符?:
7.6 循环辅助手段：continue和break
7.7 多重选择：switch和break
7.8 goto语句
7.9 关键概念
7.10 总结
7.11 复习题
7.12 编程练习
第8章 字符输入/输出和输入确认
8.1 单字符I/O：getchar（）和putchar（）
8.2 缓冲区
8.3 终止键盘输入
8.5 创建一个更友好的用户界面
8.6 输入确认
8.7 菜单浏览
8.8 关键概念
8.9 总结
8.10 复习题
8.11 编程练习
第9章 函数
9.1 函数概述
9.2 ANSI C的函数原型
9.3 递归
9.4 多源代码文件程序的编译
9.5 地址运算符：&
9.6 改变调用函数中的变量
9.7 指针简介
9.8 关键概念
9.9 总结
9.10 复习题
9.11 编程练习
第10章 数组和指针
10.1 数组
10.2 多维数组
10.3 指针和数组
10.4 函数、数组和指针
10.5 指针操作
10.6 保护数组内容
10.7 指针和多维数组
10.8 变长数组（VLA）
10.9 复合文字
10.10 关键概念
10.11 总结
10.12 复习题
10.13 编程练习
第11章 字符串和字符串函数
11.1 字符串表示和字符串I/O
11.2 字符串输入
11.3 字符串输出
11.4 自定义字符串输入/输出函数
11.5 字符串函数
11.6 字符串例子：字符串排序
11.7 ctype.h字符函数和字符串
11.8 命令行参数
11.9 把字符串转换为数字
11.10 关键概念
11.11 总结
11.12 复习题
11.13 编程练习
第12章 存储类、链接和内存管理
12.1 存储类
12.2 存储类说明符
12.3 存储类和函数
12.4 随机数函数和静态变量
12.5 掷骰子
12.6 分配内存：malloc（）和free（）
12.7 ANSI C的类型限定词
12.8 关键概念
12.9 总结
12.10 复习题
12.11 编程练习
第13章 文件输入/输出
13.1 和文件进行通信
13.2 标准I/O
13.3 一个简单的文件压缩程序
13.4 文件I/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数
13.5 随机存取：fseek（）和ftell（）函数
13.6 标准I/O内幕
13.7 其他标准I/O函数
13.8 关键概念
13.9 总结
13.10 复习题
13.11 编程练习
第14章 结构和其他数据形式
14.1 示例问题：创建图书目录
14.2 建立结构声明
14.3 定义结构变量
14.4 结构数组
14.5 嵌套结构
14.6 指向结构的指针
14.7 向函数传递结构信息
14.8 把结构内容保存到文件中
14.9 结构：下一步是什么
14.10 联合简介
14.11 枚举类型
14.12 typedef简介
14.13 奇特的声明
14.14 函数和指针
14.15 关键概念
14.16 总结
14.17 复习题
14.18 编程练习
第15章 位操作
15.1 二进制数、位和字节
15.2 其他基数
15.3 C的位运算符
15.4 位字段
15.5 关键概念
15.6 总结
15.7 复习题
15.8 编程练习
第16章 C预处理器和C库
16.1 翻译程序的第一步
16.2 明显常量：#define
16.3 在#define中使用参数
16.4 宏，还是函数
16.5 文件包含：＃include
16.6 其他指令
16.7 内联函数
16.8 C库
16.9 数学库
16.10 通用工具库
16.11 诊断库
16.12 string.h库中的memcpy（）和memmove（）
16.13 可变参数：stdarg.h
16.14 关键概念
16.15 总结
16.16 复习题
16.17 编程练习
第17章 高级数据表示
17.1 研究数据表示
17.2 从数组到链表
17.3 抽象数据类型（ADT）
17.4 队列ADT
17.5 用队列进行模拟
17.6 链表与数组
17.7 二叉搜索树
17.8 其他说明
17.9 关键概念
17.10 总结
17.11 复习题
17.12 编程练习
附录A 复习题答案
附录B 参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C Primer Plus
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>英国史（全三卷）
卷I  在世界的边缘？ 3000BC—AD1603
序言
第一章 在世界的边缘？
第二章 征服
第三章 王权无约束？
第四章 外来者和本地人
第五章 死亡之神
第六章 燃烧的信念
第七章 女王一身
致谢
参考文献
卷II  不列颠的战争 1603—1776
序言
第一章 重塑不列颠
第二章 帝王之业乎？
第三章 寻找利维坦
第四章 未竟事业
第五章 不列颠股份公司
第六章 谬误帝国
致谢
参考文献
卷III  帝国的命运 1776—2000
序言
第一章 自然的力量：通往革命之路？
第二章 自然的力量：回家之路
第三章 女王与蜂巢
第四章 妻子、女儿和寡妇
第五章 “好心”帝国的投资
第六章 “好心”帝国的红利
第七章 最后的布莱兹欧弗
第八章 忍 耐
致 谢
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>英国史（全三卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>鹿苑长春
目录
第一章 小水车
第二章 乔迪的家
第三章 飞来横祸
第四章 猎熊
第五章 草翅膀
第六章 大快朵颐
第七章 一桩好买卖
第八章 意外收获
第九章 灰岩坑
第十章 夜晚的奇遇
第十一章 猎鹿
第十二章 仗义相助
第十三章 告别奥利弗
第十四章 危机
第十五章 新伙伴
第十六章 偷蜜和猎狐
第十七章 痛失好友
第十八章 怀念“草翅膀”
第十九章 暴风雨
第二十章 暴风雨后的森林
第二十一章 瘟疫
第二十二章 储粮
第二十三章 狼群的夜袭
第二十四章 猎狼
第二十五章圣诞节前夕
第二十六章 追捕“大笨脚”
第二十七章 送别
第二十八章 孤狼
第二十九章 闯祸
第三十章 爸爸病了
第三十一章 无计可施
第三十二章 再见，小鹿
第三十三章 别了，童年
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>鹿苑长春
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
第1章 C语言概述1
1.1 C语言的历史1
1.1.1 起源1
1.1.2 标准化1
1.1.3 基于C的语言2
1.2 C语言的优缺点3
1.2.1 C语言的优点3
1.2.2 C语言的缺点3
1.2.3 高效地使用C语言4
问与答5
第2章 C语言基本概念7
2.1 编写一个简单的C程序7
程序显示双关语7
2.1.1 编译和链接8
2.1.2 集成开发环境8
2.2 简单程序的一般形式9
2.2.1 指令9
2.2.2 函数9
2.2.3 语句10
2.2.4 显示字符串10
2.3 注释11
2.4 变量和赋值12
2.4.1 类型12
2.4.2 声明13
2.4.3 赋值13
2.4.4 显示变量的值14
程序计算箱子的空间重量14
2.4.5 初始化15
2.4.6 显示表达式的值16
2.5 读入输入16
程序计算箱子的空间重量（改进版）16
2.6 定义常量的名字17
程序华氏温度转换为摄氏温度17
2.7 标识符18
2.8 C程序的书写规范19
问与答21
练习题23
编程题24
第3章 格式化输入/输出26
3.1 printf函数26
3.1.1 转换说明27
程序用printf函数格式化数28
3.1.2 转义序列28
3.2 scanf函数29
3.2.1 scanf函数的工作方法30
3.2.2 格式串中的普通字符31
3.2.3 易混淆的printf函数和scanf函数32
程序分数相加32
问与答33
练习题34
编程题35
第4章 表达式36
4.1 算术运算符36
程序计算通用产品代码的校验位38
4.2 赋值运算符39
4.2.1 简单赋值40
4.2.2 左值41
4.2.3 复合赋值41
4.3 自增运算符和自减运算符42
4.4 表达式求值43
4.5 表达式语句45
问与答45
练习题47
编程题49
第5章 选择语句50
5.1 逻辑表达式50
5.1.1 关系运算符50
5.1.2 判等运算符51
5.1.3 逻辑运算符51
5.2 if语句52
5.2.1 复合语句53
5.2.2 else子句53
5.2.3 级联式if语句54
程序计算股票经纪人的佣金55
5.2.4 “悬空else”的问题56
5.2.5 条件表达式57
5.2.6 C89中的布尔值58
5.2.7 C99中的布尔值58
5.3 switch语句59
程序显示法定格式的日期61
问与答62
练习题65
编程题67
第6章 循环69
6.1 while语句69
程序显示平方表71
程序数列求和71
6.2 do语句72
程序计算整数的位数73
6.3 for语句73
6.3.1 for语句的惯用法74
6.3.2 在for语句中省略表达式75
6.3.3 C99中的for语句75
6.3.4 逗号运算符76
程序显示平方表（改进版）77
6.4 退出循环78
6.4.1 break语句78
6.4.2 continue语句78
6.4.3 goto语句79
程序账簿结算80
6.5 空语句81
问与答83
练习题84
编程题85
第7章 基本类型88
7.1 整数类型88
7.1.1 C99中的整数类型90
7.1.2 整数常量90
7.1.3 C99中的整数常量91
7.1.4 整数溢出91
7.1.5 读/写整数91
程序数列求和（改进版）92
7.2 浮点类型93
7.2.1 浮点常量94
7.2.2 读/写浮点数94
7.3 字符类型94
7.3.1 字符操作95
7.3.2 有符号字符和无符号字符95
7.3.3 算术类型96
7.3.4 转义序列96
7.3.5 字符处理函数97
7.3.6 用scanf和printf读/写字符98
7.3.7 用getchar和putchar读/写字符98
程序确定消息的长度99
7.4 类型转换100
7.4.1 常用算术转换101
7.4.2 赋值过程中的转换102
7.4.3 C99中的隐式转换103
7.4.4 强制类型转换103
7.5 类型定义105
7.5.1 类型定义的优点105
7.5.2 类型定义和可移植性105
7.6 sizeof运算符106
问与答107
练习题109
编程题110
第8章 数组113
8.1 一维数组113
8.1.1 数组下标113
程序数列反向115
8.1.2 数组初始化115
8.1.3 指定初始化式116
程序检查数中重复出现的数字116
8.1.4 对数组使用sizeof运算符117
程序计算利息118
8.2 多维数组119
8.2.1 多维数组初始化120
8.2.2 常量数组121
程序发牌121
8.3 C99中的变长数组122
问与答123
练习题124
编程题125
第9章 函数129
9.1 函数的定义和调用129
程序计算平均值129
程序显示倒计数130
程序显示双关语（改进版）131
9.1.1 函数定义132
9.1.2 函数调用133
程序判定素数134
9.2 函数声明135
9.3 实际参数136
9.3.1 实际参数的转换137
9.3.2 数组型实际参数138
9.3.3 变长数组形式参数140
9.3.4 在数组参数声明中使用static141
9.3.5 复合字面量141
9.4 return语句142
9.5 程序终止143
9.6 递归144
程序快速排序146
问与答147
练习题150
编程题153
第10章 程序结构155
10.1 局部变量155
10.1.1 静态局部变量156
10.1.2 形式参数156
10.2 外部变量156
10.2.1 示例：用外部变量实现栈156
10.2.2 外部变量的利与弊157
程序猜数158
10.3 程序块161
10.4 作用域162
10.5 构建C程序163
程序给一手牌分类163
问与答169
练习题169
编程题170
第11章 指针172
11.1 指针变量172
11.2 取地址运算符和间接寻址运算符173
11.2.1 取地址运算符173
11.2.2 间接寻址运算符174
11.3 指针赋值174
11.4 指针作为参数176
程序找出数组中的最大元素和最小元素177
11.5 指针作为返回值179
问与答180
练习题181
编程题182
第12章 指针和数组184
12.1 指针的算术运算184
12.1.1 指针加上整数185
12.1.2 指针减去整数185
12.1.3 两个指针相减186
12.1.4 指针比较186
12.1.5 指向复合常量的指针186
12.2 指针用于数组处理186
12.3 用数组名作为指针188程序数列反向（改进版）189
12.3.1 数组型实际参数（改进版）189
12.3.2 用指针作为数组名191
12.4 指针和多维数组191
12.4.1 处理多维数组的元素191
12.4.2 处理多维数组的行192
12.4.3 处理多维数组的列192
12.4.4 用多维数组名作为指针192
12.5 C99中的指针和变长数组193
问与答194
练习题195
编程题197
第13章 字符串198
13.1 字符串字面量198
13.1.1 字符串字面量中的转义序列198
13.1.2 延续字符串字面量199
13.1.3 如何存储字符串字面量199
13.1.4 字符串字面量的操作200
13.1.5 字符串字面量与字符常量200
13.2 字符串变量200
13.2.1 初始化字符串变量201
13.2.2 字符数组与字符指针202
13.3 字符串的读和写203
13.3.1 用printf函数和puts函数写字符串203
13.3.2 用scanf函数和gets函数读字符串203
13.3.3 逐个字符读字符串204
13.4 访问字符串中的字符205
13.5 使用C语言的字符串库206
13.5.1 strcpy函数207
13.5.2 strlen函数208
13.5.3 strcat函数208
13.5.4 strcmp函数209程序显示一个月的提醒列表209
13.6 字符串惯用法211
13.6.1 搜索字符串的结尾211
13.6.2 复制字符串213
13.7 字符串数组214
程序核对行星的名字217
问与答218
练习题220
编程题222
第14章 预处理器225
14.1 预处理器的工作原理225
14.2 预处理指令227
14.3 宏定义227
14.3.1 简单的宏227
14.3.2 带参数的宏229
14.3.3 #运算符231
14.3.4 ##运算符231
14.3.5 宏的通用属性232
14.3.6 宏定义中的圆括号233
14.3.7 创建较长的宏233
14.3.8 预定义宏234
14.3.9 C99中新增的预定义宏235
14.3.10 空的宏参数236
14.3.11 参数个数可变的宏236
14.3.12 __func__标识符237
14.4 条件编译237
14.4.1 #if指令和#endif指令238
14.4.2 defined运算符238
14.4.3 #ifdef指令和#ifndef指令239
14.4.4 #elif指令和#else指令239
14.4.5 使用条件编译240
14.5 其他指令240
14.5.1 #error指令240
14.5.2 #line指令241
14.5.3 #pragma指令242
14.5.4 _Pragma运算符242
问与答243
练习题245
第15章 编写大型程序248
15.1 源文件248
15.2 头文件249
15.2.1 #include指令249
15.2.2 共享宏定义和类型定义250
15.2.3 共享函数原型251
15.2.4 共享变量声明252
15.2.5 嵌套包含253
15.2.6 保护头文件253
15.2.7 头文件中的#error指令254
15.3 把程序划分成多个文件254程序文本格式化255
15.4 构建多文件程序260
15.4.1 makefile260
15.4.2 链接期间的错误262
15.4.3 重新构建程序262
15.4.4 在程序外定义宏264
问与答264
练习题265
编程题266
第16章 结构、联合和枚举267
16.1 结构变量267
16.1.1 结构变量的声明267
16.1.2 结构变量的初始化269
16.1.3 指定初始化269
16.1.4 对结构的操作270
16.2 结构类型270
16.2.1 结构标记的声明271
16.2.2 结构类型的定义272
16.2.3 结构作为参数和返回值272
16.2.4 复合字面量273
16.3 嵌套的数组和结构274
16.3.1 嵌套的结构274
16.3.2 结构数组274
16.3.3 结构数组的初始化275程序维护零件数据库275
16.4 联合281
16.4.1 用联合来节省空间282
16.4.2 用联合来构造混合的数据结构284
16.4.3 为联合添加“标记字段”284
16.5 枚举285
16.5.1 枚举标记和类型名286
16.5.2 枚举作为整数286
16.5.3 用枚举声明“标记字段”286
问与答287
练习题289
编程题293
第17章 指针的高级应用294
17.1 动态存储分配294
17.1.1 内存分配函数294
17.1.2 空指针295
17.2 动态分配字符串296
……
第18章 声明 327
第19章 程序设计 345
第20章 底层程序设计 363
第21章 标准库 377
第22章 输入/输出 384
第23章 库对数值和字符数据的支持 419
第24章 错误处理 446
第25章 国际化特性 456
第26章 其他库函数 482
第27章 C99对数学计算的新增支持 503
附录A C语言运算符 524
附录B C99与C89的比较 525
附录C C89与经典C的比较 529
附录D 标准库函数 532
附录E ASCII字符集 569
参考文献 570
索引 573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纽约无人是客
指南与致谢
有点像跋的序
第一章 你这个种族主义者
纽约深度游线路一：黑色与白色
第二章 没有华尔的街
纽约深度游线路二：革命与资本
第三章 纽约水故事
纽约深度游线路三：饮水与思源
第四章 我的画报你的城
纽约深度游之四：寻根与漂流
第五章 曼哈顿是平的
纽约深度游之五：贫穷与富裕
第六章 开往昨天的地铁
纽约深度游之六：地下与地上
第七章 美国的归美国，纽约的归纽约
纽约深度游之七：美国与欧洲
第八章 不知道为什么就流泪
纽约深度游之八：战争与和平
有点像序的跋
附录
附录一：一些遗珠
附录二：纽约博物馆排名
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纽约无人是客
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux多线程服务端编程
第1 部分C++ 多线程系统编程1
第1章 线程安全的对象生命期管理3
1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4
1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4
1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8
1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8
1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.6 神器shared_ptr/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14
1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17
1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23
1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
第2章 线程同步精要31
2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33
2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40
2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44
2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48
2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52
第3章 多线程服务器的适用场合与常用编程模型59
3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61
3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67
3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69
3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70
3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71
3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74
第4章 C++ 多线程系统编程精要83
4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
4.2 C/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85
4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94
4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94
4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105
第5章 高效的多线程日志107
5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
第2部分 muduo 网络库123
第6章 muduo 网络库简介125
6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136
6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138
6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140
6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145
6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148
6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153
6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156
6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160
第7章 muduo 编程示例177
7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197
7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204
7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204
7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205
7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207
7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209
7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220
7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220
7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221
7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226
7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228
7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229
7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232
7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233
7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234
7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236
7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237
7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237
7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238
7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242
7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243
7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248
7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250
7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251
7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260
7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267
7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
第8章 muduo 网络库设计与实现277
8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287
8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292
8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293
8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296
8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297
8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305
8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308
8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314
8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315
8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316
8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321
8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322
8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
第3部分 工程实践经验谈337
第9章 分布式系统工程实践339
9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341
9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343
9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344
9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349
9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352
9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354
9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356
9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360
9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364
9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368
9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369
9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370
9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370
9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373
9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374
9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375
9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380
9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382
9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383
9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386
9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389
第10章 C++ 编译链接模型精要391
10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394
10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395
10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398
10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414
10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415
10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417
10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418
10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424
10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
第11章 反思C++ 面向对象与虚函数429
11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432
11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433
11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435
11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436
11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437
11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438
11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439
11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442
11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443
11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447
11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453
11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457
11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461
11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463
11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464
11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468
11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476
11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480
11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488
11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493
11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495
第12章 C++ 经验谈501
12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501
12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503
12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505
12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507
12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507
12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508
12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508
12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510
12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512
12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513
12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513
12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514
12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
12.3.2 C/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516
12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517
12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522
12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522
12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524
12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526
12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526
12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526
12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527
12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529
12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530
12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537
12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540
12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542
12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543
12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546
12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546
12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548
12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549
12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553
12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554
第4 部分附录559
附录A 谈一谈网络编程学习经验561
附录B 从《C++ Primer（第4 版）》入手学习C++ 579
附录C 关于Boost 的看法591
附录D 关于TCP 并发连接的几个思考题与试验593
参考文献599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux多线程服务端编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C Primer Plus（第6版）中文版
第1章　初识C语言	1
1．1　C语言的起源	1
1．2 选择C语言的理由	1
1．2．1 设计特性	1
1．2．2 高效性	1
1．2．3 可移植性	2
1．2．4 强大而灵活	3
1．2．5 面向程序员	3
1．2．6 缺点	3
1．3 C语言的应用范围	3
1．4 计算机能做什么	4
1．5 高级计算机语言和编译器	5
1．6 语言标准	6
1．6．1 第1个ANSI/ISO C标准	6
1．6．2 C99标准	6
1．6．3 C11标准	7
1．7 使用C语言的7个步骤	7
1．7．1 第1步：定义程序的目标	8
1．7．2 第2步：设计程序	8
1．7．3 第3步：编写代码	8
1．7．4 第4步：编译	8
1．7．5 第5步：运行程序	9
1．7．6 第6步：测试和调试程序	9
1．7．7 第7步：维护和修改代码	9
1．7．8 说明	9
1．8 编程机制	10
1．8．1 目标代码文件、可执行文件和库	10
1．8．2 UNIX系统	11
1．8．3 GNU编译器集合和LLVM项目	13
1．8．4 Linux系统	13
1．8．5 PC的命令行编译器	14
1．8．6 集成开发环境（Windows）	14
1．8．7 Windows/Linux	15
1．8．8 Macintosh中的C	15
1．9 本书的组织结构	15
1．10 本书的约定	16
1．10．1 字体	16
1．10．2 程序输出	16
1．10．3 特殊元素	17
1．11 本章小结	17
1．12 复习题	18
1．13 编程练习	18
第2章　C语言概述	19
2．1 简单的C程序示例	19
2．2 示例解释	20
2．2．1 第1遍：快速概要	21
2．2．2 第2遍：程序细节	21
2．3 简单程序的结构	28
2．4 提高程序可读性的技巧	28
2．5 进一步使用C	29
2．5．1 程序说明	30
2．5．2 多条声明	30
2．5．3 乘法	30
2．5．4 打印多个值	30
2．6 多个函数	30
2．7 调试程序	32
2．7．1 语法错误	32
2．7．2 语义错误	33
2．7．3 程序状态	34
2．8 关键字和保留标识符	34
2．9 关键概念	35
2．10 本章小结	35
2．11 复习题	36
2．12 编程练习	37
第3章　数据和C	39
3．1 示例程序	39
3．2 变量与常量数据	42
3．3 数据：数据类型关键字	42
3．3．1 整数和浮点数	43
3．3．2 整数	43
3．3．3 浮点数	43
3．4 C语言基本数据类型	44
3．4．1 int类型	44
3．4．2 其他整数类型	47
3．4．3 使用字符：char类型	50
3．4．4 _Bool类型	54
3．4．5 可移植类型：stdint．h和inttypes．h	55
3．4．6 float、double和long double	56
3．4．7 复数和虚数类型	60
3．4．8 其他类型	60
3．4．9 类型大小	62
3．5 使用数据类型	63
3．6 参数和陷阱	63
3．7 转义序列示例	64
3．7．1 程序运行情况	65
3．7．2 刷新输出	65
3．8 关键概念	66
3．9 本章小结	66
3．10 复习题	67
3．11 编程练习	68
第4章　字符串和格式化输入/输出	71
4．1 前导程序	71
4．2 字符串简介	72
4．2．1 char类型数组和null字符	72
4．2．2 使用字符串	73
4．2．3 strlen()函数	74
4．3 常量和C预处理器	76
4．3．1 const限定符	78
4．3．2 明示常量	78
4．4 printf()和scanf()	80
4．4．1 printf()函数	80
4．4．2 使用printf()	81
4．4．3 printf()的转换说明修饰符	83
4．4．4 转换说明的意义	87
4．4．5 使用scanf()	92
4．4．6 printf()和scanf()的*修饰符	95
4．4．7 printf()的用法提示	97
4．5 关键概念	98
4．6 本章小结	98
4．7 复习题	99
4．8 编程练习	100
第5章　运算符、表达式和语句	103
5．1 循环简介	103
5．2 基本运算符	105
5．2．1 赋值运算符：=	105
5．2．2 加法运算符：+	107
5．2．3 减法运算符：-	107
5．2．4 符号运算符：-和+	107
5．2．5 乘法运算符：*	108
5．2．6 除法运算符：/	110
5．2．7 运算符优先级	110
5．2．8 优先级和求值顺序	112
5．3 其他运算符	113
5．3．1 sizeof运算符和size_t类型	113
5．3．2 求模运算符：%	114
5．3．3 递增运算符：++	115
5．3．4 递减运算符：--	118
5．3．5 优先级	118
5．3．6 不要自作聪明	119
5．4 表达式和语句	120
5．4．1 表达式	120
5．4．2 语句	120
5．4．3 复合语句（块）	123
5．5 类型转换	124
5．6 带参数的函数	127
5．7 示例程序	129
5．8 关键概念	130
5．9 本章小结	130
5．10 复习题	131
5．11 编程练习	134
第6章　C控制语句：循环	137
6．1 再探while循环	137
6．1．1 程序注释	138
6．1．2 C风格读取循环	139
6．2 while语句	140
6．2．1 终止while循环	140
6．2．2 何时终止循环	141
6．2．3 while：入口条件循环	141
6．2．4 语法要点	141
6．3 用关系运算符和表达式比较大小	143
6．3．1 什么是真	144
6．3．2 其他真值	145
6．3．3 真值的问题	146
6．3．4 新的_Bool类型	147
6．3．5 优先级和关系运算符	148
6．4 不确定循环和计数循环	150
6．5 for循环	151
6．6 其他赋值运算符：+=、-=、*=、/=、%=	155
6．7 逗号运算符	156
6．8 出口条件循环：do while	159
6．9 如何选择循环	161
6．10 嵌套循环	162
6．10．1 程序分析	163
6．10．2 嵌套变式	163
6．11 数组简介	164
6．12 使用函数返回值的循环示例	166
6．12．1 程序分析	168
6．12．2 使用带返回值的函数	169
6．13 关键概念	169
6．14 本章小结	170
6．15 复习题	170
6．16 编程练习	174
第7章　C控制语句：分支和跳转	177
7．1 if语句	177
7．2 if else语句	179
7．2．1 另一个示例：介绍getchar()和putchar()	180
7．2．2 ctype．h系列的字符函数	182
7．2．3 多重选择else if	184
7．2．4 else与if配对	186
7．2．5 多层嵌套的if语句	187
7．3 逻辑运算符	190
7．3．1 备选拼写：iso646．h头文件	191
7．3．2 优先级	192
7．3．3 求值顺序	192
7．3．4 范围	193
7．4 一个统计单词的程序	194
7．5 条件运算符：?：	196
7．6 循环辅助：continue和break	198
7．6．1 continue语句	198
7．6．2 break语句	200
7．7 多重选择：switch和break	202
7．7．1 switch语句	204
7．7．2 只读每行的首字符	205
7．7．3 多重标签	206
7．7．4 switch和if else	208
7．8 goto语句	208
7．9 关键概念	211
7．10 本章小结	211
7．11 复习题	212
7．12 编程练习	214
第8章　字符输入/输出和输入验证	217
8．1 单字符I/O：getchar()和putchar()	217
8．2 缓冲区	218
8．3 结束键盘输入	219
8．3．1 文件、流和键盘输入	219
8．3．2 文件结尾	220
8．4 重定向和文件	222
8．5 创建更友好的用户界面	226
8．5．1 使用缓冲输入	226
8．5．2 混合数值和字符输入	228
8．6 输入验证	230
8．6．1 分析程序	234
8．6．2 输入流和数字	234
8．7 菜单浏览	235
8．7．1 任务	235
8．7．2 使执行更顺利	235
8．7．3 混合字符和数值输入	237
8．8 关键概念	240
8．9 本章小结	240
8．10 复习题	241
8．11 编程练习	241
第9章　函数	243
9．1 复习函数	243
9．1．1 创建并使用简单函数	244
9．1．2 分析程序	245
9．1．3 函数参数	247
9．1．4 定义带形式参数的函数	248
9．1．5 声明带形式参数函数的原型	249
9．1．6 调用带实际参数的函数	249
9．1．7 黑盒视角	250
9．1．8 使用return从函数中返回值	250
9．1．9 函数类型	252
9．2 ANSI C函数原型	253
9．2．1 问题所在	253
9．2．2 ANSI的解决方案	254
9．2．3 无参数和未指定参数	255
9．2．4 函数原型的优点	256
9．3 递归	256
9．3．1 演示递归	256
9．3．2 递归的基本原理	258
9．3．3 尾递归	258
9．3．4 递归和倒序计算	260
9．3．5 递归的优缺点	262
9．4 编译多源代码文件的程序	262
9．4．1 UNIX	263
9．4．2 Linux	263
9．4．3 DOS命令行编译器	263
9．4．4 Windows和苹果的IDE编译器	263
9．4．5 使用头文件	263
9．5 查找地址：&运算符	267
9．6 更改主调函数中的变量	268
9．7 指针简介	269
9．7．1 间接运算符：*	270
9．7．2 声明指针	270
9．7．3 使用指针在函数间通信	271
9．8 关键概念	274
9．9 本章小结	275
9．10　复习题	275
9．11 编程练习	276
第10章　数组和指针	277
10．1 数组	277
10．1．1 初始化数组	277
10．1．2 指定初始化器（C99）	281
10．1．3 给数组元素赋值	282
10．1．4 数组边界	282
10．1．5 指定数组的大小	284
10．2 多维数组	284
10．2．1 初始化二维数组	287
10．2．2 其他多维数组	288
10．3 指针和数组	288
10．4 函数、数组和指针	290
10．4．1 使用指针形参	293
10．4．2 指针表示法和数组表示法	294
10．5 指针操作	295
10．6 保护数组中的数据	298
10．6．1 对形式参数使用const	299
10．6．2　const的其他内容	300
10．7 指针和多维数组	302
10．7．1 指向多维数组的指针	304
10．7．2 指针的兼容性	305
10．7．3 函数和多维数组	306
10．8 变长数组（VLA）	309
10．9 复合字面量	312
10．10 关键概念	314
10．11 本章小结	315
10．12 复习题	316
10．13 编程练习	317
第11章　字符串和字符串函数	321
11．1 表示字符串和字符串I/O	321
11．1．1 在程序中定义字符串	322
11．1．2 指针和字符串	328
11．2 字符串输入	329
11．2．1 分配空间	329
11．2．2 不幸的gets()函数	330
11．2．3 gets()的替代品	331
11．2．4 scanf()函数	336
11．3 字符串输出	337
11．3．1 puts()函数	338
11．3．2 fputs()函数	339
11．3．3 printf()函数	339
11．4 自定义输入/输出函数	340
11．5 字符串函数	342
11．5．1 strlen()函数	342
11．5．2 strcat()函数	343
11．5．3 strncat()函数	345
11．5．4 strcmp()函数	346
11．5．5 strcpy()和strncpy()函数	351
11．5．6 sprintf()函数	356
11．5．7 其他字符串函数	357
11．6 字符串示例：字符串排序	359
11．6．1 排序指针而非字符串	360
11．6．2 选择排序算法	361
11．7 ctype．h字符函数和字符串	362
11．8 命令行参数	363
11．8．1 集成环境中的命令行参数	365
11．8．2 Macintosh中的命令行参数	365
11．9 把字符串转换为数字	365
11．10 关键概念	368
11．11 本章小结	368
11．12 复习题	369
11．13 编程练习	371
第12章　存储类别、链接和内存管理	373
12．1 存储类别	373
12．1．1 作用域	374
12．1．2 链接	376
12．1．3 存储期	376
12．1．4 自动变量	377
12．1．5 寄存器变量	380
12．1．6 块作用域的静态变量	381
12．1．7 外部链接的静态变量	382
12．1．8 内部链接的静态变量	386
12．1．9 多文件	386
12．1．10 存储类别说明符	387
12．1．11 存储类别和函数	389
12．1．12 存储类别的选择	389
12．2 随机数函数和静态变量	390
12．3 掷骰子	393
12．4 分配内存：malloc()和free()	396
12．4．1 free()的重要性	399
12．4．2 calloc()函数	400
12．4．3 动态内存分配和变长数组	400
12．4．4 存储类别和动态内存分配	401
12．5 ANSI C类型限定符	402
12．5．1 const类型限定符	403
12．5．2 volatile类型限定符	404
12．5．3 restrict类型限定符	405
12．5．4 _Atomic类型限定符（C11）	406
12．5．5 旧关键字的新位置	406
12．6　关键概念	407
12．7 本章小结	407
12．8 复习题	408
12．9 编程练习	409
第13章　文件输入/输出	413
13．1 与文件进行通信	413
13．1．1 文件是什么	413
13．1．2 文本模式和二进制模式	413
13．1．3 I/O的级别	415
13．1．4 标准文件	415
13．2 标准I/O	415
13．2．1 检查命令行参数	416
13．2．2 fopen()函数	416
13．2．3 getc()和putc()函数	417
13．2．4 文件结尾	418
13．2．5 fclose()函数	419
13．2．6 指向标准文件的指针	419
13．3 一个简单的文件压缩程序	419
13．4 文件I/O：fprintf()、fscanf()、fgets()和fputs()	421
13．4．1 fprintf()和fscanf()函数	421
13．4．2 fgets()和fputs()函数	422
13．5 随机访问：fseek()和ftell()	423
13．5．1 fseek()和ftell()的工作原理	424
13．5．2 二进制模式和文本模式	425
13．5．3 可移植性	425
13．5．4 fgetpos()和fsetpos()函数	426
13．6 标准I/O的机理	426
13．7 其他标准I/O函数	427
13．7．1 int ungetc(int c， FILE *fp)函数	427
13．7．2 int fflush()函数	428
13．7．3 int setvbuf()函数	428
13．7．4 二进制I/O：fread()和fwrite()	428
13．7．5 size_t fwrite()函数	429
13．7．6 size_t fread()函数	430
13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数	430
13．7．8 一个程序示例	430
13．7．9 用二进制I/O进行随机访问	433
13．8 关键概念	435
13．9 本章小结	435
13．10 复习题	435
13．11 编程练习	437
第14章　结构和其他数据形式	439
14．1 示例问题：创建图书目录	439
14．2 建立结构声明	441
14．3 定义结构变量	441
14．3．1 初始化结构	442
14．3．2 访问结构成员	443
14．3．3 结构的初始化器	443
14．4 结构数组	444
14．4．1 声明结构数组	446
14．4．2 标识结构数组的成员	447
14．4．3 程序讨论	447
14．5 嵌套结构	448
14．6 指向结构的指针	449
14．6．1 声明和初始化结构指针	450
14．6．2 用指针访问成员	451
14．7 向函数传递结构的信息	451
14．7．1 传递结构成员	451
14．7．2 传递结构的地址	452
14．7．3 传递结构	453
14．7．4 其他结构特性	454
14．7．5 结构和结构指针的选择	458
14．7．6 结构中的字符数组和字符指针	458
14．7．7 结构、指针和malloc()	459
14．7．8 复合字面量和结构（C99）	462
14．7．9 伸缩型数组成员（C99）	463
14．7．10 匿名结构（C11）	465
14．7．11 使用结构数组的函数	466
14．8 把结构内容保存到文件中	467
14．8．1 保存结构的程序示例	468
14．8．2 程序要点	470
14．9 链式结构	471
14．10 联合简介	472
14．10．1 使用联合	472
14．10．2 匿名联合（C11）	473
14．11 枚举类型	474
14．11．1 enum常量	475
14．11．2 默认值	475
14．11．3 赋值	475
14．11．4 enum的用法	476
14．11．5 共享名称空间	477
14．12 typedef简介	478
14．13 其他复杂的声明	479
14．14 函数和指针	481
14．15 关键概念	487
14．16 本章小结	487
14．17 复习题	488
14．18 编程练习	490
第15章　位操作	493
15．1 二进制数、位和字节	493
15．1．1 二进制整数	494
15．1．2 有符号整数	494
15．1．3 二进制浮点数	495
15．2 其他进制数	495
15．2．1 八进制	495
15．2．2 十六进制	496
15．3 C按位运算符	496
15．3．1 按位逻辑运算符	497
15．3．2 用法：掩码	498
15．3．3 用法：打开位（设置位）	498
15．3．4 用法：关闭位（清空位）	499
15．3．5 用法：切换位	499
15．3．6 用法：检查位的值	500
15．3．7 移位运算符	500
15．3．8 编程示例	501
15．3．9 另一个例子	503
15．4 位字段	505
15．4．1 位字段示例	506
15．4．2 位字段和按位运算符	509
15．5 对齐特性（C11）	515
15．6 关键概念	516
15．7 本章小结	516
15．8 复习题	517
15．9 编程练习	518
第16章　C预处理器和C库	521
16．1 翻译程序的第一步	521
16．2 明示常量：#define	522
16．2．1 记号	525
16．2．2 重定义常量	525
16．3 在#define中使用参数	525
16．3．1 用宏参数创建字符串：#运算符	527
16．3．2 预处理器黏合剂：##运算符	528
16．3．3 变参宏：．．．和_ _VA_ARGS_ _	529
16．4 宏和函数的选择	530
16．5 文件包含：#include	531
16．5．1 头文件示例	531
16．5．2 使用头文件	533
16．6 其他指令	534
16．6．1 #undef指令	534
16．6．2 从C预处理器角度看已定义	534
16．6．3 条件编译	535
16．6．4 预定义宏	539
16．6．5 #line和#error	540
16．6．6 #pragma	540
16．6．7 泛型选择（C11）	541
16．7 内联函数（C99）	542
16．8 _Noreturn函数（C11）	544
16．9 C库	544
16．9．1 访问C库	544
16．9．2 使用库描述	545
16．10 数学库	546
16．10．1 三角问题	547
16．10．2 类型变体	548
16．10．3 tgmath．h库（C99）	550
16．11 通用工具库	550
16．11．1 exit()和atexit()函数	550
16．11．2 qsort()函数	552
16．12 断言库	556
16．12．1 assert的用法	556
16．12．2 _Static_assert（C11）	557
16．13 string．h库中的memcpy()和memmove()	558
16．14 可变参数：stdarg．h	560
16．15 关键概念	562
16．16 本章小结	562
16．17 复习题	562
16．18 编程练习	563
第17章　高级数据表示	567
17．1 研究数据表示	567
17．2 从数组到链表	570
17．2．1 使用链表	572
17．2．2 反思	576
17．3 抽象数据类型（ADT）	576
17．3．1 建立抽象	577
17．3．2 建立接口	578
17．3．3 使用接口	581
17．3．4 实现接口	583
17．4 队列ADT	589
17．4．1 定义队列抽象数据类型	590
17．4．2 定义一个接口	590
17．4．3 实现接口数据表示	591
17．4．4 测试队列	598
17．5 用队列进行模拟	600
17．6 链表和数组	605
17．7 二叉查找树	608
17．7．1 二叉树ADT	608
17．7．2 二叉查找树接口	609
17．7．3 二叉树的实现	611
17．7．4 使用二叉树	624
17．7．5 树的思想	628
17．8 其他说明	629
17．9 关键概念	630
17．10 本章小结	630
17．11 复习题	630
17．12 编程练习	631
附录A　复习题答案	633
附录B　参考资料	665
B．1 参考资料I：补充阅读	665
B．2 参考资料II：C运算符	667
B．3 参考资料III：基本类型和存储类别	671
B．4 参考资料IV：表达式、语句和程序流	675
B．5 参考资料V：新增C99和C11的ANSI C库	679
B．6 参考资料VI：扩展的整数类型	714
B．7 参考资料VII：扩展字符支持	716
B．8 参考资料VIII：C99/C11数值计算增强	720
B．9 参考资料IX：C和C++的区别	726
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C Primer Plus（第6版）中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出MFC （第二版）
第一篇 勿在浮砂筑高台
第一章 Win32 程序基本概念
第二章 C++的重要性质
第三章 MFC六大关键技术之仿真
第二篇 欲善工事先利其器
第四章 Visual C++ 集成开发环境
第三篇 浅出MFC程序设计
第五章 总观Application Framework
第六章 MFC程序的生死因果
第七章 简单而完整：MFC骨干程序
第四篇 深入MFC 程序设计
第八章 Document-View深入探讨
第九章 消息映射与命令传递
第十章 MFC与对话框
第十一章 Vies功能的加强与重绘效率的提高
第十二章 打印与预览
第十三章 多重文件与多重视图
第十四章 MFC 多线程程序设计
第十五章 站在众人的肩膀――使用Components & ActiveX Controls
第五篇 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出MFC （第二版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计
1 C语言概述
1.1 C语言出现的历史背景
1.2 C语言的特点
1.3 简单的C语言程序介绍
1.4 运行C程序的步骤与方法
1.4.1 运行C程序的步骤
1.4.2 上机运行C程序的方法
习题
2 程序的灵魂--算法
2.1 算法的概念
2.2 简单算法举例
2.3 算法的特性
2.4 怎样表示一个算法
2.4.1 用自然语言表示算法
2.4.2 用流程图表示算法
2.4.3 3种基本结构和改进的流程图
2.4.4 用N-S流程图表示算法
2.4.5 用伪代码表示算法
2.4.6 用计算机语言表示算法
2.5 结构化程序设计方法
习题
3 数据类型、运算符与表达式
3.1 C语言的数据类型
3.2 常量与变量
3.2.1 常量和符号常量
3.2.2 变量
3.3 整型数据
3.3.1 整型常量的表示方法
3.3.2 整型变量
3.3.3 整型常量的类型
3.4 浮点型数据
3.4.1 浮点型常量的表示方法
3.4.2 浮点型变量
3.4.3 浮点型常量的类型
3.5 字符型数据
3.5.1 字符常量
3.5.2 字符变量
3.5.3 字符数据在内存中的存储形式及其使用方法
3.5.4 字符串常量
3.6 变量赋初值
3.7 各类数值型数据间的混合运算
3.8 算术运算符和算术表达式
3.8.1 C语言运算符简介
3.8.2 算术运算符和算术表达式
3.9 赋值运算符和赋值表达式
3.10 逗号运算符和逗号表达式
习题
4 最简单的C程序设计--顺序程序设计
4.1 C语句概述
4.2 赋值语句
4.3 数据输入输出的概念及在C语言中的实现
4.4 字符数据的输入输出
4.4.1 putchar函数
4.4.2 getchar函数
4.5 格式输入与输出
4.5.1 printf函数
4.5.2 scanf函数
4.6 顺序结构程序设计举例
习题
5 选择结构程序设计
5.1 关系运算符和关系表达式
5.1.1 关系运算符及其优先次序
5.1.2 关系表达式
5.2 逻辑运算符和逻辑表达式
5.2.1 逻辑运算符及其优先次序
5.2.2 逻辑表达式
5.3 if语句
5.3.1 if语句的3种形式
5.3.2 if语句的嵌套
5.3.3 条件运算符
5.4 switch语句
5.5 程序举例
习题
6 循环控制
6.1 概述
6.2 goto语句以及用goto语句构成循环
6.3 用while语句实现循环
6.4 用do…while语句实现循环
6.5 用for语句实现循环
6.6 循环的嵌套
6.7 几种循环的比较
6.8 break语句和continue语句
6.8.1 break语句
6.8.2 continue语句
6.9 程序举例
习题
7 数组
7.1 一维数组的定义和引用
7.1.1 一维数组的定义
7.1.2 一维数组元素的引用
7.1.3 一维数组的初始化
7.1.4 一维数组程序举例
7.2 二维数组的定义和引用
7.2.1 二维数组的定义
7.2.2 二维数组的引用
7.2.3 二维数组的初始化
7.2.4 二维数组程序举例
7.3 字符数组
7.3.1 字符数组的定义
7.3.2 字符数组的初始化
7.3.3 字符数组的引用
7.3.4 字符串和字符串结束标志
7.3.5 字符数组的输入输出
7.3.6 字符串处理函数
7.3.7 字符数组应用举例
习题
8 函数
8.1 概述
8.2 函数定义的一般形式
8.2.1 无参函数定义的一般形式
8.2.2 有参函数定义的一般形式
8.2.3 空函数
8.3 函数参数和函数的值
8.3.1 形式参数和实际参数
8.3.2 函数的返回值
8.4 函数的调用
8.4.1 函数调用的一般形式
……
9 预处理命令
10 指针
11 结构体与共用体
12 位运算
13 文件
14 常见错误和程序调试
附录A 常用字符与ASCⅡ代码对照表
附录B C语言中的关键字
附录C 运算符和结合性
附录D C语言常用语法提要
附录E C库函数
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大问题
中文版序..........i
前言..........1
哲学的主题..........4
致教师..........6
致谢..........7
导言　做哲学..........9
避免时髦词语..........12
明确表达和论证：哲学的两个重要特征..........14
概念与概念框架..........16
有风格地做哲学..........23
逻辑准备..........27
演绎..........30
归纳..........32
对论证进行批判..........34
篇末问题..........39
阅读建议..........40
第一章　哲学问题..........41
什么是哲学..........44
开篇问题..........45
阅读建议..........59
第二章　生活的意义..........61
开篇问题..........63
什么样的意义..........64
生活的各种意义..........71
篇末问题..........87
阅读建议..........88
第三章　上帝..........91
开篇问题..........94
信仰上帝..........96
男女众神..........97
西方关于上帝的传统观念..........99
恶的问题..........113
信仰与理性：信仰的方式..........120
宗教宽容：仪式、传统和精神性..........131
怀疑..........137
篇末问题..........137
阅读建议..........138
第四章　实在的本性..........141
开篇问题..........143
实在的世界..........144
什么是最真实的？..........147
最初的形而上学家..........151
早期关于实在的非物理看法..........155
柏拉图的“理式”..........158
亚里士多德的形而上学..........162
心灵与形而上学..........164
唯心论..........171
目的论..........177
形而上学与日常世界..........181
篇末问题..........183
阅读建议..........184
第五章　真理的追寻..........187
开篇问题..........189
什么是真的？..........190
两种真理..........192
唯理论与经验论..........196
知识的预设..........199
怀疑论..........201
知识、真理与科学..........211
真理的本性..........217
合理性..........222
主观真理与相对主义问题..........226
篇末问题..........232
阅读建议..........233
第六章　自我..........235
开篇问题..........237
本质自我..........238
自我及其情感..........245
心—身问题..........252
关于自我的其他理论..........260
篇末问题..........276
阅读建议..........277
第七章　自由..........279
开篇问题..........281
自由与好的生活..........282
自由意志与决定论..........294
篇末问题..........308
阅读建议..........309
第八章　道德和好的生活..........311
开篇问题..........313
道德哲学..........314
好的生活..........316
利己主义和利他主义..........325
道德和道德理论..........332
义务论道德..........337
后果论理论..........340
亚里士多德和美德伦理学..........345
女性主义伦理学：关怀伦理学..........347
道德—相对的还是绝对的？..........350
尼采和对道德的攻击..........353
篇末问题..........356
阅读建议..........357
第九章　正义和好的社会..........359
开篇问题..........361
道德与社会..........362
社会的性质..........363
该由谁来统治？—合法性问题..........365
无政府主义、自由市场以及对政府的需要..........368
什么是正义？..........371
平等的含义..........375
正义的起源与社会契约..........378
我们边界之外的正义..........382
权利和自我..........385
被拒绝的正义：种族问题..........387
性政治：女权主义哲学的兴起..........390
篇末问题..........402
阅读建议..........404
第十章　非西方哲学..........407
开篇问题..........410
超越西方传统..........410
拓宽我们的视域..........412
其他文化，其他哲学..........413
篇末问题..........440
阅读建议..........441
第十一章　美..........443
开篇问题..........445
美学..........445
美与真..........447
欣赏悲剧..........451
关于品位的争论..........453
艺术、伦理与宗教..........456
它为什么是艺术？..........459
大众文化美学..........461
篇末问题..........464
阅读建议..........465
附录一　写作哲学..........467
开篇问题..........469
写好哲学的规则..........470
间接风格..........485
附录二　演绎逻辑　有效的论证形式..........499
附录三　常见的非形式谬误..........507
“非形式”谬误..........509
术语表..........517
中文版第三版译后记..........539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大问题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>使日十年
【全书目录】
关于作者
序言
第一章 刺杀阴影笼罩下的日本
第二章 暴风雨前平静的三年
第三章 从未遂政变到公开战争
第四章 中国事变
第五章 一个世界，两场战争
第六章 一个世界，一场战争
日本主要官员及各国派驻日本的主要外交使节人名一览
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>使日十年
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高卢战记译笺·第一卷
目   次
前    言
一、解  题
二、版本源流
三、译笺说明
高卢战记·第一卷
笺    注
赫珥威提依之役（第1~29章）
第1章 高卢的地理和部族
第2章 欧尔革托瑞克斯的阴谋
第3章 赫珥威提依人准备侵扰高卢
第4章 欧尔革托瑞克斯之死
第5章 赫珥威提依人继续做准备
第6章 赫珥威提依人决意取道罗马行省
第7章 凯撒的缓兵之计
第8章 罗马人增强防御；赫珥威提依人企图强渡
第9章 色克瓦尼人允许赫珥威提依人通过他们的领地
第10章 凯撒加紧阻止赫珥威提依人行军
第11章 海都依人和阿姆巴尔瑞人向凯撒求助
第12章 阿剌尔河大捷
第13章 凯撒渡河；迪维科出使
第14章 凯撒的回复
第15章 凯撒追踪敌军；骑兵间的接触战
第16章 久未解决的粮食问题
第17章 利斯库斯道出真相
第18章 都姆诺瑞克斯的恶行
第19章 凯撒安抚迪维奇阿库斯
第20章 凯撒宽恕都姆诺瑞克斯
第21章 凯撒接近赫珥威提依人
第22章 科恩西迪乌斯延误战机
第23章 赫珥威提依人回头攻击罗马军队
第24章 凯撒布置战斗阵列
第25章 罗马军队背水一战
第26章 赫珥威提依人败北
第27章 赫珥威提依人投降；威尔比革努斯人逃跑
第28章 战后的安置工作
第29章 战斗前后赫珥威提依人的数量
阿瑞欧维斯图斯之役（第30~54章）
第30章 高卢首领拜见凯撒
第31章 残暴的阿瑞欧维斯图斯
第32章 色克瓦尼人的遭遇
第33章 凯撒的考量
第34章 阿瑞欧维斯图斯拒绝会谈
第35章 凯撒第二次遣使
第36章 阿瑞欧维斯图斯的回复
第37章 凯撒决定采取行动
第38章 凯撒占领威索恩提欧
第39章 恐惧笼罩罗马军营
第40章 凯撒用言辞鼓舞军队
第41章 罗马军队向统帅凯撒道歉；凯撒率军出发
第42章 阿瑞欧维斯图斯同意会谈；凯撒为之准备
第43章 凯撒的要求
第44章 阿氏的回复
第45章 凯撒的驳斥
第46章 会谈被日耳曼军队的袭击打断
第47章 凯撒拒绝第二次会谈
第48章 阿瑞欧维斯图斯回避正面交锋；骑兵战
第49章 罗马军队第二次扎营
第50章 阿瑞欧维斯图斯攻击小营；回避正面交锋的原因
第51章 双方列阵
第52章 战斗开始
第53章 日耳曼人败北
第54章 尾  声
附    录
一、Greenough本导言（第一至第五部分）
1. 凯撒生平
2. 罗马军事
3. 高卢与高卢人
4. 不列颠人
5. 日耳曼人
二、插  图
三、简化版拉丁文、古希腊文译音表
四、专名引得
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高卢战记译笺·第一卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解C++11
免责声明
序
前言
第1章　新标准的诞生
1.1　曙光：c++11标准的诞生
1.1.1　c++11/c++0x（以及c11/c1x）—新标准诞生
1.1.2　什么是c++11/c++0x
1.1.3　新c++语言的设计目标
1.2　今时今日的c++
1.2.1　c++的江湖地位
1.2.2　c++11语言变化的领域
1.3　c++11特性的分类
1.4　c++特性一览
1.4.1　稳定性与兼容性之间的抉择
1.4.2　更倾向于使用库而不是扩展语言来实现特性
1.4.3　更倾向于通用的而不是特殊的手段来实现特性
1.4.4　专家新手一概支持
1.4.5　增强类型的安全性
1.4.6　与硬件紧密合作
1.4.7　开发能够改变人们思维方式的特性
1.4.8　融入编程现实
1.5　本书的约定
1.5.1　关于一些术语的翻译
1.5.2　关于代码中的注释
1.5.3　关于本书中的代码示例与实验平台
第2章　保证稳定性和兼容性
2.1　保持与c99兼容
2.1.1　预定义宏
2.1.2　__func__预定义标识符
2.1.3　_pragma操作符
2.1.4　变长参数的宏定义以及__va_args__
2.1.5　宽窄字符串的连接
2.2　long long整型
2.3　扩展的整型
2.4　宏__cplusplus
2.5　静态断言
2.5.1　断言：运行时与预处理时
2.5.2　静态断言与static_assert
2.6　noexcept修饰符与noexcept操作符
2.7　快速初始化成员变量
2.8　非静态成员的sizeof
2.9　扩展的friend语法
2.10　final/override控制
2.11　模板函数的默认模板参数
2.12　外部模板
2.12.1　为什么需要外部模板
2.12.2　显式的实例化与外部模板的声明
2.13　局部和匿名类型作模板实参
2.14　本章小结
第3章　通用为本，专用为末
3.1　继承构造函数
3.2　委派构造函数
3.3　右值引用：移动语义和完美转发
3.3.1　指针成员与拷贝构造
3.3.2　移动语义
3.3.3　左值、右值与右值引用
3.3.4　std::move：强制转化为右值
3.3.5　移动语义的一些其他问题
3.3.6　完美转发
3.4　显式转换操作符
3.5　列表初始化
3.5.1　初始化列表
3.5.2　防止类型收窄
3.6　pod类型
3.7　非受限联合体
3.8　用户自定义字面量
3.9　内联名字空间
3.10　模板的别名
3.11　一般化的sfinea规则
3.12　本章小结
第4章　新手易学，老兵易用
4.1　右尖括号>的改进
4.2　auto类型推导
4.2.1　静态类型、动态类型与类型推导
4.2.2　auto的优势
4.2.3　auto的使用细则
4.3　decltype
4.3.1　typeid与decltype
4.3.2　decltype的应用
4.3.3　decltype推导四规则
4.3.4　cv限制符的继承与冗余的符号
4.4　追踪返回类型
4.4.1　追踪返回类型的引入
4.4.2　使用追踪返回类型的函数
4.5　基于范围的for循环
4.6　本章小结
第5章　提高类型安全
5.1　强类型枚举
5.1.1　枚举：分门别类与数值的名字
5.1.2　有缺陷的枚举类型
5.1.3　强类型枚举以及c++11对原有枚举类型的扩展
5.2　堆内存管理：智能指针与垃圾回收
5.2.1　显式内存管理
5.2.2　c++11的智能指针
5.2.3　垃圾回收的分类
5.2.4　c++与垃圾回收
5.2.5　c++11与最小垃圾回收支持
5.2.6　垃圾回收的兼容性
5.3　本章小结
第6章　提高性能及操作硬件的能力
6.1　常量表达式
6.1.1　运行时常量性与编译时常量性
6.1.2　常量表达式函数
6.1.3　常量表达式值
6.1.4　常量表达式的其他应用
6.2　变长模板
6.2.1　变长函数和变长的模板参数
6.2.2　变长模板：模板参数包和函数参数包
6.2.3　变长模板：进阶
6.3　原子类型与原子操作
6.3.1　并行编程、多线程与c++11
6.3.2　原子操作与c++11原子类型
6.3.3　内存模型，顺序一致性与memory_order
6.4　线程局部存储
6.5　快速退出：quick_exit与at_quick_exit
6.6　本章小结
第7章　为改变思考方式而改变
7.1　指针空值—nullptr
7.1.1　指针空值：从0到null，再到nullptr
7.1.2　nullptr和nullptr_t
7.1.3　一些关于nullptr规则的讨论
7.2　默认函数的控制
7.2.1　类与默认函数
7.2.2　“= default”与“= deleted”
7.3　lambda函数
7.3.1　lambda的一些历史
7.3.2　c++11中的lambda函数
7.3.3　lambda与仿函数
7.3.4　lambda的基础使用
7.3.5　关于lambda的一些问题及有趣的实验
7.3.6　lambda与stl
7.3.7　更多的一些关于lambda的讨论
7.4　本章小结
第8章　融入实际应用
8.1　对齐支持
8.1.1　数据对齐
8.1.2　c++11的alignof和alignas
8.2　通用属性
8.2.1　语言扩展到通用属性
8.2.2　c++11的通用属性
8.2.3　预定义的通用属性
8.3　unicode支持
8.3.1　字符集、编码和unicode
8.3.2　c++11中的unicode支持
8.3.3　关于unicode的库支持
8.4　原生字符串字面量
8.5　本章小结
附录a　c++11对其他标准的不兼容项目
附录b　弃用的特性
附录c　编译器支持
附录d　相关资源
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解C++11
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>社会学的想象力
第一章	承诺
第二章	宏大理论
第三章	抽象经验主义
第四章	各类实用取向
第五章	科层制气质
第六章	各种科学哲学
第七章	人的多样性
第八章	历史的运用
第九章	论理性与自由
第十章	论政治
附论：论治学之道
致谢
新版跋  托德•吉特林
中外专名与主题索引
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>社会学的想象力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>一站式学习C编程
《一站式学习c编程》
上篇 c语言入门
第1章 程序的基本概念 2
1.1 程序和编程语言 2
1.2 自然语言和形式语言 6
1.3 程序的调试 8
1.4 第一个程序 9
第2章 常量、变量和表达式 13
2.1 继续hello world 13
2.2 常量 16
2.3 变量 17
2.4 赋值 19
2.5 表达式 20
2.6 字符类型与字符编码 24
第3章 简单函数 26
3.1 数学函数 26
3.2 自定义函数 28
3.3 形参和实参 34
3.4 全局变量、局部变量和作用域 38
第4章 分支语句 44
.4.1 if语句 44
4.2 if/else语句 46
4.3 布尔代数 48
4.4 switch语句 52
第5章 深入理解函数 54
5.1 return语句 54
5.2 增量式开发 57
5.3 递归 61
第6章 循环语句 67
6.1 while语句 67
6.2 do/while语句 69
6.3 for语句 70
6.4 break和continue语句 72
6.5 嵌套循环 73
6.6 goto语句和标号 74
第7章 结构体 78
7.1 复合类型与结构体 78
7.2 数据抽象 82
7.3 数据类型标志 86
7.4 嵌套结构体 87
第8章 数组 89
8.1 数组的基本概念 89
8.2 数组应用实例：统计随机数 92
8.3 数组应用实例：直方图 95
8.4 字符串 98
8.5 多维数组 100
第9章 编码风格 104
9.1 缩进和空白 104
9.2 注释 108
9.3 标识符命名 112
9.4 函数 112
9.5 indent工具 113
第10章 gdb 115
10.1 单步执行和跟踪函数调用 115
10.2 断点 122
10.3 观察点 126
10.4 段错误 130
第11章 排序与查找 133
11.1 算法的概念 133
11.2 插入排序 134
11.3 算法的时间复杂度分析 136
11.4 归并排序 138
11.5 线性查找 143
11.6 折半查找 144
第12章 栈与队列 149
12.1 数据结构的概念 149
12.2 堆栈 149
12.3 深度优先搜索 151
12.4 队列与广度优先搜索 157
12.5 环形队列 162
本阶段总结 163
下篇 c语言本质
第13章 计算机中数的表示 166
13.1 为什么计算机用二进制计数 166
13.2 不同进制之间的换算 168
13.3 整数的加减运算 170
13.3.1 sign and magnitude表示法 170
13.3.2 1's complement表示法 170
13.3.3 2's complement表示法 172
13.3.4 有符号数和无符号数 173
13.4 浮点数 173
第14章 数据类型详解 176
14.1 整型 176
14.2 浮点型 180
14.3 类型转换 181
14.3.1 integer promotion 181
14.3.2 usual arithmetic conversion 182
14.3.3 由赋值产生的类型转换 183
14.3.4 强制类型转换 183
14.3.5 编译器如何处理类型转换 184
第15章 运算符详解 186
15.1 位运算 186
15.1.1 按位与、或、异或、取反运算 186
15.1.2 移位运算 187
15.1.3 掩码 188
15.1.4 异或运算的一些特性 189
15.2 其他运算符 190
15.2.1 复合赋值运算符 190
15.2.2 条件运算符 190
15.2.3 逗号运算符 191
15.2.4 sizeof运算符与typedef类型声明 191
15.3 side effect与sequence point 193
15.4 运算符总结 196
第16章 计算机体系结构基础 198
16.1 内存与地址 198
16.2 cpu 198
16.3 设备 201
16.4 mmu 203
16.5 memory hierarchy 205
第17章 x86汇编程序基础 209
17.1 最简单的汇编程序 209
17.2 x86的寄存器 212
17.3 第二个汇编程序 212
17.4 寻址方式 215
17.5 elf文件 216
17.5.1 目标文件 217
17.5.2 可执行文件 223
第18章 汇编与c之间的关系 229
18.1 函数调用 229
18.2 main函数、启动例程和退出状态 236
18.3 变量的存储布局 242
18.4 结构体和联合体 249
18.5 c内联汇编 254
18.6 volatile限定符 255
第19章 链接详解 260
19.1 多目标文件的链接 260
19.2 定义和声明 266
19.2.1 extern和static关键字 266
19.2.2 头文件 269
19.2.3 定义和声明的详细规则 274
19.3 静态库 276
19.4 共享库 279
19.4.1 编译、链接、运行 279
19.4.2 函数的动态链接过程 286
19.4.3 共享库的命名惯例 288
19.5 虚拟内存管理 290
第20章 预处理 296
20.1 预处理的步骤 296
20.2 宏定义 297
20.2.1 函数式宏定义 297
20.2.2 内联函数 300
20.2.3 #、##运算符和可变参数 301
20.2.4 #undef预处理指示 304
20.2.5 宏展开的步骤 304
20.3 条件预处理指示 305
20.4 其他预处理特性 309
第21章 makefile基础 312
21.1 基本规则 312
21.2 隐含规则和模式规则 319
21.3 变量 322
21.4 自动处理头文件的依赖关系 327
21.5 常用的make命令行选项 331
第22章 指针 334
22.1 指针的基本概念 334
22.2 指针类型的参数和返回值 337
22.3 指针与数组 339
22.4 指针与const限定符 342
22.5 指针与结构体 344
22.6 指向指针的指针与指针数组 344
22.7 指向数组的指针与多维数组 348
22.8 函数类型和函数指针类型 349
22.9 不完全类型和复杂声明 353
第23章 函数接口 357
23.1 本章的预备知识 357
23.1.1 strcpy与strncpy 357
23.1.2 malloc与free 362
23.2 传入参数与传出参数 367
23.3 两层指针的参数 368
23.4 返回值是指针的情况 370
23.5 回调函数 373
23.6 可变参数 376
第24章 c标准库 380
24.1 字符串操作函数 381
24.1.1 给字符串赋初值 381
24.1.2 取字符串的长度 382
24.1.3 拷贝字符串 383
24.1.4 连接字符串 385
24.1.5 比较字符串 386
24.1.6 搜索字符串 387
24.1.7 分割字符串 387
24.2 标准i/o库函数 391
24.2.1 文件的基本概念 391
24.2.2 fopen/fclose 392
24.2.3 stdin/stdout/stderr 395
24.2.4 errno与perror/strerror函数 396
24.2.5 以字节为单位的i/o函数 398
24.2.6 操作读写位置的函数 401
24.2.7 以字符串为单位的i/o函数 403
24.2.8 以记录为单位的i/o函数 404
24.2.9 格式化i/o函数 406
24.2.10 c标准库的i/o缓冲区 413
24.2.11 本节综合练习 417
24.3 数值字符串转换函数 418
24.4 分配内存的函数 420
第25章 链表、二叉树和哈希表 422
25.1 链表 422
25.1.1 单链表 422
25.1.2 双向链表 428
25.1.3 静态链表 433
25.1.4 本节综合练习 433
25.2 二叉树 434
25.2.1 二叉树的基本概念 434
25.2.2 排序二叉树 439
25.3 哈希表 443
本阶段总结 445
附录a 字符编码 449
参考文献 456
索引 458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>一站式学习C编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言接口与实现
第1 章  引言　　1
1.1  文学程序　　2
1.2  程序设计风格　　 6
1.3  效率　　8
1.4  扩展阅读　　9
1.5  习题　　 9
第2 章  接口与实现　　11
2.1  接口　　11
2.2  实现　　 13
2.3  抽象数据类型　　15
2.4  客户程序的职责　　17
2.5  效率　　21
2.6  扩展阅读　　22
2.7  习题　　22
第3 章  原子　　24
3.1  接口　　24
3.2  实现　　25
3.3  扩展阅读　　30
3.4  习题　　31
第4 章  异常与断言　　33
4.1  接口　　35
4.2  实现　　38
4.3  断言　　44
4.4  扩展阅读　　46
4.5  习题　　47
第5 章  内存管理　　49
5.1  接口　　 50
5.2  产品实现　　54
5.3  稽核实现　　55
5.4  扩展阅读　　62
5.5  习题　　63
第6 章  再谈内存管理　　65
6.1  接口　　65
6.2  实现　　67
6.3  扩展阅读　　 72
6.4  习题　　 73
第7 章  链表　　 75
7.1  接口　　 75
7.2  实现　　79
7.3  扩展阅读　　83
7.4  习题　　83
第8 章  表　　84
8.1  接口　　84
8.2  例子：词频　　 87
8.3  实现　　 91
8.4  扩展阅读　　97
8.5  习题　　 97
第9 章  集合　　 99
9.1  接口　　99
9.2  例子：交叉引用列表　　101
9.3  实现　　 107
9.3.1  成员操作　　109
9.3.2  集合操作　　111
9.4  扩展阅读　　114
9.5  习题　　115
第10 章  动态数组　　116
10.1  接口　　116
10.2  实现　　119
10.3  扩展阅读　　122
10.4  习题　　122
第11 章  序列　　123
11.1  接口　　123
11.2  实现　　125
11.3  扩展阅读　　129
11.4  习题　　129
第12 章  环　　131
12.1  接口　　131
12.2  实现　　134
12.3  扩展阅读　　141
12.4  习题　　141
第13 章  位向量　　142
13.1  接口　　142
13.2  实现　　144
13.2.1  成员操作　　146
13.2.2  比较　　150
13.2.3  集合操作　　151
13.3  扩展阅读　　 152
13.4  习题　　153
第14 章  格式化　　154
14.1  接口　　154
14.1.1  格式化函数　　155
14.1.2  转换函数　　 157
14.2  实现　　160
14.2.1  格式化函数　　161
14.2.2  转换函数　　166
14.3  扩展阅读　　170
14.4  习题　　171
第15 章  低级字符串　　 172
15.1  接口　　173
15.2  例子：输出标识符　　178
15.3  实现　　179
15.3.1  字符串操作　　180
15.3.2  分析字符串　　184
15.3.3  转换函数　　188
15.4  扩展阅读　　 189
15.5  习题　　189
第16 章  高级字符串　　192
16.1  接口　　192
16.2  实现　　197
16.2.1  字符串操作　　200
16.2.2  内存管理　　 204
16.2.3  分析字符串　　205
16.2.4  转换函数　　209
16.3  扩展阅读　　210
16.4  习题　　 210
第17 章  扩展精度算术　　212
17.1  接口　　212
17.2  实现　　217
17.2.1  加减法　　218
17.2.2  乘法　　220
17.2.3  除法和比较　　 221
17.2.4  移位　　226
17.2.5  字符串转换　　228
17.3  扩展阅读　　230
17.4  习题　　230
第18 章  任意精度算术　　232
18.1  接口　　 232
18.2  例子：计算器　　235
18.3  实现　　240
18.3.1  取反和乘法　　242
18.3.2  加减法　　 243
18.3.3  除法　　 246
18.3.4  取幂　　 247
18.3.5  比较　　 249
18.3.6  便捷函数　　 250
18.3.7  移位　　 251
18.3.8  与字符串和整数的转换　　 252
18.4  扩展阅读　　 254
18.5  习题　　 255
第19 章  多精度算术　　 257
19.1  接口　　 257
19.2  例子：另一个计算器　　263
19.3  实现　　269
19.3.1  转换　　 272
19.3.2  无符号算术　　275
19.3.3  有符号算术　　277
19.3.4  便捷函数　　280
19.3.5  比较和逻辑操作　　285
19.3.6  字符串转换　　288
19.4  扩展阅读　　290
19.5  习题　　291
第20 章  线程　　292
20.1  接口　　294
20.1.1  线程　　 294
20.1.2  一般信号量　　 298
20.1.3  同步通信通道　　301
20.2  例子　　301
20.2.1  并发排序　　302
20.2.2  临界区　　305
20.2.3  生成素数　　307
20.3  实现　　311
20.3.1  同步通信通道　　311
20.3.2  线程　　313
20.3.3  线程创建和上下文切换　　322
20.3.4  抢占　　328
20.3.5  一般信号量　　330
20.3.6  MIPS 和ALPHA 上的上下文切换　　332
20.4  扩展阅读　　 335
20.5  习题　　336
附录A 接口摘要　　339
参考书目　　363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言接口与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Modern C++ 简体中文版
推荐序
译者序
对本书的称许
出版商声明
致谢
绪论
术语和惯例
提交缺陷报告和改进建议
型别推导
条款1：理解模板型别推导
条款2：理解auto型别推导
条款3：理解decltype
条款4：掌握查看型别推导结果的方法
auto
条款5：优先选用auto，而非显式型别声明
条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法
转向现代C++
条款7：在创建对象时注意区分()和{}
条款8：优先选用nullptr，而非0或NULL
条款9：优先选用别名声明，而非typedef
条款10：优先选用限定作用域的枚举型别，而非不限作用域的枚举型别
条款11：优先选用删除函数，而非private未定义函数
条款12：为意在改写的函数添加override声明
条款13：优先选用const_iterator，而非iterator
条款14：只要函数不会发射异常，就为其加上noexcept声明
条款15：只要有可能使用constexpr，就使用它
条款16：保证const成员函数的线程安全性
条款17：理解特种成员函数的生成机制
智能指针
条款18：使用std::unique_ptr管理具备专属所有权的资源
条款19：使用std::shared_ptr管理具备共享所有权的资源
条款20：对于类似于std::shared_ptr、但有可能空悬的指针使用std::weak_ptr
条款21：优先选用std::make_unique和std::make_shared，而非直接使用new
条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中
右值引用、移动语义和完美转发
条款23：理解std::move和std::forward
条款24：区分万能引用和右值引用
条款25：针对右值引用实施std::move，针对万能引用实施std::forward
条款26：避免依万能引用型别进行重载
条款27：熟悉依万能引用型别进行重载的替代方案
条款28：理解引用折叠
条款29：假定移动操作不存在、成本高、未使用
条款30：熟悉完美转发的失败情形
lambda表达式
条款31：避免默认捕获模式
条款32：使用初始化捕获将对象移入闭包
条款33：对auto&&型别的形参使用decltype，以std::forward之
条款34：优先选用lambda式，而非std::bind
并发API
条款35：优先选用基于任务而非基于线程的程序设计
条款36：如果异步是必要的，则指定std::launch::async
条款37：使std::thread型别对象在所有路径皆不可联结
条款38：对变化多端的线程句柄析构函数行为保持关注
条款39：考虑针对一次性事件通信使用以void为模板型别实参的期值
条款40：对并发使用std::atomic，对特种内存使用volatile
微调
条款41：针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递
条款42：考虑置入而非插入
作者简介
题记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Modern C++ 简体中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计语言
序第1版序IntroductionChapter 1. A Tutorial Introduction       1.1  Getting Started       1.2  Variables and Arithmetic Expressions       1.3  The For Statement       1.4  Symbolic Constants       1.5  Character Input and Output       1.6  Arrays       1.7  Functions       1.8  Arguments--Call by Value       1.9  Character Arrays       1.10 External Variables and ScopeChapter 2. Types, Operators, and Expressions       2.1  Variable Names       2.2  Data Types and Sizes       2.3  Constants       2.4  Declarations        2.5  Arithmetic Operators        2.6  Relational and Logical Operators        2.7  Type Conversions        2.8  Increment and Decrement Operators        2.9  Bitwise Operators        2.10 Assignment Operators and Expressions        2.11 Conditional Expressions        2.12 Precedence and Order of Evaluation Chapter 3. Control Flow        3.1  Statements and Blocks        3.2  If-Else       3.3  Else-If       3.4  Switch       3.5  Loops--While and For       3.6  Loops-Do-while       3.7  Break and Continue       3.8  Goto and LabelsChapter 4. Functions and Program Structure       4.1  Basics of Functions       4.2  Functions Returning Non-integers       4.3  External Variables       4.4  Scope Rules       4.5  Header Files       4.6  Static Variables       4.7  Register Variables       4.8  Block Structure       4.9  Initialization       4.10 Recursion       4.11 The C PreprocessorChapter 5. Pointers and Arrays       5.1  Pointers and Addresses       5.2  Pointers and Function Arguments        5.3  Pointers and Arrays       5.4  Address Arithmetic       5.5  Character Pointers and Functions       5.6  Pointer Arrays; Pointers to Pointers       5.7  Multi-dimensional Arrays       5.8  Initialization of Pointer Arrays       5.9  Pointers vs. Multi-dimensional Arrays       5.10 Command-line Arguments       5.11 Pointers to Functions       5.12 Complicated DeclarationsChapter 6. Structures       6.1  Basics of Structures       6.2  Structures and Functions       6.3  Arrays of Structures       6.4  Pointers to Structures       6.5  Self-referential Structures       6.6  Table Lookup       6.7  Typedef       6.8  Unions       6.9  Bit-fieldsChapter 7. Input and Output       7.1  Standard Input and Output       7.2  Formatted Output--Printf      7.3  Variable-length Argument Lists      7.4  Formatted Input-Scanf      7.5  File Access      7.6  Error Handling--Stderr and Exit      7.7  Line Input and Output      7.8  Miscellaneous FunctionsChapter 8. The UNIX System Interface       8.1  File Descriptors      8.2  Low Level I/O-Read and Write      8.3  Open, Creat, Close, Unlink       8.4  Random Access--Lscek       8.5  Example--An Implementation of Fopen and Getc       8.6  Example--Listing Directories       8.7  Example--A Storage AllocatorAppendix A. Reference Marital       AI  Introduction       A2  Lexical Conventions       A3  Syntax Notation       A4  Meaning of Identifiers       A5  Objects and Lvalues       A6  Conversions       A7  Expressions       A8  Declarations       A9  Statements       AI0 External Declarations       All Scopeand Linkage       A12 Preprocessing       A13 GrammarAppendix B. Standard Library       B1  Input and Output: <stdio.h>       B2  Character Class Tests: <ctype.h>       B3  String Functions: <string.h>       B4  Mathematical Functions: <math.h>       B5  Utility Functions: <stdlib.h>       B6  Diagnostics: <assert.h>       B7  Variable Argument Lists: <stdarg.h>       B8 Non-local Jumps: <setjmp.h>       B9  Signals: <signal.h>       B10 Date and Time Functions: <time.h>       BI 1 Implementation-defined Limits: <limits.h> and <float.h>Appendix C. Summary of ChangesIndex
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>嗨翻C语言
目录（精简版）
引子　xxxi
1 　C语言入门：进入C语言的世界　　1
2 　存储器和指针：指向何方？　　41
2.5 　字符串：字符串原理　　83
3 　创建小工具：做一件事并把它做好　　103
4 　使用多个源文件：分而治之　　157
C语言实验室1：Arduino　　207
5 　结构、联合与位字段：创建自己的结构　　217
6 　数据结构与动态存储：牵线搭桥　　267
7 　高级函数：发挥函数的极限　　311
8 　静态库与动态库：热插拔代码　　351
C语言实验室2：OpenCV　　389
9 　进程与系统调用：打破疆界　　397
10 　进程间通信：沟通的艺术　　429
11 　网络与套接字：金窝，银窝，不如127.0.0.1的草窝　　467
12 　线程：平行世界　　501
C语言实验室3：爆破彗星　　523
i 　饭后甜点：十大遗漏知识点　　539
ii 　话题汇总：总复习　　553
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>嗨翻C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js：来一打 C++ 扩展
1 Node.js 的 C++ 扩展前驱知识储备 1
1.1 Node.js 的模块机制 2
1.1.1 CommonJS 的模块规范 2
1.1.2 Node.js 的模块 4
1.1.3 小结 9
1.1.4 参考资料 9
1.2 Node.js 的包机制 9
1.2.1 CommonJS 的包规范 9
1.2.2 Node.js / NPM 下的包 13
1.2.3 NPM 与 CNPM 16
1.2.4 小结 19
1.2.5 参考资料 19
1.3 Node.js 依赖简介 20
1.3.1 Chrome V8 20
1.3.2 libuv 25
1.3.3 其他依赖 28
1.3.4 小结 30
1.3.5 参考资料 30
1.4 C++ 扩展开发的准备工作 31
1.4.1 编辑器 / IDE 31
1.4.2 node-gyp 36
1.4.3 其他构建工具 54
1.4.4 小结 56
1.4.5 参考资料 56
2 C++ 模块原理简析 57
2.1 为什么要写 C++ 模块 57
2.1.1 C++ 比 JavaScript 解释器高效 57
2.1.2 已有的 C++ 轮子 72
2.1.3 小结 77
2.1.4 参考资料 77
2.2 什么是 C++ 扩展 78
2.2.1 C++ 模块本质 78
2.2.2 Node.js 模块加载原理 80
2.2.3 小结 102
2.2.4 参考资料 103
3 Chrome V8 基础 104
3.1 Node.js 与 Chrome V8 104
3.2 基本概念 105
3.2.1 内存机制 105
3.2.2 隔离实例（Isolate） 108
3.2.3 上下文（Context） 109
3.2.4 脚本（Script） 110
3.2.5 小结 110
3.2.6 参考资料 111
3.3 句柄（Handle） 111
3.3.1 本地句柄（Local） 112
3.3.2 持久句柄（Persistent） 115
3.3.3 永生句柄（Eternal） 119
3.3.4 待实本地句柄（Maybe Local） 119
3.3.5 小结 121
3.3.6 参考资料 121
3.4 句柄作用域 121
3.4.1 一般句柄作用域（Handle Scope） 122
3.4.2 可逃句柄作用域（Escapable Handle Scope） 125
3.4.3 小结 129
3.4.4 参考资料 129
3.5 上下文（Context） 129
3.6 模板（Template） 133
3.6.1 函数模板（Function Template） 133
3.6.2 对象模板（Object Template） 138
3.6.3 对象模板的访问器（Accessor）与拦截器（Interceptor） 144
3.6.4 对象模板的内置字段（Internal Field） 175
3.6.5 函数模板的继承（Inherit） 183
3.6.6 小结 188
3.6.7 参考资料 189
3.7 常用数据类型 189
3.7.1 基值（Value） 189
3.7.2 字符串（String） 194
3.7.3 数值类型 196
3.7.4 布尔类型（Boolean） 196
3.7.5 对象（Object） 196
3.7.6 函数（Function） 200
3.7.7 数组（Array） 202
3.7.8 JSON 解析器 203
3.7.9 函数回调信息（Function Callback Info） 203
3.7.10 函数返回值（Return Value） 204
3.7.11 隔离实例（Isolate） 204
3.7.12 小结 205
3.7.13 参考资料 206
3.8 异常机制 206
3.8.1 try-catch 206
3.8.2 抛出异常 209
3.8.3 异常生成类（Exception） 211
3.8.4 小结 211
3.8.5 参考资料 211
4 C++ 扩展实战初探 212
4.1 binding.gyp 212
4.1.1 惊鸿一瞥 213
4.1.2 binding.gyp 基础结构 213
4.1.3 GYP 文件 214
4.1.4 常用字段 221
4.1.5 小结 228
4.1.6 参考资料 228
4.2 牛刀小试 229
4.2.1 又是 Hello World 229
4.2.2 函数参数 232
4.2.3 回调函数 234
4.2.4 函数返回 238
4.2.5 小结 239
4.2.6 参考资料 240
4.3 循序渐进 240
4.3.1 C++ 与 JavaScript 类封装 240
4.3.2 实例化 C++ 类封装对象的函数 250
4.3.3 将 C++ 类封装对象传来传去 253
4.3.4 进程退出钩子 255
4.3.5 小结 259
4.3.6 参考资料 259
5 Node.js 原生抽象——NAN 260
5.1 Node.js 原生模块开发方式的变迁 260
5.1.1 以不变应万变 260
5.1.2 时代在召唤 261
5.1.3 小结 267
5.1.4 参考资料 267
5.2 基础开发 267
5.2.1 什么是 NAN 267
5.2.2 安装和配置 269
5.2.3 先睹为快——搭上NAN 的快车 270
5.2.4 基础帮助函数和宏 276
5.2.5 忽略 node_modules 279
5.2.6 小结 279
5.2.7 参考资料 280
5.3 JavaScript 函数 280
5.3.1 函数参数类型 280
5.3.2 函数声明 282
5.3.3 函数设置 288
5.3.4 小结 296
5.3.5 参考资料 296
5.4 常用帮助类与函数 296
5.4.1 句柄相关 296
5.4.2 创建数据对象 298
5.4.3 与数据对象“玩耍” 300
5.4.4 封装一个类 314
5.4.5 异常处理 315
5.4.6 小结 315
5.4.7 参考资料 316
5.5 NAN 中的异步机制 316
5.5.1 Nan::AsyncQueueWorker 316
5.5.2 Nan::Callback 317
5.5.3 Nan::AsyncWorker 317
5.5.4 Nan::AsyncProgressWorker 323
5.5.5 小结 327
5.5.6 参考资料 327
6 异步之旅——libuv 328
6.1 基础概念 329
6.1.1 事件循环 330
6.1.2 句柄（Handle）与请求（Request） 333
6.1.3 尝尝甜头 335
6.1.4 小结 340
6.1.5 参考资料 340
6.2 libuv 的跨线程编程基础 341
6.2.1 libuv 的线程 342
6.2.2 同步原语（Synchronization Primitive） 347
6.2.3 工作队列 355
6.2.4 小结 356
6.2.5 参考资料 357
6.3 跨线程通信 357
6.3.1 uv_async_t 句柄 357
6.3.2 Watchdog 半成品实战解析 358
6.3.3 Watchdog 试运行 367
6.3.4 小结 368
6.3.5 参考资料 369
7 实战——文件监视器 370
7.1 准备工作 370
7.1.1 功能规划 370
7.1.2 文件系统监听库——efsw 373
7.1.3 小结 376
7.1.4 参考资料 376
7.2 核心设计 376
7.2.1 API 设计 377
7.2.2 EFSWCore 的血肉之躯 377
7.2.3 EFSWCore 的灵魂 381
7.2.4 小结 385
7.3 编写JavaScript 类 386
7.3.1 类的设计 386
7.3.2 核心逻辑 388
7.3.3 简单容错 391
7.3.4 小结 393
7.4 进一步完善 393
7.4.1 C++ 代码的完善 393
7.4.2 JavaScript 代码的完善 398
7.4.3 小结 400
8 实战——现有包剖析 401
8.1 字符串哈希模块——Bling Hashes 401
8.1.1 文件设定 402
8.1.2 C++ 源码剖析 403
8.1.3 JavaScript 源码剖析 408
8.1.4 小结 409
8.1.5 参考资料 410
8.2 类 Proxy 包——Auto Object 410
8.2.1 Proxy 410
8.2.2 Auto Object 使用范例 412
8.2.3 代码剖析 415
8.2.4 小结 424
8.2.5 参考资料 424
9 N-API——下一代 Node.js C++ 扩展开发方式 425
9.1 浅尝辄止 426
9.1.1 实现一个 Echo 函数 426
9.1.2 尝试运行 N-API 扩展 430
9.1.3 向下兼容 431
9.1.4 N-API Package——C++ 封装 433
9.1.5 小结 433
9.1.6 参考资料 433
9.2 基本数据类型与错误处理 433
9.2.1 基本数据类型 433
9.2.2 与作用域及生命周期相关的数据类型 435
9.2.3 回调数据类型 438
9.2.4 错误处理 439
9.2.5 模块注册 441
9.2.6 小结 442
9.2.7 参考资料 442
9.3 对象与函数 442
9.3.1 对象 442
9.3.2 函数 448
9.3.3 类的封装 453
9.3.4 小结 455
9.3.5 参考资料 455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js：来一打 C++ 扩展
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>六论自发性
前言
无政府主义的透镜，或曰像一个无政府主义者一样观察
组织的悖论
社会科学实践中的无政府主义透镜
一些注意事项
第一章 无序和号召力的功用
碎片一 关于无政府主义操演的斯科特法则
碎片二 论不服从的重要性
碎片三 还论不服从
碎片四 广告：“诚征追随者，自愿服从领导”
第二章 民间秩序，官方秩序
碎片五 民间与官方的“知”之道
碎片六 官方的控制术与控制状态
碎片七 民间的弹性
碎片八 无序城市的诱惑力
碎片九 整洁背后的混乱
碎片十 民间秩序的宿敌
第三章 人的塑造
碎片十一 游戏与开放性
碎片十二 不要以为你可以预测一切！论不确定性和适应性
碎片十三 人类总产出
碎片十四 一家照顾机构
碎片十五 机构生活的病理学
碎片十六 一个试探性、反直觉的例子：移除交通灯
第四章 给小资产阶级的两声喝彩
碎片十七 重新认识一个被诽谤的阶级
碎片十八 蔑视从何而来
碎片十九 小资产者之梦：财产的诱惑
碎片二十 小资产阶级，不小的社会功能
碎片二十一 小资产阶级奉献的“免费午餐”
第五章 为了政治
碎片二十二 争议与质量：对抗质的量化
碎片二十三 如果……？一个假想的审计社会
碎片二十四 缺乏效力，并且最终导致腐化
碎片二十五 民主制、价值和政治的终点
碎片二十六 为政治辩护
第六章 具体性与流变
碎片二十七 善意与同情心的传达
碎片二十八 重新引入具体性、流变和偶然
碎片二十九 历史误读的政治
注释/致谢/索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>六论自发性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer 中文版（第 5 版）
第1章  开始	1
1.1  编写一个简单的C++程序	2
1.1.1  编译、运行程序	3
1.2  初识输入输出	5
1.3  注释简介	8
1.4  控制流	10
1.4.1  while语句	10
1.4.2  for语句	11
1.4.3  读取数量不定的输入数据	13
1.4.4  if语句	15
1.5  类简介	17
1.5.1  Sales_item类	17
1.5.2  初识成员函数	20
1.6  书店程序	21
小结	23
术语表	23
第Ⅰ部分  C++基础	27
第2章  变量和基本类型	29
2.1  基本内置类型	30
2.1.1  算术类型	30
2.1.2  类型转换	32
2.1.3  字面值常量	35
2.2  变量	38
2.2.1  变量定义	38
2.2.2  变量声明和定义的关系	41
2.2.3  标识符	42
2.2.4  名字的作用域	43
2.3  复合类型	45
2.3.1  引用	45
2.3.2  指针	47
2.3.3  理解复合类型的声明	51
2.4  const限定符	53
2.4.1  const的引用	54
2.4.2  指针和const	56
2.4.3  顶层const	57
2.4.4  constexpr和常量表达式	58
2.5  处理类型	60
2.5.1  类型别名	60
2.5.2  auto类型说明符	61
2.5.3  decltype类型指示符	62
2.6  自定义数据结构	64
2.6.1  定义Sales_data类型	64
2.6.2  使用Sales_data类	66
2.6.3  编写自己的头文件	67
小结	69
术语表	69
第3章  字符串、向量和数组	73
3.1  命名空间的using声明	74
3.2  标准库类型string	75
3.2.1  定义和初始化string对象	76
3.2.2  string对象上的操作	77
3.2.3  处理string对象中的字符	81
3.3  标准库类型vector	86
3.3.1  定义和初始化vector对象	87
3.3.2  向vector对象中添加元素	90
3.3.3  其他vector操作	91
3.4  迭代器介绍	95
3.4.1  使用迭代器	95
3.4.2  迭代器运算	99
3.5  数组	101
3.5.1  定义和初始化内置数组	101
3.5.2  访问数组元素	103
3.5.3  指针和数组	105
3.5.4  C风格字符串	109
3.5.5  与旧代码的接口	111
3.6  多维数组	112
小结	117
术语表	117
第4章  表达式	119
4.1  基础	120
4.1.1  基本概念	120
4.1.2  优先级与结合律	121
4.1.3  求值顺序	123
4.2  算术运算符	124
4.3  逻辑和关系运算符	126
4.4  赋值运算符	129
4.5  递增和递减运算符	131
4.6  成员访问运算符	133
4.7  条件运算符	134
4.8  位运算符	135
4.9  sizeof运算符	139
4.10  逗号运算符	140
4.11  类型转换	141
4.11.1  算术转换	142
4.11.2  其他隐式类型转换	143
4.11.3  显式转换	144
4.12  运算符优先级表	147
小结	149
术语表	149
第5章  语句	153
5.1  简单语句	154
5.2  语句作用域	155
5.3  条件语句	156
5.3.1  if语句	156
5.3.2  switch语句	159
5.4  迭代语句	165
5.4.1  while语句	165
5.4.2  传统的for语句	166
5.4.3  范围for语句	168
5.4.4  do while语句	169
5.5  跳转语句	170
5.5.1  break语句	170
5.5.2  continue语句	171
5.5.3  goto语句	172
5.6  TRY语句块和异常处理	172
5.6.1  throw表达式	173
5.6.2  try语句块	174
5.6.3  标准异常	176
小结	178
术语表	178
第6章  函数	181
6.1  函数基础	182
6.1.1  局部对象	184
6.1.2  函数声明	186
6.1.3  分离式编译	186
6.2  参数传递	187
6.2.1  传值参数	187
6.2.2  传引用参数	188
6.2.3  const形参和实参	190
6.2.4  数组形参	193
6.2.5  main：处理命令行选项	196
6.2.6  含有可变形参的函数	197
6.3  返回类型和return语句	199
6.3.1  无返回值函数	200
6.3.2  有返回值函数	200
6.3.3  返回数组指针	205
6.4  函数重载	206
6.4.1  重载与作用域	210
6.5  特殊用途语言特性	211
6.5.1  默认实参	211
6.5.2  内联函数和constexpr函数	213
6.5.3  调试帮助	215
6.6  函数匹配	217
6.6.1  实参类型转换	219
6.7  函数指针	221
小结	225
术语表	225
第7章  类	227
7.1  定义抽象数据类型	228
7.1.1  设计Sales_data类	228
7.1.2  定义改进的Sales_data类	230
7.1.3  定义类相关的非成员函数	234
7.1.4  构造函数	235
7.1.5  拷贝、赋值和析构	239
7.2  访问控制与封装	240
7.2.1  友元	241
7.3  类的其他特性	243
7.3.1  类成员再探	243
7.3.2  返回*this的成员函数	246
7.3.3  类类型	249
7.3.4  友元再探	250
7.4  类的作用域	253
7.4.1  名字查找与类的作用域	254
7.5  构造函数再探	257
7.5.1  构造函数初始值列表	258
7.5.2  委托构造函数	261
7.5.3  默认构造函数的作用	262
7.5.4  隐式的类类型转换	263
7.5.5  聚合类	266
7.5.6  字面值常量类	267
7.6  类的静态成员	268
小结	273
术语表	273
第Ⅱ部  C++标准库	275
第8章  IO库	277
8.1  IO类	278
8.1.1  IO对象无拷贝或赋值	279
8.1.2  条件状态	279
8.1.3  管理输出缓冲	281
8.2  文件输入输出	283
8.2.1  使用文件流对象	284
8.2.2  文件模式	286
8.3  string流	287
8.3.1  使用istringstream	287
8.3.2  使用ostringstream	289
小结	290
术语表	290
第9章  顺序容器	291
9.1  顺序容器概述	292
9.2  容器库概览	294
9.2.1  迭代器	296
9.2.2  容器类型成员	297
9.2.3  begin和end成员	298
9.2.4  容器定义和初始化	299
9.2.5  赋值和swap	302
9.2.6  容器大小操作	304
9.2.7  关系运算符	304
9.3  顺序容器操作	305
9.3.1  向顺序容器添加元素	305
9.3.2  访问元素	309
9.3.3  删除元素	311
9.3.4  特殊的forward_list操作	312
9.3.5  改变容器大小	314
9.3.6  容器操作可能使迭代器失效	315
9.4  vector对象是如何增长的	317
9.5  额外的string操作	320
9.5.1  构造string的其他方法	321
9.5.2  改变string的其他方法	322
9.5.3  string搜索操作	325
9.5.4  compare函数	327
9.5.5  数值转换	327
9.6  容器适配器	329
小结	332
术语表	332
第10章  泛型算法	335
10.1  概述	336
10.2  初识泛型算法	338
10.2.1  只读算法	338
10.2.2  写容器元素的算法	339
10.2.3  重排容器元素的算法	342
10.3  定制操作	344
10.3.1  向算法传递函数	344
10.3.2  lambda表达式	345
10.3.3  lambda捕获和返回	349
10.3.4  参数绑定	354
10.4  再探迭代器	357
10.4.1  插入迭代器	358
10.4.2  iostream迭代器	359
10.4.3  反向迭代器	363
10.5  泛型算法结构	365
10.5.1  5类迭代器	365
10.5.2  算法形参模式	367
10.5.3  算法命名规范	368
10.6  特定容器算法	369
小结	371
术语表	371
第11章  关联容器	373
11.1  使用关联容器	374
11.2  关联容器概述	376
11.2.1  定义关联容器	376
11.2.2  关键字类型的要求	378
11.2.3  pair类型	379
11.3  关联容器操作	381
11.3.1  关联容器迭代器	382
11.3.2  添加元素	383
11.3.3  删除元素	386
11.3.4  map的下标操作	387
11.3.5  访问元素	388
11.3.6  一个单词转换的map	391
11.4  无序容器	394
小结	397
术语表	397
第12章  动态内存	399
12.1  动态内存与智能指针	400
12.1.1  shared_ptr类	400
12.1.2  直接管理内存	407
12.1.3  shared_ptr和new结合使用	412
12.1.4  智能指针和异常	415
12.1.5  unique_ptr	417
12.1.6  weak_ptr	420
12.2  动态数组	423
12.2.1  new和数组	423
12.2.2  allocator类	427
12.3  使用标准库：文本查询程序	430
12.3.1  文本查询程序设计	430
12.3.2  文本查询程序类的定义	432
小结	436
术语表	436
第Ⅲ部分  类设计者的工具	437
第13章  拷贝控制	439
13.1  拷贝、赋值与销毁	440
13.1.1  拷贝构造函数	440
13.1.2  拷贝赋值运算符	443
13.1.3  析构函数	444
13.1.4  三/五法则	447
13.1.5  使用=default	449
13.1.6  阻止拷贝	449
13.2  拷贝控制和资源管理	452
13.2.1  行为像值的类	453
13.2.2  定义行为像指针的类	455
13.3  交换操作	457
13.4  拷贝控制示例	460
13.5  动态内存管理类	464
13.6  对象移动	470
13.6.1  右值引用	471
13.6.2  移动构造函数和移动赋值运算符	473
13.6.3  右值引用和成员函数	481
小结	486
术语表	486
第14章  操作重载与类型转换	489
14.1  基本概念	490
14.2  输入和输出运算符	494
14.2.1  重载输出运算符<<	494
14.2.2  重载输入运算符>>	495
14.3  算术和关系运算符	497
14.3.1  相等运算符	497
14.3.2  关系运算符	498
14.4  赋值运算符	499
14.5  下标运算符	501
14.6  递增和递减运算符	502
14.7  成员访问运算符	504
14.8  函数调用运算符	506
14.8.1  lambda是函数对象	507
14.8.2  标准库定义的函数对象	509
14.8.3  可调用对象与function	511
14.9  重载、类型转换与运算符	514
14.9.1  类型转换运算符	514
14.9.2  避免有二义性的类型转换	517
14.9.3  函数匹配与重载运算符	521
小结	523
术语表	523
第15章  面向对象程序设计	525
15.1  OOP：概述	526
15.2  定义基类和派生类	527
15.2.1  定义基类	528
15.2.2  定义派生类	529
15.2.3  类型转换与继承	534
15.3  虚函数	536
15.4  抽象基类	540
15.5  访问控制与继承	542
15.6  继承中的类作用域	547
15.7  构造函数与拷贝控制	551
15.7.1  虚析构函数	552
15.7.2  合成拷贝控制与继承	552
15.7.3  派生类的拷贝控制成员	554
15.7.4  继承的构造函数	557
15.8  容器与继承	558
15.8.1  编写Basket类	559
15.9  文本查询程序再探	562
15.9.1  面向对象的解决方案	563
15.9.2  Query_base类和Query类	567
15.9.3  派生类	568
15.9.4  eval函数	571
小结	575
术语表	575
第16章  模板与泛型编程	577
16.1  定义模板	578
16.1.1  函数模板	578
16.1.2  类模板	583
16.1.3  模板参数	592
16.1.4  成员模板	595
16.1.5  控制实例化	597
16.1.6  效率与灵活性	599
16.2  模板实参推断	600
16.2.1  类型转换与模板类型参数	601
16.2.2  函数模板显式实参	603
16.2.3  尾置返回类型与类型转换	604
16.2.4  函数指针和实参推断	607
16.2.5  模板实参推断和引用	608
16.2.6  理解std::move	610
16.2.7  转发	612
16.3  重载与模板	614
16.4  可变参数模板	618
16.4.1  编写可变参数函数模板	620
16.4.2  包扩展	621
16.4.3  转发参数包	622
16.5  模板特例化	624
小结	630
术语表	630
第Ⅳ部分  高级主题	633
第17章  标准库特殊设施	635
17.1  tuple类型	636
17.1.1  定义和初始化tuple	637
17.1.2  使用tuple返回多个值	638
17.2  BITSET类型	640
17.2.1  定义和初始化bitset	641
17.2.2  bitset操作	643
17.3  正则表达式	645
17.3.1  使用正则表达式库	646
17.3.2  匹配与Regex迭代器类型	650
17.3.3  使用子表达式	653
17.3.4  使用regex_replace	657
17.4  随机数	659
17.4.2  其他随机数分布	663
bernoulli_distribution类	665
17.5  IO库再探	666
17.5.1  格式化输入与输出	666
17.5.2  未格式化的输入/输出操作	673
17.5.3  流随机访问	676
小结	680
术语表	680
第18章  用于大型程序的工具	683
18.1  异常处理	684
18.1.1  抛出异常	684
18.1.2  捕获异常	687
18.1.3  函数try语句块与构造函数	689
18.1.4  noexcept异常说明	690
18.1.5  异常类层次	693
18.2  命名空间	695
18.2.1  命名空间定义	695
18.2.2  使用命名空间成员	701
18.2.3  类、命名空间与作用域	705
18.2.4  重载与命名空间	708
18.3  多重继承与虚继承	710
18.3.1  多重继承	711
18.3.2  类型转换与多个基类	713
18.3.3  多重继承下的类作用域	715
18.3.4  虚继承	717
18.3.5  构造函数与虚继承	720
小结	722
术语表	722
第19章  特殊工具与技术	725
19.1  控制内存分配	726
19.1.1  重载new和delete	726
19.1.2  定位new表达式	729
19.2  运行时类型识别	730
19.2.1  dynamic_cast运算符	730
19.2.2  typeid运算符	732
19.2.3  使用RTTI	733
19.2.4  type_info类	735
19.3  枚举类型	736
19.4  类成员指针	739
19.4.1  数据成员指针	740
19.4.2  成员函数指针	741
19.4.3  将成员函数用作可调用对象	744
19.5  嵌套类	746
19.6  union：一种节省空间的类	749
19.7  局部类	754
19.8  固有的不可移植的特性	755
19.8.1  位域	756
19.8.2  volatile限定符	757
19.8.3  链接指示：extern "C"	758
小结	762
术语表	762
附录A  标准库	765
A.1  标准库名字和头文件	766
A.2  算法概览	770
A.2.1  查找对象的算法	771
A.2.2  其他只读算法	772
A.2.3  二分搜索算法	772
A.2.4  写容器元素的算法	773
A.2.5  划分与排序算法	775
A.2.6  通用重排操作	776
A.2.7  排列算法	778
A.2.8  有序序列的集合算法	778
A.2.9  最小值和最大值	779
A.2.10  数值算法	780
A.3  随机数	781
A.3.1  随机数分布	781
A.3.2  随机数引擎	783
C++11的新特性
2.1.1  long long类型	31
2.2.1  列表初始化	39
2.3.2  nullptr常量	48
2.4.4  constexpr变量	59
2.5.1  类型别名声明	60
2.5.2  auto类型指示符	61
2.5.3  decltype类型指示符	62
2.6.1  类内初始化	65
3.2.2  使用auto或decltype缩写类型	79
3.2.3  范围for语句	82
3.3   定义vector对象的vector（向量的向量）	87
3.3.1  vector对象的列表初始化	88
3.4.1  容器的cbegin和cend函数	98
3.5.3  标准库begin和end函数	106
3.6   使用auto和decltype简化声明	115
4.2   除法的舍入规则	125
4.4   用大括号包围的值列表赋值	129
4.9   将sizeof用于类成员	139
5.4.3 范围for语句	168
6.2.6  标准库initializer_list类	197
6.3.2  列表初始化返回值	203
6.3.3  定义尾置返回类型	206
6.3.3  使用decltype简化返回类型定义
6.5.2  constexpr函数	214
7.1.4  使用=default生成默认构造函数	237
7.3.1  类对象成员的类内初始化	246
7.5.2  委托构造函数	261
7.5.6  constexpr构造函数	268
8.2.1  用string对象处理文件名	284
9.1   array和forward_list容器	293
9.2.3 容器的cbegin和cend函数	298
9.2.4  容器的列表初始化	300
9.2.5  容器的非成员函数swap	303
9.3.1  容器insert成员的返回类型	308
9.3.1  容器的emplace成员的返回类型	308
9.4   shrink_to_fit	318
9.5.5  string的数值转换函数	327
10.3.2  Lambda表达式	346
10.3.3  Lambda表达式中的尾置返回类型	353
10.3.4  标准库bind函数	354
11.2.1  关联容器的列表初始化	377
11.2.3  列表初始化pair的返回类型	380
11.3.2  pair的列表初始化	384
11.4   无序容器	394
12.1   智能指针	400
12.1.1  shared_ptr类
12.1.2  动态分配对象的列表初始化	407
12.1.2  auto和动态分配	408
12.1.5  unique_ptr类	417
12.1.6  weak_ptr类	420
12.2.1  范围for语句不能应用于动态分配数组	424
12.2.1  动态分配数组的列表初始化	424
12.2.1  auto不能用于分配数组	424
12.2.2  allocator::construct可使用任意构造函数	428
13.1.5  将=default用于拷贝控制成员	449
13.1.6  使用=default阻止拷贝类对象	449
13.5   用移动类对象代替拷贝类对象	469
13.6.1  右值引用	471
13.6.1  标准库move函数	472
13.6.2  移动构造函数和移动赋值	473
13.6.2  移动构造函数通常应该是noexcept	473
13.6.2  移动迭代器	480
13.6.3  引用限定成员函数	483
14.8.3  function类模板	512
14.9.1  explicit类型转换运算符	516
15.2.2  虚函数的override指示符	530
15.2.2  通过定义类为final来阻止继承	533
15.3   虚函数的override和final指示符	538
15.7.2  删除的拷贝控制和继承	553
15.7.4  继承的构造函数	557
16.1.2  声明模板类型形参为友元	590
16.1.2  模板类型别名	590
16.1.3  模板函数的默认模板参数	594
16.1.5  实例化的显式控制	597
16.2.3  模板函数与尾置返回类型	605
16.2.5  引用折叠规则	609
16.2.6  用static_cast将左值转换为右值	612
16.2.7  标准库forward函数	614
16.4   可变参数模板	618
16.4   sizeof...运算符	619
16.4.3  可变参数模板与转发	622
17.1   标准库Tuple类模板	636
17.2.2  新的bitset运算	643
17.3   正则表达式库	645
17.4   随机数库	659
17.5.1  浮点数格式控制	670
18.1.4  noexcept异常指示符	690
18.1.4  noexcept运算符	691
18.2.1  内联名字空间	699
18.3.1  继承的构造函数和多重继承	712
19.3   有作用域的enum	736
19.3   说明类型用于保存enum对象	738
19.3   enum的提前声明	738
19.4.3  标准库mem_fn类模板	746
19.6   类类型的联合成员	751
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer 中文版（第 5 版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言入门经典
第1章 c语言编程
1.1 创建c程序
1.1.1 编辑
1.1.2 编译
1.1.3 链接
1.1.4 执行
1.2 创建第一个程序
1.3 编辑第一个程序
1.4 处理错误
1.5 剖析一个简单的程序
1.5.1 注释
1.5.2 预处理指令
1.5.3 定义main()函数
1.5.4 关键字
1.5.5 函数体
1.5.6 输出信息
1.5.7 参数
1.5.8 控制符
1.6 用c语言开发程序
1.6.1 了解问题
1.6.2 详细设计
1.6.3 实施
1.6.4 测试
1.7 函数及模块化编程
1.8 常见错误
1.9 要点
1.10 小结
1.11 习题
第2章 编程初步
2.1 计算机的内存
2.2 什么是变量
2.3 存储数值的变量
2.3.1 整数变量
2.3.2 变量的命名
2.3.3 变量的使用
2.3.4 变量的初始化
2.3.5 算术语句
2.4 变量与内存
2.5 整数变量类型
2.5.1 无符号的整数类型
2.5.2 使用整数类型
2.5.3 指定整数常量
2.6 浮点数
2.7 浮点数变量
2.8 使用浮点数完成除法运算
2.8.1 控制小数位数
2.8.2 控制输出的字段宽度
2.9 较复杂的表达式
2.10 定义常量
2.10.1 极限值
2.10.2 sizeof运算符
2.11 选择正确的类型
2.12 强制类型转换
2.12.1 自动转换类型
2.12.2 隐式类型转换的规则
2.12.3 赋值语句中的隐式类型转换
2.13 再谈数值数据类型
2.13.1 字符类型
2.13.2 字符的输入输出
2.13.3 宽字符类型
2.13.4 枚举
2.13.5 存储布尔值的变量
2.13.6 复数类型
2.14 赋值操作的op=形式
2.15 数学函数
2.16 设计一个程序
2.16.1 问题
2.16.2 分析
2.16.3 解决方案
2.17 小结
2.18 练习
第3章 条件判断
3.1 判断过程
3.1.1 算术比较
3.1.2 涉及关系运算符的表达式
3.1.3 基本的if语句
3.1.4 扩展if语句：if-else
3.1.5 在if语句中使用代码块
3.1.6 嵌套的if语句
3.1.7 更多的关系运算符
3.1.8 逻辑运算符
3.1.9 条件运算符
3.1.10 运算符的优先级
3.2 多项选择问题
3.2.1 给多项选择使用else-if语句
3.2.2 switch语句
3.2.3 goto语句
3.3 按位运算符
3.3.1 按位运算符的op=用法
3.3.2 使用按位运算符
3.4 设计程序
3.4.1 问题
3.4.2 分析
3.4.3 解决方案
3.5 小结
3.6 练习
第4章 循环
4.1 循环
4.2 递增和递减运算符
4.3 for循环
4.4 for循环的一般语法
4.5 再谈递增和递减运算符
4.5.1 递增运算符
4.5.2 递增运算符的前置和后置形式
4.5.3 递减运算符
4.6 再论for循环
4.6.1 修改for循环变量
4.6.2 没有参数的for循环
4.6.3 循环内的break语句
4.6.4 使用for循环限制输入
4.6.5 生成伪随机整数
4.6.6 再谈循环控制选项
4.6.7 浮点类型的循环控制变量
4.7 while循环
4.8 嵌套循环
4.9 嵌套循环和goto语句
4.10 do-while循环
4.11 continue语句
4.12 设计程序
4.12.1 问题
4.12.2 分析
4.12.3 解决方案
4.13 小结
4.14 习题
第5章 数组
5.1 数组简介
5.1.1 不用数组的程序
5.1.2 什么是数组
5.1.3 使用数组
5.2 内存
5.3 数组和地址
5.4 数组的初始化
5.5 确定数组的大小
5.6 多维数组
5.7 多维数组的初始化
5.8 设计一个程序
5.8.1 问题
5.8.2 分析
5.8.3 解决方案
5.9 小结
5.10 习题
第6章 字符串和文本的应用
6.1 什么是字符串
6.2 处理字符串和文本的方法
6.3 字符串操作
6.3.1 连接字符串
6.3.2 字符串数组
6.4 字符串库函数
6.4.1 使用库函数复制字符串
6.4.2 使用库函数确定字符串的长度
6.4.3 使用库函数连接字符串
6.4.4 比较字符串
6.4.5 搜索字符串
6.5 分析和转换字符串
6.5.1 转换字符
6.5.2 将字符串转换成数值
6.7 使用宽字符串
6.8 设计一个程序
6.8.1 问题
6.8.2 分析
6.8.3 解决方案
6.9 小结
6.10 习题
第7章 指针
7.1 指针初探
7.1.1 声明指针
7.1.2 通过指针访问值
7.1.3 使用指针
7.1.4 指向常量的指针
7.1.5 常量指针
7.1.6 指针的命名
7.2 数组和指针
7.3 多维数组
7.3.1 多维数组和指针
7.3.2 访问数组元素
7.4 内存的使用
7.4.1 动态内存分配：malloc()函数
7.4.2 分配内存时使用sizeof运算符
7.4.3 用calloc()函数分配内存
7.4.4 释放动态分配的内存
7.4.5 重新分配内存
7.5 使用指针处理字符串
7.5.1 更多地控制字符串输入
7.5.2 使用指针数组
7.6 设计程序
7.6.1 问题
7.6.2 分析
7.6.3 解决方案
7.7 小结
7.8 习题
第8章 程序的结构
8.1 程序的结构
8.1.1 变量的作用域和生存期
8.1.2 变量的作用域和函数
8.2 函数
8.2.1 定义函数
8.2.2 return语句
8.3 按值传递机制
8.4 函数声明
8.5 指针用作参数和返回值
8.5.1 常量参数
8.5.2 从函数中返回指针值
8.5.3 在函数中递增指针
8.6 小结
8.7 习题
第9章 函数再探
9.1 函数指针
9.1.1 声明函数指针
9.1.2 通过函数指针调用函数
9.1.3 函数指针数组
9.1.4 作为变元的函数指针
9.2 函数中的变量
9.2.1 静态变量：函数内部的追踪
9.2.2 在函数之间共享变量
9.3 调用自己的函数：递归
9.4 变元个数可变的函数
9.4.1 复制va_list
9.4.2 长度可变的变元列表的基本规则
9.5 main()函数
9.6 结束程序
9.7 函数库：头文件
9.8 提高性能
9.8.1 内联声明函数
9.8.2 使用restrict关键字
9.9 设计程序
9.9.1 问题
9.9.2 分析
9.9.3 解决方案
9.10 小结
9.11 习题
第10章 基本输入和输出操作
10.1 输入和输出流
10.2 标准流
10.3 键盘输入
10.3.1 格式化键盘输入
10.3.2 输入格式控制字符串
10.3.3 输入格式字符串中的字符
10.3.4 输入浮点数的各种变化
10.3.5 读取十六进制和八进制值
10.3.6 用scanf()读取字符
10.3.7 scanf()的陷阱
10.3.8 从键盘上输入字符串
10.3.9 键盘的非格式化输入
10.4 屏幕输出
10.4.1 使用printf()格式输出到屏幕
10.4.2 转义序列
10.4.3 整数输出
10.4.4 输出浮点数
10.4.5 字符输出
10.5 其他输出函数
10.5.1 屏幕的非格式化输出
10.5.2 数组的格式化输出
10.5.3 数组的格式化输入
10.6 打印机输出
10.7 小结
10.8 习题
第11章 结构化数据
11.1 数据结构：使用struct
11.1.1 定义结构类型和结构变量
11.1.2 访问结构成员
11.1.3 未命名的结构
11.1.4 结构数组
11.1.5 表达式中的结构
11.1.6 结构指针
11.1.7 为结构动态分配内存
11.2 再探结构成员
11.2.1 将一个结构作为另一个结构的成员
11.2.2 声明结构中的结构
11.2.3 将结构指针用作结构成员
11.2.4 双向链表
11.2.5 结构中的位字段
11.3 结构与函数
11.3.1 结构作为函数的变元
11.3.2 结构指针作为函数变元
11.3.3 作为函数返回值的结构
11.3.4 修改程序
11.3.5 二叉树
11.4 共享内存
11.4.1 联合
11.4.2 联合指针
11.4.3 联合的初始化
11.4.4 联合中的结构成员
11.5 定义自己的数据类型
11.5.1 结构与类型定义(typedef)功能
11.5.2 使用typedef简化代码
11.6 设计程序
11.6.1 问题
11.6.2 分析
11.6.3 解决方案
11.7 小结
11.8 习题
第12章 处理文件
12.1 文件的概念
12.1.1 文件中的位置
12.1.2 文件流
12.2 文件访问
12.2.1 打开文件
12.2.2 文件重命名
12.2.3 关闭文件
12.2.4 删除文件
12.3 写入文本文件
12.4 读取文本文件
12.5 将字符串写入文本文件
12.6 从文本文件中读入字符串
12.7 格式化文件的输入输出
12.7.1 格式化文件输出
12.7.2 格式化文件输入
12.8 错误处理
12.9 再探文本文件操作模式
12.10 二进制文件的输入输出
12.10.1 指定二进制模式
12.10.2 写入二进制文件
12.10.3 读取二进制文件
12.11 在文件中移动
12.11.1 文件定位操作
12.11.2 找出我们在文件中的位置
12.11.3 在文件中设定位置
12.12 使用临时文件
12.12.1 创建临时文件
12.12.2 创建唯一的文件名
12.13 更新二进制文件
12.13.1 修改文件的内容
12.13.2 从键盘读取记录
12.13.3 将记录写入文件
12.13.4 从文件中读取记录
12.13.5 写入文件
12.13.6 列出文件内容
12.13.7 更新已有的文件内容
12.14 文件打开模式小结
12.15 设计程序
12.15.1 问题
12.15.2 分析
12.15.3 解决方案
12.16 小结
12.17 习题
第13章 支持功能
13.1 预处理
13.1.1 在程序中包含头文件
13.1.2 外部变量及函数
13.1.3 替换程序源代码
13.1.4 宏替换
13.1.5 看起来像函数的宏
13.1.6 多行上的预处理指令
13.1.7 字符串作为宏参数
13.1.8 结合两个宏展开式的结果
13.2 预处理器逻辑指令
13.2.1 条件编译
13.2.2 测试指定值的指令
13.2.3 多项选择
13.2.4 标准预处理宏
13.3 调试方法
13.3.1 集成的调试器
13.3.2 调试阶段的预处理器
13.3.3 使用assert()宏
13.4 其他库函数
13.4.1 日期和时间函数库
13.4.2 获取日期
13.5 小结
13.6 习题
附录a 计算机中的数学知识
附录b ascii字符代码定义
附录c c语言中的保留字
附录d 输入输出格式指定符
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构（C语言版）
第1章 绪论
1.1 什么是数据结构
1.2 基本概念和术语
1.3 抽象数据类型的表现与实现
1.4 算法和算法分析
第2章 线性表
2.1 线性表的类型定义
2.2 线性表的顺序表示和实现
2.3 线性表的链式表示和实现
2.4 一元多项式的表示及相加
第3章 栈和队列
3.1 栈
3.2 栈的应有和举例
3.3 栈与递归的实现
3.4 队列
3.5 离散事件模拟
第4章 串
4.1 串类型的定义
4.2 串的表示和实现
4.3 串的模式匹配算法
4.4 串操作应用举例
第5章 数组和广义表
5.1 数组的定义
5.2 数组的顺序表现和实现
5.3 矩阵的压缩存储
5.4 广义表的定义
5.5 广义表的储存结构
5.6 m元多项式的表示
5.7 广义表的递归算法第6章 树和二叉树
6.1 树的定义和基本术语
6.2 二叉树
6.2.1 二叉树的定义
6.2.2 二叉树的性质
6.2.3 二叉树的存储结构
6.3 遍历二叉树和线索二叉树
6.3.1 遍历二叉树
6.3.2 线索二叉树
6.4 树和森林
6.4.1 树的存储结构
6.4.2 森林与二叉树的转换
6.4.3 树和森林的遍历
6.5 树与等价问题
6.6 赫夫曼树及其应用
6.6.1 最优二叉树(赫夫曼树)
6.6.2 赫夫曼编码
6.7 回溯法与树的遍历
6.8 树的计数
第7章 图
7.1 图的定义和术语
7.2 图的存储结构
7.2.1 数组表示法
7.2.2 邻接表
7.2.3 十字链表
7.2.4 邻接多重表
7.3 图的遍历
7.3.1 深度优先搜索
7.3.2 广度优先搜索
7.4 图的连通性问题
7.4.1 无向图的连通分量和生成树
7.4.2 有向图的强连通分量
7.4.3 最小生成树
7.4.4 关节点和重连通分量
7.5 有向无环图及其应用
7.5.1 拓扑排序
7.5.2 关键路径
7.6 最短路径
7.6.1 从某个源点到其余各顶点的最短路径
7.6.2 每一对顶点之间的最短路径
第8章 动态存储管理
8.1 概述
8.2 可利用空间表及分配方法
8.3 边界标识法
8.3.1 可利用空间表的结构
8.3.2 分配算法
8.3.3 回收算法
8.4 伙伴系统
8.4.1 可利用空间表的结构
8.4.2 分配算法
8.4.3 回收算法
8.5 无用单元收集
8.6 存储紧缩
第9章 查找
9.1 静态查找表
9.1.1 顺序表的查找
9.1.2 有序表的查找
9.1.3 静态树表的查找
9.1.4 索引顺序表的查找
9.2 动态查找表
9.2.1 二叉排序树和平衡二叉树
9.2.2 B树和B+树
9.2.3 键树
9.3 哈希表
9.3.1 什么是哈希表
9.3.2 哈希函数的构造方法
9.3.3 处理冲突的方法
9.3.4 哈希表的查找及其分析
第10章 内部排序
10.1 概述
10.2 插入排序
10.2.1 直接插入排序
10.2.2 其他插入排序
10.2.3 希尔排序
10.3 快速排序
10.4 选择排序
10.4.1 简单选择排序
10.4.2 树形选择排序
10.4.3 堆排序
10.5 归并排序
10.6 基数排序
10.6.1 多关键字的排序
10.6.2 链式基数排序
10.7 各种内部排序方法的比较讨论
第11章 外部排序
11.1 外存信息的存取
11.2 外部排序的方法
11.3 多路平衡归并的实现
11.4 置换一选择排序
11.5 最佳归并树
第12章 文件
12.1 有关文件的基本概念
12.2 顺序文件
12.3 索引文件
12.4 ISAM文件和VSAM文件
12.4.1 ISAM文件
12.4.2 VSAM文件
12.5 直接存取文件(散列文件)
12.6 多关键字文件
12.6.1 多重表文件
12.6.2 倒排文件
附录A 名词索引
附录B 函数索引
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构（C语言版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第1章 绪论
第2章 线性表
第3章 栈和队列
第4章 串
第5章 数组和广义表
第6章 树和二叉树
第7章 图
第8章 动态存储管理
第9章 查找
第10章 内部排序
第11章 外部排序
第12章 文件
附录A 名词索引
附录B 函数索引
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript高级程序设计（第3版）
目　　录
第1章　JavaScript简介　　1
1.1　JavaScript简史　　1
1.2　JavaScript实现　　2
1.2.1　ECMAScript　　3
1.2.2　文档对象模型（DOM）　　5
1.2.3　浏览器对象模型（BOM）　　8
1.3　JavaScript版本　　8
1.4　小结　　9
第2章　在HTML中使用JavaScript　　10
2.1　<script>元素　　10
2.1.1　标签的位置　　12
2.1.2　延迟脚本　　13
2.1.3　异步脚本　　13
2.1.4　在XHTML中的用法　　14
2.1.5　不推荐使用的语法　　16
2.2　嵌入代码与外部文件　　16
2.3　文档模式　　16
2.4　<noscript>元素　　18
2.5　小结　　18
第3章　基本概念　　19
3.1　语法　　19
3.1.1　区分大小写　　19
3.1.2　标识符　　19
3.1.3　注释　　20
3.1.4　严格模式　　20
3.1.5　语句　　20
3.2　关键字和保留字　　21
3.3　变量　　22
3.4　数据类型　　23
3.4.1　typeof操作符　　23
3.4.2　Undefined类型　　24
3.4.3　Null类型　　25
3.4.4　Boolean类型　　26
3.4.5　Number类型　　27
3.4.6　String类型　　32
3.4.7　Object类型　　35
3.5　操作符　　36
3.5.1　一元操作符　　36
3.5.2　位操作符　　39
3.5.3　布尔操作符　　44
3.5.4　乘性操作符　　47
3.5.5　加性操作符　　48
3.5.6　关系操作符　　50
3.5.7　相等操作符　　51
3.5.8　条件操作符　　53
3.5.9　赋值操作符　　53
3.5.10　逗号操作符　　54
3.6　语句　　54
3.6.1　if语句　　54
3.6.2　do-while语句　　55
3.6.3　while语句　　55
3.6.4　for语句　　56
3.6.5　for-in语句　　57
3.6.6　label语句　　58
3.6.7　break和continue语句　　58
3.6.8　with语句　　60
3.6.9　switch语句　　60
3.7　函数　　62
3.7.1　理解参数　　64
3.7.2　没有重载　　66
3.8　小结　　67
第4章　变量、作用域和内存问题　　68
4.1　基本类型和引用类型的值　　68
4.1.1　动态的属性　　68
4.1.2　复制变量值　　69
4.1.3　传递参数　　70
4.1.4　检测类型　　72
4.2　执行环境及作用域　　73
4.2.1　延长作用域链　　75
4.2.2　没有块级作用域　　76
4.3　垃圾收集　　78
4.3.1　标记清除　　78
4.3.2　引用计数　　79
4.3.3　性能问题　　80
4.3.4　管理内存　　81
4.4　小结　　81
第5章　引用类型　　83
5.1　Object类型　　83
5.2　Array类型　　86
5.2.1　检测数组　　88
5.2.2　转换方法　　89
5.2.3　栈方法　　90
5.2.4　队列方法　　91
5.2.5　重排序方法　　92
5.2.6　操作方法　　94
5.2.7　位置方法　　95
5.2.8　迭代方法　　96
5.2.9　缩小方法　　97
5.3　Date类型　　98
5.3.1　继承的方法　　100
5.3.2　日期格式化方法　　101
5.3.3　日期/时间组件方法　　102
5.4　RegExp类型　　103
5.4.1　RegExp实例属性　　105
5.4.2　RegExp实例方法　　106
5.4.3　RegExp构造函数属性　　107
5.4.4　模式的局限性　　109
5.5　Function类型　　110
5.5.1　没有重载（深入理解）　　111
5.5.2　函数声明与函数表达式　　111
5.5.3　作为值的函数　　112
5.5.4　函数内部属性　　113
5.5.5　函数属性和方法　　116
5.6　基本包装类型　　118
5.6.1　Boolean类型　　120
5.6.2　Number类型　　120
5.6.3　String类型　　122
5.7　单体内置对象　　130
5.7.1　Global对象　　131
5.7.2　Math对象　　134
5.8　小结　　137
第6章　面向对象的程序设计　　138
6.1　理解对象　　138
6.1.1　属性类型　　139
6.1.2　定义多个属性　　142
6.1.3　读取属性的特性　　143
6.2　创建对象　　144
6.2.1　工厂模式　　144
6.2.2　构造函数模式　　144
6.2.3　原型模式　　147
6.2.4　组合使用构造函数模式和原型模式　　159
6.2.5　动态原型模式　　159
6.2.6　寄生构造函数模式　　160
6.2.7　稳妥构造函数模式　　161
6.3　继承　　162
6.3.1　原型链　　162
6.3.2　借用构造函数　　167
6.3.3　组合继承　　168
6.3.4　原型式继承　　169
6.3.5　寄生式继承　　171
6.3.6　寄生组合式继承　　172
6.4　小结　　174
第7章　函数表达式　　175
7.1　递归　　177
7.2　闭包　　178
7.2.1　闭包与变量　　181
7.2.2　关于this对象　　182
7.2.3　内存泄漏　　183
7.3　模仿块级作用域　　184
7.4　私有变量　　186
7.4.1　静态私有变量　　188
7.4.2　模块模式　　189
7.4.3　增强的模块模式　　191
7.5　小结　　192
第8章　BOM　　193
8.1　window对象　　193
8.1.1　全局作用域　　193
8.1.2　窗口关系及框架　　194
8.1.3　窗口位置　　197
8.1.4　窗口大小　　198
8.1.5　导航和打开窗口　　199
8.1.6　间歇调用和超时调用　　203
8.1.7　系统对话框　　205
8.2　location对象　　207
8.2.1　查询字符串参数　　207
8.2.2　位置操作　　208
8.3　navigator对象　　210
8.3.1　检测插件　　211
8.3.2　注册处理程序　　213
8.4　screen对象　　214
8.5　history对象　　215
8.6　小结　　216
第9章　客户端检测　　217
9.1　能力检测　　217
9.1.1　更可靠的能力检测　　218
9.1.2　能力检测，不是浏览器检测　　220
9.2　怪癖检测　　220
9.3　用户代理检测　　221
9.3.1　用户代理字符串的历史　　222
9.3.2　用户代理字符串检测技术　　228
9.3.3　完整的代码　　242
9.3.4　使用方法　　245
9.4　小结　　246
第10章　DOM　　247
10.1　节点层次　　247
10.1.1　Node类型　　248
10.1.2　Document类型　　253
10.1.3　Element类型　　261
10.1.4　Text类型　　270
10.1.5　Comment类型　　273
10.1.6　CDATASection类型　　274
10.1.7　DocumentType类型　　274
10.1.8　DocumentFragment类型　　275
10.1.9　Attr类型　　276
10.2　DOM操作技术　　277
10.2.1　动态脚本　　277
10.2.2　动态样式　　279
10.2.3　操作表格　　281
10.2.4　使用NodeList　　283
10.3　小结　　284
第11章　DOM扩展　　286
11.1　选择符API　　286
11.1.1　querySelector()方法　　286
11.1.2　querySelectorAll()
方法　　287
11.1.3　matchesSelector()
方法　　288
11.2　元素遍历　　288
11.3　HTML5　　289
11.3.1　与类相关的扩充　　289
11.3.2　焦点管理　　291
11.3.3　HTMLDocument的变化　　292
11.3.4　字符集属性　　293
11.3.5　自定义数据属性　　293
11.3.6　插入标记　　294
11.3.7　scrollIntoView()方法　　298
11.4　专有扩展　　298
11.4.1　文档模式　　298
11.4.2　children属性　　299
11.4.3　contains()方法　　300
11.4.4　插入文本　　301
11.4.5　滚动　　303
11.5　小结　　304
第12章　DOM2和DOM3　　305
12.1　DOM变化　　305
12.1.1　针对XML命名空间的变化　　306
12.1.2　其他方面的变化　　309
12.2　样式　　312
12.2.1　访问元素的样式　　313
12.2.2　操作样式表　　317
12.2.3　元素大小　　320
12.3　遍历　　326
12.3.1　NodeIterator　　328
12.3.2　TreeWalker　　330
12.4　范围　　332
12.4.1　DOM中的范围　　332
12.4.2　IE8及更早版本中的范围　　340
12.5　小结　　343
第13章　事件　　345
13.1　事件流　　345
13.1.1　事件冒泡　　346
13.1.2　事件捕获　　346
13.1.3　DOM事件流　　347
13.2　事件处理程序　　348
13.2.1　HTML事件处理程序　　348
13.2.2　DOM0级事件处理程序　　350
13.2.3　DOM2级事件处理程序　　351
13.2.4　IE事件处理程序　　352
13.2.5　跨浏览器的事件处理程序　　353
13.3　事件对象　　355
13.3.1　DOM中的事件对象　　355
13.3.2　IE中的事件对象　　358
13.3.3　跨浏览器的事件对象　　360
13.4　事件类型　　362
13.4.1　UI事件　　362
13.4.2　焦点事件　　367
13.4.3　鼠标与滚轮事件　　368
13.4.4　键盘与文本事件　　379
13.4.5　复合事件　　384
13.4.6　变动事件　　385
13.4.7　HTML5事件　　388
13.4.8　设备事件　　395
13.4.9　触摸与手势事件　　399
13.5　内存和性能　　402
13.5.1　事件委托　　402
13.5.2　移除事件处理程序　　404
13.6　模拟事件　　405
13.6.1　DOM中的事件模拟　　405
13.6.2　IE中的事件模拟　　410
13.7　小结　　411
第14章　表单脚本　　412
14.1　表单的基础知识　　412
14.1.1　提交表单　　413
14.1.2　重置表单　　414
14.1.3　表单字段　　414
14.2　文本框脚本　　419
14.2.1　选择文本　　420
14.2.2　过滤输入　　423
14.2.3　自动切换焦点　　426
14.2.4　HTML5约束验证API　　427
14.3　选择框脚本　　431
14.3.1　选择选项　　432
14.3.2　添加选项　　434
14.3.3　移除选项　　435
14.3.4　移动和重排选项　　435
14.4　表单序列化　　436
14.5　富文本编辑　　438
14.5.1　使用contenteditable
属性　　438
14.5.2　操作富文本　　439
14.5.3　富文本选区　　441
14.5.4　表单与富文本　　443
14.6　小结　　443
第15章　使用Canvas绘图　　445
15.1　基本用法　　445
15.2　2D上下文　　446
15.2.1　填充和描边　　446
15.2.2　绘制矩形　　447
15.2.3　绘制路径　　449
15.2.4　绘制文本　　451
15.2.5　变换　　453
15.2.6　绘制图像　　456
15.2.7　阴影　　457
15.2.8　渐变　　458
15.2.9　模式　　460
15.2.10　使用图像数据　　460
15.2.11　合成　　462
15.3　WebGL　　463
15.3.1　类型化数组　　463
15.3.2　WebGL上下文　　468
15.3.3　支持　　478
15.4　小结　　478
第16章　HTML5脚本编程　　480
16.1　跨文档消息传递　　480
16.2　原生拖放　　481
16.2.1　拖放事件　　482
16.2.2　自定义放置目标　　482
16.2.3　dataTransfer对象　　483
16.2.4　dropEffect与effectAllowed　　484
16.2.5　可拖动　　485
16.2.6　其他成员　　485
16.3　媒体元素　　486
16.3.1　属性　　487
16.3.2　事件　　488
16.3.3　自定义媒体播放器　　488
16.3.4　检测编解码器的支持情况　　489
16.3.5　Audio类型　　490
16.4　历史状态管理　　491
16.5　小结　　492
第17章　错误处理与调试　　493
17.1　浏览器报告的错误　　493
17.1.1　IE　　493
17.1.2　Firefox　　494
17.1.3　Safari　　496
17.1.4　Opera　　497
17.1.5　Chrome　　498
17.2　错误处理　　499
17.2.1　try-catch语句　　500
17.2.2　抛出错误　　503
17.2.3　错误（error）事件　　505
17.2.4　处理错误的策略　　506
17.2.5　常见的错误类型　　507
17.2.6　区分致命错误和非致命
错误　　510
17.2.7　把错误记录到服务器　　511
17.3　调试技术　　512
17.3.1　将消息记录到控制台　　512
17.3.2　将消息记录到当前页面　　515
17.3.3　抛出错误　　515
17.4　常见的IE错误　　516
17.4.1　操作终止　　516
17.4.2　无效字符　　518
17.4.3　未找到成员　　518
17.4.4　未知运行时错误　　519
17.4.5　语法错误　　519
17.4.6　系统无法找到指定资源　　519
17.5　小结　　520
第18章　JavaScript与XML　　521
18.1　浏览器对XML DOM的支持　　521
18.1.1　DOM2级核心　　521
18.1.2　DOMParser类型　　522
18.1.3　XMLSerializer类型　　523
18.1.4　IE8及之前版本中的XML　　523
18.1.5　跨浏览器处理XML　　527
18.2　浏览器对XPath的支持　　529
18.2.1　DOM3级XPath　　529
18.2.2　IE中的XPath　　534
18.2.3　跨浏览器使用XPath　　535
18.3　浏览器对XSLT的支持　　537
18.3.1　IE中的XSLT　　537
18.3.2　XSLTProcessor类型　　541
18.3.3　跨浏览器使用XSLT　　543
18.4　小结　　544
第19章　E4X　　546
19.1　E4X的类型　　546
19.1.1　XML类型　　546
19.1.2　XMLList类型　　547
19.1.3　Namespace类型　　548
19.1.4　QName类型　　549
19.2　一般用法　　550
19.2.1　访问特性　　551
19.2.2　其他节点类型　　552
19.2.3　查询　　553
19.2.4　构建和操作XML　　555
19.2.5　解析和序列化　　557
19.2.6　命名空间　　558
19.3　其他变化　　559
19.4　全面启用E4X　　560
19.5　小结　　561
第20章　JSON　　562
20.1　语法　　562
20.1.1　简单值　　562
20.1.2　对象　　563
20.1.3　数组　　564
20.2　解析与序列化　　565
20.2.1　JSON对象　　565
20.2.2　序列化选项　　566
20.2.3　解析选项　　569
20.3　小结　　570
第21章　Ajax与Comet　　571
21.1　XMLHttpRequest对象　　571
21.1.1　XHR的用法　　573
21.1.2　HTTP头部信息　　575
21.1.3　GET请求　　576
21.1.4　POST请求　　577
21.2　XMLHttpRequest 2级　　578
21.2.1　FormData　　578
21.2.2　超时设定　　579
21.2.3　overrideMimeType()
方法　　580
21.3　进度事件　　580
21.3.1　load事件　　580
21.3.2　progress事件　　581
21.4　跨源资源共享　　582
21.4.1　IE对CORS的实现　　582
21.4.2　其他浏览器对CORS的
实现　　584
21.4.3　Preflighted Reqeusts　　584
21.4.4　带凭据的请求　　585
21.4.5　跨浏览器的CORS　　585
21.5　其他跨域技术　　586
21.5.1　图像Ping　　586
21.5.2　JSONP　　587
21.5.3　Comet　　588
21.5.4　服务器发送事件　　590
21.5.5　Web Sockets　　591
21.5.6　SSE与Web Sockets　　593
21.6　安全　　593
21.7　小结　　594
第22章　高级技巧　　596
22.1　高级函数　　596
22.1.1　安全的类型检测　　596
22.1.2　作用域安全的构造函数　　597
22.1.3　惰性载入函数　　600
22.1.4　函数绑定　　602
22.1.5　函数柯里化　　604
22.2　防篡改对象　　606
22.2.1　不可扩展对象　　606
22.2.2　密封的对象　　607
22.2.3　冻结的对象　　608
22.3　高级定时器　　609
22.3.1　重复的定时器　　610
22.3.2　Yielding Processes　　612
22.3.3　函数节流　　614
22.4　自定义事件　　616
22.5　拖放　　618
22.5.1　修缮拖动功能　　620
22.5.2　添加自定义事件　　622
22.6　小结　　624
第23章　离线应用与客户端存储　　626
23.1　离线检测　　626
23.2　应用缓存　　627
23.3　数据存储　　628
23.3.1　Cookie　　629
23.3.2　IE用户数据　　637
23.3.3　Web存储机制　　638
23.3.4　IndexedDB　　643
23.4　小结　　654
第24章　最佳实践　　656
24.1　可维护性　　656
24.1.1　什么是可维护的代码　　656
24.1.2　代码约定　　657
24.1.3　松散耦合　　659
24.1.4　编程实践　　662
24.2　性能　　666
24.2.1　注意作用域　　666
24.2.2　选择正确方法　　667
24.2.3　最小化语句数　　672
24.2.4　优化DOM交互　　673
24.3　部署　　676
24.3.1　构建过程　　676
24.3.2　验证　　677
24.3.3　压缩　　679
24.4　小结　　681
第25章　新兴的API　　682
25.1　requestAnimationFrame()　　682
25.1.1　早期动画循环　　682
25.1.2　循环间隔的问题　　683
25.1.3　mozRequestAnimation-Frame　　683
25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685
25.2　Page Visibility API　　686
25.3　Geolocation API　　687
25.4　File API　　689
25.4.1　FileReader类型　　690
25.4.2　读取部分内容　　692
25.4.3　对象URL　　693
25.4.4　读取拖放的文件　　694
25.4.5　使用XHR上传文件　　695
25.5　Web计时　　696
25.6　Web Workers　　697
25.6.1　使用Worker　　697
25.6.2　Worker全局作用域　　698
25.6.3　包含其他脚本　　699
25.6.4　Web Workers的未来　　700
25.7　小结　　700
附录A　ECMAScript Harmony　　701
附录B　严格模式　　717
附录C　JavaScript库　　723
附录D　JavaScript工具　　727

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript高级程序设计（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>应用密码学
译者序
第一部分 密码协议
第二部分 密码技术
第三部分 密码算法
第四部分 真实世界
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>应用密码学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>红书
卷一（14面手稿21幅图）
卷二（193面手稿99幅图）
附录（11幅草图）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>红书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧洲中世纪史
导言
第一部分　中世纪初期：欧洲的诞生，500—1000年
第一章　罗马（帝国）皈依基督教，约公元前31-公元430年
引言
罗马帝国的和平（公元前31-公元180年）
第3和第4世纪（180—395年）
基督教
结语
第二章　野蛮民族入侵及定居于西欧，约400－500年
引言
野蛮民族与西方帝国
西罗马帝国的衰落
结语
第三章　早期西方基督教世界，约500—700年
引言
中世纪早期社会
中世纪早期政治
中世纪早期教会
学术生活
结语
第四章　西欧的邻居：拜占廷和伊斯兰，约500—1000年
引言
从东方到拜占庭帝国
拜占庭诸世纪
伊斯兰的崛起
伊斯兰帝国
伊斯兰文化
结语
第五章　加洛林王朝的欧洲，约700－850年
引言
早期的加洛林王朝
查理大帝（768—814年在位）
思想文化复兴
结语
第六章　分裂、入侵及重建，约800—1000年
引言
分裂：晚期的加洛林王朝
入侵：穆斯林、马扎尔人与维京人
重建：新的政治
结语
第二部分　中世纪中期：改革、复兴及扩张，1000-1300年
第七章　经济起飞与社会转变，约1000-1300年
引言
农业革命
村镇、庄园与教区
……
第八章　往神（天主）的新路径，约1000-1250年
第九章　征服、十字军东征及宗教迫害，约1000-1300年
第十章　政教冲突：教皇与罗马帝国，约1125-1300年
第十一章　形成中的国家：英国与法国，约1050-1300年
第十二章　文学、艺术及思想，约1000-1300年
第三部分　中世纪后期：危机与创建，1300-1500年
第十三章　灾荒、瘟疫及复苏，约1300-1500年
第十四章　迈向国家建制，约1300-1500年
第十五章　中世纪后期文化之多元化及活力，约1300-1500年
术语表
附录
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧洲中世纪史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>线性代数及其应用
译者序
关于作者
前言
给学生的注释
第1章 线性代数中的线性方程组
介绍性实例 经济学与工程中的线性模型
1.1 线性方程组
1.2 行化简与阶梯形矩阵
1.3 向量方程
1.4 矩阵方程
1.5 线性方程组的解集
1.6 线性方程组的应用
1.7 线性无关
1.8 线性变换介绍
1.9 线性变换的矩阵
1.10 经济学、科学和工程中的线性模型
第1章补充习题
第2章 矩阵代数
介绍性实例 飞机设计中的计算机模型
2.1 矩阵运算
2.2 矩阵的逆
2.3 可逆矩阵的特征
2.4 分块矩阵
2.5 矩阵因式分解
2.6 列昂惕夫投入产出模型
2.7 计算机图形学中的应用
2.8 Rn的子空间
2.9 维数与秩
第2章补充习题
第3章 行列式
介绍性实例 解析几何中的行列式
3.1 行列式介绍
3.2 行列式的性质
3.3 克拉默法则、体积和线性变换
第3章补充习题
第4章 向量空间
介绍性实例 空间飞行与控制系统
4.1 向量空间与子空间
4.2 零空间、列空间和线性变换
4.3 线性无关集和基
4.4 坐标系
4.5 向量空间的维数
4.6 秩
4.7 基的变换
4.8 差分方程中的应用
4.9 马尔可夫链中的应用
第4章补充习题
第5章 特征值与特征向量
介绍性实例 动力系统与斑点猫头鹰
5.1 特征向量与特征值
5.2 特征方程
5.3 对角化
5.4 特征向量与线性变换
5.5 复特征值
5.6 离散动力系统
5.7 微分方程中的应用
5.8 特征值的迭代估计
第5章补充习题
第6章 正交性和最小二乘法
介绍性实例 重新整理北美地质数据
6.1 内积、长度和正交性
6.2 正交集
6.3 正交投影
6.4 格拉姆-施密特方法
6.5 最小二乘问题
6.6 线性模型中的应用
6.7 内积空间
6.8 内积空间的应用
第6章补充习题
第7章 对称矩阵和二次型
介绍性实例 多波段的图像处理
7.1 对称矩阵的对角化
7.2 二次型
7.3 条件优化
7.4 奇异值分解
7.5 图像处理和统计学中的应用
第7章补充习题
附录A 简化形阶梯矩阵的惟一性
附录B 复数
术语表
奇数习题答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>线性代数及其应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码整洁之道
第1章　整洁代码　1
1.1　要有代码　2
1.2　糟糕的代码　2
1.3　混乱的代价　3
1.3.1　华丽新设计　4
1.3.2　态度　4
1.3.3　迷题　5
1.3.4　整洁代码的艺术　5
1.3.5　什么是整洁代码　6
1.4　思想流派　10
1.5　我们是作者　11
1.6　童子军军规　12
1.7　前传与原则　12
1.8　小结　12
1.9　文献　13
第2章　有意义的命名　15
2.1　介绍　15
2.2　名副其实　16
2.3　避免误导　17
2.4　做有意义的区分　18
2.5　使用读得出来的名称　19
2.6　使用可搜索的名称　20
2.7　避免使用编码　21
2.7.1　匈牙利语标记法　21
2.7.2　成员前缀　21
2.7.3　接口和实现　22
2.8　避免思维映射　22
2.9　 类名　23
2.10　方法名　23
2.11　别扮可爱　23
2.12　每个概念对应一个词　24
2.13　别用双关语　24
2.14　使用解决方案领域名称　25
2.15　使用源自所涉问题领域的名称　25
2.16　添加有意义的语境　25
2.17　不要添加没用的语境　27
2.18　最后的话　27
第3章　函数　29
3.1　短小　32
3.2　只做一件事　33
3.3　每个函数一个抽象层级　34
3.4　switch语句　35
3.5　使用描述性的名称　36
3.6　函数参数　37
3.6.1　一元函数的普遍形式　38
3.6.2　标识参数　38
3.6.3　二元函数　38
3.6.4　三元函数　39
3.6.5　参数对象　39
3.6.6　参数列表　40
3.6.7　动词与关键字　40
3.7　无副作用　40
3.8　分隔指令与询问　42
3.9　使用异常替代返回错误码　42
3.9.1　抽离Try/Catch代码块　43
3.9.2　错误处理就是一件事　44
3.9.3　Error.java依赖磁铁　44
3.10　别重复自己　44
3.11　结构化编程　45
3.12　如何写出这样的函数　45
3.13　小结　45
3.14　SetupTeardownIncluder程序　46
3.15　文献　48
第4章　注释　49
4.1　注释不能美化糟糕的代码　50
4.2　用代码来阐述　51
4.3　好注释　51
4.3.1　法律信息　51
4.3.2　提供信息的注释　51
4.3.3　对意图的解释　52
4.3.4　阐释　53
4.3.5　警示　53
4.3.6　TODO注释　54
4.3.7　放大　54
4.3.8　公共API中的Javadoc　55
4.4　坏注释　55
4.4.1　喃喃自语　55
4.4.2　多余的注释　56
4.4.3　误导性注释　58
4.4.4　循规式注释　58
4.4.5　日志式注释　59
4.4.6　废话注释　59
4.4.7　可怕的废话　61
4.4.8　能用函数或变量时就别用注释　62
4.4.9　位置标记　62
4.4.10　括号后面的注释　62
4.4.11　归属与署名　63
4.4.12　注释掉的代码　63
4.4.13　HTML注释　64
4.4.14　非本地信息　64
4.4.15　信息过多　65
4.4.16　不明显的联系　65
4.4.17　函数头　66
4.4.18　非公共代码中的Javadoc　66
4.4.19　范例　66
4.5　文献　69
第5章　格式　71
5.1　格式的目的　72
5.2　垂直格式　72
5.2.1　向报纸学习　73
5.2.2　概念间垂直方向上的区隔　73
5.2.3　垂直方向上的靠近　74
5.2.4　垂直距离　75
5.2.5　垂直顺序　79
5.3　横向格式　79
5.3.1　水平方向上的区隔与靠近　80
5.3.2　水平对齐　81
5.3.3　缩进　82
5.3.4　空范围　84
5.4　团队规则　84
5.5　鲍勃大叔的格式规则　85
第6章　对象和数据结构　87
6.1　数据抽象　87
6.2　数据、对象的反对称性　89
6.3　得墨忒耳律　91
6.3.1　火车失事　91
6.3.2　混杂　92
6.3.3　隐藏结构　92
6.4　数据传送对象　93
6.5　小结　94
6.6　文献　94
第7章　错误处理　95
7.1　使用异常而非返回码　96
7.2　先写Try-Catch-Finally语句　97
7.3　使用不可控异常　98
7.4　给出异常发生的环境说明　99
7.5　依调用者需要定义异常类　99
7.6　定义常规流程　100
7.7　别返回null值　101
7.8　别传递null值　102
7.9　小结　103
7.10 文献　104
第8章　边界　105
8.1　使用第三方代码　106
8.2　浏览和学习边界　107
8.3　学习log4j　108
8.4　学习性测试的好处不只是免费　110
8.5　使用尚不存在的代码　110
8.6　整洁的边界　111
8.7　文献　112
第9章　单元测试　113
9.1　TDD三定律　114
9.2　保持测试整洁　115
9.3　整洁的测试　116
9.3.1　面向特定领域的测试语言　118
9.3.2　双重标准　119
9.4　每个测试一个断言　121
9.5　F.I.R.S.T.　122
9.6　小结　123
9.7　文献　124
第10章　类　125
10.1　类的组织　126
10.2　类应该短小　126
10.2.1　单一权责原则　128
10.2.2　内聚　129
10.2.3　保持内聚性就会得到许多短小的类　130
10.3　为了修改而组织　136
10.4　文献　139
第11章　系统　141
11.1　如何建造一个城市　142
11.2　将系统的构造与使用分开　142
11.2.1　分解main　143
11.2.2　工厂　143
11.2.3　依赖注入　144
11.3　扩容　145
11.4　Java代理　148
11.5　纯Java AOP框架　150
11.6　AspectJ的方面　152
11.7　测试驱动系统架构　153
11.8　优化决策　154
11.9　明智使用添加了可论证价值的标准　154
11.10　系统需要领域特定语言　154
11.11　小结　155
11.12　文献　155
第12章　迭进　157
12.1　通过迭进设计达到整洁目的　157
12.2　简单设计规则1：运行所有测试　158
12.3　简单设计规则2～4：重构　158
12.4　不可重复　159
12.5　表达力　161
12.6　尽可能少的类和方法　162
12.7　小结　162
12.8　文献　162
第13章　并发编程　163
13.1　为什么要并发　164
13.2　挑战　165
13.3　并发防御原则　166
13.3.1　单一权责原则　166
13.3.2　推论：限制数据作用域　166
13.3.3　推论：使用数据复本　167
13.3.4　推论：线程应尽可能地独立　167
13.4　了解Java库　167
13.5　了解执行模型　168
13.5.1　生产者-消费者模型　169
13.5.2　读者-作者模型　169
13.5.3　宴席哲学家　169
13.6　警惕同步方法之间的依赖　169
13.7　保持同步区域微小　170
13.8　很难编写正确的关闭代码　170
13.9　测试线程代码　171
13.9.1　将伪失败看作可能的线程问题　171
13.9.2　先使非线程代码可工作　171
13.9.3　编写可插拔的线程代码　172
13.9.4　编写可调整的线程代码　172
13.9.5　运行多于处理器数量的线程　172
13.9.6　在不同平台上运行　172
13.9.7　装置试错代码　173
13.9.8　硬编码　173
13.9.9　自动化　174
13.10　小结　175
13.11　文献　175
第14章　逐步改进　176
14.1　Args的实现　177
14.2　Args：草稿　183
14.2.1　所以我暂停了　195
14.2.2　渐进　195
14.3　字符串参数　197
14.4　小结　234
第15章　JUnit内幕　235
15.1　JUnit框架　236
15.2　小结　249
第16章　重构SerialDate　251
16.1　首先，让它能工作　252
16.2　让它做对　254
16.3　小结　266
16.4　文献　267
第17章　味道与启发　269
17.1　注释　270
17.2　环境　271
17.3　函数　271
17.4　一般性问题　272
17.5　Java　288
17.6　名称　291
17.7　测试　294
17.8　小结　295
17.9　文献　296
附录A　并发编程II　297
A.1　客户端/服务器的例子　297
A.1.1　服务器　297
A.1.2　添加线程代码　298
A.1.3　观察服务器端　299
A.1.4　小结　301
A.2　执行的可能路径　301
A.2.1　路径数量　302
A.2.2　深入挖掘　303
A.2.3　小结　305
A.3　了解类库　305
A.3.1　Executor框架　305
A.3.2　非锁定的解决方案　306
A.3.3　非线程安全类　307
A.4　方法之间的依赖可能破坏并发代码　308
A.4.1　容忍错误　309
A.4.2　基于客户代码的锁定　309
A.4.3　基于服务端的锁定　311
A.5　提升吞吐量　312
A.5.1　单线程条件下的吞吐量　313
A.5.2　多线程条件下的吞吐量　313
A.6　死锁　314
A.6.1　互斥　315
A.6.2　上锁及等待　315
A.6.3　无抢先机制　315
A.6.4　循环等待　315
A.6.5　不互斥　316
A.6.6　不上锁及等待　316
A.6.7　满足抢先机制　317
A.6.8　不做循环等待　317
A.7　测试多线程代码　317
A.8　测试线程代码的工具支持　320
A.9　小结　320
A.10 教程：完整代码范例　321
A.10.1　客户端/服务器非线程代码　321
A.10.2　使用线程的客户端/服务器代码　324
附录B　org.jfree.date.SerialDate　327
结束语　389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码整洁之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer 中文版（第 4 版）
第1章 快速入门
1.1 编写简单的C++程序
1.2 初窥输入/输出
1.3 关于注释
1.4 控制结构 入
1.5 类的简介
1.6 C++程序
小结
术语
第一部分 基本语言
第2章 变量和基本类型
2.1 基本内置类型
2.2 字面值常量
2.3 变量
2.4 const限定符
2.5 引用
2.6 typedef名字
2.7 枚举
2.8 类类型
2.9 编写自己的头文件
小结
术语
第3章 标准库类型
3.1 命名空间的using声明
3.2 标准库string类型
3.3 标准库vector类型
3.4 迭代器简介
3.5 标准库bitset类型
小结
术语
第4章 数组和指针
4.1 数组
4.2 指针的引入
4.3 C风格字符串
4.4 多维数组
小结
术语
第5章 表达式
5.1 算术操作符
5.2 关系操作符和逻辑操作符
5.3 位操作符
5.4 赋值操作符
5.5 自增和自减操作符
5.6 箭头操作符
5.7 条件操作符
5.8 sizeof操作符
5.9 逗号操作符
5.10 复合表达式的求值
5.11 new和delete表达式
5.12 类型转换
小结
术语
第6章 语句
6.1 简单语句
6.2 声明语句
6.3 复合语句（块）
6.4 语句作用域
6.5 if语句
6.6 switch语句
6.7 while语句
6.8 for循环语句
6.9 do while语句
6.10 break语句
6.11 continue语句
6.12 goto语句
6.13 try块和异常处理
6.14 使用预处理器进行调试
小结
术语
第7章 函数
7.1 函数的定义
7.2 参数传递
7.3 return语句
7.4 函数声明
7.5 局部对象
7.6 内联函数
7.7 类的成员函数
7.8 重载函数
7.9 指向函数的指针
小结
术语
第8章 标准IO库
8.1 面向对象的标准库
8.2 条件状态
8.3 输出缓冲区的管理
8.4 文件的输入和输出
8.5 字符串流
小结
术语
第二部分 容器和算法
第9章 顺序容器
第10章 关联容器
第11章 泛型算法
第三部分 类和数据抽象
第12章 类
第13章 复制控制
第14章 重载操作符与转换
第四部分 面向对象编程与泛型编程
第15章 面向对象编程
第16章 模板与泛型编程
第五部分 高级主题
第17章 用于大型程序的工具
第18章 特殊工具与技术
附录 标准库
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer 中文版（第 4 版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective C# 中文版
第1章 c#语言元素. 1
条款1：使用属性代替可访问的数据成员 1
条款2：运行时常量（readonly）优于编译时常量（const） 12
条款3：操作符is或as优于强制转型 17
条款4：使用conditional特性代替#if条件编译 25
条款5：总是提供tostring()方法 31
条款6：明辨值类型和引用类型的使用场合 38
条款7：将值类型尽可能实现为具有常量性和原子性的类型 44
条款8：确保0为值类型的有效状态 51
条款9：理解几个相等判断之间的关系 56
条款10：理解gethashcode()方法的缺陷 63
条款11：优先采用foreach循环语句 70
第2章 .net资源管理 77
条款12：变量初始化器优于赋值语句 82
条款13：使用静态构造器初始化静态类成员 84
条款14：利用构造器链 87
条款15：利用using和try/finally语句来清理资源 93
条款16：尽量减少内存垃圾 100
条款17：尽量减少装箱与拆箱 103
条款18：实现标准dispose模式 109
第3章 使用c#表达设计.. 117
条款19：定义并实现接口优于继承类型 118
条款20：明辨接口实现和虚方法重写 125
条款21：使用委托表达回调 129
条款22：使用事件定义外发接口 131
条款23：避免返回内部类对象的引用 137
条款24：声明式编程优于命令式编程 142
条款25：尽可能将类型实现为可序列化的类型 148
条款26：使用icomparable和icomparer接口实现排序关系 156
条款27：避免icloneable接口 163
条款28：避免强制转换操作符 167
条款29：只有当新版基类导致问题时才考虑使用new修饰符 172
第4章 创建二进制组件 177
条款30：尽可能实现cls兼容的程序集 181
条款31：尽可能实现短小简洁的函数 186
条款32：尽可能实现小尺寸、高内聚的程序集 190
条款33：限制类型的可见性 194
条款34：创建大粒度的web api 198
第5章 使用框架 205
条款35：重写优于事件处理器 205
条款36：合理使用.net运行时诊断 208
条款37：使用标准配置机制 213
条款38：定制和支持数据绑定 217
条款39：使用.net验证 224
条款40：根据需要选用恰当的集合 229
条款41：dataset优于自定义结构 237
条款42：利用特性简化反射 246
条款43：避免过度使用反射 253
条款44：为应用程序创建特定的异常类 258
第6章 杂项讨论 265
条款45：优先选择强异常安全保证 265
条款46：最小化互操作 270
条款47：优先选择安全代码 277
条款48：掌握相关工具与资源 281
条款49：为c# 2.0做准备 284
条款50：了解ecma标准 293
索引 295
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective C# 中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>研究是一门艺术
译者序
中译本序
英文版原序
第一部分　研究、研究者与读者
前言：开始一个研究计划
第一章　以书面形式来思考
第二章　与读者建立联系
第二部分　提问题，找答案
前言：规划你的研究计划
第三章　从题目到问题
第四章　从问题到难题
第五章　从难题到原始资料
第六章　使用原始资料
第三部分　提出观点并加以支持
前言：汇集你的论证
第七章　提出好的论证
第八章　观点
第九章　理由与证据
第十章　承认与回应
第十一章　论据
第四部分 准备、撰写以及修改草稿
前言：再次规划
第十二章　规划与撰写草稿
第十三章　修改研究论文的组织架构与论证
第十四章　导言与结论
第十五章　以视觉的方式传达证据
第十六章　修改文体风格
第五部分　一些最后的省思研究的伦理
给教师的后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>研究是一门艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>善的脆弱性（修订版）
导读
修订版序言
第一版序言
致谢
参考文献缩写
第一章 运气与伦理
第一部分 悲剧：脆弱性与雄心
第二章 埃斯库罗斯与实践冲突
第三章 索福克勒斯的《安提戈涅》：冲突、视觉与简单化
第一部分的结论
第二部分 柏拉图：善没有脆弱性吗？
导论
第四章 《普罗泰戈拉篇》：一种实践推理的科学
插曲一 柏拉图的反悲剧戏剧
第五章 《理想国》：真实价值与完美立场
第六章 阿尔西比亚德斯的讲演：对《会饮篇》的一个解读
第七章 “这故事不是真的”：《斐德罗篇》中的癫狂、理性与改变论调
第三部分 亚里士多德：好的人类生活的脆弱性
导论
第八章 拯救亚里士多德的现象
第九章 理性动物与行动的说明
第十章 非科学的慎思
第十一章 好的人类生活的脆弱性：活动与灾难
第十二章 好的人类生活的脆弱性：关系性的善
第三部分附录 人与神
插曲二 运气与悲剧情感
收场白 悲剧
第十三章 背叛协定：对欧里庇得斯的《赫卡柏》的一个解释
注释
参考文献
索引
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>善的脆弱性（修订版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>红书
●  前言
●  致谢
●  导读：新书—荣格之《红书》
●  中译者按
●  英译者按
●  编者按
第一卷
序　言　来者的路
第一章　重新找回灵魂
第二章　灵魂与神
第三章　灵魂的恩宠
第四章　沙漠+沙漠中的经历
第五章　未来的地狱之旅
第六章　精神的分裂
第七章　谋杀英雄
第八章　神的孕育
第九章　神秘•遭遇
第十章　引导
第十一章　终解
第二卷
序　言　犯错者的意象
第一章　红人
第二章　森林中的城堡
第三章　卑微的人
第四章　隐士•逝去I
第五章　逝去II
第六章　死亡
第七章　早期神庙的遗迹
第八章　第一天
第九章　第二天
第十章　咒语
第十一章　蛋的打开
第十二章　地狱
第十三章　献祭性的谋杀
第十四章　圣愚
第十五章　第二夜
第十六章　第三夜
第十七章　第四夜
第十八章　三个预言
第十九章　魔法的礼物
第二十章　十字架的道路
第二十一章　魔法师
●  审视
●  后记
●  附录A
●  附录B
●  附录C
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>红书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2001：太空漫游
悼库布里克
千禧年版序
首版序
Ⅰ 太初之夜
第 1 章灭绝之路
第 2 章新石
第 3 章学院
第 4 章豹子
第 5 章黎明的遭遇
第 6 章人类的登场
ⅡTMA-1
第 7 章特别航班
第 8 章轨道会合
第 9 章月球穿梭机
第 10 章克拉维斯基地
第 11 章异象
第 12 章地球光下的旅程
第 13 章缓慢的黎明
第 14 章聆听者
Ⅲ行星之间
第 15 章发现号
第 16 章哈儿
第 17 章巡航模式
第 18 章穿过小行星带
第 19 章通过木星
第 20 章众神之国
Ⅳ深渊
第 21 章生日宴会
第 22 章短游
第 23 章诊断
第 24 章坏掉的回路
第 25 章第一个去土星的人
第 26 章与哈儿对话
第 27 章 “知的需求”
第 28 章真空之中
第 29 章孤独
第 30 章秘密
Ⅴ土星的卫星
第 31 章幸存
第 32 章有关 E.T.
第 33 章特使
第 34 章绕行的冰山
第 35 章伊阿珀托斯之眼
第 36 章老大哥
第 37 章实验
第 38 章前哨
第 39 章进入眼睛
第 40 章出口
Ⅵ穿越星之门
第 41 章超级中央车站
第 42 章异空
第 43 章地狱
第 44 章接待
第 45 章重现
第 46 章转形
第 47 章星童
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2001：太空漫游
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>认知天性
推荐序一 轻松的学习是无效的 IX
推荐序二 长谈前后 XI
前言 XV

1
学习是挑战天性的必修课
我们往往无法准确判断自己什么时候学得好，什么时候学得不好。如果感觉学起来又慢又难，似乎毫无进展，我们就会转而关注那些看似更有成效的办法，但没意识到这些方法往往并不会带来持久的效果。
天性懒惰孕育了认知规律和心智模型  /004
科学“照妖镜”下的学习方法  /009
知识多不等于学习力强  /019
考试是最有效的学习策略之一  /021
小 结  /023
2
学习的本质：知识链和记忆结
孩子用绳子把蔓越莓穿起来做项链，挂到树上后却发现蔓越莓从绳子的另一端掉下来了。不打结，就做不出绳串。检索给记忆这条绳子打了结。重复检索能让记忆更清透，而且它把记忆这条绳子又缠了一圈，使其变得更牢靠。
知识最终将变成条件反射  /029
自我检测：给知识链打上记忆结  /030
只需1次自测，一周后回忆率
从28%跃迁为39%  /033
如何成为一名主动学习者  /035
为何学习越轻松，效果越不好  /041
小 结  /046
3
“后刻意练习”时代的到来
人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。
频繁的集中练习只会产生短期记忆  /050
间隔练习使知识存储得更牢固  /052
穿插练习有助于长期记忆  /053
多样化练习促进知识的活学活用  /055
善用练习组合，带来成长性思维  /057
知识是平面的，复合型知识是立体的  /060
关于练习的几条普适性原则  /064
小 结  /068
4
知识的“滚雪球”效应
学习总是建立在已知基础之上的。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。长期记忆的容量基本上是无限的。你知道的越多，就越有可能为新知识建立联系。
学习的三个关键步骤  /079
欲求新知，先忘旧事  /083
越容易想起，越不容易记住  /086
学习中必须要做哪些“努力”  /089
这些“良性干扰”能提升学习效果  /094
化解因失败带来的焦虑感  /097
创造性源于不设限的学习  /101
别在无法克服的困难上浪费时间  /106
小 结  /108
5
打造适合自己的心智模型
效率的本质取决于我们领悟周围世界的能力，以及衡量自己表现的能力。我们总是在判断自己知道什么、不知道什么，以及是否有能力处理一项任务或解决一个问题。当你在某些领域成为专业人士后，你的心智模型就会发展得更为复杂，而组成心智模型的步骤也会淡化成记忆背景。
没头脑的机制1和爱自省的机制2  /115
学习时避免错觉和记忆扭曲  /119
打造适合自己的心智模型  /128
你无法从不擅长的事情里学到知识  /131
实践和测验才能暴露学习漏洞  /135
6
选择适合自己的学习风格
开阔眼界，别局限在自己喜欢的那套学习风格中，要运用你的资源，发挥你的全部“智力”，把你想掌握的知识或技能练得滚瓜烂熟。说出你想要知道、做到、成就的事情，然后列出需要的能力、需要学习的东西，以及从哪里可以找到这些知识和技能，再放手去做。
主动学习能制造掌控感  /143
你是分析型、创新型还是实践型思维？  /158
学不好的领域暴露了你的能力结构  /162
用搭积木的方法构建知识  /164
有人喜欢看说明书，有人喜欢动手试错  /166
小 结  /170
7
终身学习者基本的基本
我们之所以努力，是因为努力本身能拓展我们的能力。你所做的事情决定了你会成为什么样的人，决定了你有能力做什么。你做的事情越多，你能做的事情也就越多。只要保证秉持一种成长心态，你就可以接受这个道理，终身受益。
双胞胎的认知能力也会天差地别  /178
性格、求知欲和家庭条件对学习的影响  /184
脑力训练可以提升学习自信  /187
想要终身成长，请像专家一样思考  /190
学习执行力比学习技巧更重要  /194
掌握几个适合自己的记忆方法  /196
小 结  /211
8
写给大家的学习策略
不管你想要做什么，或成为什么样的人，只有掌握了学习的能力，你才能参与竞争，才不会落伍出局。我们觉得，如果列出从实证研究中得出的主要观点，并辅以案例进行讲解，读者就可以得出自己的结论，找到应用这些结论的最佳方法，所以我们在最后一章将它们一一列举。
给学生的学习策略  /215
给职场人士的学习策略  /231
给教师的学习策略  /239
给培训者的学习策略  /252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>认知天性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国家的视角
导言
第一部分  清晰化和简单化的国家项目
第一章 自然与空间
国家和科学林业：一个寓言
社会事实：原始的和加工过的
铸造清晰性的工具：流行的度量，国家的度量
土地制度：地方实践与财政简况
第二章  城市、人民和语言
姓的创造
标准的正式语言的指令
交通模式的集权化
结论
第二部分  转变中的视野
第三章  独裁主义的极端现代主义
社会的发现
极端现代主义的激进权威
20世纪的极端现代主义

第四章 极端现代主义的城市：试验与批评
总体的城市计划
巴西利亚：建成的最接近极端现代主义的城市
勒柯布西耶的昌迪加尔
反对极端现代主义城市规划的一个例子：简雅各布斯
第五章  革命的政党：计划和诊断
列宁：革命的建筑师和工程师
卢森堡：革命的内科医生和助产士
亚历山德拉柯伦泰和工人对列宁的反对
第三部分  农村定居和生产中的社会工程
第六章  苏维埃集体化，资本主义梦想
苏维埃-美国的迷信：工业化农场
苏维埃俄国的集体化
国家控制和征收的景观
独裁式极端现代主义的限制
第七章  坦桑尼亚的强制村庄化：美学和微型化
东非殖民化的极端现代主义农业
1973年以前坦桑尼亚的村庄和“改进的”农业
“到村庄中生活，这是命令”
“理想的”国家村庄：埃塞俄比亚的变异
结论
第八章  驯化自然：清晰和简单的农业
各类农业的简单化
极端现代主义农业问答
现代主义者的信念与地方实践
极端现代主义的制度亲和力
农业科学的简单化假设
科学农业的简单化实践
比较两个农业逻辑
第四部分 失去的环节
第九章  薄弱的简单化和实践知识：米提斯
米提斯：实践知识的轮廓
米提斯的社会背景和它的被破坏
一个反对知识帝国主义的例子
第十章  结语
“那是无知，傻瓜！”
为抽象公民做的计划
剥开事实见本质
图解的失败和米提斯的角色
一个亲和米提斯的制度案例
鸣谢
插图来源
索引
再版译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国家的视角
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>明解C语言
目    录
第1章　 初识C语言
1-1　 显示计算结果
计算整数的和并显示结果　　2
程序和编译　　2
注释　　3
固定代码　　4
格式化输出函数printf　　4
语句　　5
计算并显示整数的差　　5
格式化字符串和转换说明　　6
符号的称呼　　7
无格式化输出　　8
字符串常量　　9
转义字符　　9
1-2　 变量
常量和变量　　10
声明多个变量　　11
赋值　　11
1-3　 输入和显示
通过键盘进行输入　　12
格式化输入函数scanf　　12
乘法运算　　13
输出函数puts　　14
第2章　 运算和数据类型
2-1　 运算
四则运算　　18
运算符和操作数　　18
商和余数　　19
乘除运算符和加减运算符　　19
使用printf函数打印　　%　　19
获取整数的最后一位数字　　20
多个转换说明　　21
单目运算符　　22
赋值运算符　　23
表达式和赋值表达式　　23
表达式语句　　23
2-2　 数据类型
求平均值　　24
数据类型　　24
int类型和double类型　　25
数据类型和对象　　26
整数常量和浮点数常量　　27
double类型的运算　　27
数据类型和运算　　28
类型转换　　30
转换说明　　32
第3章　 分支结构程序
3-1　 if 语句
程序的流程　　36
if 语句（1）　　36
奇数的判定　　37
if 语句（2）　　38
奇数和偶数　　39
判断　　39
非0的判断　　40
语法结构　　40
相等运算符　　42
比较余数　　43
关系运算符　　44
嵌套的if语句　　45
计算较大值　　46
计算三个数的最大值　　47
条件运算符　　48
差值计算　　49
复合语句（程序块）　　50
判断季节　　52
逻辑运算符　　52
3-2　 switch语句
程序的流程　　54
switch语句和if语句　　57
选择语句　　57
第4章　 程序的循环控制
4-1　 do语句
do语句　　60
复合语句（程序块）中的声明　　61
逻辑非运算符　　61
逆向显示整数值　　62
计算整数的位数　　63
初始化　　64
复合赋值运算符　　66
后置递增运算符和
后置递减运算符　　67
4-2　 while语句
while语句　　68
字符常量　　69
putchar　　69
用递减运算符简化程序代码　　70
数据递增　　71
限定次数的循环操作　　72
前置递增运算符和
前置递减运算符　　73
4-3　 for语句
for语句　　74
循环语句　　75
固定次数的循环　　76
4-4　 多重循环
九九乘法表　　78
多重循环　　79
长方形　　80
直角三角形　　80
4-5　 程序的组成元素和格式
关键字　　82
标识符　　82
分隔符　　83
运算符　　83
常量和字符串常量　　83
自由的书写格式　　84
连接相邻的字符串常量　　85
缩进　　85
第5章　 数组
5-1　 数组
数组　　88
数组和for语句　　90
数组初始化　　92
数组的复制　　93
输入数组元素的值　　94
对数组进行倒序排列　　94
使用数组进行成绩处理　　96
对象式宏　　96
赋值表达式　　98
及格学生一览表　　100
数组的元素个数　　100
成绩分布图　　101
5-2　 多维数组
矩阵　　102
5-3　 质数计算
质数　　104
质数计算程序（第1版）　　104
大整数　　104
break语句　　104
质数计算程序（第2版）　　106
质数计算程序（第3版）　　107
质数计算程序（第4版）　　108
质数计算程序（第5版）　　110
逗号运算符　　110
第6章　 函数
6-1　 什么是函数
main函数　　114
库函数　　114
函数定义和函数调用　　114
三个数中的最大值　　118
平方差　　119
幂　　120
值传递　　120
调用其他函数　　121
6-2　 函数设计
没有返回值的函数　　122
通用性　　122
不含形参的函数　　124
函数返回值的初始化　　125
作用域　　125
计算最高分的程序　　126
文件作用域　　126
声明和定义　　127
函数原型声明　　127
头文件和文件包含指令　　128
函数的通用性　　129
数组的传递　　130
对接收到的数组进行写入处理　　132
const类型的修饰符　　133
顺序查找　　134
哨兵查找法　　135
表达式语句和空语句　　137
多维数组的传递　　138
6-3　 作用域和存储期
作用域和标识符的可见性　　140
存储期　　142
第7章　 基本数据类型
7-1　 基本数据类型和数
基本数据类型　　148
基数　　149
基数转换　　150
7-2　 整型和字符型
字符型和整型　　152
<limits.h>头文件　　154
字符型　　155
sizeof运算符　　156
size_t型和typedef声明　　157
整型的灵活运用　　157
整型常量　　158
整型常量的数据类型　　158
内部表示和位　　160
无符号整数的内部表示　　160
有符号整数的内部表示　　161
反码表示法和补码表示法　　162
窥探整数内部　　163
按位操作的逻辑运算　　164
位移运算符　　166
位数的计算　　168
求出unsigned型的位数　　168
显示位的内容　　169
整数的显示　　170
数据溢出和异常　　171
7-3　 浮点型
浮点型　　172
浮点型常量　　173
循环的控制　　174
<math.h>头文件　　175
7-4　 运算
运算符一览　　176
优先级　　176
结合性　　176
数据类型转换　　178
sizeof运算符　　180
sizeof运算符和数组　　181
第8章　 动手编写各种程序吧
8-1　 函数式宏
函数和数据类型　　184
函数式宏　　185
函数和函数式宏　　186
不带参数的函数式宏　　187
函数式宏和逗号运算符　　188
8-2　 枚举类型
枚举类型　　190
枚举常量　　192
命名空间　　193
8-3　 递归
阶乘　　194
最大公约数　　196
问题和递归　　197
8-4　 输入输出和字符
数字字符计数　　198
getchar函数　　198
EOF　　198
字符和数值　　199
字符　　200
转义字符　　203
复制　　204
第9章　 字符串的基本知识
9-1　 什么是字符串
字符串字面量　　208
字符串字面量的长度　　208
字符串　　210
字符数组的初始化赋值　　211
空字符串　　212
字符串的读取　　212
格式化显示字符串　　213
9-2　 字符串数组
字符串数组　　214
读取字符串数组中的字符串　　215
9-3　 字符串处理
字符串长度　　216
遍历字符串　　218
数字字符的出现次数　　219
字符串数组的参数传递　　220
大小写字符转换　　222
第10章　 指针
10-1　 指针
函数的参数　　226
变量和对象　　227
地址　　227
取址运算符　　228
指针　　229
指针运算符　　231
10-2　 指针和函数
作为函数参数的指针　　232
二值互换　　234
引用传递（C++语言）　　235
计算和与差　　236
scanf函数和指针　　236
将两个值升序排列　　237
指针的类型　　238
标量型　　239
10-3　 指针和数组
指针和数组　　240
数组的传递　　244
第11章　 字符串和指针
11-1　 字符串和指针
字符串和指针　　248
数组和指针的相同点　　249
数组和指针的不同点　　250
字符串数组　　252
11-2　 通过指针操作字符串
字符串和指针　　254
判断字符串长度　　254
const　　254
使用指针进行遍历　　255
字符串的复制　　256
不正确的字符串复制　　258
返回指针的函数　　259
11-3　 字符串处理库函数
字符串处理函数　　260
字符串转换函数　　264
第12章　　结构体
12-1　 结构体
排序　　268
冒泡排序法　　269
数据关联性　　270
结构体　　272
结构体成员（.运算符）　　274
成员的初始化　　275
结构体成员（->运算符）　　276
结构体和typedef　　278
结构体和程序　　279
聚合类型　　280
命名空间　　280
返回结构体的函数　　281
结构体数组　　282
派生类型　　282
表示日期和时间的结构体　　284
12-2　 作为成员的结构体
表示坐标的结构体　　286
表示具有定位功能的汽车的
结构体　　286
第13章　 文件处理
13-1　 文件与流
文件　　290
流　　290
标准流　　291
FILE型　　291
打开文件　　292
关闭文件　　294
打开与关闭文件示例　　295
文件数据汇总　　296
写入日期和时间　　298
获取上一次运行时的信息　　300
标准输入输出　　302
显示文件内容　　302
文件的复制　　304
13-2　 文本和二进制
在文本文件中保存实数　　306
文本文件和二进制文件　　307
在二进制文件中保存实数　　308
显示文件自身　　310
附录1　 C语言简介
C语言的历史　　314
K&R——C语言的圣经　　314
C语言标准规范　　314
附录2　 printf函数与scanf函数
printf函数　　318
scanf函数　　322
致谢　 326
参考文献　 326
索引　 327
版权声明　 338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>明解C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>动手学深度学习
对本书的赞誉
前言
如何使用本书
资源与支持
主要符号表
第1 章　深度学习简介… ………………… 1
1.1　起源…………………………………………… 2
1.2　发展…………………………………………… 4
1.3　成功案例……………………………………… 6
1.4　特点………………………………………… 7
小结…………………………………………… 8
练习…………………………………………… 8
第2 章　预备知识… ……………………… 9
2.1　获取和运行本书的代码……………………… 9
2.1.1　获取代码并安装运行环境 … ……… 9
2.1.2　更新代码和运行环境 … …………… 11
2.1.3　使用GPU版的MXNet … ………… 11
小结……………………………………………12
练习……………………………………………12
2.2　数据操作… ……………………………… 12
2.2.1　创建NDArray ………………………12
2.2.2　运算 …………………………………14
2.2.3　广播机制 ……………………………16
2.2.4　索引 …………………………………17
2.2.5　运算的内存开销 ……………………17
2.2.6　NDArray和NumPy相互变换………18
小结……………………………………………19
练习……………………………………………19
2.3　自动求梯度… …………………………… 19
2.3.1　简单例子 … …………………………19
2.3.2　训练模式和预测模式 …………… 20
2.3.3　对Python控制流求梯度 … …… 20
小结……………………………………………21
练习……………………………………………21
2.4　查阅文档… ……………………………… 21
2.4.1　查找模块里的所有函数和类 … ……21
2.4.2　查找特定函数和类的使用 ……… 22
2.4.3　在MXNet网站上查阅 …………… 23
小结………………………………………… 24
练习………………………………………… 24
第3 章　深度学习基础… ……………… 25
3.1　线性回归…………………………………… 25
3.1.1　线性回归的基本要素 … ………… 25
3.1.2　线性回归的表示方法 … ………… 28
小结………………………………………… 30
练习………………………………………… 30
3.2　线性回归的从零开始实现… …………… 30
3.2.1　生成数据集 … …………………… 30
3.2.2　读取数据集 ……………………… 32
3.2.3　初始化模型参数 ………………… 32
3.2.4　定义模型 ………………………… 33
3.2.5　定义损失函数 …………………… 33
3.2.6　定义优化算法 …………………… 33
3.2.7　训练模型 ………………………… 33
小结………………………………………… 34
练习………………………………………… 34
3.3　线性回归的简洁实现… ………………… 35
3.3.1　生成数据集 … …………………… 35
3.3.2　读取数据集 ……………………… 35
3.3.3　定义模型 ………………………… 36
3.3.4　初始化模型参数 ………………… 36
3.3.5　定义损失函数 …………………… 37
3.3.6　定义优化算法 …………………… 37
3.3.7　训练模型 ………………………… 37
小结………………………………………… 38
练习………………………………………… 38
3.4　softmax回归… ………………………… 38
3.4.1　分类问题 … ……………………… 38
3.4.2　softmax回归模型… …………… 39
3.4.3　单样本分类的矢量计算表达式…… 40
3.4.4　小批量样本分类的矢量计算表达式 …………………………… 40
3.4.5　交叉熵损失函数 ……………………41
3.4.6　模型预测及评价 ………………… 42
小结………………………………………… 42
练习………………………………………… 42
3.5　图像分类数据集（Fashion-MNIST）… ……………… 42
3.5.1　获取数据集 … …………………… 42
3.5.2　读取小批量 ……………………… 44
小结………………………………………… 45
练习………………………………………… 45
3.6　softmax回归的从零开始实现… ……… 45
3.6.1　读取数据集 … …………………… 45
3.6.2　初始化模型参数 ………………… 45
3.6.3　实现softmax运算 … …………… 46
3.6.4　定义模型 ………………………… 46
3.6.5　定义损失函数 …………………… 47
3.6.6　计算分类准确率 ………………… 47
3.6.7　训练模型 ………………………… 48
3.6.8　预测… …………………………… 48
小结………………………………………… 49
练习………………………………………… 49
3.7　softmax回归的简洁实现… …………… 49
3.7.1　读取数据集 … …………………… 49
3.7.2　定义和初始化模型 ……………… 50
3.7.3　softmax和交叉熵损失函数 … … 50
3.7.4　定义优化算法 …………………… 50
3.7.5　训练模型 ………………………… 50
小结………………………………………… 50
练习………………………………………… 50
3.8　多层感知机… …………………………… 51
3.8.1　隐藏层 … ……………………………51
3.8.2　激活函数 ………………………… 52
3.8.3　多层感知机 ……………………… 55
小结………………………………………… 55
练习………………………………………… 55
3.9　多层感知机的从零开始实现… ………… 56
3.9.1　读取数据集 … …………………… 56
3.9.2　定义模型参数 …………………… 56
3.9.3　定义激活函数 …………………… 56
3.9.4　定义模型 ………………………… 56
3.9.5　定义损失函数 …………………… 57
3.9.6　训练模型 ………………………… 57
小结………………………………………… 57
练习………………………………………… 57
3.10　多层感知机的简洁实现………………… 57
3.10.1　定义模型 ………………………… 58
3.10.2　训练模型 … …………………… 58
小结………………………………………… 58
练习………………………………………… 58
3.11　模型选择、欠拟合和过拟合… ………… 58
3.11.1　训练误差和泛化误差 …………… 59
3.11.2　模型选择 ………………………… 59
3.11.3　欠拟合和过拟合 ………………… 60
3.11.4　多项式函数拟合实验 ……………61
小结………………………………………… 65
练习………………………………………… 65
3.12　权重衰减………………………………… 65
3.12.1　方法 ……………………………… 65
3.12.2　高维线性回归实验 … ………… 66
3.12.3　从零开始实现 … ……………… 66
3.12.4　简洁实现 … …………………… 68
小结………………………………………… 70
练习………………………………………… 70
3.13　丢弃法…………………………………… 70
3.13.1　方法 ……………………………… 70
3.13.2　从零开始实现 … …………………71
3.13.3　简洁实现 … …………………… 73
小结………………………………………… 74
练习………………………………………… 74
3.14　正向传播、反向传播和计算图………… 74
3.14.1　正向传播 ……………………… 74
3.14.2　正向传播的计算图 … ………… 75
3.14.3　反向传播 … …………………… 75
3.14.4　训练深度学习模型 … ………… 76
小结………………………………………… 77
练习………………………………………… 77
3.15　数值稳定性和模型初始化……………… 77
3.15.1　衰减和爆炸 ……………………… 77
3.15.2　随机初始化模型参数 … ……… 78
小结………………………………………… 78
练习………………………………………… 79
3.16　实战Kaggle比赛：房价预测… ……… 79
3.16.1　Kaggle比赛 … ………………… 79
3.16.2　读取数据集 … ………………… 80
3.16.3　预处理数据集 … …………………81
3.16.4　训练模型 … …………………… 82
3.16.5　k 折交叉验证 …………………… 82
3.16.6　模型选择 … …………………… 83
3.16.7　预测并在Kaggle提交结果… … 84
小结………………………………………… 85
练习………………………………………… 85
第4 章　深度学习计算… ……………… 86
4.1　模型构造………………………………… 86
4.1.1　继承Block类来构造模型 … …… 86
4.1.2　Sequential类继承自Block类…………………………… 87
4.1.3　构造复杂的模型… ……………… 88
小结………………………………………… 89
练习………………………………………… 90
4.2　模型参数的访问、初始化和共享… …… 90
4.2.1　访问模型参数 … ………………… 90
4.2.2　初始化模型参数 ………………… 92
4.2.3　自定义初始化方法 ……………… 93
4.2.4　共享模型参数 …………………… 94
小结………………………………………… 94
练习………………………………………… 94
4.3　模型参数的延后初始化… ……………… 95
4.3.1　延后初始化 … …………………… 95
4.3.2　避免延后初始化 ………………… 96
小结………………………………………… 96
练习………………………………………… 97
4.4　自定义层… ……………………………… 97
4.4.1　不含模型参数的自定义层 … …… 97
4.4.2　含模型参数的自定义层 ………… 98
小结………………………………………… 99
练习………………………………………… 99
4.5　读取和存储… …………………………… 99
4.5.1　读写NDArray… ………………… 99
4.5.2　读写Gluon模型的参数… ……… 100
小结………………………………………… 101
练习………………………………………… 101
4.6　GPU计算………………………………… 101
4.6.1　计算设备 … ……………………… 102
4.6.2　NDArray的GPU计算…………… 102
4.6.3　Gluon的GPU计算 ……………… 104
小结………………………………………… 105
练习………………………………………… 105
第5 章　卷积神经网络… ……………… 106
5.1　二维卷积层………………………………… 106
5.1.1　二维互相关运算 … ……………… 106
5.1.2　二维卷积层 … …………………… 107
5.1.3　图像中物体边缘检测 … ………… 108
5.1.4　通过数据学习核数组 … ………… 109
5.1.5　互相关运算和卷积运算 … ……… 109
5.1.6　特征图和感受野… ……………… 110
小结………………………………………… 110
练习………………………………………… 110
5.2　填充和步幅… …………………………… 111
5.2.1　填充 … …………………………… 111
5.2.2　步幅 ……………………………… 112
小结………………………………………… 113
练习………………………………………… 113
5.3　多输入通道和多输出通道… …………… 114
5.3.1　多输入通道 … …………………… 114
5.3.2　多输出通道… …………………… 115
5.3.3　1×1卷积层 ……………………… 116
小结………………………………………… 117
练习………………………………………… 117
5.4　池化层… ………………………………… 117
5.4.1　二维最大池化层和平均池化层 … ………………………… 117
5.4.2　填充和步幅 ……………………… 119
5.4.3　多通道 …………………………… 120
小结………………………………………… 120
练习………………………………………… 121
5.5　卷积神经网络（LeNet）… …………… 121
5.5.1　LeNet模型 … …………………… 121
5.5.2　训练模型… ……………………… 122
小结………………………………………… 124
练习………………………………………… 124
5.6　深度卷积神经网络（AlexNet）… …… 124
5.6.1　学习特征表示 … ………………… 125
5.6.2　AlexNet… ……………………… 126
5.6.3　读取数据集 ……………………… 127
5.6.4　训练模型 ………………………… 128
小结………………………………………… 128
练习………………………………………… 129
5.7　使用重复元素的网络（VGG）………… 129
5.7.1　VGG块 …………………………… 129
5.7.2　VGG网络 … …………………… 129
5.7.3　训练模型… ……………………… 130
小结………………………………………… 131
练习………………………………………… 131
5.8　网络中的网络（NiN）… ……………… 131
5.8.1　NiN块 … ………………………… 131
5.8.2　NiN模型 … ……………………… 132
5.8.3　训练模型… ……………………… 133
小结………………………………………… 134
练习………………………………………… 134
5.9　含并行连结的网络（GoogLeNet）…… 134
5.9.1　Inception块 ……………………… 134
5.9.2　GoogLeNet模型 … …………… 135
5.9.3　训练模型 ………………………… 137
小结………………………………………… 137
练习………………………………………… 137
5.10　批量归一化……………………………… 138
5.10.1　批量归一化层 ………………… 138
5.10.2　从零开始实现 … ……………… 139
5.10.3　使用批量归一化层的LeNet … … 140
5.10.4　简洁实现 … …………………… 141
小结………………………………………… 142
练习………………………………………… 142
5.11　残差网络（ResNet） ……………… 143
5.11.1　残差块 …………………………… 143
5.11.2　ResNet模型… ………………… 145
5.11.3　训练模型………………………… 146
小结………………………………………… 146
练习………………………………………… 146
5.12　稠密连接网络（DenseNet）………… 147
5.12.1　稠密块 …………………………… 147
5.12.2　过渡层 … ……………………… 148
5.12.3　DenseNet模型 ………………… 148
5.12.4　训练模型 … …………………… 149
小结………………………………………… 149
练习………………………………………… 149
第6 章　循环神经网络… ……………… 150
6.1　语言模型………………………………… 150
6.1.1　语言模型的计算 … ……………… 151
6.1.2　n 元语法 … ……………………… 151
小结………………………………………… 152
练习………………………………………… 152
6.2　循环神经网络… ………………………… 152
6.2.1　不含隐藏状态的神经网络 … …… 152
6.2.2　含隐藏状态的循环神经网络… … 152
6.2.3　应用：基于字符级循环神经网络的语言模型 … ……………………… 154
小结………………………………………… 155
练习………………………………………… 155
6.3　语言模型数据集（歌词）…… 155
6.3.1　读取数据集 … …………………… 155
6.3.2　建立字符索引 …………………… 156
6.3.3　时序数据的采样 ………………… 156
小结………………………………………… 158
练习………………………………………… 159
6.4　循环神经网络的从零开始实现… ……… 159
6.4.1　one-hot向量 … ………………… 159
6.4.2　初始化模型参数 ………………… 160
6.4.3　定义模型 ………………………… 160
6.4.4　定义预测函数 …………………… 161
6.4.5　裁剪梯度 ………………………… 161
6.4.6　困惑度 …………………………… 162
6.4.7　定义模型训练函数 ……………… 162
6.4.8　训练模型并创作歌词 …………… 163
小结………………………………………… 164
练习………………………………………… 164
6.5　循环神经网络的简洁实现… …………… 165
6.5.1　定义模型 … ……………………… 165
6.5.2　训练模型 ………………………… 166
小结………………………………………… 168
练习………………………………………… 168
6.6　通过时间反向传播… …………………… 168
6.6.1　定义模型 … ……………………… 168
6.6.2　模型计算图 ……………………… 169
6.6.3　方法 ……………………………… 169
小结………………………………………… 170
练习………………………………………… 170
6.7　门控循环单元（GRU）………………… 170
6.7.1　门控循环单元 … ………………… 171
6.7.2　读取数据集 ……………………… 173
6.7.3　从零开始实现 …………………… 173
6.7.4　简洁实现 ………………………… 175
小结………………………………………… 176
练习………………………………………… 176
6.8　长短期记忆（LSTM）… ……………… 176
6.8.1　长短期记忆 … …………………… 176
6.8.2　读取数据集 ……………………… 179
6.8.3　从零开始实现 …………………… 179
6.8.4　简洁实现 ………………………… 181
小结………………………………………… 181
练习………………………………………… 182
6.9　深度循环神经网络… …………………… 182
小结………………………………………… 183
练习………………………………………… 183
6.10　双向循环神经网络……………………… 183
小结………………………………………… 184
练习………………………………………… 184
第7 章　优化算法… …………………… 185
7.1　优化与深度学习…………………………… 185
7.1.1　优化与深度学习的关系 … ……… 185
7.1.2　优化在深度学习中的挑战 … …… 186
小结………………………………………… 188
练习………………………………………… 189
7.2　梯度下降和随机梯度下降… …………… 189
7.2.1　一维梯度下降 … ………………… 189
7.2.2　学习率 …………………………… 190
7.2.3　多维梯度下降 …………………… 191
7.2.4　随机梯度下降 …………………… 193
小结………………………………………… 194
练习………………………………………… 194
7.3　小批量随机梯度下降… ………………… 194
7.3.1　读取数据集 … …………………… 195
7.3.2　从零开始实现 …………………… 196
7.3.3　简洁实现 ………………………… 198
小结………………………………………… 199
练习………………………………………… 199
7.4　动量法… …………………………………200
7.4.1　梯度下降的问题 … ……………… 200
7.4.2　动量法 …………………………… 201
·6·　目　　录
7.4.3　从零开始实现 …………………… 203
7.4.4　简洁实现 ………………………… 205
小结………………………………………… 205
练习………………………………………… 205
7.5　AdaGrad算法……………………………206
7.5.1　算法 … …………………………… 206
7.5.2　特点 ……………………………… 206
7.5.3　从零开始实现 …………………… 208
7.5.4　简洁实现 ………………………… 209
小结………………………………………… 209
练习………………………………………… 209
7.6　RMSProp算法… ………………………209
7.6.1　算法 … …………………………… 210
7.6.2　从零开始实现 …………………… 211
7.6.3　简洁实现 ………………………… 212
小结………………………………………… 212
练习………………………………………… 212
7.7　AdaDelta算法… ……………………… 212
7.7.1　算法… …………………………… 212
7.7.2　从零开始实现 …………………… 213
7.7.3　简洁实现 ………………………… 214
小结………………………………………… 214
练习………………………………………… 214
7.8　Adam算法… …………………………… 215
7.8.1　算法 … …………………………… 215
7.8.2　从零开始实现 …………………… 216
7.8.3　简洁实现 ………………………… 216
小结………………………………………… 217
练习………………………………………… 217
第8 章　计算性能… …………………… 218
8.1　命令式和符号式混合编程… …………… 218
8.1.1　混合式编程取两者之长 … ……… 220
8.1.2　使用HybridSequential类构造模型 … …………………………… 220
8.1.3　使用HybridBlock类构造模型… …………………………… 222
小结………………………………………… 224
练习………………………………………… 224
8.2　异步计算… ………………………………224
8.2.1　MXNet中的异步计算 …………… 224
8.2.2　用同步函数让前端等待计算结果 … …………………………… 226
8.2.3　使用异步计算提升计算性能 …… 226
8.2.4　异步计算对内存的影响 ………… 227
小结………………………………………… 229
练习………………………………………… 229
8.3　自动并行计算… …………………………229
8.3.1　CPU和GPU的并行计算 … …… 230
8.3.2　计算和通信的并行计算 ………… 231
小结………………………………………… 231
练习………………………………………… 231
8.4　多GPU计算……………………………… 232
8.4.1　数据并行 … ……………………… 232
8.4.2　定义模型 ………………………… 233
8.4.3　多GPU之间同步数据 … ……… 234
8.4.4　单个小批量上的多GPU训练 … …………………………… 236
8.4.5　定义训练函数 …………………… 236
8.4.6　多GPU训练实验 … …………… 237
小结………………………………………… 237
练习………………………………………… 237
8.5　多GPU计算的简洁实现………………… 237
8.5.1　多GPU上初始化模型参数……… 238
8.5.2　多GPU训练模型 … …………… 239
小结………………………………………… 241
练习………………………………………… 241
第9 章　计算机视觉… ………………… 242
9.1　图像增广…………………………………242
9.1.1　常用的图像增广方法 … ………… 243
9.1.2　使用图像增广训练模型 … ……… 246
小结………………………………………… 250
练习………………………………………… 250
9.2　微调… ……………………………………250
热狗识别 … ……………………………… 251
小结………………………………………… 255
练习………………………………………… 255
目　　录　·7·
9.3　目标检测和边界框… ……………………255
边界框 … ………………………………… 256
小结………………………………………… 257
练习………………………………………… 257
9.4　锚框… …………………………………… 257
9.4.1　生成多个锚框… ………………… 257
9.4.2　交并比 …………………………… 259
9.4.3　标注训练集的锚框 ……………… 260
9.4.4　输出预测边界框… ……………… 263
小结………………………………………… 265
练习………………………………………… 265
9.5　多尺度目标检测… ………………………265
小结………………………………………… 268
练习………………………………………… 268
9.6　目标检测数据集（皮卡丘）… …………268
9.6.1　获取数据集 … …………………… 269
9.6.2　读取数据集… …………………… 269
9.6.3　图示数据 ………………………… 270
小结………………………………………… 270
练习………………………………………… 271
9.7　单发多框检测（SSD）… ……………… 271
9.7.1　定义模型… ……………………… 271
9.7.2　训练模型 ………………………… 275
9.7.3　预测目标 ………………………… 277
小结………………………………………… 278
练习………………………………………… 278
9.8　区域卷积神经网络（R-CNN）系列……280
9.8.1　R-CNN … ……………………… 280
9.8.2　Fast R-CNN …………………… 281
9.8.3　Faster R-CNN ………………… 283
9.8.4　Mask R-CNN … ……………… 284
小结………………………………………… 285
练习………………………………………… 285
9.9　语义分割和数据集… ……………………285
9.9.1　图像分割和实例分割 … ………… 285
9.9.2　Pascal VOC2012语义分割数据集 … ………………………… 286
小结………………………………………… 290
练习………………………………………… 290
9.10　全卷积网络（FCN）… ………………290
9.10.1　转置卷积层 …………………… 291
9.10.2　构造模型 … …………………… 292
9.10.3　初始化转置卷积层……………… 294
9.10.4　读取数据集 … ………………… 295
9.10.5　训练模型………………………… 296
9.10.6　预测像素类别…………………… 296
小结………………………………………… 297
练习………………………………………… 297
9.11　样式迁移… ………………………………298
9.11.1　方法 ……………………………… 298
9.11.2　读取内容图像和样式图像……… 299
9.11.3　预处理和后处理图像 ………… 300
9.11.4　抽取特征 ……………………… 301
9.11.5　定义损失函数 ………………… 302
9.11.6　创建和初始化合成图像 ……… 303
9.11.7　训练模型………………………… 304
小结………………………………………… 306
练习………………………………………… 306
9.12　实战Kaggle比赛：图像
分类（CIFAR-10）……………………306
9.12.1　获取和整理数据集 ……………… 307
9.12.2　图像增广 … …………………… 310
9.12.3　读取数据集 … ………………… 310
9.12.4　定义模型………………………… 311
9.12.5　定义训练函数 … ……………… 312
9.12.6　训练模型 … …………………… 312
9.12.7　对测试集分类并在Kaggle
提交结果 … …………………… 313
小结………………………………………… 313
练习………………………………………… 313
9.13　实战Kaggle比赛：狗的品种
识别（ImageNet Dogs）…………… 314
9.13.1　获取和整理数据集 …………… 315
9.13.2　图像增广 … …………………… 316
9.13.3　读取数据集 … ………………… 317
9.13.4　定义模型 … …………………… 318
9.13.5　定义训练函数 … ……………… 318
9.13.6　训练模型 … …………………… 319
·8·　目　　录
9.13.7　对测试集分类并在Kaggle提交结果 … …………………… 319
小结………………………………………… 320
练习………………………………………… 320
第10 章　自然语言处理………………… 321
10.1　词嵌入（word2vec）………………… 321
10.1.1　为何不采用one-hot向量… …… 321
10.1.2　跳字模型 ………………………… 322
10.1.3　连续词袋模型 …………………… 323
小结………………………………………… 325
练习………………………………………… 325
10.2　近似训练…………………………………325
10.2.1　负采样 …………………………… 325
10.2.2　层序softmax …………………… 326
小结………………………………………… 327
练习………………………………………… 328
10.3　word2vec的实现………………………328
10.3.1　预处理数据集 …………………… 328
10.3.2　负采样 … ……………………… 331
10.3.3　读取数据集 … ………………… 331
10.3.4　跳字模型 … …………………… 332
10.3.5　训练模型 … …………………… 333
10.3.6　应用词嵌入模型 … …………… 335
小结………………………………………… 336
练习………………………………………… 336
10.4　子词嵌入（fastText）… ……………336
小结………………………………………… 337
练习………………………………………… 337
10.5　全局向量的词嵌入（GloVe）…………337
10.5.1　GloVe模型 …………………… 338
10.5.2　从条件概率比值理解GloVe模型……………………… 339
小结………………………………………… 340
练习………………………………………… 340
10.6　求近义词和类比词………………………340
10.6.1　使用预训练的词向量 ………… 340
10.6.2　应用预训练词向量 … ………… 341
小结………………………………………… 343
练习………………………………………… 343
10.7　文本情感分类：使用循环神经网络…… 343
10.7.1　文本情感分类数据集 ………… 343
10.7.2　使用循环神经网络的模型……… 345
小结………………………………………… 347
练习………………………………………… 347
10.8　文本情感分类：使用卷积神经网络（textCNN）… …………………347
10.8.1　一维卷积层 … ………………… 348
10.8.2　时序最大池化层 … …………… 349
10.8.3　读取和预处理IMDb数据集 … ……………………… 350
10.8.4　textCNN模型 … ……………… 350
小结………………………………………… 353
练习………………………………………… 353
10.9　编码器-解码器（seq2seq）…………353
10.9.1　编码器 ………………………… 354
10.9.2　解码器 … ……………………… 354
10.9.3　训练模型………………………… 355
小结………………………………………… 355
练习………………………………………… 355
10.10　 束搜索… ………………………………355
10.10.1　贪婪搜索 … …………………… 356
10.10.2　穷举搜索 ……………………… 357
10.10.3　束搜索 ………………………… 357
小结………………………………………… 358
练习………………………………………… 358
10.11　注意力机制… …………………………358
10.11.1　计算背景变量 … ……………… 359
10.11.2　更新隐藏状态 … ……………… 360
10.11.3　发展… ………………………… 361
小结………………………………………… 361
练习………………………………………… 361
10.12　机器翻译… …………………………… 361
10.12.1　读取和预处理数据集… ……… 361
10.12.2　含注意力机制的编码器-解码器 … …………… 363
10.12.3　训练模型 ……………………… 365
10.12.4　预测不定长的序列… ………… 367
10.12.5　评价翻译结果 ………………… 367
小结………………………………………… 369
练习………………………………………… 369
附录A　数学基础… …………………… 370
附录B　使用 Jupyter 记事本… ……… 376
附录C　使用 AWS 运行代码…………… 381
附录D　GPU 购买指南………………… 388
附录E　如何为本书做贡献… ………… 391
附录F　d2lzh 包索引…………………… 395
附录G　中英文术语对照表… ………… 397
参考文献………………………………… 402
索引……………………………………… 407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>动手学深度学习
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
第Ⅰ部分 敏捷开发
第一章 敏捷实践
1.1 敏捷联盟
1.2 原则
1.3 结论
参考文献
第二章 极限编程概述
2.1 极限编程实践
2.2 结论
参考文献
第三章 计划
3.1 初始探索
3.2 发布计划
3.3 迭代计划
3.4 任务计划
3.5 迭代
3.6 结论
参考文献
第四章 测试
4.1 测试驱动的开发方法
4.2 验收测试
4.3 结论
参考文献
第五章 重构
5.1 素数产生程序一个简单的重构示例
5.2 结论
参考文献
第六章 一次编程实践
6.1 保龄球比赛
6.2 结论
第Ⅱ部分 敏捷设计
第七章 什么是敏捷设计
7.1 软件出了什么错
7.2 设计的臭味——腐化软件的气味
7.3 “Copy”程序
7.4 保持尽可能好的设计
7.5 结论
参考文献
第八章 单一责任原则（SRP）
8.1 单一职责原则（SRP）
8.2 结论
参考文献
第九章 开放—封闭原则（OCP）
9.1 开放—封闭原则（OCP）
9.2 描述
9.3 关键是抽象
9.4 结论
参考文献
第十章 Liskov替换原则（LSP）
10.1 Liskov替换原则（LSP）
10.2 一个违反LSP的简单例子
10.3 正方形和矩形，更微妙的违规
10.4 一个实际的例子
10.5 用提取公共部分的方法代替继承
10.6 启发式规则和习惯用法
10.7 结论
参考文献
第十一章 依赖倒置原则（DIP）
11.1 依赖倒置原则（DIP）
11.2 层次化
11.3 一个简单的例子
11.4 熔炉示例
11.5 结论
参考文献
第十二章 接口隔离原则（ISP）
12.1 接口污染
12.2 分离客户就是分离接口
12.3 接口隔离原则（ISP）
12.4 类接口与对象接口
12.5 ATM用户界面的例子
12.6 结论
参考文献
第Ⅲ部分 薪水支付案例研究
第十三章 COMMAND模式和ACTIVE OBJECT模式
第十四章 TEMPLATE METHOD模式和STRATEGY模式：继承与委托
第十五章 FACADE模式和MEDIATOR模式
第十六章 SINGLETON模式和MONOSTATE模式
第十七章 NULL OBJECT模式
第十八章 薪水支付案例研究：第一次迭代开始
第十九章 薪水支付案例研究：实现
第Ⅳ部分 打包薪水支付系统
第二十章 包的设计原则
第二十一章 FACTORY模式
第二十二章 薪水支付案例研究（第2部分）
第Ⅴ部分 气象站案例研究
第二十三章 COMPOSITE模式
第二十四章 OBSERVER模式——回归为模式
第二十五章 ABSTRACT SERVER模式、ADAPTER模式和BRIDGE模式
第二十六章 PROXY模式和STAIRWAY TO HEAVEN模式：管理第三方API
第二十七章 案例研究：气象站
第Ⅵ部分 ETS案例研究
第二十八章 VISITOR模式
第二十九章 STATE模式
第三十章 ETS框架
附录
附录A UML表示法Ⅰ：CGI示例
附录B UML表示法Ⅱ：统计多路复用器
附录C 两个公司的讽刺小品
附录D 源代码就是设计
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哲学导论
导　言
哲学的历史
导　论
第一部分 世界与彼岸
第1章　实　在
第2章　宗　教
第3章　知　识
第二部分 认识你自己
第4章　自　我
第5章　心灵与身体
第6章　自　由
第三部分：善与权利
第7章　伦理学
第8章　正　义
哲学家小传
重要词汇
出版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哲学导论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>现代编译原理
第一部分　编译基本原理
第1章　绪论　　1
1.1　模块与接口　　1
1.2　工具和软件　　3
1.3　树语言的数据结构　　3
程序设计：直线式程序解释器　　7
推荐阅读　　8
习题　　9
第2章　词法分析　　10
2.1　词法单词　　10
2.2　正则表达式　　11
2.3　有限自动机　　13
2.4　非确定有限自动机　　15
2.5　Lex：词法分析器的生成器　　20
程序设计：词法分析　　22
推荐阅读　　23
习题　　23
第3章　语法分析　　27
3.1　上下文无关文法　　28
3.2　预测分析　　32
3.3　LR分析　　39
3.4　使用分析器的生成器　　48
3.5　错误恢复　　54
程序设计：语法分析　　57
推荐阅读　　58
习题　　58
第4章　抽象语法　　62
4.1　语义动作　　62
4.2　抽象语法分析树　　65
程序设计：抽象语法　　71
推荐阅读　　71
习题　　72
第5章　语义分析　　73
5.1　符号表　　73
5.2　Tiger编译器的绑定　　79
5.3　表达式的类型检查　　82
5.4　声明的类型检查　　84
程序设计：类型检查　　86
习题　　87
第6章　活动记录　　89
6.1　栈帧　　90
6.2　Tiger编译器的栈帧　　96
程序设计：栈帧　　102
推荐阅读　　103
习题　　103
第7章　翻译成中间代码　　106
7.1　中间表示树　　106
7.2　翻译为树中间语言　　108
7.3　声明　　120
程序设计：翻译成树　　122
习题　　123
第8章　基本块和轨迹　　125
8.1　规范树　　126
8.2　处理条件分支　　131
推荐阅读　　134
习题　　134
第9章　指令选择　　136
9.1　指令选择算法　　138
9.2 　CISC机器　　144
9.3　Tiger编译器的指令选择　　146
程序设计：指令选择　　152
推荐阅读　　153
习题　　154
第10章　活跃分析　　155
10.1　数据流方程的解　　156
10.2　Tiger编译器的活跃分析　　162
程序设计：构造流图　　164
程序设计：活跃分析模块　　165
习题　　165
第11章　寄存器分配　　166
11.1　通过简化进行着色　　166
11.2　合并　　168
11.3　预着色的结点　　171
11.4　图着色的实现　　175
11.5　针对树的寄存器分配　　181
程序设计：图着色　　184
推荐阅读　　185
习题　　185
第12章　整合为一体　　188
程序设计：过程入口/出口　　189
程序设计：创建一个可运行的编译器　　191
第二部分　高级主题
第13章　垃圾收集　　193
13.1　标记-清扫式收集　　194
13.2　引用计数　　197
13.3　复制式收集　　198
13.4　分代收集　　201
13.5　增量式收集　　203
13.6　Baker算法　　205
13.7　编译器接口　　205
程序设计：描述字　　208
程序设计：垃圾收集　　208
推荐阅读　　208
习题　　210
第14章　面向对象的语言　　211
14.1　类　　211
14.2　数据域的单继承性　　213
14.3　多继承　　214
14.4　测试类成员关系　　216
14.5　私有域和私有方法　　218
14.6　无类语言　　219
14.7　面向对象程序的优化　　219
程序设计：OBJECT-Tiger　　220
推荐阅读　　220
习题　　221
第15章　函数式程序设计语言　　222
15.1　一个简单的函数式语言　　222
15.2　闭包　　224
15.3　不变的变量　　225
15.4　内联扩展　　229
15.5　闭包变换　　233
15.6　高效的尾递归　　235
15.7　懒惰计算　　236
推荐阅读　　243
程序设计：编译函数式语言　　244
习题　　244
第16章　多态类型　　246
16.1　参数多态性　　246
16.2　类型推论　　253
16.3　多态变量的表示　　259
16.4　静态重载的解决方法　　265
推荐阅读　　266
习题　　266
第17章　数据流分析　　269
17.1　流分析使用的中间表示　　270
17.2　各种数据流分析　　271
17.3　使用数据流分析结果的几种转换　　274
17.4　加快数据流分析　　276
17.5　别名分析　　281
推荐阅读　　285
习题　　285
第18章　循环优化　　287
18.1　必经结点　　289
18.2　循环不变量计算　　292
18.3　归纳变量　　293
18.4　数组边界检查　　297
18.5　循环展开　　300
推荐阅读　　301
习题　　301
第19章　静态单赋值形式　　303
19.1　转化为SSA形式　　305
19.2　必经结点树的高效计算　　310
19.3　使用SSA的优化算法　　315
19.4　数组、指针和存储器　　320
19.5　控制依赖图　　321
19.6　从SSA形式转变回来　　323
19.7　函数式中间形式　　324
推荐阅读　　327
习题　　328
第20章　流水和调度　　331
20.1　没有资源约束时的循环调度　　332
20.2　有资源约束的循环流水　　336
20.3　分支预测　　341
推荐阅读　　343
习题　　343
第21章　存储层次　　346
21.1　cache的组织结构　　346
21.2　cache块对齐　　349
21.3　预取　　350
21.4　循环交换　　354
21.5　分块　　355
21.6　垃圾收集和存储层次　　357
推荐阅读　　358
习题　　358
附录　Tiger语言参考手册　　360
参考文献　　368
索引　　376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>现代编译原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度探索C++对象模型
本立道生
目录
前言
第0章 导读（译者的话）
第1章 关于对象
第2章 构造函数语意学
第3章 Data语意学
第4章 Function语意学
第5章 构造、解构、拷贝语意学
第6章 执行期语意学
第7章 站在对象模型的尖端
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度探索C++对象模型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>弱者的武器
前言
第一章　阶级战争中的短兵相接
拉扎克
哈吉·“布鲁姆”
权力的象征性平衡
第二章　常规的剥削，常规的反抗
未被书写的反抗史
作为思想和象征的反抗
人类行动者的经验与意识
第三章　反抗的景观
背景：马来西亚和水稻主产区
中层背景：吉打州和穆达地区的灌溉系统
第四章　塞达卡：从1967年到1979年
村庄
富与穷
村庄构成
土地占有与使用
租佃的变化
水稻生产的变化和工资的变化
地方机构和经济权力
第五章　胜利者和失败者眼中的历史
分类
夜行船
绿色革命的阶级史
双耕与双重看法
从活租到死租
联合收割机
失去的地盘：土地的获得
慈善的仪式与社会控制
记忆中的村庄
第六章　延展事实：意识形态的运作
特定情境中的意识形态运作
剥削的词汇表
歪曲事实：分层与收入
合理化的剥削
意识形态冲突：村庄大门
意识形态冲突：村庄改进计划
作为反抗的争论
第七章　超越口舌之战：谨慎反抗与适度遵从
公开的集体反抗的障碍
抵制联合收割机的努力
“常规的”反抗
“常规的”镇压
常规的顺从与不留痕迹的反抗
服从以及部分的文本
何谓反抗？
第八章　霸权与意识：
意识形态斗争的日常形式
塞达卡的物质基础和规范性上层建筑
重新思考霸权概念
附录
附录A　村庄人口记录，1967—1979
附录B　不同土地使用类型／农场规模的农场收入比较（穆达地区，1966、1974和1979年）
附录C　关于土地使用情况变更、净利润及政治事务的数据
附录D　飞翔信的译文
参考文献
索引
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>弱者的武器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构、算法与应用（原书第2版）
出版者的话
译者序
前言
第一部分　预备知识
第1章　C++回顾 2
1.1　引言 2
1.2　函数与参数 3
1.2.1　传值参数 3
1.2.2　模板函数 4
1.2.3　引用参数 4
1.2.4　常量引用参数 5
1.2.5　返回值 5
1.2.6　重载函数 6
1.3　异常 7
1.3.1　抛出异常 7
1.3.2　处理异常 7
1.4　动态存储空间分配 9
1.4.1　操作符new 9
1.4.2　一维数组 9
1.4.3　异常处理 9
1.4.4　操作符delete 10
1.4.5　二维数组 10
1.5　自有数据类型 12
1.5.1　类currency 12
1.5.2　一种不同的描述方法 18
1.5.3　操作符重载 20
1.5.4　友元和保护性类成员 22
1.5.5　增加#ifndef、#define和#endif语句 23
1.6　异常类illegalParameterValue 24
1.7　递归函数 25
1.7.1　递归的数学函数 25
1.7.2　归纳 25
1.7.3　C++递归函数 26
1.8　标准模板库 30
1.9　测试与调试 32
1.9.1　什么是测试 32
1.9.2　测试数据的设计 34
1.9.3　调试 36
1.10　参考及推荐读物 37
第2章　程序性能分析 38
2.1　什么是程序性能 38
2.2　空间复杂度 39
2.2.1　空间复杂度的组成 39
2.2.2　举例 42
2.3　时间复杂度 44
2.3.1　时间复杂度的组成 44
2.3.2　操作计数 45
2.3.3　最好、最坏和平均操作计数 48
2.3.4　步数 53
第3章　渐近记法 64
3.1　引言 64
3.2　渐近记法 65
3.2.1　大Ο记法 65
3.2.2　渐近记法Ω和Θ 67
3.3　渐近数学（可选） 69
3.3.1　大O记法 69
3.3.2　Ω记法 71
3.3.3　Θ记法 72
3.3.4　小ο记法 73
3.3.5　特性 73
3.4　复杂度分析举例 75
3.5　实际复杂度 78
3.6　参考及推荐读物 80
第4章　性能测量 81
4.1　引言 81
4.2　选择实例的大小 82
4.3　设计测试数据 82
4.4　实验设计 82
4.5　高速缓存 87
4.5.1　简单计算机模型 87
4.5.2　缓存未命中对运行时间的影响 87
4.5.3　矩阵乘法 88
4.6　参考及推荐读物 90
第二部分　数据结构
第5章　线性表——数组描述 92
5.1　数据对象和数据结构 92
5.2　线性表数据结构 93
5.2.1　抽象数据类型linearList	94
5.2.2　抽象类linearList 94
5.3　数组描述 95
5.3.1　描述 95
5.3.2　变长一维数组 96
5.3.3　类arrayList 97
5.3.4　C++迭代器 102
5.3.5　arrayList的一个迭代器 103
5.4　vector的描述 107
5.5　在一个数组中实现的多重表 109
5.6　性能测量 111
5.7　参考及推荐读物 112
第6章　线性表——链式描述 113
6.1　单向链表 113
6.1.1　描述 113
6.1.2　结构chainNode 114
6.1.3　类chain 115
6.1.4　抽象数据类型linearList的扩充 121
6.1.5　类extendedChain 121
6.1.6　性能测量 122
6.2　循环链表和头节点 126
6.3　双向链表 128
6.4　链表用到的词汇表 129
6.5　应用 130
6.5.1　箱子排序 130
6.5.2　基数排序 134
6.5.3　凸包 135
6.5.4　并查集 137
第7章　数组和矩阵 146
7.1　数组 146
7.1.1　抽象数据类型 146
7.1.2　C++数组的索引 147
7.1.3　行主映射和列主映射 147
7.1.4　用数组的数组来描述 148
7.1.5　行主描述和列主描述 149
7.1.6　不规则二维数组 149
7.2　矩阵 151
7.2.1　定义和操作 151
7.2.2　类matrix 152
7.3　特殊矩阵 157
7.3.1　定义和应用 157
7.3.2　对角矩阵 158
7.3.3　三对角矩阵 159
7.3.4　三角矩阵 160
7.3.5　对称矩阵 161
7.4　稀疏矩阵 164
7.4.1　基本概念 164
7.4.2　用单个线性表描述 165
7.4.3　用多个线性表描述 170
7.4.4　性能测量 172
第8章　栈 175
8.1　定义和应用 175
8.2　抽象数据类型 177
8.3　数组描述 178
8.3.1　作为一个派生类实现 178
8.3.2　类arrayStack 179
8.3.3　性能测量 181
8.4　链表描述 182
8.4.1　类derivedLinkedStack 182
8.4.2　类linkedStack 183
8.4.3　性能测量 184
8.5　应用 184
8.5.1　括号匹配 184
8.5.2　汉诺塔 185
8.5.3　列车车厢重排 187
8.5.4　开关盒布线 191
8.5.5　离线等价类问题 193
8.5.6　迷宫老鼠 196
8.6　参考及推荐读物 204
第9章　队列 205
9.1　定义和应用 205
9.2　抽象数据类型 206
9.3　数组描述 207
9.3.1　描述 207
9.3.2　类arrayQueue 209
9.4　链表描述 212
9.5　应用 214
9.5.1　列车车厢重排 214
9.5.2　电路布线 217
9.5.3　图元识别 219
9.5.4　工厂仿真 222
9.6　参考及推荐读物 234
第10章　跳表和散列 235
10.1　字典 235
10.2　抽象数据类型 236
10.3　线性表描述 237
10.4　跳表表示（可选） 239
10.4.1　理想情况 239
10.4.2　插入和删除 241
10.4.3　级的分配 241
10.4.4　结构skipNode 242
10.4.5　类skipList 242
10.4.6　skipList方法的复杂度 246
10.5　散列表描述 246
10.5.1　理想散列 246
10.5.2　散列函数和散列表 248
10.5.3　线性探查 250
10.5.4　链式散列 255
10.6　一个应用——文本压缩 260
10.6.1　LZW压缩 260
10.6.2　LZW压缩的实现 261
10.6.3　LZW解压缩 264
10.6.4　LZW解压缩的实现 265
10.6.5　性能评价 268
10.7　参考及推荐读物 269
第11章　二叉树和其他树 270
11.1　树 270
11.2　二叉树 273
11.3　二叉树的特性 274
11.4　二叉树的描述 275
11.4.1　数组描述 275
11.4.2　链表描述 276
11.5　二叉树常用操作 277
11.6　二叉树遍历 277
11.7　抽象数据类型BinaryTree 281
11.8　类linkedBinaryTree 282
11.9　应用 285
11.9.1　设置信号放大器 285
11.9.2　并查集 288
11.10　参考及推荐读物 296
第12章　优先级队列 297
12.1　定义和应用 297
12.2　抽象数据类型 298
12.3　线性表 299
12.4　堆 299
12.4.1　定义 299
12.4.2　大根堆的插入 300
12.4.3　大根堆的删除 301
12.4.4　大根堆的初始化 301
12.4.5　类maxHeap 302
12.4.6　堆和STL 305
12.5　左高树 306
12.5.1　高度优先与宽度优先的最大及最小左高树 306
12.5.2　最大HBLT的插入 308
12.5.3　最大HBLT的删除 308
12.5.4　两棵最大HBLT的合并 308
12.5.5　初始化 309
12.5.6　类maxHblt 310
12.6　应用 313
12.6.1　堆排序 313
12.6.2　机器调度 314
12.6.3　霍夫曼编码 317
12.7　参考及推荐读物 322
第13章　竞赛树 323
13.1　赢者树和应用 323
13.2　抽象数据类型WinnerTree 326
13.3　赢者树的实现 327
13.3.1　表示 327
13.3.2　赢者树的初始化 328
13.3.3　重新组织比赛 328
13.3.4　类completeWinnerTree 328
13.4　输者树 329
13.5　应用 331
13.5.1　用最先适配法求解箱子装载问题 331
13.5.2　用相邻适配法求解箱子装载问题 335
13.6　参考及推荐读物 337
第14章　搜索树 338
14.1　定义 338
14.1.1　二叉搜索树 338
14.1.2　索引二叉搜索树 340
14.2　抽象数据类型 340
14.3　二叉搜索树的操作和实现 341
14.3.1　类binarySearchTree 341
14.3.2　搜索 342
14.3.3　插入 342
14.3.4　删除 343
14.3.5　二叉搜索树的高度 346
14.4　带有相同关键字元素的二叉搜索树 347
14.5　索引二叉搜索树 348
14.6　应用 349
14.6.1　直方图 349
14.6.2　箱子装载问题的最优匹配法 351
14.6.3　交叉分布 353
第15章　平衡搜索树 359
15.1　AVL树 360
15.1.1　定义 360
15.1.2　AVL树的高度 361
15.1.3　AVL树的描述 361
15.1.4　AVL搜索树的搜索 361
15.1.5　AVL搜索树的插入 361
15.1.6　AVL搜索树的删除 364
15.2　红-黑树 367
15.2.1　基本概念 367
15.2.2　红-黑树的描述 368
15.2.3　红-黑树的搜索 368
15.2.4　红-黑树的插入 368
15.2.5　红-黑树的删除 371
15.2.6　实现细节的考虑及复杂性分析 374
15.3　分裂树 376
15.3.1　介绍 376
15.3.2　分裂树的操作 376
15.3.3　折算复杂性 378
15.4　B-树 379
15.4.1　索引顺序访问方法 379
15.4.2　m叉搜索树 380
15.4.3　m阶B-树 381
15.4.4　B-树的高度 382
15.4.5　B-树的搜索 382
15.4.6　B-树的插入 382
15.4.7　B-树的删除 384
15.4.8　节点结构 387
15.5　参考及推荐读物 389
第16章　图 390
16.1　基本概念 390
16.2　应用和更多的概念 391
16.3　特性 394
16.4　抽象数据类型graph 395
16.5　无权图的描述 396
16.5.1　邻接矩阵 396
16.5.2　邻接链表 397
16.5.3　邻接数组 398
16.6　加权图的描述 400
16.7　类实现 400
16.7.1　不同的类 400
16.7.2　邻接矩阵类 401
16.7.3　扩充chain类 405
16.7.4　链表类 405
16.8　图的遍历 407
16.8.1　广度优先搜索 407
16.8.2　广度优先搜索的实现 408
16.8.3　方法graph::bfs的复杂性分析 409
16.8.4　深度优先搜索 410
16.8.5　深度优先搜索的实现 411
16.8.6　方法graph::dfs的复杂性分析 412
16.9　应用 412
16.9.1　寻找一条路径 412
16.9.2　连通图及其构成 414
16.9.3　生成树 415
第三部分　算法设计方法
第17章　贪婪算法 420
17.1　最优化问题 420
17.2　贪婪算法思想 421
17.3　应用 424
17.3.1　货箱装载 424
17.3.2　0/1背包问题 425
17.3.3　拓扑排序 427
17.3.4　二分覆盖 430
17.3.5　单源最短路径 433
17.3.6　最小成本生成树 436
17.4　参考及推荐读物 445
第18章　分而治之 446
18.1　算法思想 446
18.2　应用 453
18.2.1　残缺棋盘 453
18.2.2　归并排序 455
18.2.3　快速排序 459
18.2.4　选择 464
18.2.5　相距最近的点对 466
18.3　解递归方程 474
18.4　复杂度的下限 475
18.4.1　最小最大问题的下限 476
18.4.2　排序算法的下限 477
第19章　动态规划 479
19.1　算法思想 479
19.2　应用 481
19.2.1　0/1背包问题 481
19.2.2　矩阵乘法链 484
19.2.3　所有顶点对之间的最短路径 489
19.2.4　带有负值的单源最短路径 492
19.2.5　网组的无交叉子集 496
19.3　参考及推荐读物 501
第20章　回溯法 502
20.1　算法思想 502
20.2　应用 506
20.2.1　货箱装载 506
20.2.2　0/1背包问题 512
20.2.3　最大完备子图 515
20.2.4　旅行商问题 517
20.2.5　电路板排列 519
第21章　分支定界 525
21.1　算法思想 525
21.2　应用 528
21.2.1　货箱装载 528
21.2.2　0/1背包问题 535
21.2.3　最大完备子图 536
21.2.4　旅行商问题 538
21.2.5　电路板排列 541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构、算法与应用（原书第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如果一切重来
1. 遇刺
2. 偶遇
3. 相约
4. 求婚
5. 美丽的女人
6. 逃避
7. 悔意
8. 一切重来
9. 漫长的一天
10. 着手调查
11. 遇袭
12. 绝望的母亲
13. 拉斐尔
14. 现场调查
15. 不堪回首的往事
16. 可疑的同事
17. 线人
18. 愤怒的读者
19. 阿根廷遇险
20. 秘密计划
21. 接近真相
22. 恐慌
23. 迟来的真相
24. 等待
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如果一切重来
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金赛性学报告
上部《男性性行为》
第一章 　 研究概况
第二章 　 少年性发育与性活动
第三章 　 性释放总论
第四章 　 年龄与性释放
第五章 　 青春期初始年龄与性释放
第六章 　 婚姻与性释放
第七章 　 社会地位与性释放
第八章 　 性模式的固化
第九章 　 宗教信仰与性释放
第十章 　 自慰
第十一章 　 异性爱抚
第十二章 　 婚前性交合
第十三章 　 婚内性交合
第十四章 　 婚外性交合
第十五章 　 与卖淫者的性交合
第十六章 　 同性性行为
下部《女性性行为》
第十七章 　 调查概况
第十八章 　 前青春期性发育
第十九章 　 自慰
第二十章 　 性梦
第二十一章 　 婚前亲昵爱抚
第二十二章 　 婚前性交合
第二十三章 　 婚内性交合
第二十四章 　 婚外性交合
第二十五章 　 同性性反应与性接触
第二十六章 　 与动物的性接触
第二十七章 　 性反应与性高潮的器官
第二十八章 　 性反应与性高潮的生理机制
第二十九章 　 性反应中的心理因素
附录　调查内容
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金赛性学报告
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>与拉玛相会
1．太空卫士计划
2．入侵者
3．拉玛与希塔
4．登陆拉玛
5．首次出舱
6．拉玛委员会
7．两个妻子
8．进入中轴区
9．勘察
10．深入黑暗
11．男人、女人与猴子
12．众神的阶梯
13．拉玛平原
14．暴风雨
15．柱面海边缘
16．克拉克卡海湾
17．春天
18．黎明
19．水星人的警告
20．启示录
21．暴风雨后
22．柱面海之旅
23．拉玛的纽约
24．“蜻蜓”号
25．第一次飞行
26．拉玛之声
27．电流风
28．伊卡洛斯
29．螃蟹
30．花
31．终极速度
32．海浪
33．蜘蛛
34．大使阁下深表歉意
35．快递
36．生物机器人总监察
37．导弹
38．星球联盟大会
39．船长的抉择
40．破坏
41．英雄
42．玻璃圣殿
43．撤退
44．宇宙推动力
45．凤凰涅槃
46．插曲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>与拉玛相会
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>直觉泵和其他思考工具
推荐序一 从流俗的看法中跳脱出来（陈嘉映）
推荐序二 哲学家的法宝 （万维钢）
推荐序三 这是真正的批判性思维训练营 （叶峰）
前 言 我要写一本人人都能读懂的书
引 言 什么是直觉泵
第一部分 通用思考工具
01 犯错儿—— 犯“好”错儿才有价值
02 归谬法——发现错误命题的妙招
03 拉波波特法则——批评他人的正确方式
04 史特金定律——不要把时间浪费在无意义的事情上
05 奥卡姆剃刀——如无必要，勿增实体
06 奥卡姆扫把——有意隐瞒对自己不利的证据
07 外行做媒——既不“过少解释”，又不“惹恼行家”
08 跳出系统——打破惯性思维的好方法
09 古尔德的 3 种思考工具——“不如说”“故意堆积”和“古尔德两步”
10 小心“当然”这个词 ——一种让你无需思考就认同的花招
11 反问——让你不好意思说“不”
12 什么是“深马”——爱就一个字
第一部分小结
第二部分 关于意义和内容的思考工具
13 特拉法尔加广场上的谋杀案——意义和内容都是我们大脑的“意向性”产物
14 生活在克利夫兰的一位兄长——一种观念只能生长在一堆观念之上
15 “爸爸是名医生”——理解是随着时间推移而逐渐清晰的
16 常识映像和科学映像——反映世界的两个不同视角
17 常识心理——人们无需正规教育就拥有的一种能力
18 意向立场——解释实体行为的一种策略
19 人与“次人”的区别——自上而下的认知能力分解
20 大脑中的小人儿委员会——认知科学的好理念
21 近似算子——达尔文渐进主义的启示
22 神奇组织——不要为逃避难题而求助于“魔法”
23 身陷机器人控制室——初长成的大脑不是一块“白板”
第三部分 关于计算机的思考工具
24 计算机施展魔法的7个秘密——部分之和大于总体的最好实例
25 虚拟机——模仿硬件运行的计算机程序
26 算法——有效解决问题的策略机制
27 让电梯实现自动控制——机器取代人类的逻辑
第三部分小结
第四部分 更多关于意义的思考工具
28 红发人那事儿——大脑中的认知机制
29 彷徨的双币机、孪生地球以及巨型机器人——原初意向性和派生意向性存在明显的边界吗
30 彻底翻译与蒯因式填字游戏——不存在绝对正确的翻译
31 语义引擎和句法引擎——大脑只是通过句法引擎模仿语义引擎
32 沼泽人遇上母牛鲨——哲学家最喜爱的直觉泵
33 两个黑盒子——究竟是什么让红灯闪烁
第四部分小结
第五部分 关于进化论的思考工具
第五部分小结
第六部分 关于意识的思考工具
第六部分小结
第七部分 关于自由意志的思考工具
第七部分小结
第八部分 做个哲学家是一种怎样的体验
结 语 加倍努力地使用这些工具吧
附录一 未写入本书正文中的几个直觉泵
附录二 寄存器机练习题的答案
素材来源
参考文献
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>直觉泵和其他思考工具
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>被弃的意象
目 录
中译本导言 001
序言 027
第一章　中世纪概况 029
第二章　补充说明 042
第三章　古典时期文献精选 050
第一节　《西庇阿之梦》 051
第二节　卢坎 058
第三节　斯塔提乌斯、克劳迪乌斯和“自然女神” 065
第四节　阿普列乌斯的《论苏格拉底之神》 073
第四章　酝酿时期文献精选 078
第一节　卡尔齐地乌斯 082
第二节　马克罗比乌斯 097
第三节　伪狄奥尼修斯 109
第四节　波埃修斯 116
第五章　诸天 139
第一节　宇宙的构成 139
第二节　诸天的运转 151
第三节　诸天的栖居者 165
第六章　长生灵 174
第七章　地球及其栖居者 196
第一节　地球 196
第二节　动物 205
第三节　人类的灵魂 213
第四节　理性魂 219
第五节　感觉魂和植物魂 225
第六节　灵魂与肉身 230
第七节　人类的肉身 235
第八节　人类的历史 240
第九节　博雅七艺 254
第八章　中世纪模型的影响 270
结语 290
索引 297
附：中世纪人的想象和思想 321
译后记 349
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>被弃的意象
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>操作系统导论
第1章 关于本书的对话	1
第2章 操作系统介绍	3
2.1 虚拟化CPU	4
2.2 虚拟化内存	6
2.3 并发	7
2.4 持久性	9
2.5 设计目标	11
2.6 简单历史	12
2.7 小结	15
参考资料	15
第1部分 虚拟化
第3章 关于虚拟化的对话	18
第4章 抽象：进程	19
4.1 抽象：进程	20
4.2 进程API	20
4.3 进程创建：更多细节	21
4.4 进程状态	22
4.5 数据结构	24
4.6 小结	25
参考资料	25
作业 26
问题 26
第5章 插叙：进程API	28
5.1 fork()系统调用	28
5.2 wait()系统调用	29
5.3 最后是exec()系统调用	30
5.4 为什么这样设计API	32
5.5 其他API	34
5.6 小结	34
参考资料	34
作业（编码）	35
问题 35
第6章 机制：受限直接执行	37
6.1 基本技巧：受限直接执行	37
6.2 问题1：受限制的操作	38
6.3 问题2：在进程之间切换	40
6.4 担心并发吗	44
6.5 小结	45
参考资料	45
作业（测量）	47
第7章 进程调度：介绍	48
7.1 工作负载假设	48
7.2 调度指标	49
7.3 先进先出（FIFO）	49
7.4 最短任务优先（SJF）	50
7.5 最短完成时间优先（STCF）	51
7.6 新度量指标：响应时间	52
7.7 轮转	52
7.8 结合I/O	54
7.9 无法预知	54
7.10 小结	55
参考资料	55
作业 56
问题 56
第8章 调度：多级反馈队列	57
8.1 MLFQ：基本规则	57
8.2 尝试 #1：如何改变优先级	58
8.3 尝试 #2：提升优先级	60
8.4 尝试 #3：更好的计时方式	61
8.5 MLFQ调优及其他问题 61
8.6 MLFQ：小结	62
参考资料	63
作业 64
问题 64
第9章 调度：比例份额	65
9.1 基本概念：彩票数表示份额	65
9.2 彩票机制	66
9.3 实现	67
9.4 一个例子	68
9.5 如何分配彩票	68
9.6 为什么不是确定的	69
9.7 小结	70
参考资料	70
作业 71
问题 71
第10章 多处理器调度（高级）	73
10.1 背景：多处理器架构	73
10.2 别忘了同步	75
10.3 最后一个问题：缓存亲和度	76
10.4 单队列调度	76
10.5 多队列调度	77
10.6 Linux 多处理器调度	79
10.7 小结	79
参考资料	79
第11章 关于CPU虚拟化的总结对话	81
第12章 关于内存虚拟化的对话	83
第13章 抽象：地址空间	85
13.1 早期系统	85
13.2 多道程序和时分共享	85
13.3 地址空间	86
13.4 目标	87
13.5 小结	89
参考资料	89
第14章 插叙：内存操作API	91
14.1 内存类型	91
14.2 malloc()调用	92
14.3 free()调用	93
14.4 常见错误	93
14.5 底层操作系统支持	96
14.6 其他调用	97
14.7 小结	97
参考资料	97
作业（编码）	98
问题 98
第15章 机制：地址转换	100
15.1 假设	101
15.2 一个例子	101
15.3 动态（基于硬件）重定位	103
15.4 硬件支持：总结	105
15.5 操作系统的问题 105
15.6 小结	108
参考资料	109
作业 110
问题 110
第16章 分段	111
16.1 分段：泛化的基址/界限	111
16.2 我们引用哪个段	113
16.3 栈怎么办	114
16.4 支持共享	114
16.5 细粒度与粗粒度的分段	115
16.6 操作系统支持	115
16.7 小结	117
参考资料	117
作业 118
问题 119
第17章 空闲空间管理	120
17.1 假设	120
17.2 底层机制	121
17.3 基本策略	126
17.4 其他方式	128
17.5 小结	130
参考资料	130
作业 131
问题 131
第18章 分页：介绍	132
18.1 一个简单例子	132
18.2 页表存在哪里	134
18.3 列表中究竟有什么	135
18.4 分页：也很慢	136
18.5 内存追踪	137
18.6 小结	139
参考资料	139
作业 140
问题 140
第19章 分页：快速地址转换（TLB）	142
19.1 TLB的基本算法	142
19.2 示例：访问数组	143
19.3 谁来处理TLB未命中	145
19.4 TLB的内容	146
19.5 上下文切换时对TLB的处理	147
19.6 TLB替换策略	149
19.7 实际系统的TLB表项	149
19.8 小结	150
参考资料	151
作业（测量）	152
问题 153
第20章 分页：较小的表	154
20.1 简单的解决方案：更大的页	154
20.2 混合方法：分页和分段	155
20.3 多级页表	157
20.4 反向页表	162
20.5 将页表交换到磁盘	163
20.6 小结	163
参考资料	163
作业 164
问题 164
第21章 超越物理内存：机制	165
21.1 交换空间	165
21.2 存在位	166
21.3 页错误	167
21.4 内存满了怎么办	168
21.5 页错误处理流程	168
21.6 交换何时真正发生	169
21.7 小结	170
参考资料	171
第22章 超越物理内存：策略	172
22.1 缓存管理	172
22.2 最优替换策略	173
22.3 简单策略：FIFO	175
22.4 另一简单策略：随机	176
22.5 利用历史数据：LRU	177
22.6 工作负载示例	178
22.7 实现基于历史信息的算法	180
22.8 近似LRU	181
22.9 考虑脏页	182
22.10 其他虚拟内存策略	182
22.11 抖动	183
22.12 小结	183
参考资料	183
作业 185
问题 185
第23章 VAX/VMS虚拟内存系统	186
23.1 背景	186
23.2 内存管理硬件	186
23.3 一个真实的地址空间	187
23.4 页替换	189
23.5 其他漂亮的虚拟内存技巧	190
23.6 小结	191
参考资料	191
第24章 内存虚拟化总结对话	193
第2部分 并发
第25章 关于并发的对话	196
第26章 并发：介绍	198
26.1 实例：线程创建	199
26.2 为什么更糟糕：共享数据	201
26.3 核心问题：不可控的调度	203
26.4 原子性愿望	205
26.5 还有一个问题：等待另一个
线程	206
26.6 小结：为什么操作系统课要研究
并发	207
参考资料	207
作业 208
问题 208
第27章 插叙：线程API	210
27.1 线程创建	210
27.2 线程完成	211
27.3 锁	214
27.4 条件变量	215
27.5 编译和运行	217
27.6 小结	217
参考资料	218
第28章 锁	219
28.1 锁的基本思想	219
28.2 Pthread锁	220
28.3 实现一个锁	220
28.4 评价锁	220
28.5 控制中断	221
28.6 测试并设置指令（原子交换）	222
28.7 实现可用的自旋锁	223
28.8 评价自旋锁	225
28.9 比较并交换	225
28.10 链接的加载和条件式存储指令	226
28.11 获取并增加	228
28.12 自旋过多：怎么办	229
28.13 简单方法：让出来吧，宝贝	229
28.14 使用队列：休眠替代自旋	230
28.15 不同操作系统，不同实现	232
28.16 两阶段锁	233
28.17 小结	233
参考资料	233
作业 235
问题 235
第29章 基于锁的并发数据结构	237
29.1 并发计数器	237
29.2 并发链表	241
29.3 并发队列	244
29.4 并发散列表	245
29.5 小结	246
参考资料	247
第30章 条件变量	249
30.1 定义和程序	250
30.2 生产者/消费者（有界缓冲区）
问题	252
30.3 覆盖条件	260
30.4 小结	261
参考资料	261
第31章 信号量	263
31.1 信号量的定义	263
31.2 二值信号量（锁）	264
31.3 信号量用作条件变量	266
31.4 生产者/消费者（有界缓冲区）
问题	268
31.5 读者—写者锁	271
31.6 哲学家就餐问题	273
31.7 如何实现信号量	275
31.8 小结	276
参考资料	276
第32章 常见并发问题	279
32.1 有哪些类型的缺陷	279
32.2 非死锁缺陷	280
32.3 死锁缺陷	282
32.4 小结	288
参考资料	289
第33章 基于事件的并发（进阶）	291
33.1 基本想法：事件循环	291
33.2 重要API：select()（或poll()）	292
33.3 使用select()	293
33.4 为何更简单？无须锁	294
33.5 一个问题：阻塞系统调用	294
33.6 解决方案：异步I/O	294
33.7 另一个问题：状态管理	296
33.8 什么事情仍然很难	297
33.9 小结	298
参考资料	298
第34章 并发的总结对话	300
第3部分 持久性
第35章 关于持久性的对话	302
第36章 I/O设备	303
36.1 系统架构	303
36.2 标准设备	304
36.3 标准协议	304
36.4 利用中断减少CPU开销	305
36.5 利用DMA进行更高效的数据
传送	306
36.6 设备交互的方法	307
36.7 纳入操作系统：设备驱动程序	307
36.8 案例研究：简单的IDE磁盘驱动
程序	309
36.9 历史记录	311
36.10 小结	311
参考资料	312
第37章 磁盘驱动器	314
37.1 接口	314
37.2 基本几何形状	314
37.3 简单的磁盘驱动器	315
37.4 I/O时间：用数学	318
37.5 磁盘调度	320
37.6 小结	323
参考资料	323
作业 324
问题 324
第38章 廉价冗余磁盘阵列（RAID）	326
38.1 接口和RAID内部	327
38.2 故障模型	327
38.3 如何评估RAID	328
38.4 RAID 0级：条带化	328
38.5 RAID 1级：镜像	331
38.6 RAID 4级：通过奇偶校验节省
空间	333
38.7 RAID 5级：旋转奇偶校验	336
38.8 RAID比较：总结	337
38.9 其他有趣的RAID问题	338
38.10 小结	338
参考资料	339
作业 340
问题 340
第39章 插叙：文件和目录	342
39.1 文件和目录	342
39.2 文件系统接口	343
39.3 创建文件	343
39.4 读写文件	344
39.5 读取和写入，但不按顺序	346
39.6 用fsync()立即写入	346
39.7 文件重命名	347
39.8 获取文件信息	348
39.9 删除文件	349
39.10 创建目录	349
39.11 读取目录	350
39.12 删除目录	351
39.13 硬链接	351
39.14 符号链接	353
39.15 创建并挂载文件系统	354
39.16 总结	355
参考资料	355
作业 356
问题 356
第40章 文件系统实现	357
40.1 思考方式	357
40.2 整体组织	358
40.3 文件组织：inode	359
40.4 目录组织	363
40.5 空闲空间管理	364
40.6 访问路径：读取和写入	364
40.7 缓存和缓冲	367
40.8 小结	369
参考资料	369
作业 370
问题 371
第41章 局部性和快速文件系统	372
41.1 问题：性能不佳	372
41.2 FFS：磁盘意识是解决方案	373
41.3 组织结构：柱面组	373
41.4 策略：如何分配文件和目录	374
41.5 测量文件的局部性	375
41.6 大文件例外	376
41.7 关于FFS的其他几件事	377
41.8 小结	378
参考资料	378
第42章 崩溃一致性：FSCK和日志	380
42.1 一个详细的例子	380
42.2 解决方案＃1：文件系统检查
程序	383
42.3 解决方案＃2：日志
（或预写日志）	384
42.4 解决方案＃3：其他方法	392
42.5 小结	393
参考资料	393
第43章 日志结构文件系统	395
43.1 按顺序写入磁盘	396
43.2 顺序而高效地写入	396
43.3 要缓冲多少	397
43.4 问题：查找inode	398
43.5 通过间接解决方案：inode映射	398
43.6 检查点区域	399
43.7 从磁盘读取文件：回顾	400
43.8 目录如何	400
43.9 一个新问题：垃圾收集	401
43.10 确定块的死活	402
43.11 策略问题：要清理哪些块，
何时清理	403
43.12 崩溃恢复和日志	403
43.13 小结	404
参考资料	404
第44章 数据完整性和保护	407
44.1 磁盘故障模式	407
44.2 处理潜在的扇区错误	409
44.3 检测讹误：校验和	409
44.4 使用校验和	412
44.5 一个新问题：错误的写入	412
44.6 最后一个问题：丢失的写入	413
44.7 擦净	413
44.8 校验和的开销	414
44.9 小结	414
参考资料	414
第45章 关于持久的总结对话	417
第46章 关于分布式的对话	418
第47章 分布式系统	419
47.1 通信基础	420
47.2 不可靠的通信层	420
47.3 可靠的通信层	422
47.4 通信抽象	424
47.5 远程过程调用（RPC）	425
47.6 小结	428
参考资料	429
第48章 Sun的网络文件系统（NFS）	430
48.1 基本分布式文件系统	430
48.2 交出NFS	431
48.3 关注点：简单快速的服务器崩溃
恢复	431
48.4 快速崩溃恢复的关键：无状态	432
48.5 NFSv2协议	433
48.6 从协议到分布式文件系统	434
48.7 利用幂等操作处理服务器故障	435
48.8 提高性能：客户端缓存	437
48.9 缓存一致性问题	437
48.10 评估NFS的缓存一致性	439
48.11 服务器端写缓冲的隐含意义	439
48.12 小结	440
参考资料	440
第49章 Andrew文件系统（AFS）	442
49.1 AFS版本1	442
49.2 版本1的问题	443
49.3 改进协议	444
49.4 AFS版本2	444
49.5 缓存一致性	446
49.6 崩溃恢复	447
49.7 AFSv2的扩展性和性能	448
49.8 AFS：其他改进	450
49.9 小结	450
参考资料	451
作业 452
问题 452
第50章 关于分布式的总结对话	453
附录A 关于虚拟机监视器的对话	454
附录B 虚拟机监视器	455
附录C 关于监视器的对话	466
附录D 关于实验室的对话	467
附录E 实验室：指南	468
附录F 实验室：系统项目	478
附录G 实验室：xv6项目	480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>操作系统导论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective C++
译序
中英简繁术语对照
目录
序言
致谢
导读
1. 让自己习惯c++
2. 构造/析构/赋值运算
3. 资源管理
4. 设计与声明
5. 实现
6. 继承与面向对象设计
7. 模板与泛型编程
8. 定制new和delete
9. 杂项讨论
a 本书之外
b 新旧版条款对照
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective C++
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>小说鉴赏（双语修订第3版）
审阅者序  曹文轩	  1
译  者  序  李文俊	4
原序  主 万 译	6
Preface
第一章小说的意图与要素主 万 译	1
Intentions and Elements of Fiction
001.进攻堡垒 （美）弗朗西斯•帕克曼 著主 万 译	4
The Attack on the Fort  by Francis Parkman
002.艾赛亚•塞勒斯船长 （美）马克•吐温  著主 万 译	7
Captain Isaiah Sellers  by Mark Twain
003.格拉米格纳的情人 （意）乔万尼•维尔加 著姚梅琪 译	12
Gramigna's Lover  by Giovanni Verga
004.沃尔特•米蒂的隐秘生活 （美）詹姆斯•瑟伯 著冯亦代 译	21
The Secret Life of Walter Mitty  by James Thurber
005.年轻的布朗大爷 （美）纳撒尼尔•霍桑 著主 万 译	30
Young Goodman Brown  by Nathaniel Hawthorne
第二章情节潘庆舲 译	47
What Plot Reveals
006.带家具出租的房间 （美）欧•亨利 著刘文荣 译	59
The Furnished Room  by O.Henry
007.万卡 （俄）安东•契诃夫 著汝 龙 译	71
Vanka  by Anton Chekhov
008.埋葬 （英）约翰•科利尔 著潘庆舲 译	76
De Mortuis  by John Collier
009.鹰溪桥上 （美）安布鲁斯•比尔斯 著江锡祥 纪 锋 译	85
An Occurrence at Owl Creek Bridge  by Ambrose Bierce
010.进入波兰 （俄）艾萨克•巴贝尔 著潘庆舲 译	95
Crossing into Poland  by Isaac Babel
011.项链 （法）盖伊•德•莫泊桑 著郑克鲁 译	98
The Necklace  by Guy de Maupassant
012.战争 （意）路易吉•皮兰德娄 著潘庆舲 译	109
War  by Luigi Pirandello
013.国王迷 （英）路德亚德•吉卜林 著潘庆舲 译	118
The Man Who Would Be King  by Rudyard Kipling
第三章人物性格王秋荣 译	159
What Character Reveals
014.田纳西的伙伴 （美）布雷特•哈特 著主 万 译	168
Tennessee's Partner  by Bret Harte
015.阿拉比 （爱尔兰）詹姆斯•乔伊斯 著宗 白 译	182
Araby  by James Joyce
016.县城的医生 （俄）伊凡•屠格涅夫 著丰子恺 译	193
The District Doctor  by Ivan Turgenev
017.侨民 （美）卡森•麦卡勒斯 著彭嘉林 译	203
The Sojourner  by Carson McCullers
018.醉汉 （爱尔兰）弗兰克•奥康纳 著彭嘉林 译	213
The Drunkard  by Frank O'Connor
019.请买票 （英）D.H.劳伦斯 著邢 历 译	224
Tickets,Please  by D.H.Lawrence
020.理发 （美）林•拉德纳 著雨 宁 译	240
Haircut  by Ring Lardner
第四章主题刘文荣 译	259
What Theme Reveals
021.爱情：某猎人笔记上的三页 （法）盖伊•德•莫泊桑 著刘家有 译	267
Love:Three Pages from a Sportsman's Book  by Guy de Maupassant
022.爱情 （美）杰西•斯图尔特 著刘家有 译	272
Love  by Jesse Stuart
023.杀手 （美）厄内斯特•海明威 著海 观 译	276
The Killers  by Ernest Hemingway
024.林中之死 （美）舍伍德•安德森 著刘文荣 译	298
Death in the Woods  by Sherwood Anderson
025.人，差点儿 （美）理查德•赖特 著刘家有 译	310
The Man Who Was Almost a Man  by Richard Wright
026.纪念爱米丽的一朵玫瑰花 （美）威廉•福克纳 著杨岂深 译	324
A Rose for Emily  by William Faulkner
027.好人难寻 （美）弗兰纳里•奥康纳 著屠 珍 译	339
A Good Man Is Hard to Find  by Flannery O'Connor
第五章新小说刘文荣 译	355
The New Fiction
028.花园余影 （阿根廷）胡里奥•科塔萨尔 著刘文荣 译	360
Continuity of Parks  by Julio Cortzar
029.相遇 （阿根廷）乔治•路易斯•博尔赫斯 著刘文荣 译 	364
The Meeting  by Jorge Luis Borges
030.密室 （法）阿兰•罗布-格里耶 著刘文荣 译 	371
The Secret Room  by Alain Robbe-Grillet
031.二十九条臆想 （美）乔伊斯•卡罗尔•欧茨 著蓝仁哲 译 	378
29 Inventions  by Joyce Carol Oates
032.爱玛琴的手 （美）彼得•泰勒 著刘文荣 译 	395
The Hand of Emmagene  by Peter Taylor
033.气球 （美）唐纳德•巴塞尔姆 著刘文荣 译 	416
The Balloon  by Donald Barthelme
第六章小说与人生经验刘文荣 译	425
Fiction and Human Experience
034.没有你的位置，我的爱 （美）尤多拉•韦尔蒂 著刘文荣 译 	433
No Place for You,My Love  by Eudora Welty
035.我怎样写作？ （美）尤多拉•韦尔蒂 著刘文荣 译 	451
How I Write  by Eudora Welty
036.中午酒 （美）凯瑟琳•安•波特 著李文俊 译 	462
Noon Wine  by Katherine Anne Porter
037.《中午酒》的源流 （美）凯瑟琳•安•波特 著刘文荣 译 	505
“Noon Wine”:The Sources  by Katherine Anne Porter
038.春寒 （美）罗伯特•潘•沃伦 著郑启吟 译 	519
Blackberry Winter  by Robert Penn Warren
039.《春寒》：一段回忆 （美）罗伯特•潘•沃伦 著刘文荣 译 	539
“Blackberry Winter”:A Recollection  by Robert Penn Warren
第七章阅读材料雨 宁 译	547
Stories for Reading
040.芙恩 （美）吉恩•图默 著雨 宁 译 	549
Fern  by Jean Toomer
041.拳击大赛 （美）拉尔夫•艾利森 著雨 宁 译 	554
The Battle Royal  by Ralph Ellison
042.远和近 （美）托马斯•沃尔夫 著万 紫 译 	569
The Far and the Near  by Thomas Wolfe
043.狗 （法）科莱特 著 万 紫 译 	572
The Bitch  by Colette
044.魔桶 （美）伯纳德•马拉默德 著董衡巽 译 	576
The Magic Barrel  by Bernard Malamud
045.戴米舍 （法）马瑟尔•埃梅 著万 紫 译 	591
Dermuche  by Marcel Aym
046.黑圣母 （英）多丽丝•莱辛 著万 紫 译 	598
The Black Madonna  by Doris Lessing
047.A和P （美）约翰•厄普代克 著雨 宁 译 	611
A & P  by John Updike
048.伊凡•伊里奇之死 （俄）列夫•托尔斯泰 著草 婴 译 	618
The Death of Ivan Ilych  by Leo Tolstoi
049.新娘来到黄天镇 （美）斯蒂芬•克莱恩 著万 紫 译 	662
The Bride Comes to Yellow Sky   by Stephen Crane
050.冬梦 （美）弗•司各特•菲兹杰拉德 著雨 宁 译 	672
Winter Dreams   by F.Scott Fitzgerald
051.岩石 （美）詹姆斯•鲍德温 著万 紫 译 	694
The Rockpile   by James Baldwin
重要词汇  马 昕 译	702
Glossary
出版后记	711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>小说鉴赏（双语修订第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>神祇、陵墓与学者
导言
这本书讲什么
第一部  雕像之书
第1章  在古典文化诞生之地奏响序曲
第2章  温克尔曼一门新学科的诞生
第3章  历史的追踪者
第4章  穷小子发现宝藏的童话
第5章  阿伽门农的面具
第6章  施里曼与科学
第7章  迈锡尼、梯林斯和神秘岛
第8章  阿里阿德涅线团
第二部  金字塔之书
第9章  转败为胜
第10章  商博良与罗塞塔碑
第11章  叛国者破解埃及象形文字
第12章  “四千年的历史在俯视着你们！”
第13章  皮特里与阿蒙涅姆赫特之墓
第14章  “帝王谷”中的盗墓贼
第15章  木乃伊
第16章  霍华德·卡特发现图坦卡蒙
第17章  金质墙
第三部  庙塔之书
第18章  《圣经》上的记载
第19章  博塔发现尼尼微
第20章  破译楔形文字
第21章  用实例检验
第22章  尼姆鲁德土丘下的宫殿
第23章  乔治·史密斯大海捞针
第24章  子弹绕着科尔德维飞
第25章  埃特曼安吉——巴别塔
第26章  千年王室和大洪水
第四部  阶梯之书
第27章  蒙特祖马二世的宝藏
第28章  被斩首的文明
第29章  斯蒂芬斯先生买下一座城市
第30章  插曲
第31章  弃城之谜
第32章  通往圣井之路
第33章  森林和熔岩下的梯遒
第五部  尚未写就之书
第34章  古老帝国新探
附录
年表
参考文献
地图
特别致谢
策拉姆自传
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>神祇、陵墓与学者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ 程序设计语言（第 1 - 3 部分）（原书第 4 版）
出版者的话
译者序
前言
第3版前言
第2版前言
第1版前言
第一部分　引言
第1章　致读者 2
1.1　本书结构 2
1.1.1　引言 2
1.1.2　基本特性 3
1.1.3　抽象机制 4
1.1.4　标准库 5
1.1.5　例子和参考文献 5
1.2　C++的设计 7
1.2.1　程序设计风格 8
1.2.2　类型检查 11
1.2.3　C兼容性 12
1.2.4　语言、库和系统 12
1.3　学习C++ 14
1.3.1　用C++编程 15
1.3.2　对C++程序员的建议 16
1.3.3　对C程序员的建议 16
1.3.4　对Java程序员的建议 17
1.4　C++的历史 18
1.4.1　大事年表 19
1.4.2　早期的C++ 19
1.4.3　1998标准 21
1.4.4　2011标准 23
1.4.5　C++的用途 26
1.5　建议 27
1.6　参考文献 28
第2章　C++概览：基础知识 32
2.1　引言 32
2.2　基本概念 33
2.2.1　Hello，World! 33
2.2.2　类型、变量和算术运算 34
2.2.3　常量 36
2.2.4　检验和循环 37
2.2.5　指针、数组和循环 38
2.3　用户自定义类型 40
2.3.1　结构 41
2.3.2　类 42
2.3.3　枚举 43
2.4　模块化 44
2.4.1　分离编译 45
2.4.2　名字空间 46
2.4.3　错误处理 47
2.5　附记 50
2.6　建议 50
第3章　C++概览：抽象机制 51
3.1　引言 51
3.2　类 51
3.2.1　具体类型 52
3.2.2　抽象类型 56
3.2.3　虚函数 58
3.2.4　类层次 59
3.3　拷贝和移动 62
3.3.1　拷贝容器 63
3.3.2　移动容器 64
3.3.3　资源管理 66
3.3.4　抑制操作 66
3.4　模板 67
3.4.1　参数化类型 67
3.4.2　函数模板 69
3.4.3　函数对象 69
3.4.4　可变参数模板 71
3.4.5　别名 72
3.5　建议 73
第4章　C++概览：容器与算法 74
4.1　标准库 74
4.1.1　标准库概述 75
4.1.2　标准库头文件与名字空间 75
4.2　字符串 77
4.3　I/O流 78
4.3.1　输出 78
4.3.2　输入 79
4.3.3　用户自定义类型的I/O 80
4.4　容器 81
4.4.1　vector 81
4.4.2　list 84
4.4.3　map 85
4.4.4　unordered_map 86
4.4.5　容器概述 86
4.5　算法 87
4.5.1　使用迭代器 88
4.5.2　迭代器类型 90
4.5.3　流迭代器 91
4.5.4　谓词 93
4.5.5　算法概述 93
4.5.6　容器算法 94
4.6　建议 94
第5章　C++概览：并发与实用功能 96
5.1　引言 96
5.2　资源管理 96
5.2.1　unique_ptr与shared_ptr 97
5.3　并发 99
5.3.1　任务和thread 99
5.3.2　传递参数 100
5.3.3　返回结果 100
5.3.4　共享数据 101
5.3.5　任务通信 103
5.4　小工具组件 106
5.4.1　时间 106
5.4.2　类型函数 107
5.4.3　pair和tuple 109
5.5　正则表达式 110
5.6　数学计算 111
5.6.1　数学函数和算法 111
5.6.2　复数 111
5.6.3　随机数 112
5.6.4　向量算术 113
5.6.5　数值限制 113
5.7　建议 114
第二部分　基本功能
第6章　类型与声明 116
6.1　ISO C++标准 116
6.1.1　实现 117
6.1.2　基本源程序字符集 118
6.2　类型 118
6.2.1　基本类型 119
6.2.2　布尔值 119
6.2.3　字符类型 121
6.2.4　整数类型 124
6.2.5　浮点数类型 126
6.2.6　前缀和后缀 127
6.2.7　void 128
6.2.8　类型尺寸 128
6.2.9　对齐 130
6.3　声明 131
6.3.1　声明的结构 133
6.3.2　声明多个名字 134
6.3.3　名字 134
6.3.4　作用域 136
6.3.5　初始化 138
6.3.6　推断类型：auto和decltype() 141
6.4　对象和值 144
6.4.1　左值和右值 144
6.4.2　对象的生命周期 145
6.5　类型别名 146
6.6　建议 147
第7章　指针、数组与引用 148
7.1　引言 148
7.2　指针 148
7.2.1　void* 149
7.2.2　nullptr 150
7.3　数组 150
7.3.1　数组的初始化器 152
7.3.2　字符串字面值常量 152
7.4　数组中的指针 155
7.4.1　数组漫游 156
7.4.2　多维数组 158
7.4.3　传递数组 159
7.5　指针与const 161
7.6　指针与所有权 163
7.7　引用 163
7.7.1　左值引用 164
7.7.2　右值引用 167
7.7.3　引用的引用 169
7.7.4　指针与引用 170
7.8　建议 172
第8章　结构、联合与枚举 173
8.1　引言 173
8.2　结构 173
8.2.1　struct的布局 175
8.2.2　struct的名字 176
8.2.3　结构与类 177
8.2.4　结构与数组 178
8.2.5　类型等价 180
8.2.6　普通旧数据 180
8.2.7　域 182
8.3　联合 183
8.3.1　联合与类 185
8.3.2　匿名 186
8.4　枚举 188
8.4.1　enum class 188
8.4.2　普通的enum 191
8.4.3　未命名的enum 192
8.5　建议 193
第9章　语句 194
9.1　引言 194
9.2　语句概述 194
9.3　声明作为语句 195
9.4　选择语句 196
9.4.1　if语句 196
9.4.2　switch语句 198
9.4.3　条件中的声明 200
9.5　循环语句 201
9.5.1　范围for语句 201
9.5.2　for语句 202
9.5.3　while语句 203
9.5.4　do语句 203
9.5.5　退出循环 204
9.6　goto语句 204
9.7　注释与缩进 205
9.8　建议 207
第10章　表达式 208
10.1　引言 208
10.2　一个桌面计算器示例 208
10.2.1　分析器 209
10.2.2　输入 213
10.2.3　底层输入 216
10.2.4　错误处理 217
10.2.5　驱动程序 217
10.2.6　头文件 218
10.2.7　命令行参数 218
10.2.8　关于风格 220
10.3　运算符概述 220
10.3.1　结果 224
10.3.2　求值顺序 224
10.3.3　运算符优先级 225
10.3.4　临时对象 226
10.4　常量表达式 227
10.4.1　符号化常量 229
10.4.2　常量表达式中的const 229
10.4.3　字面值常量类型 229
10.4.4　引用参数 230
10.4.5　地址常量表达式 231
10.5　隐式类型转换 231
10.5.1　提升 231
10.5.2　类型转换 232
10.5.3　常用的算术类型转换 234
10.6　建议 235
第11章　选择适当的操作 236
11.1　其他运算符 236
11.1.1　逻辑运算符 236
11.1.2　位逻辑运算符 236
11.1.3　条件表达式 238
11.1.4　递增与递减 238
11.2　自由存储 240
11.2.1　内存管理 241
11.2.2　数组 243
11.2.3　获取内存空间 244
11.2.4　重载new 245
11.3　列表 247
11.3.1　实现模型 248
11.3.2　限定列表 249
11.3.3　未限定列表 249
11.4　lambda表达式 251
11.4.1　实现模型 251
11.4.2　lambda的替代品 252
11.4.3　捕获 254
11.4.4　调用与返回 257
11.4.5　lambda的类型 257
11.5　显式类型转换 258
11.5.1　构造 259
11.5.2　命名转换 261
11.5.3　C风格的转换 262
11.5.4　函数形式的转换 262
11.6　建议 263
第12章　函数 264
12.1　函数声明 264
12.1.1　为什么使用函数 265
12.1.2　函数声明的组成要件 265
12.1.3　函数定义 266
12.1.4　返回值 267
12.1.5　inline函数 269
12.1.6　constexpr函数 269
12.1.7　[[noreturn]]函数 271
12.1.8　局部变量 272
12.2　参数传递 273
12.2.1　引用参数 273
12.2.2　数组参数 275
12.2.3　列表参数 277
12.2.4　数量未定的参数 278
12.2.5　默认参数 281
12.3　重载函数 282
12.3.1　自动重载解析 283
12.3.2　重载与返回类型 284
12.3.3　重载与作用域 285
12.3.4　多实参解析 285
12.3.5　手动重载解析 286
12.4　前置与后置条件 286
12.5　函数指针 288
12.6　宏 292
12.6.1　条件编译 294
12.6.2　预定义宏 295
12.6.3　编译指令 296
12.7　建议 296
第13章　异常处理 297
13.1　错误处理 297
13.1.1　异常 298
13.1.2　传统的错误处理 299
13.1.3　渐进决策 300
13.1.4　另一种视角看异常 301
13.1.5　何时不应使用异常 302
13.1.6　层次化错误处理 303
13.1.7　异常与效率 304
13.2　异常保障 305
13.3　资源管理 307
13.3.1　finally 310
13.4　强制不变式 311
13.5　抛出与捕获异常 315
13.5.1　抛出异常 315
13.5.2　捕获异常 318
13.5.3　异常与线程 324
13.6　vector的实现 324
13.6.1　一个简单的vector 325
13.6.2　显式地表示内存 328
13.6.3　赋值 331
13.6.4　改变尺寸 332
13.7　建议 335
第14章　名字空间 337
14.1　组合问题 337
14.2　名字空间 338
14.2.1　显式限定 339
14.2.2　using声明 340
14.2.3　using指示 341
14.2.4　参数依赖查找 342
14.2.5　名字空间是开放的 344
14.3　模块化和接口 345
14.3.1　名字空间作为模块 346
14.3.2　实现 348
14.3.3　接口和名字 349
14.4　组合使用名字空间 351
14.4.1　便利性与安全性 351
14.4.2　名字空间别名 352
14.4.3　组合名字空间 352
14.4.4　组合与选择 353
14.4.5　名字空间和重载 354
14.4.6　版本控制 356
14.4.7　名字空间嵌套 358
14.4.8　无名名字空间 359
14.4.9　C头文件 359
14.5　建议 360
第15章　源文件与程序 362
15.1　分离编译 362
15.2　链接 363
15.2.1　文件内名字 365
15.2.2　头文件 366
15.2.3　单一定义规则 368
15.2.4　标准库头文件 369
15.2.5　链接非C++代码 370
15.2.6　链接和函数指针 372
15.3　使用头文件 373
15.3.1　单头文件组织 373
15.3.2　多头文件组织 376
15.3.3　包含保护 380
15.4　程序 381
15.4.1　非局部变量初始化 381
15.4.2　初始化和并发 382
15.4.3　程序终止 383
15.5　建议 384
第三部分　抽象机制
第16章　类 386
16.1　引言 386
16.2　类基础 387
16.2.1　成员函数 388
16.2.2　默认拷贝 389
16.2.3　访问控制 389
16.2.4　class和struct 390
16.2.5　构造函数 391
16.2.6　explicit构造函数 393
16.2.7　类内初始化器 395
16.2.8　类内函数定义 395
16.2.9　可变性 396
16.2.10　自引用 399
16.2.11　成员访问 400
16.2.12　static成员 401
16.2.13　成员类型 403
16.3　具体类 403
16.3.1　成员函数 406
16.3.2　辅助函数 408
16.3.3　重载运算符 410
16.3.4　具体类的重要性 410
16.4　建议 411
第17章　构造、清理、拷贝和移动 413
17.1　引言 413
17.2　构造函数和析构函数 415
17.2.1　构造函数和不变式 415
17.2.2　析构函数和资源 416
17.2.3　基类和成员析构函数 417
17.2.4　调用构造函数和析构函数 418
17.2.5　virtual析构函数 419
17.3　类对象初始化 420
17.3.1　不使用构造函数进行初始化 420
17.3.2　使用构造函数进行初始化 421
17.3.3　默认构造函数 424
17.3.4　初始化器列表构造函数 425
17.4　成员和基类初始化 429
17.4.1　成员初始化 429
17.4.2　基类初始化器 431
17.4.3　委托构造函数 431
17.4.4　类内初始化器 432
17.4.5　static成员初始化 434
17.5　拷贝和移动 435
17.5.1　拷贝 435
17.5.2　移动 441
17.6　生成默认操作 444
17.6.1　显式声明默认操作 444
17.6.2　默认操作 445
17.6.3　使用默认操作 446
17.6.4　使用delete删除的函数 449
17.7　建议 451
第18章　运算符重载 452
18.1　引言 452
18.2　运算符函数 453
18.2.1　二元和一元运算符 454
18.2.2　运算符的预置含义 455
18.2.3　运算符与用户自定义类型 456
18.2.4　传递对象 456
18.2.5　名字空间中的运算符 457
18.3　复数类型 459
18.3.1　成员和非成员运算符 459
18.3.2　混合模式运算 460
18.3.3　类型转换 461
18.3.4　字面值常量 463
18.3.5　访问函数 464
18.3.6　辅助函数 465
18.4　类型转换 466
18.4.1　类型转换运算符 466
18.4.2　explicit类型转换运算符 467
18.4.3　二义性 468
18.5　建议 469
第19章　特殊运算符 471
19.1　引言 471
19.2　特殊运算符 471
19.2.1　取下标 471
19.2.2　函数调用 472
19.2.3　解引用 473
19.2.4　递增和递减 475
19.2.5　分配和释放 477
19.2.6　用户自定义字面值常量 478
19.3　字符串类 481
19.3.1　必备操作 481
19.3.2　访问字符 482
19.3.3　类的表示 483
19.3.4　成员函数 485
19.3.5　辅助函数 487
19.3.6　应用String 489
19.4　友元 490
19.4.1　发现友元 491
19.4.2　友元与成员 492
19.5　建议 493
第20章　派生类 495
20.1　引言 495
20.2　派生类 496
20.2.1　成员函数 498
20.2.2　构造函数和析构函数 499
20.3　类层次 500
20.3.1　类型域 500
20.3.2　虚函数 502
20.3.3　显式限定 504
20.3.4　覆盖控制 505
20.3.5　using基类成员 508
20.3.6　返回类型放松 511
20.4　抽象类 512
20.5　访问控制 514
20.5.1　protected成员 517
20.5.2　访问基类 518
20.5.3　using声明与访问控制 519
20.6　成员指针 520
20.6.1　函数成员指针 520
20.6.2　数据成员指针 522
20.6.3　基类和派生类成员 523
20.7　建议 523
第21章　类层次 524
21.1　引言 524
21.2　设计类层次 524
21.2.1　实现继承 525
21.2.2　接口继承 527
21.2.3　替代实现方式 529
21.2.4　定位对象创建 532
21.3　多重继承 533
21.3.1　多重接口 533
21.3.2　多重实现类 533
21.3.3　二义性解析 535
21.3.4　重复使用基类 538
21.3.5　虚基类 539
21.3.6　重复基类与虚基类 544
21.4　建议 546
第22章　运行时类型信息 547
22.1　引言 547
22.2　类层次导航 547
22.2.1　dynamic_cast 548
22.2.2　多重继承 551
22.2.3　static_cast和dynamic_cast 552
22.2.4　恢复接口 553
22.3　双重分发和访客 557
22.3.1　双重分发 557
22.3.2　访客 559
22.4　构造和析构 561
22.5　类型识别 561
22.5.1　扩展类型信息 563
22.6　RTTI的使用和误用 564
22.7　建议 565
第23章　模板 566
23.1　引言和概述 566
23.2　一个简单的字符串模板 568
23.2.1　定义模板 569
23.2.2　模板实例化 571
23.3　类型检查 571
23.3.1　类型等价 572
23.3.2　错误检测 573
23.4　类模板成员 574
23.4.1　数据成员 574
23.4.2　成员函数 575
23.4.3　成员类型别名 575
23.4.4　static成员 575
23.4.5　成员类型 576
23.4.6　成员模板 577
23.4.7　友元 580
23.5　函数模板 582
23.5.1　函数模板实参 583
23.5.2　函数模板实参推断 584
23.5.3　函数模板重载 586
23.6　模板别名 590
23.7　源码组织 591
23.7.1　链接 593
23.8　建议 594
第24章　泛型程序设计 595
24.1　引言 595
24.2　算法和提升 596
24.3　概念 599
24.3.1　发现概念 599
24.3.2　概念和约束 602
24.4　具体化概念 604
24.4.1　公理 607
24.4.2　多实参概念 607
24.4.3　值概念 608
24.4.4　约束检查 609
24.4.5　模板定义检查 610
24.5　建议 612
第25章　特例化 613
25.1　引言 613
25.2　模板参数和实参 614
25.2.1　类型作为实参 614
25.2.2　值作为实参 615
25.2.3　操作作为实参 616
25.2.4　模板作为实参 618
25.2.5　默认模板实参 619
25.3　特例化 621
25.3.1　接口特例化 623
25.3.2　主模板 624
25.3.3　特例化顺序 625
25.3.4　函数模板特例化 626
25.4　建议 628
第26章　实例化 629
26.1　引言 629
26.2　模板实例化 630
26.2.1　何时需要实例化 630
26.2.2　手工控制实例化 631
26.3　名字绑定 632
26.3.1　依赖性名字 633
26.3.2　定义点绑定 635
26.3.3　实例化点绑定 636
26.3.4　多实例化点 638
26.3.5　模板和名字空间 639
26.3.6　过于激进的ADL 639
26.3.7　来自基类的名字 641
26.4　建议 643
第27章　模板和类层次 645
27.1　引言 645
27.2　参数化和类层次 646
27.2.1　生成类型 647
27.2.2　模板类型转换 649
27.3　类模板层次 650
27.3.1　模板作为接口 651
27.4　模板参数作为基类 652
27.4.1　组合数据结构 652
27.4.2　线性化类层次 655
27.5　建议 660
第28章　元编程 661
28.1　引言 661
28.2　类型函数 663
28.2.1　类型别名 665
28.2.2　类型谓词 666
28.2.3　选择函数 668
28.2.4　萃取 668
28.3　控制结构 670
28.3.1　选择 670
28.3.2　迭代和递归 673
28.3.3　何时使用元编程 674
28.4　条件定义：Enable_if 675
28.4.1　使用Enable_if 676
28.4.2　实现Enable_if 678
28.4.3　Enable_if与概念 678
28.4.4　更多Enable_if例子 679
28.5　一个编译时列表：Tuple 681
28.5.1　一个简单的输出函数 683
28.5.2　元素访问 684
28.5.3　make_tuple 686
28.6　可变参数模板 686
28.6.1　一个类型安全的printf() 687
28.6.2　技术细节 689
28.6.3　转发 691
28.6.4　标准库tuple 692
28.7　国际标准单位例子 694
28.7.1　Unit 695
28.7.2　Quantity 696
28.7.3　Unit字面值常量 697
28.7.4　工具函数 698
28.8　建议 700
第29章　一个矩阵设计 701
29.1　引言 701
29.1.1　Matrix的基本使用 701
29.1.2　对Matrix的要求 703
29.2　Matrix模板 704
29.2.1　构造和赋值 705
29.2.2　下标和切片 706
29.3　Matrix算术运算 708
29.3.1　标量运算 709
29.3.2　加法 710
29.3.3　乘法 711
29.4　Matrix实现 712
29.4.1　slice() 713
29.4.2　Matrix切片 713
29.4.3　Matrix_ref 714
29.4.4　Matrix列表初始化 715
29.4.5　Matrix访问 717
29.4.6　零维Matrix 719
29.5　求解线性方程组 720
29.5.1　经典高斯消去法 721
29.5.2　旋转 722
29.5.3　测试 723
29.5.4　熔合运算 723
29.6　建议 725
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ 程序设计语言（第 1 - 3 部分）（原书第 4 版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>邓普顿教你逆向投资
《邓普顿教你逆向投资:牛市和熊市都稳赚的长赢投资法》作者劳伦•邓普顿，约翰•邓普顿的侄孙女，约翰•邓普顿爵士，一位具有传奇色彩的基金经理，被美国《Money》杂志誉为“本世纪最伟大的选股人”，并被尊奉为全球顶尖价值投资人。他开创了全球投资的先河，在长达50年的股市上叱咤风云，表现出色。以前所未有的视角，揭开了邓普顿爵士的投资之谜——通过讲述他辉煌投资生涯中一些可圈可点的成功战绩，如第一个发现战后日本股票的投资前景，在日本经济起飞中获益良多；又如在20世纪70年代末的市场低迷中伺机买入，在后市中收益颇丰——，阐释了他著名的“最大悲观点”理论的基本原理，让我们得以一窥约翰爵士那长盛不衰的投资原则和方法。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>邓普顿教你逆向投资
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力精英
总序
致谢
第一章 上流阶层
第二章 地方社会
第三章 大都会四百强
第四章 名流显贵
第五章 大富翁
第六章 行政长官
第七章 公司富豪
第八章 军界领袖
第九章 军方的入阁
第十章 政治董事
第十一章 平衡理论
第十二章 权力精英
第十三章 大众社会
第十四章 高层的不道德
后记
索引
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力精英
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解C指针
前言　　XI
第1章　认识指针　　1
1.1 　指针和内存　　2
1.1.1 　为什么要精通指针　　3
1.1.2 　声明指针　　5
1.1.3 　如何阅读声明　　6
1.1.4 　地址操作符　　7
1.1.5 　打印指针的值　　8
1.1.6 　用间接引用操作符解引指针　　10
1.1.7 　指向函数的指针　　10
1.1.8 　null 的概念　　10
1.2 　指针的长度和类型　　14
1.2.1 　内存模型　　14
1.2.2 　指针相关的预定义类型　　15
1.3 　指针操作符　　18
1.3.1 　指针算术运算　　19
1.3.2 　比较指针　　23
1.4 　指针的常见用法　　23
1.4.1 　多层间接引用　　23
1.4.2 　常量与指针　　24
1.5 　小结　　29
第2章　C 的动态内存管理　　31
2.1 　动态内存分配　　32
2.2 　动态内存分配函数　　36
2.2.1 　使用malloc 函数　　36
2.2.2 　使用calloc 函数　　39
2.2.3 　使用realloc 函数　　40
2.2.4 　alloca 函数和变长数组　　42
2.3 　用free 函数释放内存　　43
2.3.1 　将已释放的指针赋值为NULL　　44
2.3.2 　重复释放　　44
2.3.3 　堆和系统内存　　45
2.3.4 　程序结束前释放内存　　46
2.4 　迷途指针　　46
2.4.1 　迷途指针示例　　47
2.4.2 　处理迷途指针　　48
2.4.3 　调试器对检测内存泄漏的支持　　49
2.5 　动态内存分配技术　　49
2.5.1 C 的垃圾回收　　50
2.5.2 　资源获取即初始化　　50
2.5.3 　使用异常处理函数　　51
2.6 　小结　　52
第3章　指针和函数　　53
3.1 　程序的栈和堆　　53
3.1.1 　程序栈　　54
3.1.2 　栈帧的组织　　55
3.2 　通过指针传递和返回数据　　57
3.2.1 　用指针传递数据　　57
3.2.2 　用值传递数据　　58
3.2.3 　传递指向常量的指针　　59
3.2.4 　返回指针　　60
3.2.5 　局部数据指针　　61
3.2.6 　传递空指针　　62
3.2.7 　传递指针的指针　　63
3.3 　函数指针　　66
3.3.1 　声明函数指针　　66
3.3.2 　使用函数指针　　67
3.3.3 　传递函数指针　　69
3.3.4 　返回函数指针　　69
3.3.5 　使用函数指针数组　　70
3.3.6 　比较函数指针　　71
3.3.7 　转换函数指针　　71
3.4 　小结　　72
第4章　指针和数组　　75
4.1 　数组概述　　76
4.1.1 　一维数组　　76
4.1.2 　二维数组　　77
4.1.3 　多维数组　　78
4.2 　指针表示法和数组　　78
4.3 　用malloc 创建一维数组　　81
4.4 　用realloc 调整数组长度　　82
4.5 　传递一维数组　　85
4.5.1 　用数组表示法　　85
4.5.2 　用指针表示法　　86
4.6 　使用指针的一维数组　　87
4.7 　指针和多维数组　　89
4.8 　传递多维数组　　91
4.9 　动态分配二维数组　　94
4.9.1 　分配可能不连续的内存　　94
4.9.2 　分配连续内存　　95
4.10 　不规则数组和指针　　96
4.11 　小结　　99
第5章　指针和字符串　　101
5.1 　字符串基础　　101
5.1.1 　字符串声明　　102
5.1.2 　字符串字面量池　　103
5.1.3 　字符串初始化　　104
5.2 　标准字符串操作　　108
5.2.1 　比较字符串　　108
5.2.2 　复制字符串　　109
5.2.3 　拼接字符串　　 111
5.3 　传递字符串　　114
5.3.1 　传递简单字符串　　114
5.3.2 　传递字符常量的指针　　116
5.3.3 　传递需要初始化的字符串　　116
5.3.4 　给应用程序传递参数　　118
5.4 　返回字符串　　119
5.4.1 　返回字面量的地址　　119
5.4.2 　返回动态分配内存的地址　　120
5.5 　函数指针和字符串　　122
5.6 　小结　　124
第6章　指针和结构体　　125
6.1 　介绍　　125
6.2 　结构体释放问题　　128
6.3 　避免malloc/free 开销　　131
6.4 　用指针支持数据结构　　133
6.4.1 　单链表　　134
6.4.2 　用指针支持队列　　141
6.4.3 　用指针支持栈　　143
6.4.4 　用指针支持树　　145
6.5 　小结　　148
第7章　安全问题和指针误用　　149
7.1 　指针的声明和初始化　　150
7.1.1 　不恰当的指针声明　　150
7.1.2 　使用指针前未初始化　　151
7.1.3 　处理未初始化指针　　151
7.2 　指针的使用问题　　152
7.2.1 　测试NULL　　153
7.2.2 　错误使用解引操作　　153
7.2.3 　迷途指针　　154
7.2.4 　越过数组边界访问内存　　154
7.2.5 　错误计算数组长度　　155
7.2.6 　错误使用sizeof 操作符　　156
7.2.7 　一定要匹配指针类型　　156
7.2.8 　有界指针　　157
7.2.9 　字符串的安全问题　　157
7.2.10 　指针算术运算和结构体　　158
7.2.11 　函数指针的问题　　160
7.3 　内存释放问题　　161
7.3.1 　重复释放　　162
7.3.2 　清除敏感数据　　162
7.4 　使用静态分析工具　　163
7.5 　小结　　164
第8章　其他重要内容　　165
8.1 　转换指针　　166
8.1.1 　访问特殊用途的地址　　167
8.1.2 　访问端口　　168
8.1.3 　用DMA 访问内存　　169
8.1.4 　判断机器的字节序　　169
8.2 　别名、强别名和restrict 关键字　　170
8.2.1 　用联合体以多种方式表示值　　171
8.2.2 　强别名　　172
8.2.3 　使用restrict 关键字　　173
8.3 　线程和指针　　174
8.3.1 　线程间共享指针　　175
8.3.2 　用函数指针支持回调　　177
8.4 　面向对象技术　　179
8.4.1 　创建和使用不透明指针　　179
8.4.2 　C 中的多态　　182
8.5 　小结　　187
关于作者和封面　　188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解C指针
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构整洁之道
第1部分  概述
第1章  设计与架构究竟是什么  3
目标是什么  4
案例分析  5
本章小结  11
第2章  两个价值维度  12
行为价值  13
架构价值  13
哪个价值维度更重要  14
艾森豪威尔矩阵  15
为好的软件架构而持续斗争  16
第2部分  从基础构件开始：编程范式
第3章  编程范式总览  21
结构化编程  22
面向对象编程  22
函数式编程  23
仅供思考  23
本章小结  24
第4章  结构化编程  25
可推导性  26
goto是有害的  28
功能性降解拆分  29
形式化证明没有发生  29
科学来救场  29
测试  30
本章小结  31
第5章  面向对象编程  32
封装  33
继承  36
多态  38
本章小结  44
第6章  函数式编程  45
整数平方  46
不可变性与软件架构  47
可变性的隔离  48
事件溯源  49
本章小结  51
第3部分  设计原则
第7章  SRP：单一职责原则  56
反面案例2：代码合并  59
解决方案  60
本章小结  61
第8章  OCP：开闭原则  62
思想实验  63
依赖方向的控制  67
信息隐藏  67
本章小结  67
第9章  LSP：里氏替换原则  68
继承的使用指导  69
正方形/长方形问题  70
LSP与软件架构  70
违反LSP的案例  71
本章小结  73
第10章 ISP：接口隔离原则  74
ISP与编程语言  76
ISP与软件架构  76
本章小结  77
第11章 DIP：依赖反转原则  78
稳定的抽象层  79
工厂模式  80
具体实现组件  82
本章小结  82
第4部分  组件构建原则
第12章 组件  84
组件发展史  85
重定位技术  88
链接器  88
本章小结  90
第13章 组件聚合  91
复用/发布等同原则  92
共同闭包原则  93
共同复用原则  94
组件聚合张力图  95
本章小结  97
第14章 组件耦合  98
无依赖环原则  99
自上而下的设计  105
稳定依赖原则  106
稳定抽象原则  112
本章小结  117
第5部分  软件架构
第15章 什么是软件架构  120
开发（Development）  122
部署（Deployment）  123
运行（Operation）  123
维护（Maintenance）  124
保持可选项  124
设备无关性  126
垃圾邮件  128
物理地址寻址  129
本章小结  130
第16章 独立性  131
用例  132
运行  133
开发  133
部署  134
保留可选项  134
按层解耦  135
用例的解耦  136
解耦的模式  136
开发的独立性  137
部署的独立性  137
重复  138
再谈解耦模式  139
本章小结  141
第17章 划分边界  142
几个悲伤的故事  143
FitNesse  146
应在何时、何处画这些线  148
输入和输出怎么办  151
插件式架构  152
插件式架构的好处  153
本章小结  154
第18章 边界剖析  155
跨边界调用  156
令人生畏的单体结构  156
部署层次的组件  158
线程  159
本地进程  159
服务  160
本章小结  161
第19章 策略与层次  162
层次（Level）  163
本章小结  166
第20章 业务逻辑  167
业务实体  168
用例  169
请求和响应模型  171
本章小结  172
第21章 尖叫的软件架构  173
架构设计的主题  174
架构设计的核心目标  175
那Web呢  175
框架是工具而不是生活信条  175
可测试的架构设计  176
本章小结  176
第22章 整洁架构  177
依赖关系规则  179
一个常见的应用场景  183
本章小结  184
第23章 展示器和谦卑对象  185
谦卑对象模式  186
展示器与视图  186
测试与架构  187
数据库网关  188
数据映射器  188
服务监听器  189
本章小结  189
第24章 不完全边界  190
省掉最后一步  191
单向边界  192
门户模式  193
本章小结  193
第25章 层次与边界  194
基于文本的冒险游戏：Hunt The Wumpus  195
可否采用整洁架构  196
交汇数据流  199
数据流的分割  199
本章小结  201
第26章 Main组件  203
最细节化的部分  204
本章小结  208
第27章 服务：宏观与微观  209
面向服务的架构  210
服务所带来的好处  210
运送猫咪的难题  212
对象化是救星  213
基于组件的服务  215
横跨型变更  216
本章小结  216
第28章 测试边界  217
测试也是一种系统组件  218
可测试性设计  219
测试专用API  220
本章小结  221
第29章 整洁的嵌入式架构  222
“程序适用测试”测试  225
目标硬件瓶颈  228
本章小结  238
第6部分  实现细节
第30章 数据库只是实现细节  240
关系型数据库  241
为什么数据库系统如此流行  242
假设磁盘不存在会怎样  243
实现细节  243
但性能怎么办呢  244
一段轶事  244
本章小结  246
第31章 Web是实现细节  247
无尽的钟摆  248
总结一下  250
本章小结  251
第32章 应用程序框架是实现细节  252
框架作者  253
单向婚姻  253
风险  254
解决方案  255
不得不接受的依赖  255
本章小结  256
第33章 案例分析：视频销售网站  257
产品  258
用例分析  258
组件架构  260
依赖关系管理  261
本章小结  262
第34章 拾遗  263
按层封装  264
按功能封装  266
端口和适配器  268
按组件封装  270
具体实现细节中的陷阱  274
组织形式与封装的区别  275
其他的解耦合模式  277
本章小结：本书拾遗  279
后序  280
附录A  架构设计考古  283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构整洁之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇
《狮子、女巫和魔衣柜》
《凯斯宾王子》
《黎明踏浪号》
《银椅》
《能言马与男孩》
《魔法师的外甥》
《最后一战》
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>共同基金常识
推荐序 以开放的视野拓展中国基金业发展新途径 / VII        中国人寿资产管理公司董事长 缪建民
译者序 回归常识 / XI                              国务院发展研究中心金融研究所副所长 巴曙松
10周年纪念版序 见证全球基金业十年蜕变 / 1                    耶鲁大学首席投资官 大卫•斯文森
原版序 为何本书如此与众不同 / 5                            美国著名金融史学家 彼得•伯恩斯坦
10周年纪念版前言 / 7
原版前言 / 11
第一部分 投资策略
第1章 长期投资：强斯和花园 / 19
第2章 回报的本质：奥卡姆剃刀原则 / 48
第3章 资产配置：业绩归因之谜 / 72
第4章 简单化：如何到达应去之地 / 96
第二部分 投资选择
第5章 指数化：经验对希望的胜利 / 125
第6章 股票投资风格：井字游戏 / 159
第7章 债券投资：逐渐被遗忘 / 180
第8章 全球投资：钻石之邦 / 205
第9章 选择优质基金：寻找圣杯 / 224
第三部分 投资业绩
第10章 均值回复：牛顿对华尔街的报复 / 245
第11章 投资相对主义：幸福还是不幸 / 263
第12章 基金资产规模：胜利是最大的失败 / 275
第13章 税收的影响：视差的启示 / 294
第14章 时间的作用：第四维度，魔法还是专制 / 314
第四部分 基金管理
第15章 投资原则：重要的原则不可动摇 / 333
第16章 基金营销：信息即媒介 / 347
第17章 现代科技：又有何益 / 361
第18章 基金董事：一仆事二主 / 373
第19章 基金治理结构：策略规则 / 387
第五部分 基金精神
第20章 企业家精神：创造的喜悦 / 409
第21章 领导力：目标意识 / 420
第22章 人性化：客户和员工 / 433
后记 / 446
附录一：2010年年初对股票市场的一些思考 / 449
附录二：1999年年初对股票市场的一些思考 / 456
10周年纪念版致谢 / 461
原版致谢 / 462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>共同基金常识
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你的灯亮着吗?
第一部分　问题是什么？　　1
第1章　一个问题　　3
第2章　彼得发起了一个请愿　　9
第3章　你的问题是什么？　　16
第二部　分这次的问题是什么？　　29
第4章　比利战胜投标人　　31
第5章　比利忍住没说　　39
第6章　比利反思投标案　　42
第三部分　问题到底是什么？　　49
第7章　无尽的链条　　51
第8章　忽视不协调之处　　57
第9章　找到问题所属的层面　　66
第10章　注意你所表达的含义　　73
第四部分　问题该由谁解决？　　81
第11章　烟雾缭绕　　83
第12章　校园停车难问题　　89
第13章　隧道尽头的灯光　　96
第五部分　问题来自哪里？　　103
第14章　詹妮特·贾沃斯基遇上了混蛋　　105
第15章　麦特兹锡恩先生解决了问题　　111
第16章　找事让人做的人和领赏的人　　119
第17章　考试和其他谜题　　126
第六部分　你真的想解决问题吗？　　133
第18章　不怕累的汤姆被玩具耍了　　135
第19章　佩兴丝的计谋　　147
第20章　一项优先任务　　153
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你的灯亮着吗?
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国家的视角
第一部分　清晰化和简单化的国家项目
第一章　自然与空间
第二章　城市、人民和语言
第二部分　转变中的视野
第三章　独裁主义的极端现代主义
第四章　极端现代主义的城市：试验与批评
第五章　革命的政党：计划和诊断
第三部分　农村定居和生产中的社会工程
第六章　苏维埃集体化，资本主义梦想
第七章　坦桑尼亚的强制村庄化：美学和微型化
第八章　驯化自然：清晰和简单的农业
第四部分　失去的环节
第九章　薄弱的简单化和实践知识：米提斯
第十章　结语
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国家的视角
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑的永恒之道
永恒之道
第1章 永恒之道
质
第2章 无名特质
第3章 生机勃勃
第4章 事件模式
第5章 空间模式
第6章 有活力的模式
第7章 有活力模式的复合
第8章 特质本身
门
第9章 花与种子
第10章 我们的模式语言
第11章 我们的模式语言（续）
第12章 语言的创造力
第13章 语言的瓦解
第14章 可共享的模式
第15章 模式的真实
第16章 语言的结构
第17章 城市共同语言的演化
道
第18章 语言的发生力
第19章 空间的分化
第20章 每次一个模式
第21章 建筑的形成
第22章 建筑组团的形成
第23章 建造的过程
第24章 修整的过程
第25章 城市的缓慢出现
第26章 其超时代的特征
道之核心
第27章 道之核心
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑的永恒之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙趣横生的算法
第1部分 基础篇　第1章 数据结构基础　　1.1 什么是数据结构　　1.2 顺序表　　　1.2.1 顺序表的定义　　　1.2.2 向顺序表中插入元素　　　1.2.3 从顺序表中删除元素　　　1.2.4 实例与分析　　1.3 链表　　　1.3.1 创建一个链表　　　1.3.2 向链表中插入结点　　　1.3.3 从链表中删除结点　　　1.3.4 销毁一个链表　　　1.3.5 实例与分析　　1.4 栈　　　1.4.1 栈的定义　　　1.4.2 创建一个栈　　　1.4.3 入栈操作　　　1.4.4 出栈操作　　　1.4.5 栈的其他操作　　　1.4.6 实例与分析　　1.5 队列　　　1.5.1 队列的定义　　　1.5.2 创建一个队列　　　1.5.3 入队列操作　　　1.5.4 出队列操作　　　1.5.5 销毁一个队列　　　1.5.6 循环队列的概念　　　1.5.7 循环队列的实现　　　1.5.8 实例与分析　　1.6 树结构　　　1.6.1 树的概念　　　1.6.2 树结构的计算机存储形式　　　1.6.3 二叉树的定义　　　1.6.4 二叉树的遍历　　　1.6.5 创建二叉树　　　1.6.6 实例与分析　　1.7 图结构　　　1.7.1 图的概念　　　1.7.2 图的存储形式　　　1.7.3 邻接表的定义　　　1.7.4 图的创建　　　1.7.5 图的遍历（1）——深度优先搜索　　　1.7.6 图的遍历（2）——广度优先搜索　　　1.7.7 实例与分析　第2章 常用的查找与排序方法　　2.1 顺序查找　　2.2 折半查找　　2.3 排序的概述　　2.4 直接插入排序　　2.5 选择排序　　2.6 冒泡排序　　2.7 希尔排序　　2.8 快速排序　第3章 常用的算法思想　　3.1 什么是算法　　3.2 算法的分类表示及测评　　　3.2.1 算法的分类　　　3.2.2 算法的表示　　　3.2.3 算法性能的测评　　3.3 穷举法思想　　　3.3.1 基本概念　　　3.3.2 寻找给定区间的素数　　　3.3.3 TOM的借书方案　　3.4 递归与分治思想　　　3.4.1 基本概念　　　3.4.2 计算整数的划分数　　　3.4.3 递归的折半查找算法　　3.5 贪心算法思想　　　3.5.1 基本概念　　　3.5.2 最优装船问题　　3.6 回溯法　　　3.6.1 基本概念　　　3.6.2 四皇后问题求解　　3.7 数值概率算法　　　3.7.1 基本概念　　　3.7.2 计算定积分第2部分 编程实例解析　第4章 编程基本功    4.1 字符类型统计器    4.2 计算字符的ASCII码    4.3 嵌套if.else语句的妙用    4.4 基于switch语句的译码器    4.5 判断闰年    4.6 指针变量作参数    4.7 矩阵的转置运算    4.8 矩阵的乘法运算    4.9 巧用位运算    4.10 文件的读写    4.11 计算文件的大小    4.12 记录程序的运行时间    4.13 十进制／二进制转化器    4.14 打印特殊图案    4.15 打印杨辉三角    4.16 复杂级数的前n项和    4.17 寻找矩阵中的“鞍点”    4.18 n阶勒让德多项式求解    4.19 递归反向输出字符串    4.20 一年中的第几天  第5章 数学趣题(一)    5.1 舍罕王的失算    5.2 求两个数的最大公约数和最小公倍数    5.3 歌德巴赫猜想的近似证明    5.4 三色球问题    5.5 百钱买百鸡问题    5.6 判断回文数字    5.7 填数字游戏求解    5.8 新郎和新娘    5.9 爱因斯坦的阶梯问题    5.10 寻找水仙花数    5.11 猴子吃桃问题    5.12 兔子产仔问题    5.13 分解质因数    5.14 常胜将军    5.15 求兀的近似值    5.16 魔幻方阵    5.17 移数字游戏    5.18 数字的全排列    5.19 完全数    5.20 亲密数    5.21 数字翻译器    5.22 递归实现数制转换    5.23 谁在说谎  第6章 数学趣题(二)    6.1 连续整数固定和问题    6.2 表示成两个数的平方和    6.3 具有特殊性质的数    6.4 验证角谷猜想    6.5 验证四方定理    6.6 递归法寻找最小值    6.7 寻找同构数    6.8 验证尼科彻斯定理    6.9 三重回文数字    6.10 马克思手稿中的数学题    6.11 渔夫捕鱼问题    6.12 寻找假币    6.13 计算组合数    6.14 递归法求幂    6.15 汉诺Hanoi塔    6.16 选美比赛  第7章 数据结构趣题    7.1 顺序表的就地逆置    7.2 动态数列排序    7.3 在原表空间进行链表的归并    7.4 约瑟夫环    7.5 二进制／八进制转换器    7.6 回文字符串的判定    7.7 括号匹配    7.8 魔王语言翻译    7.9 动态双向链表的应用    7.10 判断完全二叉树    7.11 动画模拟创建二叉树    7.12 打印符号三角形    7.13 递归函数的非递归求解    7.14 任意长度整数加法  第8章 数值计算问题    8.1 递推化梯形法求解定积分    8.2 求解低阶定积分    8.3 迭代法开平方运算    8.4 牛顿法解方程    8.5 欧拉方法求解微分方程    8.6 改进的欧拉方法求解微分方程    8.7 雅可比迭代公式求解线性方程组  第9章 综合题    9.1 破碎的砝码    9.2 计算24的问题    9.3 马踏棋盘    9.4 0-1背包问题    9.5 八皇后问题求解    9.6 简易文件加密／解密系统  第10章 算法设计与数据结构面试题精粹    10.1 常见的算法设计题    10.2 常见的数据结构题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙趣横生的算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>死者在说话
1 每天都是万圣节
2 健谈的头骨们
3 “骨头的捆绑”
4 “环抱的大地”
5 破碎的残骸
6 当你病入灵魂
7 与魔鬼赛跑的人
8 反常的自然
9 “阳光照不到的地方……”
10 火与瓮
11 碎尸万段
12 遗失的军团
13 被错放的征服者
14 砷与“老马虎”
15 所有俄国人的沙皇
16 这些潦草的记录和我们的死尸
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>死者在说话
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>要素品牌战略
推荐序一 3M
推荐序二 张惟炯
推荐序三 拜  耳
推荐序四 美克邦
推荐序五 Bitrex
自序
1.为什么要打造品牌
1.1什么是要素品牌战略
1.2一种新的品牌战略
1.3你能从本书中学到什么
2.要素品牌战略基础
2.1要素品牌战略的理论基础
2.2要素品牌原则
2.3要素品牌的要求
2.4收益和风险
3.Intel Inside——要素品牌成功故事
4.要素品牌战略的实施
4.1品牌概念的重要性
4.2要素品牌战略的品牌概念
4.3战略选择
4.4沟通政策
5.要素品牌战略的成功故事
5.1汽车行业部件
5.2纺织行业的纤维品牌
5.3一种重要的成分——玻璃
5.4食品行业的例子
6.要素品牌的成功案例
6.1特氟龙：要素品牌战略基础
6.2杜比：创新引导科技发展
6.3利乐：从设备制造商到大众品牌
6.4苦味分子（Bitrex）：完善营销网络
6.5禧玛诺：隐形要素品牌
6.6模克隆：高科技材料
6.7数字光处理技术（DLP）：宠爱你的客户
6.8肖特赛兰：成功的差异化战略
6.9美克邦：说服客户，衡量价值
7.管理并衡量要素品牌
7.1管理要素品牌
7.2衡量品牌的原则
8.成功的要素品牌的视角
关于作者
参考文献
公司网址
要素品牌公司图例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>要素品牌战略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言从入门到精通
第1篇 基础知识　第1章 C语言概述　第2章 算法　第3章 数据类型　第4章 运算符与表达式　第5章 常用的数据输入、输出函数　第6章 选择结构程序设计　第7章 循环控制第2篇 核心技术　第8章 数组　第9章 函数　第10章 指针第3篇 高级应用　第11章 结构体和共用体　第12章 位运算　第13章 预处理　第14章 文件　第15章 存储管理　第16章 网络套接字编程第4篇 项目实战　第17章 学生成绩管理系统附 录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>科学的广告+我的广告生涯
我的广告生涯
前言/
1早年的影响/
我生来就比较保守，与其他原因相比，不够保守更常是广告人和企业家失败的原因。
2从广告和销售中学到的/
好东西自己就是最好的推销员。如果没有试用品让顾客试用，仅靠书面或口头的宣传，要想把东西卖出去，那就是件费力的事了。
3我在生意上的开端/
勤俭的人总能够得到命运之神的眷顾，而这样的眷顾一般都是人生旅程中最重要的事情。
4初涉广告/
这是我最初的成功案例，它靠的是取悦于人，就像我的其他成功一样。这种方式很有效，不仅对经销商，对使用者也一样。
5更广阔的天地/
在广告业中获得成功的人并不是那些有高贵教养的人，不是那些小心翼翼避免自己显得粗鲁而力图做出有礼貌样子的人，而是那些知道应该怎样激发淳朴的人们的热情的人。
6人员推销术/
任何种类的产品都要得到对方同意才送出去。要想卖出任何东西都要作好被人退回来的准备。所有好的推销术，无论是写在书本上的还是个人经验，都是建立在某种吸引人的服务上的。
7药品广告/
我总是提供服务。每个人都可以试一试我的做法，一点风险都没有。你的结果或许会比我在这里说的还要好，即便做不到这一点，你的成本也是微不足道的。
8我在“利库宗”的经验/
如果我们能排除所有的条条框框大胆地说“我们信任你”，人性就会对这种信任给予公正的回报。
917年广告公司生涯的开始/
只讲你自身的优势，你的顾客就总是有限的，但站在不自私的角度替你的顾客着想，他们会很自然地跑来找你。
10汽车广告/
唯一的推销方式是通过某种途径让别人看到你在提供超值的服务。你可以采取最简单的方式提出你的诉求，大多数成功的广告是通过简单的方式达到的目的。
11轮胎广告/
人们总有从众心理，对很多事情，他们很难分析原因和结果，所以他们接受大多数人的判断。
12“棕榈橄榄”的早期历史/
回头来看看所有的案例，它们背后都隐藏着人员推销的基本规律，所有广告都必须建立在这种规律之上。
13膨化谷物与桂格燕麦/
我们的成功取决于产品诉求是否能取悦于人。通过花费不高的试验，我们能够了解到自己是不是真的能做到。据此，我们可以不断调整自己的努力方向。
14百普素登/
新的问题需要新的经验。我们必须尽可能精确地审视我们要做的事情，发现不当之处，就及时纠正它们，要注意观察每一个诉求的效果。
15邮购广告的一些经验/
做生意是要赚钱的，一个人如果有助于别人赚钱，那他就有无穷的发展机会；但是如果想法很精彩，结果却赔了钱，那他就彻底完蛋了。
16成功的原因/
我怎么能在这种情况下取得这么多巨大的成功？这是因为我在很多小地方犯过错误，但从每个错误里都学到了一些东西。同样的错误我绝不会犯两遍。
17科学的广告/
自始至终都提供服务。这才是你所要销售的，也是你的潜在顾客们所想要的。在此基础上衡量你的每一句话。
18我的重大失误/
希望那些头脑清醒的人能从我的经历中得到启示，找准方向。我已经努力指出了在广告业中获取成功的唯一方法。
19一些个人情况/
我相信没有谁能比我从生活中得到的更多——更多真实的欢乐和满足。我把这个归结于对简朴生活的热爱，对普通人的热爱，这些因素使我在广告上获得了成功。
译者后记/
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>科学的广告+我的广告生涯
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇：狮子、女巫和魔衣柜
1 露茜初探魔衣柜
2 柜中天地
3 爱德蒙和魔衣柜
4 士耳其软糖果
5 回到柜门这边
6 深入森林
7 跟海狸夫妇共度的一天
8 午饭后发生的事
9 女巫的房子
10 魔法开始破了
11 阿斯兰快到了
12 彼得初战告捷
13 远古时代更加高深的魔法
14 女巫的胜利
15 太古时代更加高深的魔法
16 石像的遭遇
17 追猎白鹿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇：狮子、女巫和魔衣柜
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高质量程序设计指南
第1章  高质量软件开发之道	1
1.1  软件质量基本概念	1
1.1.1  如何理解软件的质量	1
1.1.2  提高软件质量的基本方法	2
1.1.3  “零缺陷”理念	4
1.2  细说软件质量属性	4
1.2.1  正确性	4
1.2.2  健壮性	4
1.2.3  可靠性	5
1.2.4  性能	6
1.2.5  易用性	6
1.2.6  清晰性	7
1.2.7  安全性	7
1.2.8  可扩展性	8
1.2.9  兼容性	8
1.2.10 可移植性	8
1.3  人们关注的不仅仅是质量	9
1.3.1  质量、生产率和成本之间的关系	9
1.3.2  软件过程改进的基本概念	10
1.4  高质量软件开发的基本方法	13
1.4.1  建立软件过程规范	13
1.4.2  复用	15
1.4.3  分而治之	16
1.4.4  优化与折中	17
1.4.5  技术评审	17
1.4.6  测试	19
1.4.7  质量保证	21
1.4.8  改错	22
1.5  关于软件开发的一些常识和思考	23
1.5.1  有最好的编程语言吗	23
1.5.2  编程是一门艺术吗	23
1.5.3  编程时应该多使用技巧吗	24
1.5.4  换更快的计算机还是换更快的算法	24
1.5.5  错误是否应该分等级	24
1.5.6  一些错误的观念	25
1.6  小结	25
第2章  编程语言发展简史	27
2.1  编程语言大事记	27
2.2  Ada的故事	31
2.3  C/C++发展简史	31
2.4  Borland与Microsoft之争	32
2.5  Java阵营与Microsoft的较量	33
2.6  小结	36
第3章  程序的基本概念	37
3.1  程序设计语言	37
3.2  语言实现	38
3.3  程序库	40
3.4  开发环境	40
3.5  程序的工作原理	41
3.6  良好的编程习惯	42
第4章  C++/C程序设计入门	45
4.1  C++/C程序的基本概念	45
4.1.1  启动函数main()	45
4.1.2  命令行参数	47
4.1.3  内部名称	48
4.1.4  连接规范	49
4.1.5  变量及其初始化	51
4.1.6  C Runtime Library	52
4.1.7  编译时和运行时的不同	52
4.1.8  编译单元和独立编译技术	54
4.2  基本数据类型和内存映像	54
4.3  类型转换	56
4.3.1  隐式转换	56
4.3.2  强制转换	58
4.4  标识符	60
4.5  转义序列	61
4.6  运算符	62
4.7  表达式	63
4.8  基本控制结构	65
4.9  选择（判断）结构	65
4.9.1  布尔变量与零值比较	66
4.9.2  整型变量与零值比较	67
4.9.3  浮点变量与零值比较	67
4.9.4  指针变量与零值比较	69
4.9.5  对if语句的补充说明	69
4.9.6  switch结构	70
4.10 循环（重复）结构	71
4.10.1  for语句的循环控制变量	72
4.10.2  循环语句的效率	73
4.11 结构化程序设计原理	78
4.12  goto/continue/break语句	79
4.13 示例	79
第5章  C++/C常量	85
5.1  认识常量	85
5.1.1  字面常量	85
5.1.2  符号常量	86
5.1.3  契约性常量	87
5.1.4  枚举常量	87
5.2  正确定义符号常量	87
5.3  const与#define的比较	88
5.4  类中的常量	89
5.5  实际应用中如何定义常量	90
第6章  C++/C函数设计基础	95
6.1  认识函数	95
6.2  函数原型和定义	96
6.3  函数调用方式	97
6.4  认识函数堆栈	99
6.5  函数调用规范	100
6.6  函数连接规范	101
6.7  参数传递规则	102
6.8  返回值的规则	104
6.9  函数内部实现的规则	107
6.10 存储类型及作用域规则	109
6.10.1  存储类型	109
6.10.2  作用域规则	110
6.10.3  连接类型	111
6.11 递归函数	113
6.12 使用断言	116
6.13 使用const提高函数的健壮性	118
6.13.1  用const修饰函数的参数	118
6.13.2  用const修饰函数的返回值	119
第7章  C++/C指针、数组和字符串	121
7.1  指针	121
7.1.1  指针的本质	121
7.1.2  指针的类型及其支持的运算	123
7.1.3  指针传递	125
7.2  数组	126
7.2.1  数组的本质	126
7.2.2  二维数组	128
7.2.3  数组传递	129
7.2.4  动态创建、初始化和删除数组的方法	131
7.3  字符数组、字符指针和字符串	133
7.3.1  字符数组、字符串和'\0'的关系	133
7.3.2  字符指针的误区	134
7.3.3  字符串拷贝和比较	134
7.4  函数指针	134
7.5  引用和指针的比较	137
第8章  C++/C高级数据类型	141
8.1  结构（struct）	141
8.1.1  关键字struct与class的困惑	141
8.1.2  使用struct	142
8.1.3  位域	145
8.1.4  成员对齐	147
8.2  联合（Union）	159
8.3  枚举（Enum）	161
8.4  文件	162
第9章  C++/C编译预处理	165
9.1  文件包含	165
9.1.1  内部包含卫哨和外部包含卫哨	165
9.1.2  头文件包含的合理顺序	166
9.2  宏定义	166
9.3  条件编译	169
9.3.1  #if、#elif和#else	169
9.3.2  #ifdef 和 #ifndef	170
9.4  #error	170
9.5  #pragma	171
9.6  #和##运算符	171
9.7  预定义符号常量	172
第10章  C++/C文件结构和程序版式	173
10.1  程序文件的目录结构	173
10.2  文件的结构	174
10.2.1  头文件的用途和结构	174
10.2.2  版权和版本信息	175
10.2.3  源文件结构	176
10.3  代码的版式	176
10.3.1  适当的空行	176
10.3.2  代码行及行内空格	177
10.3.3  长行拆分	178
10.3.4  对齐与缩进	179
10.3.5  修饰符的位置	180
10.3.6  注释风格	180
10.3.7  ADT/UDT版式	181
第11章  C++/C应用程序命名规则	183
11.1  共性规则	183
11.2  简单的Windows应用程序命名	184
第12章  C++面向对象程序设计方法概述	187
12.1  漫谈面向对象	187
12.2  对象的概念	188
12.3  信息隐藏与类的封装	189
12.4  类的继承特性	193
12.5  类的组合特性	199
12.6  动态特性	200
12.6.1  虚函数	200
12.6.2  抽象基类	201
12.6.3  动态绑定	203
12.6.4  运行时多态	206
12.6.5  多态数组	207
12.7  C++对象模型	214
12.7.1  对象的内存映像	214
12.7.2  隐含成员	224
12.7.3  C++编译器如何处理成员函数	225
12.7.4  C++编译器如何处理静态成员	225
12.8  小结	226
第13章  对象的初始化、拷贝和析构	229
13.1  构造函数与析构函数的起源	229
13.2  为什么需要构造函数和析构函数	230
13.3  构造函数的成员初始化列表	232
13.4  对象的构造和析构次序	234
13.5  构造函数和析构函数的调用时机	235
13.6  构造函数和赋值函数的重载	236
13.7  示例：类String的构造函数和析构函数	238
13.8  何时应该定义拷贝构造函数和拷贝赋值函数	239
13.9  示例：类String的拷贝构造函数和拷贝赋值函数	240
13.10 用偷懒的办法处理拷贝构造函数和 拷贝赋值函数	242
13.11 如何实现派生类的基本函数	243
第14章  C++函数的高级特性	247
14.1  函数重载的概念	247
14.1.1  重载的起源	247
14.1.2  重载是如何实现的	247
14.1.3  小心隐式类型转换导致重载函数产生二义性	249
14.2  成员函数的重载、覆盖与隐藏	250
14.2.1  重载与覆盖	250
14.2.2  令人迷惑的隐藏规则	251
14.2.3  摆脱隐藏	253
14.3  参数的默认值	254
14.4  运算符重载	255
14.4.1  基本概念	255
14.4.2  运算符重载的特殊性	256
14.4.3  不能重载的运算符	257
14.4.4  重载++和--	257
14.5  函数内联	259
14.5.1  用函数内联取代宏	259
14.5.2  内联函数的编程风格	260
14.5.3  慎用内联	261
14.6  类型转换函数	261
14.7  const成员函数	264
第15章  C++异常处理和RTTI	267
15.1  为什么要使用异常处理	267
15.2  C++异常处理	268
15.2.1  异常处理的原理	268
15.2.2  异常类型和异常对象	269
15.2.3  异常处理的语法结构	270
15.2.4  异常的类型匹配规则	272
15.2.5  异常说明及其冲突	272
15.2.6  当异常抛出时局部对象如何释放	273
15.2.7  对象构造和析构期间的异常	273
15.2.8  如何使用好异常处理技术	275
15.2.9  C++的标准异常	278
15.3  虚函数面临的难题	278
15.4  RTTI及其构成	280
15.4.1  起源	280
15.4.2  typeid运算符	281
15.4.3  dynamic_cast<>运算符	283
15.4.4  RTTI的魅力与代价	285
第16章  内存管理	287
16.1  内存分配方式	287
16.2  常见的内存错误及其对策	288
16.3  指针参数是如何传递内存的	289
16.4  free和delete把指针怎么啦	291
16.5  动态内存会被自动释放吗	292
16.6  杜绝“野指针”	292
16.7  有了malloc/free为什么还要new/delete	293
16.8  malloc/free的使用要点	295
16.9  new有3种使用方式	296
16.9.1  plain new/delete	296
16.9.2  nothrow new/delete	297
16.9.3  placement new/delete	297
16.10  new/delete的使用要点	300
16.11  内存耗尽怎么办	301
16.12  用对象模拟指针	302
16.13  泛型指针auto_ptr	305
16.14  带有引用计数的智能指针	306
16.15  智能指针作为容器元素	312
第17章  学习和使用STL	323
17.1  STL简介	323
17.2  STL头文件的分布	324
17.2.1  容器类	324
17.2.2  泛型算法	325
17.2.3  迭代器	325
17.2.4  数学运算库	325
17.2.5  通用工具	325
17.2.6  其他头文件	326
17.3  容器设计原理	326
17.3.1  内存映像	326
17.3.2  存储方式和访问方式	327
17.3.3  顺序容器和关联式容器的比较	328
17.3.4  如何遍历容器	331
17.3.5  存储空间重分配问题	332
17.3.6  什么样的对象才能作为STL容器的元素	333
17.4  迭代器	334
17.4.1  迭代器的本质	334
17.4.2  迭代器失效及其危险性	337
17.4.3  如何在遍历容器的过程中正确删除元素	346
17.5  存储分配器	347
17.6  适配器	349
17.7  泛型算法	352
17.8  一些特殊的容器	355
17.8.1  string类	356
17.8.2  bitset并非set	356
17.8.3  节省存储空间的vector<bool>	358
17.8.4  空容器	360
17.9  STL容器特征总结	361
17.10  STL使用心得	364
附录A  C++/C试题	367
附录B  C++/C试题答案与评分标准	371
附录C  大学十年	377
附录D  《大学十年》后记	395
附录E  术语与缩写解释	397
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高质量程序设计指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金融学
第1部分  金融和金融体系第1章  金融学  1.1  对金融学进行界定  1.2  为什么学习金融学？  1.3  居民户的金融决策  1.4  企业的金融决策  1.5  企业组织的形式  1.6  所有权与管理的分离  1.7  管理的目标  1.8  市场性管束：收购  1.9  财务专家在公司中的角色  小结  问题与疑难第2章  金融市场和金融机构  2.1  什么是金融体系？    2.2  资金流动  2.3  从功能出发的视角  2.4  金融创新与“看不见的手”    2.5  金融市场  2.6  金融市场中的比率  2.7  金融中介  2.8  金融基础设施与金融管制  2.9  政府与准政府组织  小结  问题与疑难第3章  管理财务健康状况和业绩  3.1  财务报表的功能  3.2  财务报表回顾  3.3  市场价值与账面价值  3.4  收入的会计标准与经济标准  3.5  股东收益率与账面净资产收益率  3.6  运用财务比率进行分析  3.7  财务规划过程  3.8  构建财务规划模型  3.9  增长与外源融资需要  3.10  营运资本管理  3.11  流动性与现金预算  小结  问题与疑难第2部分  时间与资源配置第4章  跨期配置资源  4.1  复利  4.2  复利的频率  4.3  现值与折现  4.4  其他折现现金流决策规则  4.5  复合现金流  4.6  年金  4.7  永续年金  4.8  贷款的分期偿还  4.9  汇率以及货币的时间价值  4.10  通货膨胀和折现现金流分析  4.11  税收与投资决策  小结  问题与疑难第5章  居民户的储蓄和投资决策  5.1  生命周期储蓄模型  5.2  考察社会保障  5.3  通过自愿性退休计划延迟支付税收  5.4  你是否应当投资于一项专业学位？  5.5  你应当购买还是租赁？  小结  问题与疑难第6章  投资项目分析  6.1  项目分析的性质  6.2  投资构思源自何处？  6.3  净现值投资规则  6.4  估计一个项目的现金流  6.5  资本成本  6.6  运用试算平衡表进行敏感性分析  6.7  分析成本下降的项目  6.8  拥有不同存续期的项目  6.9  对相互排斥的项目进行排序  6.10  通货膨胀与资本预算  小结  问题与疑难第3部分  价值评估模型第7章  市场估值原理  7.1  资产价值与资产价格的关系  7.2  价值最大化和金融决策  7.3  一价定律与套利  7.4  套利与金融资产价格  7.5  利率和一价定律  7.6  汇率与三角套利  7.7  运用参照物进行价值评估  7.8  价值评估模型  7.9  价值的会计标准  7.10  信息怎样反映在股票价格之中？    7.11  有效市场假说  小结  问题与疑难第8章  已知现金流的价值评估：债券  8.1  使用现值因子对已知现金流进行价值评估  8.2  基本构成要素：纯粹折现债券  8.3  附息债券、当期收益率和到期收益率  8.4  解读债券行情表  8.5  为什么到期期限相同的债券的收益率可能有所不同？  8.6  随时间推移的债券价格行为  小结  问题与疑难第9章  普通股的价值评估  9.1  解读股票行情表  9.2  折现红利模型  9.3  盈利和投资机会  9.4  对市盈率方法的重新考察  9.5  红利政策是否影响股东财富？  小结  问题与疑难第4部分  风险管理与资产组合理论第10章  风险管理的原理  10.1  什么是风险？    10.2  风险与经济决策  10.3  风险管理过程  10.4  风险转移的三个方面  10.5  风险转移与经济效率  10.6  风险管理机构  10.7  资产组合理论：最优风险管理的量化分析  10.8  收益率的概率分布  10.9  作为风险度量标准的标准差  小结  问题与疑难第11章  对冲、投保和分散化  11.1  使用远期合约和期货合约对冲风险  11.2  运用互换合约对冲汇率风险  11.3  通过针对负债配比资产对冲缺口风险  11.4  最小化对冲成本  11.5  投保与对冲  11.6  保险合约的基本特征  11.7  金融性担保  11.8  利率的最高限价与最低限价  11.9  作为保险的期权  11.10  分散化原理  11.11  分散化与保险成本  小结  问题与疑难第12章  资产组合机会和选择  12.1  个人资产组合选择的过程  12.2  预期收益率和风险之间的权衡取舍  12.3  运用多种风险资产的有效分散化  小结  问题与疑难第5部分  资产定价第13章  资本市场均衡  13.1  资本资产定价模型概述  13.2  市场资产组合风险溢价的决定因素  13.3  单个证券的贝塔系数和风险溢价  13.4  在资产组合选择的过程中运用资本资产定价模型  13.5  评估价值与管制收益率  13.6  资本资产定价模型的修正与替代选择  小结  问题与疑难第14章  远期市场与期货市场  14.1  远期合约与期货合约的区别  14.2  期货市场的经济功能  14.3  投机者的角色  14.4  商品的即期价格与期货价格之间的关系  14.5  从商品的期货价格中提取信息  14.6  黄金的远期一即期价格平价  14.7  金融期货  14.8  “隐含性”无风险利率  14.9  远期价格不是未来即期价格的预测值  14.10  存在现金支付的远期一即期价格平价关系式  14.11  “隐含性”红利  14.12  外汇的平价关系  14.13  汇率决定中预期的作用  小结  问题与疑难第15章  期权市场与或有索取权市场  15.1  期权怎样运作？    15.2  使用期权进行投资  15.3  卖出期权与买人期权的平价关系  15.4  波动性与期权价格  15.5  二项式期权定价  15.6  动态复制与二项式模型  15.7  布莱克-斯科尔斯模型  15.8  隐含波动性  15.9  公司负债与权益的或有索取权分析  15.10  信用担保  15.11  期权定价方法的其他应用  小结  问题与疑难第6部分  公司金融第16章  企业的财务结构  16.1  内源融资与外源融资  16.2  权益性融资  16.3  债务性融资  16.4  无摩擦环境中的资本结构无关性  16.5  通过财务决策创造价值  16.6  降低成本  16.7  解决利益冲突  16.8  为利益关联方创造新机会  16.9  实践中的融资决策  16.10  怎样评价杠杆化投资？  小结  问题与疑难第17章  实物期权  17.1  投资于实物期权  17.2  递延期权：不确定性与不可逆性的例证  17.3  运用布莱克-斯科尔斯公式评估实物期权  小结  问题与疑难专业术语表译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金融学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大众天文学(上下两册)
《大众天文学》在中国（新版代序）
译者序言
原出版说明
第一篇 地球
第一章 天空中的地球
……
第二篇 月亮
第九章 月亮――地球的卫星
……
第三篇 太阳
第十五章 主宰世界的太阳
……
第四篇 行星世界
第二十六章 视运动与真运动
……
第五篇 彗星、流星与陨星
第六篇 恒星宇宙
第七篇 天文仪器
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大众天文学(上下两册)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力精英
第一章 上流社会 / 1
第二章 当地社会 / 29
第三章 都市400强 / 47
第四章 名流 / 73
第五章 超级富豪 / 99
第六章 首席行政官 / 129
第七章 企业富豪 / 161
第八章 军界领袖 / 187
第九章 军界地位上升 / 215
第十章 政治局 / 247
第十一章 平衡理论 / 267
第十二章 权力精英 / 295
第十三章 大众社会 / 321
第十四章 保守情绪 / 347
第十五章 高层腐败 / 365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力精英
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货及其他衍生产品
推荐序一推荐序二译者序作者简介译者简介前言第1章 导言  1.1 交易所市场  1.2 场外市场  1.3 远期合约  1.4 期货合约  1.5 期权合约  1.6 交易员的种类  1.7 对冲者  1.8 投机者  1.9 套利者  1.10 危害  小结  推荐阅读  练习题  作业题第2章 期货市场的运作机制第3章 利用期货的对冲策略第4章 利率第5章 远期和期货价格的确定第6章 利率期货第7章 互换第8章 期权市场的运作过程第9章 股票期权的性质第10章 期权交易策略第11章 二叉树简介第12章 维纳过程和伊藤引理第13章 布莱克斯科尔斯默顿模型第14章 雇员股票期权第15章 股指期权与货币期权第16章 期货期权第17章 希腊值第18章 波动率微笑第19章 基本数值方法第20章 风险价值度第21章 估计波动率和相关系数第22章 信用风险第23章 信用衍生产品第24章 特种期权第25章 气候、能源以及保险衍生产品第26章 再论模型和数值算法第27章 鞅与测度第28章 利率衍生产品：标准市场模型第29章 曲率、时间与Quanto调整第30章 利率衍生产品：短期利率模型第31章 利率衍生产品：HJM与LMM模型第32章 再谈互换第33章 实物期权第34章 重大金融损失以及借鉴意义术语表附录A DerivaGem软件说明附录B 世界上的主要期权期货交易所附录C x≤0时N（x）的取值附录D x≥0时N（x）的取值
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货及其他衍生产品
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer Plus
"第1章  预备知识 1
1.1  C++简介 2
1.2  C++简史 2
1.2.1  C语言 3
1.2.2  C语言编程原理 3
1.2.3  面向对象编程 3
1.2.4  C++和泛型编程 4
1.2.5  C++的起源 4
1.3  可移植性和标准 5
1.3.1  C++的发展 6
1.3.2  本书遵循的C++标准 6
1.4  程序创建的技巧 7
1.4.1  创建源代码文件 7
1.4.2  编译和链接 8
1.5  总结 11
第2章  开始学习C++ 13
2.1  进入C++ 14
2.1.1  main( )函数 15
2.1.2  C++注释 17
2.1.3  C++预处理器和iostream文件 17
2.1.4  头文件名 18
2.1.5  名称空间 18
2.1.6  使用cout进行C++输出 19
2.1.7  C++源代码的格式化 21
2.2  C++语句 22
2.2.1  声明语句和变量 22
2.2.2  赋值语句 23
2.2.3  cout的新花样 24
2.3  其他C++语句 24
2.3.1  使用cin 25
2.3.2  使用cout进行拼接 25
2.3.3  类简介 26
2.4  函数 27
2.4.1  使用有返回值的函数 27
2.4.2  函数变体 30
2.4.3  用户定义的函数 31
2.4.4  用户定义的有返回值的函数 33
2.4.5  在多函数程序中使用using编译指令 34
2.5  总结 35
2.6  复习题 35
2.7  编程练习 36
第3章  处理数据 37
3.1  简单变量 38
3.1.1  变量名 38
3.1.2  整型 39
3.1.3  整型short、int、long和long long 39
3.1.4  无符号类型 43
3.1.5  选择整型类型 44
3.1.6  整型字面值 45
3.1.7  C++如何确定常量的类型 45
3.1.8  char类型：字符和小整数 46
3.1.9  bool类型 51
3.2  const限定符 52
3.3  浮点数 52
3.3.1  书写浮点数 53
3.3.2  浮点类型 54
3.3.3  浮点常量 55
3.3.4  浮点数的优缺点 55
3.4  C++算术运算符 55
3.4.1  运算符优先级和结合性 56
3.4.2  除法分支 57
3.4.3  求模运算符 57
3.4.4  类型转换 58
3.4.5  C++11中的auto声明 61
3.5  总结 62
3.6  复习题 62
3.7  编程练习 63
第4章  复合类型 65
4.1  数组 66
4.1.1  程序说明 67
4.1.2  数组的初始化规则 68
4.1.3  C++11数组初始化方法 68
4.2  字符串 69
4.2.1  拼接字符串常量 70
4.2.2  在数组中使用字符串 70
4.2.3  字符串输入 71
4.2.4  每次读取一行字符串输入 72
4.2.5  混合输入字符串和数字 74
4.3  string类简介 75
4.3.1  C++11字符串初始化 76
4.3.2  赋值、拼接和附加 76
4.3.3  string类的其他操作 76
4.3.4  string类I/O 77
4.3.5  其他形式的字符串字面值 78
4.4  结构简介 79
4.4.1  在程序中使用结构 80
4.4.2  C++11结构初始化 81
4.4.3  结构可以将string类作为成员吗 81
4.4.4  其他结构属性 82
4.4.5  结构数组 82
4.4.6  结构中的位字段 83
4.5  共用体 83
4.6  枚举 84
4.6.1  设置枚举量的值 85
4.6.2  枚举的取值范围 86
4.7  指针和自由存储空间 86
4.7.1  声明和初始化指针 88
4.7.2  指针的危险 90
4.7.3  指针和数字 90
4.7.4  使用new来分配内存 90
4.7.5  使用delete释放内存 92
4.7.6  使用new来创建动态数组 92
4.8  指针、数组和指针算术 94
4.8.1  程序说明 94
4.8.2  指针小结 96
4.8.3  指针和字符串 97
4.8.4  使用new创建动态结构 100
4.8.5  自动存储、静态存储和动态存储 101
4.9  类型组合 103
4.10  数组的替代品 104
4.10.1  模板类vector 104
4.10.2  模板类array（C++11） 105
4.10.3  比较数组、vector对象和array对象 105
4.11  总结 106
4.12  复习题 106
4.13  编程练习 107
第5章  循环和关系表达式 109
5.1  for循环 110
5.1.1  for循环的组成部分 110
5.1.2  回到for循环 114
5.1.3  修改步长 115
5.1.4  使用for循环访问字符串 116
5.1.5  递增运算符（++）和递减运算符（--） 116
5.1.6  副作用和顺序点 117
5.1.7  前缀格式和后缀格式 117
5.1.8  递增/递减运算符和指针 118
5.1.9  组合赋值运算符 119
5.1.10  复合语句（语句块） 119
5.1.11  其他语法技巧——逗号运算符 120
5.1.12  关系表达式 121
5.1.13  赋值、比较和可能犯的错误 122
5.1.14  C-风格字符串的比较 123
5.1.15  比较string类字符串 125
5.2  while循环 125
5.2.1  for与while 127
5.3.2  等待一段时间：编写延时循环 128
5.3  do while循环 129
5.4  基于范围的for循环（C++11） 131
5.5  循环和文本输入 131
5.5.1  使用原始的cin进行输入 131
5.5.2  使用cin.get(char)进行补救 132
5.5.3  使用哪一个cin.get( ) 132
5.5.4  文件尾条件 133
5.5.5  另一个cin.get( )版本 135
5.6  嵌套循环和二维数组 136
5.6.1  初始化二维数组 138
5.6.2  使用二维数组 138
5.7  总结 139
5.8  复习题 139
5.9  编程练习 140
第6章  分支语句和逻辑运算符 143
6.1  if语句 144
6.1.1  if else语句 145
6.1.2  格式化if else语句 146
6.1.3  if else if else结构 146
6.2  逻辑表达式 147
6.2.1  逻辑OR运算符：|| 147
6.2.2  逻辑AND运算符：&& 148
6.2.3  用&&来设置取值范围 149
6.2.4  逻辑NOT运算符：! 150
6.2.5  逻辑运算符细节 151
6.2.6  其他表示方式 151
6.3  字符函数库cctype 152
6.4  ?:运算符 153
6.5  switch语句 154
6.5.1  将枚举量用作标签 155
6.5.2  switch和if else 155
6.6  break和continue语句 156
6.7  读取数字的循环 157
6.8  简单文件输入/输出 159
6.8.1  文本I/O和文本文件 159
6.8.2  写入到文本文件中 160
6.8.3  读取文本文件 162
6.9  总结 164
6.10  复习题 165
6.11  编程练习 165
第7章  函数——C++的编程模块 169
7.1  复习函数的基本知识 170
7.1.1  定义函数 170
7.1.2  函数原型和函数调用 172
7.2  函数参数和按值传递 174
7.2.1  多个参数 175
7.2.2  另外一个接受两个参数的函数 176
7.3  函数和数组 177
7.3.1  函数如何使用指针来处理数组 178
7.3.2  将数组作为参数意味着什么 178
7.3.3  更多数组函数示例 180
7.3.4  使用数组区间的函数 182
7.3.5  指针和const 183
7.4  函数和二维数组 185
7.5  函数和C-风格字符串 186
7.5.1  将C-风格字符串作为参数的函数 187
7.5.2  返回c-风格字符串的函数 187
7.6  函数和结构 188
7.6.1  传递和返回结构 188
7.6.2  另一个处理结构的函数示例 189
7.6.3  传递结构的地址 192
7.7  函数和string对象 192
7.8  函数与array对象 193
7.9  递归 194
7.9.1  包含一个递归调用的递归 194
7.9.2  包含多个递归调用的递归 195
7.10  函数指针 196
7.10.1  函数指针的基础知识 196
7.10.2  函数指针示例 197
7.10.3  深入探讨函数指针 198
7.10.4  使用typedef进行简化 200
7.11  总结 200
7.12  复习题 201
7.13  编程练习 202
第8章  函数探幽 205
8.1  C++内联函数 206
8.2  引用变量 208
8.2.1  创建引用变量 208
8.2.2  将引用用作函数参数 209
8.2.3  引用的属性和特别之处 211
8.2.4  将引用用于结构 213
8.2.5  将引用用于类对象 217
8.2.6  对象、继承和引用 218
8.2.7  何时使用引用参数 219
8.3  默认参数 220
8.4  函数重载 221
8.4.1  重载示例 223
8.4.2  何时使用函数重载 224
8.5  函数模板 224
8.5.1  重载的模板 226
8.5.2  模板的局限性 226
8.5.3  显式具体化 226
8.5.4  实例化和具体化 227
8.5.5  编译器选择使用哪个函数版本 228
8.5.6  模板函数的发展 232
8.6  总结 234
8.7  复习题 234
8.8  编程练习 235
第9章  内存模型和名称空间 237
9.1  单独编译 238
9.2  存储持续性、作用域和链接性 240
9.2.1  作用域和链接 241
9.2.2  自动存储持续性 241
9.2.3  静态持续变量 243
9.2.4  静态持续性、外部链接性 245
9.2.5  静态持续性、内部链接性 247
9.2.6  静态存储持续性、无链接性 248
9.2.7  说明符和限定符 248
9.2.8  函数和链接性 250
9.2.9  语言链接性 250
9.2.10  存储方案和动态分配 251
9.3  名称空间 254
9.3.1  传统的C++名称空间 254
9.3.2  新的名称空间特性 254
9.3.3  名称空间示例 259
9.3.4  名称空间及其前途 260
9.4  总结 261
9.5  复习题 262
9.6  编程练习 262
第10章  对象和类 265
10.1  过程性编程和面向对象编程 266
10.2  抽象和类 267
10.2.1  类型是什么 267
10.2.2  C++中的类 267
10.2.3  实现类成员函数 270
10.2.4  使用类 272
10.2.5  修改实现 273
10.2.6  小结 274
10.3  类的构造函数和析构函数 274
10.3.1  声明和定义构造函数 275
10.3.2  使用构造函数 276
10.3.3  默认构造函数 276
10.3.4  析构函数 277
10.3.5  改进Stock类 278
10.3.6  构造函数和析构函数小结 281
10.4  this指针 282
10.5  对象数组 285
10.6  类作用域 286
10.6.1  作用域为类的常量 286
10.6.2  作用域内枚举（C++11） 287
10.7  抽象数据类型 288
10.8  总结 289
10.9  复习题 289
10.11  编程练习 290
第11章  使用类 293
11.1  运算符重载 294
11.2  计算时间：一个运算符重载示例 295
11.2.1  添加加法运算符 296
11.2.2  重载限制 297
11.2.3  其他重载运算符 298
11.3  友元 298
11.3.1  创建友元 300
11.3.2  常用的友元：重载<<运算符 300
11.4  重载运算符：作为成员函数还是非成员函数 304
11.5  再谈重载：一个矢量类 304
11.5.1  使用状态成员 307
11.5.2  为Vector类重载算术运算符 308
11.5.3  对实现的说明 309
11.5.4  使用Vector类来模拟随机漫步 310
11.6  类的自动转换和强制类型转换 311
11.6.1  转换函数 314
11.6.2  转换函数和友元函数 317
11.7  总结 319
11.8  复习题 320
11.9  编程练习 320
第12章  类和动态内存分配 323
12.1  动态内存和类 324
12.1.1  复习示例和静态类成员 324
12.1.2  特殊成员函数 328
12.1.3  回到Stringbad：复制构造函数的哪里出了问题 330
12.1.4  Stringbad的其他问题：赋值运算符 333
12.2  改进后的新String类 334
12.2.1  修订后的默认构造函数 335
12.2.2  比较成员函数 335
12.2.3  使用中括号表示法访问字符 336
12.2.4  静态类成员函数 337
12.2.5  进一步重载赋值运算符 338
12.3  在构造函数中使用new时应注意的事项 339
12.3.1  应该和不应该 339
12.3.2  包含类成员的类的逐成员复制 340
12.4  有关返回对象的说明 340
12.4.1  返回指向const对象的引用 340
12.4.2  返回指向非const对象的引用 341
12.4.3  返回对象 341
12.4.4  返回const对象 341
12.5  使用指向对象的指针 342
12.5.1  再谈new和delete 343
12.5.2  指针和对象小结 344
12.5.3  再谈定位new运算符 345
12.6  复习各种技术 346
12.6.1  重载<<运算符 346
12.6.2  转换函数 347
12.6.3  其构造函数使用new的类 347
12.7  队列模拟 347
12.7.1  队列类 348
12.7.2  Customer类 354
12.7.3  ATM模拟 355
12.8  总结 356
12.9  复习题 357
12.10  编程练习 357
第13章  类继承 359
13.1  一个简单的基类 360
13.1.1  派生一个类 361
13.1.2  构造函数：访问权限的考虑 362
13.1.3  使用派生类 364
13.1.4  派生类和基类之间的特殊关系 364
13.2  继承：is-a关系 366
13.3  多态公有继承 367
13.3.1  开发Brass类和BrassPlus类 367
13.4  静态联编和动态联编 371
13.4.1  指针和引用类型的兼容性 371
13.4.2  虚成员函数和动态联编 372
13.4.3  有关虚函数注意事项 373
13.5  访问控制：protected 375
13.6  抽象基类 375
13.6.1  应用ABC概念 377
13.6.2  ABC理念 378
13.7  继承和动态内存分配 378
13.7.1  第一种情况：派生类不使用new 378
13.7.2  第二种情况：派生类使用new 379
13.7.3  使用动态内存分配和友元的继承示例 380
13.8  类设计回顾 381
13.8.1  编译器生成的成员函数 381
13.8.2  其他的类方法 382
13.8.3  公有继承的考虑因素 384
13.8.4  类函数小结 386
13.9  总结 387
13.10  复习题 387
13.11  编程练习 388
第14章  C++中的代码重用 391
14.1  包含对象成员的类 392
14.1.1  valarray类简介 392
14.1.2  Student类的设计 393
14.1.3  Student类示例 394
14.2  私有继承 396
14.2.1  Student类示例（新版本） 396
14.2.2  使用包含还是私有继承 398
14.2.3  保护继承 399
14.2.4  使用using重新定义访问权限 399
14.3  多重继承 400
14.3.1  有多少Worker 401
14.3.2  哪个方法 404
14.3.3  MI小结 406
14.4  类模板 407
14.4.1  定义类模板 407
14.4.2  使用模板类 408
14.4.3  深入探讨模板类 409
14.4.4  数组模板示例和非类型参数 411
14.4.5  模板多功能性 411
14.4.6  模板的具体化 413
14.4.7  成员模板 414
14.4.8  将模板用作参数 415
14.4.9  模板类和友元 416
14.4.10  模板别名（C++11） 419
14.5  总结 419
14.6  复习题 421
14.7  编程练习 421
第15章  友元、异常和其他 425
15.1  友元 426
15.1.1  友元类 426
15.1.2  友元成员函数 427
15.1.3  其他友元关系 429
15.2  嵌套类 429
15.2.1  嵌套类和访问权限 430
15.2.2  模板中的嵌套 431
15.3  异常 432
15.3.1  调用abort( ) 432
15.3.2  返回错误码 432
15.3.3  异常机制 433
15.3.4  将对象用作异常类型 435
15.3.4  异常规范和C++11 436
15.3.5  栈解退 436
15.3.6  其他异常特性 439
15.3.7  exception类 440
15.3.8  异常、类和继承 442
15.3.9  异常何时会迷失方向 442
15.3.10  有关异常的注意事项 444
15.4  RTTI 445
15.4.1  RTTI的用途 445
15.4.2  RTTI的工作原理 445
15.5  类型转换运算符 449
15.6  总结 451
15.7  复习题 451
15.8  编程练习 452
第16章  string类和标准模板库 453
16.1  string类 454
16.1.1  构造字符串 454
16.1.2  string类输入 457
16.1.3  使用字符串 458
16.1.4  string还提供了哪些功能 460
16.1.5  字符串种类 461
16.2  智能指针模板类 461
16.2.1  使用智能指针 462
16.2.2  有关智能指针的注意事项 464
16.2.3  unique_ptr为何优于auto_ptr 465
16.2.4  选择智能指针 466
16.3  标准模板库 466
16.3.1  模板类vector 467
16.3.2  可对矢量执行的操作 467
16.3.3  对矢量可执行的其他操作 469
16.3.4  基于范围的for循环（C++11） 471
16.4  泛型编程 471
16.4.1  为何使用迭代器 472
16.4.2  迭代器类型 474
16.4.3  迭代器层次结构 475
16.4.4  概念、改进和模型 476
16.4.5  容器种类 480
16.4.4  关联容器 485
16.4.5  无序关联容器（C++11） 488
16.5  函数对象 488
16.5.1  函数符概念 489
16.5.2  预定义的函数符 490
16.5.3  自适应函数符和函数适配器 491
16.6  算法 493
16.6.1  算法组 493
16.6.2  算法的通用特征 493
16.6.3  STL和string类 494
16.6.4  函数和容器方法 494
16.6.5  使用STL 495
16.7  其他库 496
16.7.1  vector、valarray和array 497
16.7.2  模板initializer_list（C++11） 500
16.7.3  使用initializer_list 500
16.8  总结 501
16.9  复习题 502
16.10  编程练习 503
第17章  输入、输出和文件 505
17.1  C++输入和输出概述 506
17.1.1  流和缓冲区 506
17.1.2  流、缓冲区和iostream文件 508
17.1.3  重定向 510
17.2  使用cout进行输出 510
17.2.1  重载的<<运算符 511
17.2.2  其他ostream方法 512
17.2.3  刷新输出缓冲区 514
17.2.4  用cout进行格式化 515
17.3  使用cin进行输入 522
17.3.1  cin>>如何检查输入 523
17.3.2  流状态 524
17.3.3  其他istream类方法 527
17.3.4  其他istream方法 530
17.4  文件输入和输出 532
17.4.1  简单的文件I/O 532
17.4.2  流状态检查和is_open( ) 534
17.4.3  打开多个文件 534
17.4.3  命令行处理技术 535
17.4.5  文件模式 536
17.4.6  随机存取 540
17.5  内核格式化 543
17.6  总结 544
17.7  复习题 545
17.8  编程练习 546
第18章  探讨C++新标准 549
18.1  复习前面介绍过的C++11功能 550
18.1.1  新类型 550
18.8.2  统一的初始化 550
18.1.3  声明 551
18.1.4  智能指针 552
18.1.5  异常规范方面的修改 552
18.1.6  作用域内枚举 553
18.1.7  对类的修改 553
18.1.8  模板和STL方面的修改 554
18.1.9  右值引用 555
18.2  移动语义和右值引用 555
18.2.1  为何需要移动语义 555
18.2.2  一个移动示例 556
18.2.3  移动构造函数解析 557
18.2.4  赋值 558
18.2.5  强制移动 558
18.3  新的类功能 559
18.3.1  特殊的成员函数 559
18.3.2  默认的方法和禁用的方法 559
18.3.3  委托构造函数 560
18.3.4  继承构造函数 560
18.3.5  管理虚方法：override和final 561
18.4  Lambda函数 561
18.4.1  比较函数指针、函数符和Lambda函数 562
18.4.2  为何使用lambda 563
18.5  包装器 564
18.5.1  包装器function及模板的低效性 565
18.5.2  修复问题 566
18.5.3  其他方式 566
18.6  可变参数模板 567
18.6.1  模板和函数参数包 567
18.6.2  展开参数包 568
18.6.3  在可变参数模板函数中使用递归 568
18.7  C++11新增的其他功能 570
18.7.1  并行编程 570
18.7.2  新增的库 570
18.7.3  低级编程 570
18.7.4  杂项 571
18.8  语言变化 571
18.8.1  Boost项目 571
18.8.2  TR1 572
18.8.3  使用Boost 572
18.9  接下来的任务 572
18.10  总结 573
18.11  复习题 573
18.12  编程练习 574
附录A  计数系统 575
A.1  十进制数 576
A.2  八进制整数 576
A.3  十六进制数 576
A.4  二进制数 577
A.5  二进制和十六进制 577
附录B  C++保留字 579
B.1  C++关键字 580
B.2  替代标记 580
B.3  C++库保留名称 580
B.4  有特殊含义的标识符 581
附录C  ASCII字符集 583
附录D  运算符优先级 589
附录E  其他运算符 593
E.1  按位运算符 594
E.1.1  移位运算符 594
E.1.2  逻辑按位运算符 595
E.1.3  按位运算符的替代表示 597
E.1.4  几种常用的按位运算符技术 598
E.2  成员解除引用运算符 599
E.3  alignof（C++11） 600
E.4  noexcept（C++11） 601
附录F  模板类string 603
F.1  13种类型和一个常量 604
F.2  数据信息、构造函数及其他 605
F.2.1  默认构造函数 606
F.2.2  使用C-风格字符串的构造函数 607
F.2.3  使用部分C-风格字符串的构造函数 607
F.2.4  使用左值引用的构造函数 607
F.2.5  使用右值引用的构造函数（C++11） 608
F.2.6  使用一个字符的n个副本的构造函数 609
F.2.7  使用区间的构造函数 609
F.2.8  使用初始化列表的构造函数（C++11） 609
F.2.9  内存杂记 610
F.3  字符串存取 610
F.4  基本赋值 611
F.5  字符串搜索 611
F.5.1  find( )系列 611
F.5.2  rfind( )系列 612
F.5.3  find_first_of( )系列 612
F.5.4  find_last_of( )系列 612
F.5.5  find_first_not_of( )系列 612
F.5.6  find_last_not_of( )系列 613
F.6  比较方法和函数 613
F.7  字符串修改方法 614
F.7.1  用于追加和相加的方法 614
F.7.2  其他赋值方法 614
F.7.3  插入方法 614
F.7.4  清除方法 615
F.7.5  替换方法 615
F.7.6  其他修改方法：copy( )和swap( ) 615
F.8  输出和输入 616
附录G  标准模板库方法和函数 617
G.1  STL和C++11 618
G.1.1  新增的容器 618
G.1.2  对C++98容器所做的修改 618
G.2  大部分容器都有的成员 619
G.3  序列容器的其他成员 621
G.4  set和map的其他操作 623
G.4  无序关联容器（C++11） 625
G.5  STL函数 626
G.5.1  非修改式序列操作 626
G.5.2  修改式序列操作 629
G.5.3  排序和相关操作 635
G.5.4  数值运算 642
附录H  精选读物和网上资源 645
H.1  精选读物 646
H.2  网上资源 647
附录I  转换为ISO标准C++ 649
I.1  使用一些预处理器编译指令的替代品 650
I.1.1  使用const而不是#define来定义常量 650
I.1.2  使用inline而不是# define来定义小型函数 651
I.2  使用函数原型 651
I.3  使用类型转换 652
I.4  熟悉C++特性 652
I.5  使用新的头文件 652
I.6  使用名称空间 652
I.7  使用智能指针 653
I.8  使用string类 653
I.9  使用STL 654
附录J  复习题答案 655
第2章复习题答案 656
第3章复习题答案 656
第4章复习题答案 657
第5章复习题答案 658
第6章复习题答案 659
第7章复习题答案 660
第8章复习题答案 661
第9章复习题答案 662
第10章复习题答案 662
第11章复习题答案 663
第12章复习题答案 664
第13章复习题答案 665
第14章复习题答案 665
第15章复习题答案 666
第16章复习题答案 667
第17章复习题答案 667
第18章复习题答案 668
"
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer Plus
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计语言（特别版）
出版者的话
专家指导委员会
中文版序
译者序
序
第2版序
第1版序
导论
第1章 致读者
第2章 C++概览
第3章 标准库概览
第一部分 基本功能
第4章 类型和声明
第5章 指针、数组和结构
第6章 表达式和语句
第7章 函数
第8章 名字空间和异常
第9章 源文件和程序
第二部分 抽象机制
第10章 类
第11章 运算符重载
第12章 派生类
第13章 模板
第14章 异常处理
第15章 类层次结构
第16章 库组织和容器
第17章 标准容器
第18章 算法和函数对象
第19章 迭代器和分配器
第20章 串
第21章 流
第22章 数值
第三部分 用C++做设计
第23章 开发和设计
第24章 设计和编程
第25章 类的作用
附录和索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计语言（特别版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>不成熟的父母
赞　誉
导　读
引言   /1
第1章　情感不成熟的父母如何影响他们孩子的生活   /7
父母的忽视与拒斥会对一个人的自信以及成年后的人际关系造成很大负面影响。
第2章　认识情感不成熟的父母   /32
这些父母童年通常生活在不利于心智发展的家庭中，因此很难与自己的孩子建立亲密关系。
第3章　和情感不成熟的父母相处是一种怎样的体验   /62
情感不成熟的父母毫不在意别人的感受，只专注于别人是否让他们舒服。
第4章　四类情感不成熟的父母   /86
这四类分别是情绪型父母、驱动型父母、消极型父母、拒绝型父母。
第5章　不同孩子对情感不成熟的父母的养育会如何表现   /107
为了在家中有一席之地，孩子会在潜意识里形成治愈型幻想，也会扮演角色型自我。
第6章　作为自我掌控者是怎样一种感受   /132
自我掌控者非常渴望与他人建立情感联系，所以不成熟的父母会给他们带来很多痛苦。
第7章　崩溃与觉醒   /158
当处理好童年问题并发现自己的优点时，你会更加自信地按照自己的本心来生活。
第8章　如何避免被情感不成熟的父母影响   /181
如果不想在成年后的关系中重复童年的角色型自我，就必须与这个角色保持距离。
第9章　没有角色扮演和幻想的生活是怎样一种体验   /205
当你不再为了取悦父母而扮演角色，你就可以发现自己真实的想法和感受。
第10章　如何判断一个人是否情感成熟   /230
利用自己的观察力去发现那些情感成熟的人，并与之建立联系。
后记   /255
参考文献   /258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>不成熟的父母
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简单的艺术
第一章	物质主义和极简主义
1 物质主义的过度
拥有造成的（具体和抽象意义的）负担
住宅：不要塞满
物品：清理哪些，留下哪些
衣柜：风格和简单
2 极简主义的益处
时间：少浪费就是拥有更多，以及更好地利用
金钱是我们的奴仆，而不是我们的主人
3 伦理和审美
美的需要
条理整洁的“少就是多”原则
第二章	 身体
1 美丽与你
发现你的自我形象
强调你的个性
用保养和睡眠解放你的身体
2 极简主义护理方法
皮肤、头发和指甲（趾甲）
橄榄油或鳄梨油面膜
告别不完美之处
远离健身房
3 饮馔少而精
放纵饮食
饮食有度，脍不厌细
几条“清除体内垃圾”的营养学提示
重新学习饥饿
第三章	 精神
1 你的内在生态
纯洁你的精神
控制你的精神
凝神与静思
2 其他
精简联系人
利他主义和清净自处
打磨自己，光滑如卵石
为改变做好准备
每天用一个小时实现一项诺言
阅读和写作
锻炼和纪律
节省你的能量
总  结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简单的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++标准程序库
目录
侯捷译序a
孟岩译序g
目录（contents） v
前言（preface） xvii
致谢（acknowledgments） xix
1 关于本书1
1.1 缘起1
1.2 阅读前的必要基础2
1.3 本书风格与结构2
1.4 如何阅读本书4
1.5 目前发展形式5
1.6 范例程序代码及额外信息5
1.7 回应5
2 c++ 及其标准程序库简介7
2.1 沿革7
2.2 新的语言特性9
2.2.1 templates（模板） 9
2.2.2 基本型别的显式初始化（explicit initialization） 14
2.2.3 异常处理（exception handling） 15
.2.2.4 命名空间（namespaces） 16
2.2.5 bool型别18
2.2.6 关键词explicit 18
2.2.7 新的型别转换操作符（type conversion operators） 19
2.2.8 常数静态成员（constant static members）的初始化20
2.2.9 main() 的定义21
2.3 复杂度和big-o 表示法21
3 一般概念（general concepts） 23
3.1 命名空间（namespace）std 23
3.2 头文件（header files） 24
3.3 错误（error）处理和异常（exception）处理25
3.3.1 标准异常类别（standard exception classes） 25
3.3.2 异常类别（exception classes）的成员28
3.3.3 抛出标准异常29
3.3.4 从标准异常类别（exception classes）中派生新的类别30
3.4 配置器（allocators） 31
4 通用工具（utilities） 33
4.1 pairs（对组） 33
4.1.1 便捷函数make_pair() 36
4.1.2 pair运用实例37
4.2 class auto_ptr 38
4.2.1 auto_ptr的发展动机38
4.2.2 auto_ptr拥有权（ownership）的转移40
4.2.3 auto_ptrs 做为成员之一44
4.2.4 auto_ptrs 的错误运用46
4.2.5 auto_ptr运用实例47
4.2.6 auto_ptr实作细目51
4.3 数值极限（numeric limits） 59
4.4 辅助函数66
4.4.1 挑选较小值和较大值66
4.4.2 两值互换67
4.5 辅助性的“比较操作符”（comparison operators） 69
4.6 头文件[cstddef] 和[cstdlib] 71
4.6.1 [cstddef] 内的各种定义71
4.6.2 [cstdlib] 内的各种定义71
5 standard template library（标准模板库） 73
5.1 stl 组件（stl components） 73
5.2 容器（containers） 75
5.2.1 序列式容器（sequence containers） 76
5.2.2 关联式容器（associative containers） 81
5.2.3 容器配接器（container adapters） 82
5.3 迭代器（iterators） 83
5.3.1 关联式容器的运用实例86
5.3.2 迭代器类型（iterator categories） 93
5.4 算法（algorithms） 94
5.4.1 区间（ranges） 97
5.4.2 处理多个区间101
5.5 迭代器之配接器（iterator adapters） 104
5.5.1 insert iterators（安插型迭代器） 104
5.5.2 stream iterators（串流迭代器） 107
5.5.3 reverse iterators（逆向迭代器） 109
5.6 更易型算法（manipulating algorithms） 111
5.6.1 移除（removing）元素111
5.6.2 更易型算法和关联式容器115
5.6.3 算法v.s. 成员函数116
5.7 使用者自定之泛型函数（user-defined generic functions） 117
5.8 以函数做为算法的参数119
5.8.1“以函数做为算法的参数”实例示范119
5.8.2 判断式（predicates） 121
5.9 仿函数（functors or function objects） 124
5.9.1 什么是仿函数124
5.9.2 预先定义的仿函数131
5.10 容器内的元素（container elements） 134
5.10.1 容器元素的条件134
5.10.2 value 语意vs. reference 语意135
5.11 stl内部的错误处理和异常处理136
5.11.1 错误处理（error handling） 137
5.11.2 异常处理（exception handling） 139
5.12 扩展stl 141
6 stl 容器（containers） 143
6.1 容器的共通能力和共通操作144
6.1.1 容器的共通能力144
6.1.2 容器的共通操作144
6.2 vectors 148
6.2.1 vectors 的能力148
6.2.2 vector 的操作函数150
6.2.3 将vectors 当做一般arrays 使用155
6.2.4 异常处理155
6.2.5 vectors 运用实例156
6.2.6 class vector[bool] 158
6.3 deques 160
6.3.1 deques 的能力161
6.3.2 deque 的操作函数162
6.3.3 异常处理（exception handling） 164
6.3.4 deques 运用实例164
6.4 lists 166
6.4.1 lists 的能力166
6.4.2 list 的操作函数167
6.4.3 异常处理（exception handling） 172
6.4.4 lists 运用实例172
6.5 sets和multisets
175
6.5.1 sets 和multisets 的能力176
6.5.2 set 和multiset 的操作177
6.5.3 异常处理（exception handling） 185
6.5.4 sets 和multisets 运用实例186
6.5.5 执行期指定排序准则（sorting criterion） 191
6.6 maps 和multimaps 194
6.6.1 maps 和multimaps 的能力195
6.6.2 map 和multimap 的操作函数196
6.6.3 将maps 视为关联式数组（associated arrays） 205
6.6.4 异常处理（exception handling） 207
6.6.5 maps 和multimaps 运用实例207
6.6.6 综合实例：运用maps, strings 并于执行期指定排序准则213
6.7 其它的stl容器217
6.7.1 strings 可被视为一种stl容器217
6.7.2 arrays 可被视为一种stl容器218
6.7.3 hash tables 221
6.8 动手实现reference 语意222
6.9 各种容器的运用时机226
6.10 细说容器内的型别和成员230
6.10.1 容器内的型别230
6.10.2 生成（create）、复制（copy）、销毁（destroy） 231
6.10.3“非变动性操作（nonmodifying operations） 233
6.10.4 赋值（指派, assignments） 236
6.10.5 直接元素存取237
6.10.6 “会产出迭代器”的各项操作239
6.10.7 元素的安插（inserting）和移除（removing） 240
6.10.8 lists 的特殊成员函数244
6.10.9 对配置器（allocator）的支持246
6.10.10 综观stl容器的异常处理248
7 stl 迭代器（iterators） 251
7.1 迭代器头文件251
7.2 迭代器类型（iterator categories） 251
7.2.1 input（输入）迭代器252
7.2.2 output（输出）迭代器253
7.2.3 forward（前向）迭代器254
7.2.4 bidirectional（双向）迭代器255
7.2.5 random access（随机存取）迭代器255
7.2.6 vector 迭代器的递增（increment）和递减（decrement） 258
7.3 迭代器相关辅助函数259
7.3.1 advance() 可令迭代器前进259
7.3.2 distance() 可处理迭代器之间的距离261
7.3.3 iter_swap() 可交换两个迭代器所指内容263
7.4 迭代器配接器（iterator adapters） 264
7.4.1 reverse（逆向）迭代器264
7.4.2 insert（安插型）迭代器271
7.4.3 stream（串流）迭代器277
7.5 迭代器特性（iterator traits） 283
7.5.1 为迭代器编写泛型函数（generic functions） 285
7.5.2 使用者自定（user-defined）的迭代器288
8 stl 仿函数（functors or function objects） 293
8.1 仿函数的概念293
8.1.1 仿函数可当做排序准则（sort criteria） 294
8.1.2 仿函数可拥有自己的内部状态（internal state） 296
8.1.3 for_each() 的回返值300
8.1.4 判断式（predicates）和仿函数（functors） 302
8.2 预定义的仿函数305
8.2.1 函数配接器（function adapters） 306
8.2.2 针对成员函数而设计的函数配接器307
8.2.3 针对一般函数（非成员函数）而设计的函数配接器309
8.2.4 让自定仿函数也可以使用函数配接器310
8.3 辅助用（组合型）仿函数313
8.3.1 一元组合函数配接器（unary compose function object adapters） 314
8.3.2 二元组合函数配接器（binary compose function object adapters） 318
9 stl 算法（algorithms） 321
9.1 算法头文件（header files） 321
9.2 算法概观322
9.2.1 简介322
9.2.2 算法分门别类323
9.3 辅助函数332
9.4 for_each() 算法334
9.5 非变动性算法（nonmodifying algorithms） 338
9.5.1 计算元素个数338
9.5.2 求最大值和最小值339
9.5.3 搜寻元素341
9.5.4 区间的比较356
9.6 变动性算法（modifying algorithms） 363
9.6.1 复制（copying）元素363
9.6.2 转换（transforming）和结合（combining）元素366
9.6.3 互换（swapping）元素内容370
9.6.4 赋予（assigning）新值372
9.6.5 替换（replacing）元素375
9.7 移除性算法（removing algorithms） 378
9.7.1 移除某些特定元素378
9.7.2 移除重复元素381
9.8 变序性算法（mutating algorithms） 386
9.8.1 逆转（reversing）元素次序386
9.8.2 旋转（rotating）元素次序388
9.8.3 排列（permuting）元素391
9.8.4 重排元素（shuffling, 搅乱次序） 393
9.8.5 将元素向前搬移395
9.9 排序算法（sorting algorithms） 397
9.9.1 对所有元素排序397
9.9.2 局部排序（partial sorting） 400
9.9.3 根据第n 个元素排序404
9.9.4 heap 算法406
9.10 已序区间算法（sorted range algorithms） 409
9.10.1 搜寻元素（searching） 410
9.10.2 合并元素（merging） 416
9.11 数值算法（numeric algorithms） 425
9.11.1 加工运算后产生结果425
9.11.2 相对值和绝对值之间的转换429
10 特殊容器（special containers） 435
10.1 stacks（堆栈） 435
10.1.1 核心界面436
10.1.2 stacks 运用实例437
10.1.3 class stack[] 细部讨论438
10.1.4 一个使用者自定的stack class 441
10.2 queues（队列） 444
10.2.1 核心界面445
10.2.2 queues 运用实例446
10.2.3 class queue[] 细部讨论447
10.2.4 一个使用者自定的queue class 450
10.3 priority queues（优先队列） 453
10.3.1 核心界面455
10.3.2 priority queues 运用实例455
10.3.3 class priority_queue[] 细部讨论456
10.4 bitsets 460
10.4.1 bitsets 运用实例460
10.4.2 class bitset 细部讨论463
11 strings（字符串） 471
11.1 动机471
11.1.1 例一：引出一个临时文件名
472
11.1.2 例二：引出一段文字并逆向打印476
11.2 string classes 细部描述479
11.2.1 string 的各种相关型别479
11.2.2 操作函数（operations）综览481
11.2.3 建构式和解构式（constructors and destructors） 483
11.2.4 strings 和c-strings 484
11.2.5 大小（size）和容量（capacity） 485
11.2.6 元素存取（element access） 487
11.2.7 比较（comparisons） 488
11.2.8 更改内容（modifiers） 489
11.2.9 子字符串及字符串接合492
11.2.10 i/o 操作符492
11.2.11 搜寻和查找（searching and finding） 493
11.2.12 数值npos 的意义495
11.2.13 strings 对迭代器的支援497
11.2.14 国际化（internationalization） 503
11.2.15 效率（performance） 506
11.2.16 strings 和vectors 506
11.3 细说string class 507
11.3.1 内部的型别定义和静态值507
11.3.2 生成（create）、拷贝（copy）、销毁（destroy） 508
11.3.3 大小（size）和容量（capacity） 510
11.3.4 比较（comparisons） 511
11.3.5 字符存取（character access） 512
11.3.6 产生c-strings 和字符数组（character arrays） 513
11.3.7 更改内容514
11.3.8 搜寻（searching and finding） 520
11.3.9 子字符串及字符串接合524
11.3.10 i/o 函数524
11.3.11 产生迭代器525
11.3.12 对配置器（allocator）的支持526
12 数值（numerics） 529
12.1 复数（complex numbers） 529
12.1.1 class complex运用实例530
12.1.2 复数的各种操作533
12.1.3 class complex[] 细部讨论541
12.2 valarrays 547
12.2.1 认识valarrays 547
12.2.2 valarray 的子集（subsets） 553
12.2.3 class valarray 细部讨论569
12.2.4 valarray子集类别（subset classes）细部讨论575
12.3 全域性的数值函数581
13 以stream classes完成输入和输出583
13.1 i/o streams 基本概念584
13.1.1 stream物件584
13.1.2 stream类别584
13.1.3 全域性的stream物件585
13.1.4 stream操作符586
13.1.5 操控器（manipulators） 586
13.1.6 一个简单的例子587
13.2 基本的stream类别和stream对象588
13.2.1 相关类别及其阶层体系588
13.2.2 全域性的stream物件591
13.2.3 头文件（headers） 592
13.3 标准的stream操作符[[ 和]] 593
13.3.1 output操作符[[ 593
13.3.2 input操作符]] 594
13.3.3 特殊型别的i/o 595
13.4 streams 的状态（state） 597
13.4.1 用来表示streams 状态的一些常数597
13.4.2 用来处理streams 状态的一些成员函数598
13.4.3 stream状态与布尔条件测试600
13.4.4 stream的状态和异常602
13.5 标准i/o 函数607
13.5.1 输入用的成员函数607
13.5.2 输出用的成员函数610
13.5.3 运用实例611
13.6 操控器（manipulators） 612
13.6.1 操控器如何运作612
13.6.2 使用者自定操控器614
13.7 格式化（formatting） 615
13.7.1 格式标志（format flags） 615
13.7.2 布尔值（boolean values）的i/o 格式617
13.7.3 字段宽度、填充字符、位置调整618
13.7.4 正记号与大写字620
13.7.5 数值进制（numeric base） 621
13.7.6 浮点数（floating-point）表示法623
13.7.7 一般性的格式定义625
13.8 国际化（internationalization） 625
13.9 文件存取（file access） 627
13.9.1 文件标志（file flags） 631
13.9.2 随机存取634
13.9.3 使用文件描述器（file descriptors） 637
13.10 连接input streams 和output streams 637
13.10.1 以tie()完成“松耦合”（loose coupling） 637
13.10.2 以stream缓冲区完成“紧耦合”（tight coupling） 638
13.10.3 将标准streams 重新导向（redirecting） 641
13.10.4 用于读写的streams 643
13.11 string stream classes 645
13.11.1 string stream classes 645
13.11.2 char* stream classes 649
13.12 “使用者自定型别”之i/o操作符652
13.12.1 实作一个output 操作符652
13.12.2 实作一个input 操作符654
13.12.3 以辅助函数完成i/o 656
13.12.4 以非格式化函数完成使用者自定的操作符658
13.12.5 使用者自定的格式标志（format flags） 659
13.12.6 使用者自定之i/o 操作符的数个依循惯例662
13.13 stream buffer classes 663
13.13.1 从使用者的角度看stream缓冲区663
13.13.2 stream缓冲区迭代器（buffer iterators） 665
13.13.3 使用者自定的stream 缓冲区668
13.14 关于效能（performance） 681
13.14.1 与c 标准输入输出流（standard streams）同步682
13.14.2 stream缓冲区内的缓冲机制682
13.14.3 直接使用stream缓冲区683
14 国际化（internationalization, i18n） 685
14.1 不同的字符编码（character encoding） 686
14.1.1 宽字符（wide-character）和多字节文本（multibyte text） 686
14.1.2 字符特性（character traits） 687
14.1.3 特殊字符国际化691
14.2 locales 的概念692
14.2.1 运用locales 693
14.2.2 locale facets 698
14.3 locales 细部讨论700
14.4 facets 细部讨论704
14.4.1 数值格式化705
14.4.2 时间和日期格式化708
14.4.3 货币符号格式化711
14.4.4 字符的分类和转换715
14.4.5 字符串校勘（string collation） 724
14.4.6 信息国际化725
15 空间配置器（allocators） 727
15.1 应用程序开发者如何使用配置器727
15.2 程序库开发者如何使用配置器728
15.3 c++ 标准程序库的预设配置器732
15.4 使用者自行定义的配置器735
15.5 配置器细部讨论737
15.5.1 内部定义的型别737
15.5.2 各项操作739
15.6“未初始化内存”之处理工具细部讨论740
网络上的资源（internet resources） 743
参考书目（bibliography） 745
索引（index） 747
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++标准程序库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>公司财务原理
译者序
前言
第一部分 价值
第1章 财务与财务经理 2
1.1 什么是公司 2
1.2 财务经理的职责 3
1.3 谁是财务经理 4
1.4 所有权与管理权的分离 5
1.5 本书论题综述 6
本章小结 7
推荐读物 7
练习题 8
第2章 现值与资本机会成本 9
2.1 现值概论 10
2.1.1 现值的计算 10
2.1.2 净现值 10
2.1.3 关于风险与现值的一点注记 11
2.1.4 现值与收益率 11
2.1.5 资本机会成本 12
2.1.6 一个容易出错的地方 13
2.2 净现值法则的基础 13
金融市场对当前消费与未来消费偏好的协调 13
2.3 一个基本的结果 15
其他公司目标 16
2.4 经理真的关心股东利益吗 16
2.5 经理应该关心股东的利益吗 17
本章小结 17
推荐读物 18
练习题 18
实务题 19
思考题 20
第3章 现值的计算 23
3.1 长期资产的价值评估 23
3.1.1 多期现金流的价值评估 23
3.1.2 贴现因子随着期限的增加而递减的原因—对生钱机器的一点题外话 24
3.1.3 现值与净现值的计算 25
3.2 经验公式—永久年金与年金 26
3.2.1 增长型永久年金的价值评估 26
3.2.2 年金的价值评估 27
3.3 复利与现值 28
关于复利间隔期的一点注记 30
3.4 名义利率与实际利率 32
3.5 利用现值公式评估债券价值 33
3.5.1 利率变化与债券定价 34
3.5.2 复利间隔期与债券定价 35
本章小结 35
推荐读物 36
练习题 36
实务题 37
思考题 39
微型案例：琼斯家族公司 40
第4章 普通股的价值 41
第5章 与其他投资准则相比，为什么净现值法则能保证较优的投资决策 65
第6章 利用净现值法则进行投资决策 86
第二部分 风险
第7章 风险、收益与资本机会成本概论 112
第8章 风险与收益 137
第9章 资本预算与风险 162
第三部分 资本预算的实务问题
第10章 项目并不是黑箱 190
第11章 正净现值的来源 213
第12章 确保经理最大化净现值 231
第四部分 融资决策与市场有效性
第13章 公司融资与市场有效性的6点启示 256
第14章 公司融资概况 280
15章 公司如何发行证券 296
第五部分 红利政策与资本结构
第16章 红利政策之争议 322
第17章 负债政策重要吗 345
第18章 公司负债该多少 363
第19章 融资决策与价值评估 389
第六部分 期权
第20章 期权的基本知识 420
第21章 期权的价值评估 442
第22章 实物期权 461
第23章 认股权证和可转换债券 480
第七部分 负债融资
第24章 债券的价值评估 500
第25章 多种多样的债券 525
第26章 租赁 545
第八部分 风险管理
第27章 风险管理 566
第28章 国际风险管理 589
第九部分 财务计划与短期财务管理
第29章 财务分析与财务计划 612
第30章 短期财务计划 636
第31章 现金管理 657
第32章 信用管理 676
第十部分 兼并、公司控制与治理
第33章 兼并 692
第34章 控制、治理与财务架构 718
第十一部分 总结
第35章 总结：财务理论的已知与未知 742
附录A 现值表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>公司财务原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++设计新思维
译序by 侯捷	i
译序by 於春景	iii
目录	 v
序言by scott meyers	 xi
序言by john vlissides	 xv
前言	 xvii
致谢	 xxi
第一篇 技术（techniques）	1
第1章	基于policy的class设计（policy-based class design）	3
1.1	软件设计的多样性（multiplicity）	 3
1.2	全功能型（do-it-all）接口的失败	 4
1.3	多重继承（multiple inheritance）是救世主？	5
1.4	templates带来曙光	 6
1.5	policies和policy classes	 7
1.6	更丰富的policies	 12
1.7	policy classes的析构函数（destructors）	 12
1.8	通过不完全具现化（incomplete instantiation）而获得的选择性机能（optional functionality）	 13
1.9	结合policy classes	14
.	1.10	以policy classes定制结构	16
1.11	policies的兼容性	 17
1.12	将一个class分解为一堆policies	 19
1.13	摘要	 20
第2章	技术（techniques）	 23
2.1	编译期（compile-time）assertions	23
2.2	partial template specialization（模板偏特化）	26
2.3	局部类（local classes）	 28
2.4	常整数映射为型别（mapping integral constants to types）	29
2.5	型别对型别的映射（type-to-type mapping）	31
2.6	型别选择（type selection）	 33
2.7	编译期间侦测可转换性（convertibility）和继承性（inheritance）	34
2.8	type_info的一个外覆类（wrapper）	37
2.9	nulltype和emptytype	 39
2.10	type traits	 40
2.11	摘要	 46
第3章	typelists	 49
3.1	typelists的必要性 49
3.2	定义typelists	 51
3.3	将typelist的生成线性化（linearizing）	52
3.4	计算长度	 53
3.5	间奏曲	 54
3.6	索引式访问（indexed access）	55
3.7	查找typelists	 56
3.8	附加元素至typelists	 57
3.9	移除typelist中的某个元素	58
3.10	移除重复元素（erasing duplicates）59
3.11	取代typelist中的某个元素	60
3.12	为typelists局部更换次序（partially ordering）	61
3.13	运用typelists自动产生classes	 64
3.14	摘要	 74
3.15	typelist要点概览	 75
第4章	小型对象分配技术（small-object allocation）	 77
4.1	缺省的free store分配器	 78
4.2	内存分配器的工作方式	 78
4.3	小型对象分配器（small-object allocator）	80
4.4	chunks（大块内存）	 81
4.5	大小一致（fixed-size）的分配器	84
4.6	smallobjallocator class	 87
4.7	帽子下的戏法	 89
4.8	简单，复杂，终究还是简单	92
4.9	使用细节	 93
4.10	摘要	 94
4.11	小型对象分配器（small-object allocator）要点概览	94
第二篇	组件（components）	 97
第5章	泛化仿函数（generalized functors）	99
5.1	command设计模式	 100
5.2	真实世界中的command	 102
5.3	c++ 中的可呼叫体（callable entities）	 103
5.4	functor class template骨干	104
5.5	实现“转发式”（forwarding）functor::operator()	 108
5.6	处理仿函数	 110
5.7	做一个，送一个	 112
5.8	引数（argument）和返回型别（return type）的转换	 114
5.9	处理pointer to member function（成员函数指针）	 115
5.10	绑定（binding）	 119
5.11	将请求串接起来（chaining requests）	122
5.12	现实世界中的问题之1：转发式函数的成本	122
5.13	现实世界中的问题之2：heap分配	 124
5.14	通过functor实现undo和redo	 125
5.15	摘要	 126
5.16	functor要点概览	 126
第6章	singletons（单件）实现技术	 129
6.1	静态数据 + 静态函数 != singleton	130
6.2	用以支持singleton的一些c++ 基本手法	131
6.3	实施“singleton的唯一性”	 132
6.4	摧毁singleton	 133
6.5	dead（失效的）reference问题	 135
6.6	解决dead reference问题（i）：phoenix singleton	 137
6.7	解决dead reference问题（ii）：带寿命的singletons	139
6.8	实现“带寿命的singletons”	 142
6.9	生活在多线程世界	 145
6.10	将一切组装起来	 148
6.11	使用singletonholder	 153
6.12	摘要	 155
6.13	singletonholder class template要点概览	155
第7章	smart pointers（智能指针）	157
7.1	smart pointers基础	157
7.2	交易	 158
7.3	smart pointers的存储	160
7.4	smart pointer的成员函数	161
7.5	拥有权（ownership）管理策略	 163
7.6	address-of（取址）操作符	 170
7.7	隐式转换（implicit conversion）至原始指针型别	 171
7.8	相等性（equality）和不等性（inequality）	 173
7.9	次序比较（ordering comparisons）	178
7.10	检测及错误报告（checking and error reporting）	 181
7.11	smart pointers to const和const smart pointers	 182
7.12	arrays	 183
7.13	smart pointers和多线程（multithreading）	184
7.14	将一切组装起来	187
7.15	摘要	 194
7.16	smartptr要点概览194
第8章	object factories（对象工厂）	197
8.1	为什么需要object factories	198
8.2	object factories in c++：classes和objects	200
8.3	实现一个object factory	 201
8.4	型别标识符（type identifiers）	206
8.5	泛化（generalization）	 207
8.6	细节琐务	210
8.7	clone factories（克隆工厂、翻制工厂、复制工厂）	211
8.8	通过其他泛型组件来使用object factories	 215
8.9	摘要	 216
8.10	factory class template要点概览	 216
8.11	clonefactory class template要点概览	217
第9章	abstract factory（抽象工厂）	219
9.1	abstract factory扮演的体系结构角色（architectural role）	219
9.2	一个泛化的abstract factory接口	 223
9.3	实作出abstractfactory	 226
9.4	一个prototype-based abstract factory实作品	228
9.5	摘要	233
9.6	abstractfactory和concretefactory要点概览	233
第10章	visitor（访问者、视察者）	235
10.1	visitor 基本原理	235
10.2	重载（overloading）：catch-all函数	 242
10.3	一份更加精炼的实作品：acyclic visitor	 243
10.4	visitor之泛型实作	248
10.5	再论 "cyclic" visitor	255
10.6	变化手段	 258
10.7	摘要	 260
10.8	visitor泛型组件要点概览	 261
第11章	multimethods	 263
11.1	什么是multimethods?	264
11.2	何时需要multimethods？	264
11.3	double switch-on-type：暴力法	265
11.4	将暴力法自动化	 268
11.5	暴力式dispatcher 的对称性	273
11.6	对数型（logarithmic）double dispatcher	276
11.7	fndispatcher 和对称性	 282
11.8	double dispatch（双重分派）至仿函数（functors）	282
11.9	引数的转型：static_cast或dynamic_cast？	 285
11.10	常数时间的multimethods：原始速度（raw speed）	290
11.11	将basicdispatcher 和basicfastdispatcher当做policies	293
11.12	展望	294
11.13	摘要	296
11.14	double dispatcher要点概览	297
附录	一个超迷你的多线程程序库（a minimalist multithreading library）	301
a.1	多线程的反思	302
a.2	loki的作法	303
a.3	整数型别上的原子操作（atomic operations）	303
a.4	mutexes（互斥器）	305
a.5	面向对象编程中的锁定语意（locking semantics）	306
a.6	可有可无的（optional）volatile标识符	308
a.7	semaphores, events和其他好东西	 309
a.8	摘要	309
参考书目（bibliography）	311
索引（index）	 313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++设计新思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>线性代数及其应用（原书第5版）
译者序
前言
给学生的注释
关于作者
第1章 线性代数中的线性方程组1
介绍性实例 经济学与工程中的线性模型1
1.1 线性方程组2
1.2 行化简与阶梯形矩阵12
1.3 向量方程23
1.4 矩阵方程34
1.5 线性方程组的解集42
1.6 线性方程组的应用49
1.7 线性无关55
1.8 线性变换介绍62
1.9 线性变换的矩阵71
1.10 商业、科学和工程中的线性模型81
补充习题90
第2章 矩阵代数93
介绍性实例 飞机设计中的计算机模型93
2.1 矩阵运算94
2.2 矩阵的逆103
2.3 可逆矩阵的特征112
2.4 分块矩阵117
2.5 矩阵因式分解123
2.6 列昂惕夫投入产出模型132
2.7 计算机图形学中的应用137
2.8 (n的子空间145
2.9 维数与秩153
补充习题160
第3章 行列式162
介绍性实例 随机过程和畸变162
3.1 行列式介绍163
3.2 行列式的性质168
3.3 克拉默法则、体积和线性变换176
补充习题184
第4章 向量空间187
介绍性实例 空间飞行与控制系统187
4.1 向量空间与子空间188
4.2 零空间、列空间和线性变换197
4.3 线性无关集和基206
4.4 坐标系214
4.5 向量空间的维数223
4.6 秩229
4.7 基的变换236
4.8 差分方程中的应用242
4.9 马尔可夫链中的应用251
补充习题260
第5章 特征值与特征向量263
介绍性实例 动力系统与斑点猫头鹰263
5.1 特征向量与特征值264
5.2 特征方程271
5.3 对角化278
5.4 特征向量与线性变换285
5.5 复特征值292
5.6 离散动力系统298
5.7 微分方程中的应用307
5.8 特征值的迭代估计315
补充习题321
第6章 正交性和最小二乘法325
介绍性实例 北美地质资料和GPS导航325
6.1 内积、长度和正交性326
6.2 正交集334
6.3 正交投影343
6.4 格拉姆-施密特方法350
6.5 最小二乘问题356
6.6 线性模型中的应用365
6.7 内积空间373
6.8 内积空间的应用381
补充习题387
第7章 对称矩阵和二次型390
介绍性实例 多波段的图像处理390
7.1 对称矩阵的对角化391
7.2 二次型397
7.3 条件优化404
7.4 奇异值分解411
7.5 图像处理和统计学中的应用421
补充习题428
第8章 向量空间的几何学430
介绍性实例 柏拉图多面体430
8.1 仿射组合431
8.2 仿射无关性438
8.3 凸组合448
8.4 超平面454
8.5 多面体462
8.6 曲线与曲面474
附录A 简化阶梯形矩阵的唯一性485
附录B 复数486
术语表491
奇数习题答案506
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>线性代数及其应用（原书第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>测试驱动的嵌入式C语言开发
对本书的赞誉
译者序
推荐序一
推荐序二
前言
致谢
第1章 测试驱动开发  1
1.1 为什么我们需要TDD  2
1.2 什么是测试驱动开发  3
1.3 TDD的机理  4
1.4 TDD的微循环  5
1.5 TDD的好处  7
1.6 对于嵌入式开发的益处  7
第一部分 开始
第2章 测试驱动开发的工具和约定  9
2.1 什么是自动化单元测试框架  9
2.2 Unity：一个全部用C实现的自动化测试框架  10
2.3 CppUTest：一个用C++实现的自动化单元测试框架  16
2.4 单元测试也会崩溃  19
2.5 “四阶段”模式  19
2.6 我们到哪里了  19
第3章 开始一个C语言模块  21
3.1 具有可测性的C模块的那些元素  21
3.2 LED驱动都做些什么  22
3.3 写一个测试列表  23
3.4 写第一个测试  23
3.5 先测试驱动接口再测试驱动内部实现  29
3.6 增量式前进  34
3.7 测试驱动开发者的状态机  36
3.8 测试要做到FIRST  37
3.9 我们到哪里了  37
第4章 一路测试直到完成  39
4.1 从简单入手“生长”出解决方案  39
4.2 保持代码整洁——边做边重构  53
4.3 重复直到完成  55
4.4 声明完成之前先向回走一步  61
4.5 我们到哪里了  61
第5章  嵌入式系统TDD策略  63
5.1 目标硬件的瓶颈  63
5.2 双目标开发的好处  64
5.3 双目标测试的风险  65
5.4 嵌入式的TDD循环  65
5.5 双目标的不兼容性  67
5.6 和硬件一起测试  71
5.7 欲速则不达  74
5.8 我们到哪里了  74
第6章 是的，但是……  75
6.1 我们没那个时间  75
6.2 为什么不在写了代码之后再写测试  77
6.3 测试也需要维护  78
6.4 单元测试不能发现所有的bug  78
6.5 我们的构建时间太长  79
6.6 我们有现存的代码  79
6.7 我们的内存有约束  79
6.8 我们不得不和硬件交互  80
6.9 为什么要用C++的测试框架来测试C  81
6.10 我们到哪里了  81
第二部分 测试有合作者的模块
第7章 测试替身  83
7.1 合作者  83
7.2 脱离依赖关系  84
7.3 何时使用测试替身  86
7.4 用C来仿冒，下一步  88
7.5 我们到哪里了  89
第8章 监视产品代码  90
8.1 灯光调度测试列表  90
8.2 对于硬件和操作系统的依赖  91
8.3 链接时代换  92
8.4 监视被测试代码  93
8.5 控制时钟  97
8.6 先0后  198
8.7 处理多个的情况  110
8.8 我们到哪里了  115
第9章 运行时绑定的测试替身  116
9.1 测试随机性  116
9.2 冒仿函数指针  118
9.3 外科手术般地插入间谍  120
9.4 用间谍来校验输出  124
9.5 我们到哪里了  127
第10章 仿制对象  129
10.1 闪存驱动程序  129
10.2 MockIO  136
10.3 测试驱动开发驱动程序  138
10.4 模拟设备超时  142
10.5 这值得吗  144
10.6 用CppUMock来仿制  144
10.7 生成仿制对象  147
10.8 我们到哪里了  148
第三部分 设计与持续改进
第11章 SOLID、灵活并可测试的设计  149
11.1 SOLID设计原则  150
11.2 C语言中的SOLID模型  152
11.3 演进的需求和有问题的设计  154
11.4 用动态接口来改进设计  160
11.5 更灵活的基于类型的动态接口  168
11.6 做多少设计才是足够的  171
11.7 我们到哪里了  173
第12章 重构  174
12.1 软件的两个价值  174
12.2 三项关键技能  175
12.3 代码中的坏味道以及如何改进它们  176
12.4 转化代码  184
12.5 那性能和大小怎么办  199
12.6 我们到哪里了  201
第13章 为遗留代码加测试  203
13.1 遗留代码改动准则  203
13.2 童子军原则  204
13.3 遗留代码改动步骤  205
13.4 测试点  206
13.5 两步结构体初始化  209
13.6 崩溃直到通过  211
13.7 鉴别测试  216
13.8 为第三方代码做学习测试  219
13.9 测试驱动缺陷修正  220
13.10 增加策略测试  221
13.11 我们到哪里了  221
第14章 测试的模式与反模式  223
14.1 “喋喋不休”测试反模式  223
14.2 “拷贝－粘贴－调整－重复”反模式  224
14.3 “格格不入的测试用例”反模式  225
14.4  “测试组之间的重复”反模式  227
14.5  “不尊重测试”反模式  228
14.6 “行为驱动开发”测试模式  228
14.7 我们到哪里了  229
第15章 结束语  230
第四部分 附  录
附录A 开发系统的测试环境  233
附录B Unity快速索引  237
附录C CppUTest快速索引  241
附录D 开始之后的LedDriver  245
附录E 操作系统隔离层的例子  248
附录F 参考书目255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>测试驱动的嵌入式C语言开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑模式语言（上下）
上册
本书使用说明
1 《建筑模式语言》
2 《建筑模式语言》概要
3 为你的设计选用模式语言
4 诗意盎然的模式语言
一、城镇  使用语言模式
下册
二、建筑  使用语言模式
三、构造  使用语言模式
四、城镇  使用语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>建筑模式语言（上下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度探索C++对象模型
本立道生(侯捷 译序)III目录VII前言(Stanley B. Lippman)XIII第0章  导读(译者的话)XXV第1章  关于对象(Object Lessons)1    加上封装后的布局成本(Layout Costs for Adding Encapsulation)5  1.1　C++对象模式(The C++ Object Model)6    简单对象模型(A Simple Object Model)7    表格驱动对象模型(A Table-driven Object Model)8    C++对象模型(The C++ Object Model)9    对象模型如何影响程序(How the Object Model Effects Programs)13  1.2  关键词所带来的差异(A Keyword Distinction)15    关键词的困扰16    策略性正确的struct(The Politically Correct Struct)19  1.3  对象的差异(An Object Distinction)22    指针的类型(The Type of a Pointer)28    加上多态之后(Adding Polymorphism)29第2章  构造函数语意学(The Semantics of Constructors)37  2.1  Default Constructor的构造操作39    “带有Default Constructor”的Member Class Object41    “带有Default Constructor”的Base Class44    “带有一个Virtual Function”的Class44    “带有一个Virtual Base Class”的Class46    总结47  2.2  Copy Constructor的构造操作48    Default Memberwise Initialization49    Bitwise Copy Semantics(位逐次拷贝)51    不要Bitwise Copy Semantics！53    重新设定Virtual Table的指针54    处理Virtual Base Class Subobject57  2.3  程序转化语意学(Program Transformation Semantics)60    显式的初始化操作(Explicit Initialization)61    参数的初始化(Argument Initialization)62    返回值的初始化(Return Value Initialization)63    在使用者层面做优化(Optimization at the User Level)65    在编译器层面做优化(Optimization at the Compiler Level)66    Copy Constructor：要还是不要？72    摘要74  2.4  成员们的初始化队伍(Member Initialization List)74第3章  Data语意学(The Semantics of Data)83  3.1  Data Member的绑定(The Binding of a Data Member)88  3.2  Data Member的布局(Data Member Layout)92  3.3  Data Member的存取94    Static Data Members95    Nonstatic Data Members97  3.4 “继承”与Data Member99    只要继承不要多态(Inheritance without Polymorphism)100    加上多态(Adding Polymorphism)107    多重继承(Multiple Inheritance)112    虚拟继承(Virtual Inheritance)116  3.5  对象成员的效率(Object Member Efficiency)124  3.6  指向Data Members的指针(Pointer to Data Members)129    “指向Members的指针”的效率问题134第4章  Function语意学(The Semantics of Function)139  4.1  Member的各种调用方式140    Nonstatic Member Functions(非静态成员函数)141    Virtual Member Functions(虚拟成员函数)147    Static Member Functions(静态成员函数)148  4.2  Virtual Member Functions(虚拟成员函数)152    多重继承下的Virtual Functions159    虚拟继承下的Virtual Functions168  4.3  函数的效能170  4.4  指向Member Function的指针(Pointer-to-Member Functions)174    支持“指向Virtual Member Functions”的指针176    在多重继承之下，指向Member Functions的指针178    “指向Member Functions之指针”的效率180  4.5  Inline Functions182    形式参数(Formal Arguments)185    局部变量(Local Variables)186第5章  构造、析构、拷贝语意学(Semantics of Construction,    Destruction, and Copy)191    纯虚函数的存在(Presence of a Pure Virtual Function)193    虚拟规格的存在(Presence of a Virtual Specification)194    虚拟规格中const的存在195    重新考虑class的声明195  5.1 “无继承”情况下的对象构造196    抽象数据类型(Abstract Data Type)198    为继承做准备202  5.2  继承体系下的对象构造206    虚拟继承(Virtual Inheritance)210    vptr初始化语意学(The Semantics of the vptr Initialization)213  5.3  对象复制语意学(Object Copy Semantics)219  5.4  对象的效能(Object Efficiency)225  5.5  析构语意学(Semantics of Destruction)231第6章  执行期语意学(Runtime Semantics)237  6.1  对象的构造和析构(Object Construction and Destruction)240    全局对象(Global Objects)242    局部静态对象(Local Static Objects)247    对象数组(Array of Objects)250    Default Constructors和数组252  6.2  new和delete运算符254    针对数组的new语意257    Placement Operator new的语意263  6.3  临时性对象(Temporary Objects)267    临时性对象的迷思(神话、传说)275第7章  站在对象模型的尖端(On the Cusp of the Object Model)279  7.1  Template280    Template的“实例化”行为(Template Instantiation)281    Template的错误报告(Error Reporting within a Template)285    Template中的名称决议法(Name Resolution within a Template)289    Member Function的实例化行为(Member Function Instantiation)292  7.2  异常处理(Exception Handling)297    Exception Handling快速检阅298    对Exception Handling的支持303  7.3  执行期类型识别(Runtime Type Identification，RTTI)308    Type-Safe Downcast(保证安全的向下转换操作)310    Type-Safe Dynamic Cast(保证安全的动态转换)311    References并不是Pointers313    Typeid运算符314  7.4  效率有了，弹性呢？318    动态共享函数库(Dynamic Shared Libraries)318    共享内存(Shared Memory)318
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度探索C++对象模型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity 5实战
目录
第Ⅰ部分起步
第1章初识Unity
1.1为什么Unity如此优秀
1.1.1Unity的优势
1.1.2要意识到的缺点
1.1.3使用Unity构建的游戏案例
1.2如何使用Unity
1.2.1Scene视图、Game视图和工具栏
1.2.2使用鼠标和键盘
1.2.3Hierarchy标签和Inspector
1.2.4Project和Console标签
1.3开始使用Unity编程
1.3.1代码在Unity中是如何运行的：脚本组件
1.3.2使用MonoDevelop，跨平台的DE
1.3.3打印到控制台：HelloWbrld！
1.4小结
第2章构建一个让你置身3D空间的演示
2.1在开始之前
2.1.1对项目做计划
2.1.2了解3D坐标空间
2.2开始项目：在场景中放置对象
2.2.1第二步：地板、外墙和内墙
2.2.2灯光和摄像机
2.2.3玩家的碰撞器和视口
2.3让东西移动：应用变换的脚本
2.3.1图示说明如何通过编程实现旋转
2.3.2编写代码实现图中演示的运动
2.3.3本地和全局坐标空间
2.4用于观察周围的组件脚本：MouseLook
2.4.1跟踪鼠标运动的水平旋转
2.4.2在一定范围内的垂直旋转
2.4.3同时水平和垂直旋转
2.5键盘输入组件：第一人称控件
2.5.1响应按下的键
2.5.2设置独立于计算机运行速度的运动速率
2.5.3为了碰撞检测，移动CharacterController
2.5.4调整组件为走路而不是飞翔
2.6小结
第3章为3D游戏添加敌人和子弹
3.1通过射线射击
3.1.1什么是射线发射
3.1.2使用命令ScreenPointToRay来发射
3.1.3为准心和击中点添加可视化提示
3.2脚本化反应的目标
3.2.1确定被击中的对象
3.2.2警告目标它被击中
3.3基本漫游AI
3.3.1图解基础AI的工作原理
3.3.2使用射线发射发现障碍物
3.3.3跟踪角色状态
3.4产生敌人预设
3.4.1什么是预设
3.4.2创建敌人预设
3.4.3在不可见的SceneController中实例化
3.5通过实例化对象进行射击
3.5.1创建子弹预设
3.5.2发射子弹并和目标碰撞
3.5.3伤害玩家
3.6小结
第4章为游戏开发图形
4.1了解美术资源
4.2构建基础3D场景：白盒
4.2.1白盒的解释
4.2.2为关卡绘制地板平面图
4.2.3根据平面图布局几何体
4.3使用2D图像给场景贴图
4.3.1选择文件格式
4.3.2导入图像文件
4.3.3应用图像
4.4使用贴图图像产生天空视觉效果
4.4.1什么是天空盒
4.4.2创建一个新天空盒材质
4.5使用自定义3D模型
4.5.1选择文件格式
4.5.2导出和导入模型
4.6使用粒子系统创建效果
4.6.1调整默认效果的参数
4.6.2为火焰应用新贴图
4.6.3将粒子效果附加到3D对象上
4.7小结
第Ⅱ部分轻松工作
第5章使用Unity新的2D功能构建一款记忆力游戏
5.1设置2D图形
5.1.1为项目做准备
5.1.2显示2D图像（亦称精灵）
5.1.3将摄像机切换为2D模式
5.2构建卡片对象并让它响应单击
5.2.1从精灵构建对象
5.2.2鼠标输入代码
5.2.3当单击时显示卡片
5.3显示不同的卡片图像
5.3.1通过程序加载图像
5.3.2通过不可见的SceneController来设置图像
5.3.3实例化一个网格的卡片
5.3.4打乱卡片
5.4实现匹配和匹配得分
5.4.1保存并比较翻开的卡片
5.4.2隐藏错误卡片
5.4.3显示积分的文本
5.5重启按钮
5.5.1使用SendMessage编写UIButton组件
5.5.2从SceneController中调用LoadLevel
5.6小结
第6章在3D游戏中放置2D图形用户界面
6.1在开始写代码之前
6.1.1直接模式GUI还是高级2D界面
6.1.2规划布局
6.1.3导入UI图像
6.2设置GUI显示
6.2.1为界面创建画布
6.2.2按钮、图像和文本标签
6.2.3控制UI元素的位置
6.3编写UI中的交互
6.3.1编写不可见的UIController
6.3.2创建弹出窗口
6.3.3使用滑动条和输入域设置值
6.4通过响应事件更新游戏
6.4.1集成事件系统
6.4.2从场景中广播和侦听事件
6.4.3从HUD广播和侦听事件
6.5小结
第7章创建第三人称3D游戏：玩家移动和动画
7.1调整摄像机视图为第三人称视角
7.1.1导入一个用于观察的角色
7.1.2将阴影添加到场景
7.1.3摄像机环绕玩家角色
7.2编写程序控制camera—relative的移动
7.2.1旋转角色，以朝向移动方向
7.2.2朝着方向向前移动
7.3实现跳跃动作
7.3.1应用垂直速度和加速度
7.3.2修改地面检测来处理边缘和斜坡
7.4设置玩家角色上的动画
7.4.1在导入的模型上定义动画剪辑
7.4.2为动画创建动画控制器
7.4.3编写操作Animator组件的代码
7.5小结
第8章在游戏中添加交互设施和物件
8.1创建门和其他设施
8.1.1由按键控制开／关的门
8.1.2在开门之前检查距离和朝向
8.1.3创建一个变色监控器
8.2通过碰撞与对象交互
8.2.1和具有物理功能的障碍物碰撞
8.2.2用一个压力板来触发门
8.2.3收集当前关卡游戏中分散的物件
8.3管理仓库数据和游戏状态
8.3.1设置玩家和仓库管理器
8.3.2编程实现游戏管理器
8.3.3把物品存储在集合对象中：List与Dictionary
8.4使用和装备物品的仓库UI
8.4.1在UI中显示仓库物品
8.4.2装备一个用来开门的钥匙
8.4.3通过使用血量包来恢复玩家的血量
8.5小结
第Ⅲ部分冲刺阶段
第9章将游戏连接到互联网
9.1创建户外场景
9.1.1使用天空盒生成天空视觉效果
9.1.2通过代码设置大气环境
9.2从互联网服务下载天气数据
9.2.1使用协程请求WWW数据
9.2.2解析XML
9.2.3解析JSON
9.2.4基于天气数据影响场景
9.3添加一个网络布告栏
9.3.1从互联网加载图像
9.3.2在布告栏上显示图像
9.3.3缓存下载的图像以供重用
9.4将数据发送到Web服务器
9.4.1跟踪当前的天气：发送post请求
9.4.2PHP中的服务器端代码
9.5小结
第10章播放音频：音效和音乐
10.1导入音效
10.1.1所支持的文件格式
10.1.2导入音频文件
10.2播放音效
10.2.1音频剪辑、音源和声音侦听器
10.2.2设定一个循环声音
10.2.3从代码触发音效
10.3音频控制接口
10.3.1建立中心AudioManager
10.3.2音量控制UI
10.3.3播放UI声音
10.4背景音乐
10.4.1播放循环音乐
10.4.2独立控制音乐的音量
10.4.3歌曲间的淡入淡出
10.5小结
第11章将各部分整合为一个完整的游戏
11.1再次利用项目来构建角色扮演RPG
11.1.1将多个项目的资源和代码装配在一起
11.1.2编写指向单击的控件：移动和设备
11.1.3使用新界面替换旧GUI
11.2开发总体的游戏结构
11.2.1控制任务流和多关卡
11.2.2通过到达退出条件完成一个关卡
11.2.3当被敌人捕捉时关卡失败
11.3处理玩家游戏过程中的进度
11.3.1保存并加载玩家进度
11.3.2通过完成三个关卡打败游戏
11.4小结
第12章将游戏部署到玩家的设备
12.1构建桌面环境：Windows、Mac和Linux
12.1.1构建应用
12.1.2调整Player Settings：设置游戏的名称和图标
12.1.3平台依赖的编译
12.2为Web构建游戏
12.2.1Unity Player和HTMUWebGL
12.2.2构建Unity文件和一个测试Web页面
12.2.3与浏览器中的JavaScript通信
12.3构建移动应用的平台：iOS和Android
12.3.1设置构建工具
12.3.2贴图压缩
12.3.3开发插件
12.4小结
附录A场景导航和键盘快捷键
A.1使用鼠标进行场景导航
A.2一般使用键盘快捷键
附录B与Unity一同使用的外部工具
B.1编程工具
B.1.1Visual Studio
B.1.2Xcode
B.1.3Android SDK
B.1.4SVN、Git或Mercurial
B.23D美术应用
B.2.1Maya
B.2.23dsMax
B.2.3Blender
B.32D图像编辑器
B.3.1Photoshop
B.3.2GMP
B.3.311exturePacker
B.4音频软件
B.4.1Pro Tools
B.4.2Audacity
附录C在Blender中建模一个板凳
C.1构建网格几何体
C.2模型贴图映射
附录D在线学习资源
D.1附加的指南
D.2代码库
后序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity 5实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白领
《白领》、中产阶级与中国的误读（代译序）
导言
第一部 老式中产阶级
第一章 小业主的世界
1．老式中产阶级
2．财产、自由和安全
3．自平衡社会
第二章 财产的转化
1．乡村的崩溃
2．商业发展的动力
3．游民资产阶级
第三章 竞争的修辞学
1．竞争性的生活方式
2．独立农场主
3．小企业的前哨
4．政治的持续性
第二部 白领的世界
第四章 新中产阶级：I
1．职业变化
2．工业结构
3．白领金字塔
第五章 管理官员
1．科层制
2．从上到下
3．领班的情况
4．新型企业家
5．管理者的权力
6．三大趋势
第六章 旧职业和新技能
1．专门职业和科层制
2．医学界
3．律师
4．教授
5．商业和专门职业
第七章 智力有限公司
1．四大阶段
2．科层制的社会背景
3．意识形态的需要
4．技术人员的崛起
第八章 大卖场
1．销售员的种类
2．世界ZUI大的百货商店
3．进货员和巡视员
4．售货小姐
5．销售的集中化
6．人格市场
第九章 巨大的文件堆
1．旧式办公室
2．权势和发展
3．白领姑娘
4．新式办公室
5．白领等级
第三部 生活方式
第十章 工作
1．工作的意义
2．手工艺人的理想
3．现代工作条件
4．接受的构架
5．愉悦的机器人士气
6．巨大的裂隙
第十一章 地位恐慌
1．白领的声望
2．小城市
3．大都市
4．地位恐慌
第十二章 成功
1．模式与意识形态
2．教育的提升机
3．出身和流动
4．艰难岁月
5．黯淡的形象
第四部 权力的路径
第十三章 新中产阶级：Ⅱ
1．理论与困境
2．心态
3．组织
第十四章 白领工联主义
1．组织化的程度
2．接受和拒绝
3．个体的卷入
4．工联主义的塑造
5．工会和政治
第十五章 后卫政治
1．意识的模式
2．政治冷漠
3．大众媒介
4．社会结构
5．美国政治
6．后卫
致谢和资料来源
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白领
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>制度、制度变迁与经济绩效
出版前言
代译序一再评诺思
的制度变迁理论
前言
第1篇 制度
1 制度与制度变迁绪论
2 合作：理论问题
3 制度理论中的行为假定
4 关于交换的交易费用理论
5 非正式约束
6 正式约束
7 实施
8 制度与交易费用和转形成本
第2篇 制度变迁
9 组织、学习与制度变迁
10 稳定性与制度变迁
11 制度变迁的路径
第3篇 经济绩效
12 制度、经济理论与经济绩效
13 经济史上的稳定与变迁
14 制度分析与经济史的结合：前景与疑难
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>制度、制度变迁与经济绩效
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微观动机与宏观行为
第1章 微观动机和宏观行为
目的性行为
市场行为
均衡分析
交换和其他交易行为
人为市场和局部市场
互动行为
第2章 抢凳子游戏中必要的数学分析
概念的定义
两类群体的匹配
两类群体的分布率
成长的动态学
加速原理
在分配中的地位
排队等候和循环运输系统
漏损和衰退系统
模式和结构
第3章 自动调温器、次品以及其他类似模型集合
社会科学中的模型
临界密度、倾斜以及次品
临界质量图解
公地
自我实现及其他预期
自我约束的传统习俗
社会契约
第4章 分类与融合:种族与性别
个体激励和集体性的结果
一些数量限制
分离的机制
分类和争先恐后
一个自我形成的邻里模式
连锁反应
这是“分隔”状态吗?
有界邻里模式
关于“容忍度”分布的描述
“容忍度”数据的图形转换
位移的动力
另外一些容忍度安排
另外一组数据
种族融合论者的偏好
政策和工具
第5章 分类与融合:年龄与收入
分类与融合的模型
离散的与连续的变量
离散的与连续的行动
限制性恒等式
开放式模型
封闭式模型
封闭模式中的其他偏好
稍微更为一般的公式
第三个房间
分离或不分离的最优性
建模的需要
几个应用
其他的一些“分类变量”
模型的结构
市场上的类比
随着时间流逝而发生的改变
协调性变量
第6章 选择孩子们的基因
选择的菜单
选择的技术
性别选择的特异性
选择孩子们的性别
选择其他特征
选择后代的一些人口学后果
选择后代在文化方面的一些后果
预测，还是猜测?
与传统优生学的对比
一些动机性的或者人口学意义上的结构
为谁而选择?
拥有选择的后果
第7章 曲棍球头盔、夏令时以及其他二元选择
知识和观察
囚徒困境
概念的扩展
重要参数
一些不同的结构
交叉曲线
有条件的外部性
公地
双重均衡
作为不完整双重均衡的MPD
曲线弯曲度
一致性
互补性
充足性
概要总结
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微观动机与宏观行为
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言参考手册
译者序
前　　言
第一部分　C语言
第1章　 概述 2
1.1　 C语言的演变 2
1.1.1　 传统C 2
1.1.2　 标准C（1989） 2
1.1.3　 标准C（1995） 3
1.1.4　 标准C（1999） 3
1.1.5　 标准C++ 4
1.1.6　 本书内容 4
1.2　 应该使用哪种C语言 4
1.3　 C编程概述 5
1.4　 一致性 6
1.5　 语法约定 7
第2章　 词法元素 8
2.1　 字符集 8
2.1.1　 执行字符集 9
2.1.2　 空白字符和行终止符 9
2.1.3　 字符编码 10
2.1.4　 三字符组 10
2.1.5　 多字节字符和宽字符 11
2.2　 注释 13
2.3　 标记 14
2.4　 操作符和分隔符 15
2.5　 标识符 15
2.6　 关键字 17
2.7　 常量 18
2.7.1　 整数常量 18
2.7.2　 浮点数常量 22
2.7.3　 字符常量 23
2.7.4　 字符串常量 25
2.7.5　 转义字符 27
2.7.6　 字符转义码 28
2.7.7　 数值转义码 29
2.8　 C++兼容性 29
2.8.1　 字符集 30
2.8.2　 注释 30
2.8.3　 操作符 30
2.8.4　 标识符和关键字 30
2.8.5　 字符常量 30
2.9　 关于字符集、指令集和编码 30
2.10　 练习 32
第3章　 C预处理器 34
3.1　 预处理器命令 34
3.2　 预处理器词法约定 35
3.3　 定义和替换 36
3.3.1　 类似对象的宏定义 36
3.3.2　 定义带参数的宏 37
3.3.3　 宏表达式的重新扫描 39
3.3.4　 预定义的宏 40
3.3.5　 取消宏定义和重新定义宏 42
3.3.6　 宏展开的优先级错误 42
3.3.7　 宏参数的副作用 43
3.3.8　 把标记转换为字符串 43
3.3.9　宏展开中的标记合并 44
3.3.10　 宏的可变参数列表 45
3.3.11　 其他问题 46
3.4　 文件包含 46
3.5　 条件编译 48
3.5.1　 #if、#else和#endif命令 48
3.5.2　 #elif命令 49
3.5.3　 #ifdef和#ifndef命令 50
3.5.4　 条件命令中的常量表达式 51
3.5.5　 defined操作符 52
3.6　 显式的行号 52
3.7　 pragma指令 53
3.7.1　 标准pragma命令 53
3.7.2　 标准pragma指令的位置 54
3.7.3 _Pragma操作符 54
3.8　 错误指令 54
3.9　 C++兼容性 55
3.10　 练习 55
第4章　 声明 57
4.1　 声明的组织形式 57
4.2　 术语 58
4.2.1　 作用域 58
4.2.2　 可见性 59
4.2.3　 前向引用 59
4.2.4　 名称的重载 60
4.2.5　 重复声明 61
4.2.6　 重复可见性 62
4.2.7　 范围 62
4.2.8　 初始值 63
4.2.9　 外部名称 64
4.2.10　 编译时名称 65
4.3　 存储类别和函数指定符 65
4.3.1　 默认存储类别指定符 66
4.3.2　 存储类别指定符的例子 66
4.3.3　 函数指定符 67
4.4　 类型指定符和限定符 67
4.4.1　 默认类型指定符 68
4.4.2　 缺失的声明器 69
4.4.3　 类型限定符 70
4.4.4　 const 70
4.4.5　 volatile和序列点 72
4.4.6　 restrict 74
4.5　 声明器 75
4.5.1　 简单声明器 75
4.5.2　 指针声明器 76
4.5.3　 数组声明器 77
4.5.4　 函数声明器 78
4.5.5　 声明器的组合 80
4.6　 初始化值 81
4.6.1　 整数 82
4.6.2　 浮点数 83
4.6.3　 指针 83
4.6.4　 数组 84
4.6.5　 枚举 86
4.6.6　 结构 86
4.6.7　 联合 87
4.6.8　 省略花括号 88
4.6.9　 指定成员的初始化值 88
4.7　 隐式声明 89
4.8　 外部名称 90
4.8.1　 初始化值模型 90
4.8.2　 省略的存储类别模型 90
4.8.3　 公共模型 90
4.8.4　 混合公共模型 91
4.8.5　 总结和建议 91
4.8.6　 未引用的外部声明 92
4.9　 C++兼容性 92
4.9.1　 作用域 92
4.9.2　 标签和typedef名称 92
4.9.3　 用于类型的存储类别指定符 93
4.9.4　 const类型限定符 93
4.9.5　 初始化值 93
4.9.6　 隐式声明 93
4.9.7　 定义和引用声明 94
4.9.8　 函数链接 94
4.9.9　 无参函数 94
4.10　 练习 94
第5章　 类型 97
5.1　 整数类型 98
5.1.1　 有符号整数类型 98
5.1.2　 无符号整数类型 101
5.1.3　 字符类型 102
5.1.4　 扩展整数类型 104
5.1.5　 布尔类型 104
5.2　 浮点类型 104
5.3　 指针类型 108
5.3.1　 通用指针 109
5.3.2　 null指针和非法指针 109
5.3.3　 使用指针的一些警告 110
5.4　 数组类型 111
5.4.1　 数组和指针 111
5.4.2　 多维数组 112
5.4.3　 数组边界 112
5.4.4　 操作 113
5.4.5　 可变长度的数组 113
5.5　 枚举类型 115
5.6　 结构类型 117
5.6.1　 结构类型引用 119
5.6.2　 结构上的操作 120
5.6.3　 成员 120
5.6.4　 结构成员的布局 122
5.6.5　 位段 122
5.6.6　 移植性问题 124
5.6.7　 结构的大小 125
5.6.8　 灵活数组成员 126
5.7　 联合类型 127
5.7.1　 联合成员的布局 127
5.7.2　 联合的大小 128
5.7.3　 使用联合类型 129
5.7.4　 （其他）使用联合类型 130
5.8　 函数类型 131
5.9　 void类型 133
5.10　 typedef名称 133
5.10.1　 用于函数类型的typedef名称 135
5.10.2　 重定义typedef名称 135
5.10.3　 编译器的说明 136
5.11　 类型兼容性 136
5.11.1　 等价的类型 136
5.11.2　 枚举兼容性 137
5.11.3　 数组兼容性 138
5.11.4　 函数兼容性 138
5.11.5　 结构和联合兼容性 139
5.11.6　 指针兼容性 139
5.11.7　 源文件之间的兼容性 139
5.12　 类型名称和抽象声明器 139
5.13　 C++兼容性 141
5.13.1　 枚举类型 141
5.13.2　 typedef名称 141
5.13.3　 类型兼容性 141
5.14　 练习 141
第6章　 转换和表示形式 144
6.1　 表示形式 144
6.1.1　 存储单位和数据长度 144
6.1.2　 字节顺序 145
6.1.3　 对齐限制 146
6.1.4　 指针的长度 147
6.1.5　 地址模型的效果 147
6.1.6　 类型表示形式 149
6.2　 转换 150
6.2.1　 表示形式的变化 150
6.2.2　 细微的转换 150
6.2.3　 转换为整数类型 150
6.2.4　 转换为浮点类型 152
6.2.5　 转换为结构和联合类型 152
6.2.6　 转换为枚举类型 152
6.2.7　 转换为指针类型 152
6.2.8　 转换为数组和函数类型 153
6.2.9　 转换为void类型 153
6.3　 寻常转换 154
6.3.1　 类型转换 154
6.3.2　 赋值转换 154
6.3.3　 寻常单目转换 155
6.3.4　 寻常双目转换 157
6.3.5　 默认的函数实参转换 158
6.3.6　 其他函数转换 159
6.4　 C++兼容性 159
6.5　 练习 159
第7章　 表达式 161
7.1　 对象、左值和指示符 161
7.2　 表达式和优先级 162
7.2.1　 操作符的优先级和结合性 162
7.2.2　 溢出和其他算术异常 163
7.3　 基本表达式 164
7.3.1　 名称 164
7.3.2　 字面值 165
7.3.3　 带括号的表达式 165
7.4　 后缀表达式 166
7.4.1　 下标表达式 166
7.4.2　 成员选择 168
7.4.3　 函数调用 169
7.4.4　 后缀增值和减值操作符 171
7.4.5　 复合字面值 172
7.5　 单目表达式 173
7.5.1　 类型转换 174
7.5.2　 sizeof操作符 174
7.5.3　 单目负号和正号 176
7.5.4　 逻辑反 176
7.5.5　 位反 177
7.5.6　 取地址操作符 177
7.5.7　 间接访问 178
7.5.8　 前缀增值和减值操作符 179
7.6　 双目操作符表达式 180
7.6.1　 乘除操作符 180
7.6.2　 加减操作符 182
7.6.3　 移位操作符 183
7.6.4　 关系操作符 185
7.6.5　 相等操作符 186
7.6.6　 位操作符 188
7.6.7　 整数集合的例子 189
7.7　 逻辑操作符表达式 192
7.8　 条件表达式 194
7.9　 赋值表达式 195
7.9.1　 简单赋值 196
7.9.2　 复合赋值 197
7.10　 线性表达式 197
7.11　 常量表达式 198
7.11.1　 预处理器常量表达式 199
7.11.2　 整型常量表达式 200
7.11.3　 初始化值常量表达式 200
7.12　 求值的顺序 201
7.13　 被丢弃的值 202
7.14　 内存访问的优化 203
7.15　 C++兼容性 204
7.16　 练习 204
第8章　 语句 206
8.1　 语句的基本语法规则 206
8.2　 表达式语句 207
8.3　 标签语句 207
8.4　 复合语句 208
8.5　 条件语句 210
8.5.1　 多路条件语句 210
8.5.2　 悬疑的else问题 211
8.6　 迭代式语句 212
8.6.1　 while语句 212
8.6.2　 do语句 213
8.6.3　 for语句 214
8.6.4　 使用for语句 215
8.6.5　 多个控制变量 217
8.7　 switch语句 218
8.8　 break和continue语句 220
8.9　 return语句 222
8.10　 goto语句 223
8.11　 空语句 224
8.12　 C++兼容性 224
8.12.1　 复合语句 224
8.12.2　 循环中的声明 224
8.13　 练习 225
第9章　 函数 226
9.1　 函数定义 226
9.2　 函数原型 228
9.2.1　 原型出现在什么时候 230
9.2.2　 混合使用原型和非原型声明 230
9.2.3　 合理地使用原型 231
9.2.4　 原型和调用约定 231
9.2.5　 标准C和传统C的兼容性 233
9.3　 形式参数声明 233
9.4　 形参类型的调整 235
9.5　 参数传递约定 236
9.6　 形参的一致 237
9.7　 函数的返回类型 238
9.8　 返回类型的一致 239
9.9　 main函数 239
9.10　 内联函数 240
9.11　 C++兼容性 242
9.11.1　 原型 242
9.11.2　 形参和返回类型中的类型声明 242
9.11.3　 返回类型的一致 242
9.11.4　 main 242
9.11.5　 内联 243
9.12　 练习 243
第二部分　 C函数库
第10章　 函数库简介 246
10.1　 标准C工具 246
10.2　 C++兼容性 247
10.3　 库头文件和名称 249
10.3.1　 assert.h 249
10.3.2　 complex.h 249
10.3.3　 ctype.h 249
10.3.4　 errno.h 249
10.3.5　 fenv.h 249
10.3.6　 float.h 250
10.3.7　 inttypes.h 250
10.3.8　 iso64.h 250
10.3.9　 limits.h 250
10.3.10　 locale.h 250
10.3.11　 math.h 251
10.3.12　 setjmp.h 252
10.3.13　 signal.h 252
10.3.14　 stdarg.h 252
10.3.15　 stdbool.h 252
10.3.16　 stddef.h 252
10.3.17　 stdint.h 252
10.3.18　 stdio.h 252
10.3.19　 stdlib.h 253
10.3.20　 string.h 253
10.3.21　 tgmath.h 253
10.3.22　 time.h 254
10.3.23　 wchar.h 254
10.3.24　 wctype.h 254
第11章　 标准语言附加 255
11.1　 NULL、ptrdiff_t、size_t、offsetof 255
11.2　 EDOM、ERANGE、EILSEQ、errno、
strerror、perror 256
11.3　 bool、false、true 257
11.4　 va_list、va_start、va_arg、va_end 258
11.5　 标准C的操作符宏 261
第12章　 字符处理 262
12.1　 isalnum、isalpha、iscntrl、iswalnum、iswalpha、iswcntrl 262
12.2　 iscsym、iscsymf 264
12.3　 isdigit、isodigit、isxdigit、iswdigit、iswxdigit 264
12.4　 isgraph、isprint、ispunct、iswgraph、iswprint、iswpunct 265
12.5　 islower、isupper、iswlower、iswupper 266
12.6　 isblank、isspace、iswhite、iswspace 266
12.7　 toascii 267
12.8　 toint 267
12.9　 tolower、toupper、towlower、
towupper 267
12.10　 wctype_t、wctype、iswctype 268
12.11　 wctrans_t、wctrans 269
第13章　 字符串处理 270
13.1　 strcat、strncat、wcscat、wcsncat 270
13.2　 strcmp、strncmp、wcscmp、wcsncmp 271
13.3　 strcpy、strncpy、wcscpy、cscncpy 272
13.4　 strlen、wcslen 273
13.5　 strchr、strrchr、wcschr、wcsrchr 273
13.6　 strspn、strcspn、strpbrk、strrpbrk、
wcsspn、wcscspn、wcspbrk 274
13.7　 strstr、strtok、wcsstr、wcstok 275
13.8　 strtod、strtof、strtold、strtol、strtoll、strtoul、strtoull 276
13.9　 atof、atoi、atol、atoll 277
13.10　 strcoll、strxfrm、wcscoll、wcsxfrm 277
第14章　 内存函数 279
14.1　 memchr、wmemchr 279
14.2　 memcmp、wmemcmp 279
14.3　 memcpy、memccpy、memmove、wmemcpy、wmemmove 280
14.4　 memset、wmemset 281
第15章　 输入/输出工具 282
15.1　 FILE、EOF、wchar_t、WEOF 283
15.2　 fopen、fclose、fflush、freopen、
fwide 284
15.2.1　 文件模式 285
15.2.2　 文件的定向 286
15.3　 setbuf、setvbuf 287
15.4　 stdin、stdout、stderr 287
15.5　 fseek、ftell、rewind、fgetpos、
fsetpos 288
15.5.1　 fseek和ftell 287
15.5.2　 fgetpos和fsetpos 290
15.6　 fgetc、fgetwc、getc、getwc、getchar、getwchar、ungetc、ungetwc 290
15.7　 fgets、fgetws、gets 291
15.8　 fscanf、fwscanf、scanf、wscanf、
sscanf、swscanf 292
15.8.1　 控制字符串 293
15.8.2　 转换规范 293
15.9　 fputc、fputwc、putc、putwc、putchar、putwchar 298
15.10　 fputs、fputws、puts 299
15.11　 fprintf、printf、sprintf、snprintf、fwprintf、wprintf、swprintf 299
15.11.1　 输出格式 300
15.11.2　 转换规范 301
15.11.3　 转换标志 301
15.11.4　 最小字段宽度 302
15.11.5　 精度 303
15.11.6　 长度规范 303
15.11.7　 转换操作 304
15.12　 v[x]printf、v[x]scanf 311
15.13　 fread、fwrite 312
15.14　 feof、ferror、clearerr 313
15.15　 remove、rename 314
15.16　 tmpfile、tmpnam、mktemp 314
第16章　 基本工具 316
16.1　 malloc、calloc、mlalloc、clalloc、free、cfree 316
16.2　 rand、srand、RAND_MAX 318
16.3　 atof、atoi、atol、atoll 319
16.4　 strtod、strtof、strtold、strtol、strtoll、strtoul、strtoull 319
16.5　 abort、atexit、exit、_Exit、EXIT_FAILURE、EXIT_SUCCESS 321
16.6　 getenv 322
16.7　 system 323
16.8　 bsearch、qsort 323
16.9　 abs、labs、llabs、div、ldiv、lldiv 325
16.10　 mblen、mbtowc、wctomb 326
16.10.1　 编码和转换状态 327
16.10.2　 长度函数 327
16.10.3　 转换为宽字符 327
16.10.4　 宽字符转换为多字节字符 328
16.11　 mbstowcs、wcstombs 328
16.11.1　 转换为宽字符串 328
16.11.2　 从宽字符串转换为多字节字符 329
第17章　 数学函数 331
17.1　 abs、lbas、llabs、div、ldiv、lldiv 331
17.2　 fabs 332
17.3　 ceil、floor、lrint、llrint、lround、llround、nearbyint、round、rint、trunc 332
17.4　 fmod、remainder、remquo 333
17.5　 frexp、ldexp、modf、scalbn 334
17.6　 exp、exp2、expm1、ilogb、log、log10、log1p、log2、logb 334
17.7　 cbrt、fma、hypot、pow、sqrt 335
17.8　 rand、srand、RAND_MAX 336
17.9　 cos、sin、tan、cosh、sinh、tanh 336
17.10　 acos、asin、atan、atan2、acosh、
asinh、atanh 337
17.11　 fdim、fmax、fmin 338
17.12　 类型通用的宏 338
17.13　 erf、erfc、lgamma、tgamma 341
17.14　 fpclassify、isfinite、isinf、isnan、isnormal、signbit 342
17.15　 copysign、nan、nextafter、
nexttoward 343
17.16　 isgreater、isgreaterequal、isless、
islessequal、islessgreater、isunordered 343
第18章　 时间和日期函数 345
18.1　 clock、clock_t、CLOCKS_PER_SEC、times 345
18.2　 time、time_t 346
18.3　 asctime、ctime 346
18.4　 gmtime、localtime、mktime 347
18.5　 difftime 348
18.6　 strtime、wcsftime 349
第19章　 控制函数 352
19.1　 assert、NDEBUG 352
19.2　 system、exec 352
19.3　 exit、abort 353
19.4　 setjmp、longjmp、jmp_buf 353
19.5　 atexit 354
19.6　 signal、raise、gsignal、ssignal、
psignal 354
19.7　 sleep、alarm 356
第20章　 区域 357
20.1　 setlocale 357
20.2　 localeconv 358
第21章　 扩展整数类型 361
21.1　 基本规则 361
21.1.1　 类型的种类 361
21.1.2　 要么都定义，要么都不定义 361
21.1.3　 MIN和MAX限制 361
21.1.4　　PRI...和SCN...格式字符串宏 362
21.2　 固定长度的整数类型 363
21.3　 具有最小宽度的最小长度类型 364
21.4　 具有最小宽度的快速类型 364
21.5　 指针长度和最大长度整数类型 365
21.6　 ptrdiff_t、size_t、wchar_t、wint_t和sig_atomic_t的范围 366
21.7　 imaxabs、imaxdiv、imaxdiv_t 366
21.8　 strtoimax、strtouimax 367
21.9　 wcstoimax、wcstoumax 367
第22章　 浮点环境 368
22.1　 介绍 368
22.2　 浮点环境 369
22.3　 浮点异常 369
22.4　 浮点四舍五入模式 370
22.5　 浮点表达式收缩 371
第23章　 复数运算 372
23.1　 复数函数库约定 372
23.2　 complex、_Complex_I、imaginary、_Imaginary_I、I 372
23.3　 CX_LIMITED_RANGE 372
23.4　 cacos、casin、catan、ccos、csin、
ctan 373
23.5　 cacosh、casinh、catanh、ccosh、csinh、ctanh 374
23.6　 cexp、clog、cabs、cpow、csqrt 374
23.7　 carg、cimag、creal、conj、cproj 375
第24章　 宽字符和多字节字符工具 377
24.1　 基本类型和宏 377
24.2　 宽字符和多字节字符之间的转换 377
24.3　 宽字符串和多字节字符串之间的转换 379
24.4　 转换为算术类型 380
24.5　 输入和输出函数 380
24.6　 字符串函数 381
24.7　 日期和时间转换 382
24.8　 宽字符分类和映射函数 382
附录A　 ASCII字符集 383
附录B　 语法 384
附录C　 练习答案 396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>武侠，从牛A到牛C
第一章　喜新厌旧是成长的标志
1.《冲雕侠侣》：还是志平好
2.《天龙八部》：命运啊，命运
3.黄药师：屌，真屌
4.包不同万岁万万岁
第二章　妖女都嫁了人——黄蓉、赵敏、任盈盈
1.“美”之异同
2.“智慧”之异同
3.“妖”之异同
第三章　剩女都变了态——李莫愁、灭绝师太、东方不败
1.傻姑娘：李莫愁
2.爱之深，恨之切，终灭绝：灭绝师太
3.未完成：东方不败
第四章　皇帝排行榜
1.从群众中来，离群众而去：南帝
2.从哥们儿到领导：康熙
3.领导就是领导：乾隆
4.从领导到情圣：顺治
第五章　高手排行榜——super-牛B型、牛B型、牛C型
1.super-牛B型：达摩祖师、黄裳、独孤求败、前朝太监
2.牛B型
3.牛C型
第六章　女性高手排行榜
1.深得古墓派矫揉造作之遗风：黄衫女子
2.穿越时空，飞速成长：阿青MM
3.请不要再拿杨过来烦我：郭襄
4.是她，不是她：天山童姥、李秋水
5.国破，家亡，情殇，胳膊断：九难
第七章　知识分子也不甘寂寞
第八章  “独孤九剑”备忘录——杨过和令狐冲，谁得真传
第九章  《葵花宝典》备忘录——《葵花宝典》和《辟邪剑谱》的辩证统—性
第十章  “好快的剑”备忘录
第十一章  “2008—2009武侠数字化信息工程”备忘录
第十二章  我的失败和伟大——令狐冲
第十三章  浑身都是宝——岳不群
第十四章  完美老婆——宁中则
第十五章  只因不是男主角——林平之
第十六章　《飞狐》三大红杏——南兰、马春花和田青文
第十七章　神仙般的日子——胡一刀夫妇
第十八章  史上最无聊的情侣——郑克爽和阿珂
第十九章　还记得你答应我的事吗——张翠山和殷素素
第二十章　查史最神秘人物——胡逸之
第二十一章  阶段性世界观大转折——《连城诀》
第二十二章  彩云之南倾情奉献
第二十三章  金古之争永不停息
第二十四章　天下的妞都是我一个人的
第二十五章　江湖其实是骗人的
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>武侠，从牛A到牛C
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>剑桥古代史
前言
第一章 地质时代
第二章 农耕和城市生活兴起前东欧、西亚和埃及的自然状态
第三章 埃及、西亚和欧洲的原始人类
第四章 语言的见证
第五章 欧洲、西亚和北非的早期人类
第六章 年代学
第七章 上篇    西亚最早的聚落（公元前9—5千纪）
第七章 下篇    公元前4000年以前的安那托利亚
第八章 城市的发展（从欧贝德至乌鲁克Ｖ末期）
第九章 上篇    前王朝时期的埃及
第九章 中篇    新石器时代和铜石并用时代的巴勒斯坦
第九章 下篇    新石器时代和铜石并用时代的塞浦路斯
第十章 爱琴海地区的石器时代
缩写文献
各章参考文献
总索引
地图索引
地图导读
译者注
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>剑桥古代史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中国社会中的宗教
荐序（欧大年）
代　序
自　序
第一章　导　论
第二章　家庭整合中的宗教
第三章　社会和经济团体中的宗教
第四章　民间信仰的公众性
第五章　历史视角下中国宗教的政治作用
第六章　天命的运作
第七章　政治伦理信仰：“以神道设教”
第八章　国家对宗教的控制
第九章　宗教与政治反抗
第十章　儒家学说及其仪式中的宗教面向
第十一章　宗教和传统道德秩序
第十二章　中国社会中的弥漫性和制度性宗教
第十三章　1949年以前宗教在中国社会中角色的变化
附录1　8个地方主要庙宇的功能分类
附录2
制度性宗教VS.弥漫性宗教？——关于杨庆堃《中国社会中的宗教》的讨论
译后记
再版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中国社会中的宗教
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第1章 绪论
1.1 什么是数据结构
1.2 基本概念和术语
1.3 抽象数据类型的表现与实现
1.4 算法和算法分析
第2章 线性表
2.1 线性表的类型定义
2.2 线性表的顺序表示和实现
2.3 线性表的链式表示和实现
2.4 一元多项式的表示及相加
第3章 栈和队列
3.1 栈
3.2 栈的应有和举例
3.3 栈与递归的实现
3.4 队列
3.5 离散事件模拟
第4章 串
4.1 串类型的定义
4.2 串的表示和实现
4.3 串的模式匹配算法
4.4 串操作应用举例
第5章 数组和广义表
5.1 数组的定义
5.2 数组的顺序表现和实现
5.3 矩阵的压缩存储
5.4 广义表的定义
5.5 广义表的储存结构
5.6 m元多项式的表示
5.7 广义表的递归算法第6章 树和二叉树
6.1 树的定义和基本术语
6.2 二叉树
6.2.1 二叉树的定义
6.2.2 二叉树的性质
6.2.3 二叉树的存储结构
6.3 遍历二叉树和线索二叉树
6.3.1 遍历二叉树
6.3.2 线索二叉树
6.4 树和森林
6.4.1 树的存储结构
6.4.2 森林与二叉树的转换
6.4.3 树和森林的遍历
6.5 树与等价问题
6.6 赫夫曼树及其应用
6.6.1 最优二叉树(赫夫曼树)
6.6.2 赫夫曼编码
6.7 回溯法与树的遍历
6.8 树的计数
第7章 图
7.1 图的定义和术语
7.2 图的存储结构
7.2.1 数组表示法
7.2.2 邻接表
7.2.3 十字链表
7.2.4 邻接多重表
7.3 图的遍历
7.3.1 深度优先搜索
7.3.2 广度优先搜索
7.4 图的连通性问题
7.4.1 无向图的连通分量和生成树
7.4.2 有向图的强连通分量
7.4.3 最小生成树
7.4.4 关节点和重连通分量
7.5 有向无环图及其应用
7.5.1 拓扑排序
7.5.2 关键路径
7.6 最短路径
7.6.1 从某个源点到其余各顶点的最短路径
7.6.2 每一对顶点之间的最短路径
第8章 动态存储管理
8.1 概述
8.2 可利用空间表及分配方法
8.3 边界标识法
8.3.1 可利用空间表的结构
8.3.2 分配算法
8.3.3 回收算法
8.4 伙伴系统
8.4.1 可利用空间表的结构
8.4.2 分配算法
8.4.3 回收算法
8.5 无用单元收集
8.6 存储紧缩
第9章 查找
9.1 静态查找表
9.1.1 顺序表的查找
9.1.2 有序表的查找
9.1.3 静态树表的查找
9.1.4 索引顺序表的查找
9.2 动态查找表
9.2.1 二叉排序树和平衡二叉树
9.2.2 B树和B+树
9.2.3 键树
9.3 哈希表
9.3.1 什么是哈希表
9.3.2 哈希函数的构造方法
9.3.3 处理冲突的方法
9.3.4 哈希表的查找及其分析
第10章 内部排序
10.1 概述
10.2 插入排序
10.2.1 直接插入排序
10.2.2 其他插入排序
10.2.3 希尔排序
10.3 快速排序
10.4 选择排序
10.4.1 简单选择排序
10.4.2 树形选择排序
10.4.3 堆排序
10.5 归并排序
10.6 基数排序
10.6.1 多关键字的排序
10.6.2 链式基数排序
10.7 各种内部排序方法的比较讨论
第11章 外部排序
11.1 外存信息的存取
11.2 外部排序的方法
11.3 多路平衡归并的实现
11.4 置换一选择排序
11.5 最佳归并树
第12章 文件
12.1 有关文件的基本概念
12.2 顺序文件
12.3 索引文件
12.4 ISAM文件和VSAM文件
12.4.1 ISAM文件
12.4.2 VSAM文件
12.5 直接存取文件(散列文件)
12.6 多关键字文件
12.6.1 多重表文件
12.6.2 倒排文件
附录A 名词索引
附录B 函数索引
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货和其他衍生品（第5版）
序言
第1章 绪论
第2章 期货市场的机制
第3章 远期和期货价格的确定
第4章 期货的套期保值策略
第5章 利率市场
第6章 互换
第7章 期权市场的机制
第8章 股票期权的性质
第9章 期权的交易策略
第10章 二叉树模型介绍
第11章 股票价格的行为模式
第12章 BlackScholes模型
第13章 股票指数期权、货币期权和期货期权
第14章 希腊字母
第15章 波动率微笑
第16章 风险值
第17章 估计波动率与相关性
第18章 数值方法
第19章 奇异期权
第21章 鞅和测度
第22章 利率衍生品： 标准的市场模型
第23章 利率衍生品： 瞬时利率模型
第24章 利率衍生品： 更高级的模型
第26章 信用风险
第27章 信用衍生品
第28章 实物期权
第30章 衍生品灾难以及我们能从中学到什么
符号表
术语表
x≤0时N(x)表
x≥0时N(x)表
主题索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货和其他衍生品（第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自由的进化
序
第一章 自然自由
认清我们是什么
我是我所是
我们呼吸的空气
小飞象丹波的魔羽和宝琳娜的险境

第二章 思考决定论的一个工具
一些有用的过度简化
从物理学到康威生命世界里的设计
我们能得到天降救星吗？
从慢速移动避免者到星球大战
可避免性的诞生

第三章 思考决定论
可能世界
因果关系
奥斯丁的推杆
一场计算机象棋马拉松
决定论宇宙中的无原因事件
未来会像过去一样吗？

第四章 倾听自由意志主义
自由意志主义的诉求
我们应将亟须的缺口开在哪儿？
凯恩的非决定论决策制定模型
“如果你把自己变得足够小，你可以外部化几乎所有东西”
小心元初哺乳动物
那怎么可能“取决于我”？

第五章 所有这些设计是从哪儿来的？
早期岁月
囚徒困境
合众为一
题外话：基因决定论的威胁
自由度和对真相的探求

第六章 开放头脑的进化
文化共生如何将灵长类转变为人
达尔文主义解释的多样性
娇贵工具，但你仍不得不使用它们

第七章 道德主体性的进化
有益自私性
做个好人以便看起来像个好人
学会对付你自己
我们的昂贵勋章
第八章 你被排除出圈子了吗？
描绘错误道德
从心而动
一个心智写入者的观点
你自己的自我

第九章 自举我们自己的自由
我们如何抓住理由并将其变成我们自己的理由
灵魂工程和理性能力军备竞赛
在我朋友的一点帮助之下
自主性、洗脑和教育

第十章 人类自由的未来
守住防备潜行开脱的界线
“谢谢，我需要这个！”
我们比我们希望的更自由吗？
人类自由是脆弱的

术语对照表
人名对照表
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自由的进化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>乐观而不绝望
导 言  C. J. 波利赫罗纽
第一部分
分崩离析的美国社会与变动转型的人类世界
难以形容的恐怖：“反恐战争”的最新阶段
混乱帝国
争夺控制权的全球性斗争：“伊斯兰国”、北约和俄罗斯
欧洲一体化进程是否正在解体
“布基尼”禁令、新无神论和国家崇拜：宗教介入政治领域
构建“永久和平”的愿景
有钱有势则无忧无虑
面对“真实存在的资本主义”，文明还能继续生存下去吗
第二部分
特朗普时代的美国
共和党的根基已然开始“失控”
2016年大选让美国“在劫难逃”
执掌白宫的特朗普
全球变暖和人类的未来
美国对他国选举活动的长期干涉
奥巴马政权的政治遗产
对富人实行社会主义，对穷人实行资本主义
美国的医疗体系是一个国际丑闻
——废除平价医疗法案后果更糟
教育市场化的危害
第三部分
无政府主义、共产主义和革命
拥抱社会主义，美国准备好了吗
为什么我选择乐观而不选择绝望
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>乐观而不绝望
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unix/Linux编程实践教程
第1章 Unix 系统编程概述
第2章 用户、文件操作与联机帮助：编写 who 命令
第3章 目录与文件属性：编写 ls
第4章 文件系统：编写 pwd
第5章 连接控制：学习 stty
第6章 为用户编程：终端控制和信号
第7章 事件驱动编程：编写一个视频游戏
第8章 进程和程序：编写命令解释器 sh
第9章 可编程的 shell、shell 变量和环境：编写自己的 shell
第10章 I/O 重定向和管道
第11章 连接到近端或远端的进程：服务器与 Socket（套接字）
第12章 连接和协议：编写 Web 服务器
第13章 基于数据报（Datagram）的编程：编写许可证服务器
第14章 线程机制：并发函数的使用
第15章 进程间通信（IPC）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unix/Linux编程实践教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>主动投资组合管理
中文版序言
译者序
前言
致谢
第1章绪论
第一部分基础理论
第2章一致预期收益率：资本资产定价模型
第3章风险
第4章超常收益率、业绩基准和附加值
第5章残差风险和残差收益率：信息率
第6章主动管理基本定律
第二部分预期收益率和估值
第7章预期收益率和套利定价理论
第8章估值理论
第9章估值实践
第三部分信息处理
第10章预测基础
第11章高级预测
第12章信息分析
第13章信息时间尺度
第四部分策略实施
第14章组合构建
第15章多空投资
第16章交易成本、换手率和交易
第17章业绩分析
第18章资产配置
第19章基准择时
第20章主动管理的历史业绩
第21章开放性问题
第22章总结
附录A标准符号表
附录B词汇表
附录C收益率和统计基础
关于作者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>主动投资组合管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>暴力与社会秩序
出版前言
代序
中文版前言
平装版前言
前言
致谢
1 概念性框架
1.1 导言
1.2 社会秩序的概念：暴力、制度和组织
1.3 自然国家的逻辑
1.4 权利开放秩序的逻辑
1.5 由自然国家向权利开放秩序转型的逻辑
1.6 关于信念的一点说明
1.7 本书写作计划
2 自然国家
2.1 导言
2.2 共性：权利限制秩序的特征
2.3 区别：自然国家的类型
2.4 特权、权利和精英的动态性
2.5 起源：社会规模与暴力
2.6 自然国家的动态性：从脆弱的自然国家到初级的自然国家
2.7 向成熟的自然国家转变：无序、组织和中世纪教会
2.8 成熟的自然国家：16世纪、17世纪和18世纪的法国和英格兰
2.9 自然国家
附录：骨骼证据和经验研究结果
3 自然国家框架的应用：英国土地法
3.1 导言
3.2 年表
3.3 法庭、法律观念和财产法
3.4 异态封建制度
3.5 异态封建制度与财产的非人际关系化
3.6 自然国家的类型
附录
4 权利开放秩序
4.1 导言
4.2 共性：权利开放秩序的特征
4.3 制度、信念，以及支持权利开放的激励
4.4 编入：公民身份的扩展
4.5 权利开放秩序中的暴力控制
4.6 政府的成长
4.7 维持短期稳定的力量
4.8 维持长期稳定的力量：适应性效率
4.9 为何同样的制度在权利开放与权利限制秩序中所起的作用不同
4.10 一个新的“集体行动的逻辑”和寻租理论
4.11 民主与再分配
4.12 适应性效率与权利开放秩序中看似独立的经济与政治
5 从权利限制秩序向权利开放秩序的转型：门阶条件
5.1 导言
5.2 人际关系化和非人际关系化：门阶条件
5.3 门阶条件1：对精英的法治
5.4 门阶条件2：公共或私人领域内的永久性组织
5.5 门阶条件3：对军队的统一控制
5.6 英国海军和英国
5.7 时间、秩序和制度形式
6 真正意义上的转型
6.1 制度化权利开放
6.2 对派系的担忧
6.3 事件
6.4 政党和法入团体
6.5 英国向权利开放的转型
6.6 法国向权利开放的转型
6.7 美国向权利开放的转型
6.8 制度化权利开放：为什么是西方国家？
7 对社会科学下一步研究的设想
7.1 框架问题
7.2 概念性框架
7.3 社会科学的一个新进路：暴力、制度、组织和信念
7.4 社会科学的一个新进路：发展和民主
7.5 转向国家理论
7.6 暴力与社会秩序：未来研究的方向
参考文献
平装版后记
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>暴力与社会秩序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>跨平台软件开发
目录
第1章 可移植性概念  1
1.1 可移植性是一种考虑问题的方式, 而不是一种状态  1
1.2 培养良好的可移植性编程习惯  2
1.3 良好的习惯胜过故障或标准的具体知识  2
1.3.1 尽早经常移植  3
1.3.2 在不同的环境中开发  3
1.3.3 使用不同的编译器  4
1.3.4 在多个平台上进行测试  4
1.3.5 支持多个程序库  4
1.4 为新项目规划可移植性  5
1.4.1 使可移植性变得容易  5
1.4.2 选择可移植性的合理水平  5
1.4.3 不要将项目变成专有产品  7
1.5 移植旧程序  9
1.5.1 除非程序已经被移植, 否则就认定该程序是不可移植的  9
1.5.2 只做最低限度必要的改动  9
1.5 3 规划攻击目标  9
1.5.4 在修改控制程序中记录每一件事  10
第2章 ANSI C与C++  11
2.1 选择C和C++语言的理由  11
2.1.1 C和C++提供了低级访问  11
2.1.2 C与C++编译成本机代码  12
2.2 Ｃ与C++的术语  12
2.3 可移植性与C/C++  13
第3章 可移植性技术  17
3.1 避免使用新特性  17
3.2 处理变化的特性  18
3.3 使用安全的串行化和反串行化  21
3.4 综合测试  23
3.5 使用编译选项  25
3.5.1 编译时断言  25
3.5.2 严格编译  26
3.6 从可移植文件中隔离平台相关文件  26
3.7 编写简单明了的代码  27
3.8 使用唯一的名称  27
3.9 实现抽象  29
3.9.1 分派抽象  30
3.9.2 抽象数据类型 (typedef)  35
3.9.3 使用Ｃ预处理程序  37
3.9.4 对无法预料的事情做好准备  38
3.9.5 传输与系统相关的信息  39
3.9.6 桥接函数  41
3.10 低级编程  42
3.10.1 避免使用自修改代码/动态生成代码  42
3.10.2 保持高级后退  46
3.10.3 关键字register  47
3.10.4 外部与嵌入式asm文件  48
第4章 编辑与源代码控制  51
4.1 文本文件行结束格式之间的差异  51
4.2 可移植的文件名  53
4.3 源控制  53
4.3.1 源控制系统  54
4.3.2 通过代理程序迁出  56
4.4 构建工具  57
4.4.1 平台特有的构建工具  57
4.4.2 可移植的构建工具  58
4.5 编辑器  61
4.6 本章小结  62
第5章 处理器的不同之处  63
5.1 对齐  63
5.2 字节排序和Endianess  66
5.2.1 Big-Endian值与Little-Endian值的比较  66
5.2.2 标准化存储格式  68
5.2.3 固定的网络字节排序  69
5.3 带符号整数的表示方法  70
5.4 本地类型的大小  70
5.5 地址空间  74
5.6 本章小结  75
第6章 浮点  77
6.1 浮点的历史  77
6.2 标准的C与C++浮点支持  78
6.3 浮点的问题  79
6.3.1 不一致的评估  79
6.3.2 浮点与联网应用程序  80
6.3.3 转换  81
6.4 定点整数数学  82
6.5 从浮点数中析取整数位  82
6.6 实现查询  85
6.7 异常结果  87
6.7.1 特殊值  88
6.7.2 异常  89
6.7.3 浮点环境访问  89
6.8 存储格式  90
6.9 本章小结  91
第7章 预处理程序  93
7.1 预定义符号  93
7.2 头文件  95
7.2.1 头文件的路径规范  96
7.2.2 头文件名  96
7.3 配置宏  97
7.4 条件编译  98
7.5 Pragma  99
7.6 本章小结  99
第8章 编译器  101
8.1 结构大小、填充和对齐  101
8.2 内存管理的特性  104
8.2.1 释放的影响  104
8.2.2 对齐的内存分配  104
8.3 堆栈  105
8.3.1 堆栈的大小  105
8.3.2 alloca()的问题  106
8.4 printf()例程  106
8.5 类型尺寸与行为  107
8.5.1 64位整数类型  107
8.5.2 基本类型的尺寸  108
8.5.3 有符号与无符号的char类型  110
8.5.4 作用如同int的enum  111
8.5.5 数字常量  112
8.5.6 有符号与无符号的右移  112
8.6 调用约定  113
8.6.1 名称修饰  114
8.6.2 函数指针与回调  114
8.6.3 可移植性  115
8.7 返回结构  116
8.8 Bitfield  116
8.9 注释  117
8.10 本章小结  118
第9章 用户交互作用  119
9.1 用户界面的演变  119
9.1.1 命令行  119
9.1.2 窗口系统  120
9.2 本机GUI与应用程序GU的比较  121
9.3 低级图形  121
9.4 数字音频  122
9.5 输入  123
9.5.1 键盘  123
9.5.2 鼠标  123
9.5.3 操纵杆与游戏键盘  124
9.6 跨平台工具箱  124
9.7 本章小结  124
第10章 联网  125
10.1 网络协议的演化  125
10.2 编程接口  126
10.2.1 套接字  126
10.2.2 RPC (远程过程调用) 与RMI (远程方法调用)  128
10.2.3 分布式对象  129
10.3 本章小结  129
第11章 操作系统  131
11.1 操作系统的演化  131
11.2 宿主环境与独立式环境  132
11.3 操作系统可移植性的悖论  132
11.4 内存  133
11.4.1 内存限制  133
11.4.2 内存映射  133
11.4.3 受保护内存  134
11.5 进程与线程  135
11.5.1 进程控制与通信函数  135
11.5.2 IPC(进程间通信)  135
11.5.3 多线程技术  136
11.6 环境变量  140
11.7 异常处理  141
11.7.1 C异常处理  141
11.7.2 C++异常处理  142
11.8 用户数据存储  142
11.8.1 Microsoft Windows注册表  143
11.8.2 Linux用户数据  144
11.8.3 OS X的首选项  144
11.9 安全与许可  145
11.9.1 应用程序安装  145
11.9.2 特权目录与数据  145
11.9.3 低级访问  146
11.10 本章小结  146
第12章 动态库  147
12.1 动态链接  147
12.2 动态加载  148
12.3 共享库的问题 (亦称为DLL地狱)  148
12.3.1 版本问题  148
12.3.2 扩散  150
12.4 Gun LGPL  150
12.5 Windows DLL  150
12.6 Linux的共享对象  153
12.7 Mac OS X架构、插件捆绑  154
12.7.1 架构  154
12.7.2 捆绑  155
12.7.3 插件  156
12.8 本章小结  157
第13章 文件系统  159
13.1 符号链接、快捷方式与别名  159
13.1.1 Windows的LNK文件  160
13.1.2 Unix的链接  160
13.2 路径规范  160
13.2.1 磁盘驱动器与卷说明符  161
13.2.2 路径分隔符与其他特殊字符  161
13.2.3 当前目录  161
13.2.4 路径长度  162
13.2.5 区分大小写  162
13.3 安全性与访问权限  162
13.4 Macintoch的古怪行为  164
13.5 文件属性  164
13.6 特殊目录  164
13.7 文本处理  165
13.8 C运行时库与可移植文件访问  165
13.9 本章小结  166
第14章 可扩缩性  167
14.1 较好的算法等于较好的可扩缩性  167
14.2 可扩缩性的局限性  168
14.3 本章小结  169
第15章 可移植性与数据  171
15.1 应用程序数据与资源文件  171
15.1.1 二进制文件  171
15.1.2 文本文件  171
15.1.3 XML  173
15.1.4 作为数据文件的脚本语言  174
15.2 创建可移植的图形  174
15.3 创建可移植的音频  175
15.4 本章小结  175
第16章 国际化与本地化  177
16.1 字符串与统一代码标准  177
16.2 货币  179
16.3 界面元素  180
16.4 本章小结  180
第17章 脚本语言  183
17.1 脚本语言的一些缺点  184
17.2 JavaScript/ECMAScript  184
17.3 Python  185
17.4 Lua  186
17.5 Ruby  186
17.6 本章小结  186
第18章 跨平台的程序库与工具包  187
18.1 库  187
18.2 应用程序架构  188
18.2.1 Qt  188
18.2.2 GTK+  188
18.2.3 FLTK  188
18.2.4 wxWidgets  189
18.3 本章小结  189
附录A 可移植开源装置 (POSH)  191
A.1 POSH的预定义符号  191
A.2 POSH的固定大小类型  192
A.3 POSH的实用函数和宏  193
附录B 用于可移植性的规则  197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>跨平台软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微积分之屠龙宝刀
第1章 引言
第2章 你的任课老师到底如何
*2.1 选择你的任课老师
*2.2 对任课老师该有什么要求
*2.3 如何对待任课老师
第3章 轻松拿高分的十大通则
第4章 好问题和坏问题
*4.1 为什么要问问题
*4.2 问题举例
*4.3 不该问的问题
第5章 准备好了吗？预备知识
*5.1 你学过些什么？
*5.2 在上微积分的第一天，你应该知道什么
*5.3 电脑与计算机，咱们的2-bit朋友
第6章 如何应付考试
*6.1 会考些什么
*6.2 如何备考
*6.3 不为考试而钻研
*6.4 应考须知
第7章 直线、圆、圆锥曲线族
*7.1 笛卡尔平面
*7.2 一般作图妙方：抛物线的寓言
*7.3 直线
*7.4 圆
*7.5 椭圆、抛物线、双曲线
第8章 极限：你可少不了它们
*8.1 基本概念
*8.2 取极限的一般步骤
*8.3 单侧极限
*8.4 怪异函数的极限
*8.5 计算机与极限
第9章 连续性，或你为何不该在不连续的坡道上滑雪
*9.1 概念
*9.2 连续性的3个条件
第10章 何谓导数？变才是硬道理
第11章 导数的极限定义：求导数的麻烦方法
*11.1 定义导数
*11.2 导数极限定义的其他形式
第12章 求导数的简单方法
*12.1 微分法的基本法则
*12.2 幂法则
*12.3 积法则
*12.4 商法则
*12.5 三角函数的导数
*12.6 二阶导数、三阶导数、更高阶导数
第13章 速度：油门踩到底
*13.1 速度即导数
*13.2 车子的位置与速度
*13.3 自由落体的速度
第14章 链式法则：S&M的游戏
第15章 画函数图像：如何当个专家
*15.1 画函数图像
*15.2 能够绊倒你的狡猾图像
*15.3 二姐导数检测
*15.4 凹性
第16章 极大值与极小值：使用部分
*16.1 闭区间上的最大值及最小值
*16.2 应用问题
第17章 隐微分法：咱们就拐弯抹角吧
第18章 相关变化率：你变，我跟着变
第19章 求近似值：评估你的成名之路
第20章 介值定理与中值定理
*20.1 介值定理：面包中间没夹东西就不叫三明治
*20.2 中值定理：陡就是陡
第21章 积分：倒过来做就成了
*21.1 不定积分
*21.2 积分法：简单的方法
*21.3 代换法
*21.4 眼球技术
*21.5 积分表
*21.6 利用电脑和计算机
第22章 定积分
*22.1 如何求定积分
*22.2 面积
*22.3 微积分基本定理
*22.4 定积分的一些基本法则
*22.5 数值逼近法
*22.6 黎曼和——附带一些关键细节
第23章 模型：从玩具飞机到跑道
*23.1 现实问题
第24章 指数与对数，“e”把戏总复习
*24.1 指数
*24.2 对数
第25章 把微积分这玩意儿用到指数与对数上
*25.1 微分e^x与e^x的朋友们
*25.2 积分e^x与e^x的朋友们
*2.53 微分自然对数
*2.54 当底数为其他数时
*25.5 积分与自然对数
第26章 对数微分法：化难为易
第27章 指数增长与指数衰退：坏家伙的兴亡
第28章 形形色色的积分技巧
*28.1 分部积分法
*28.2 三角代换法
*28.3 部分分式积分法
第29章 20个最常犯的错误
第30章 期末考会考什么
词汇表 数学名词活学指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微积分之屠龙宝刀
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>科学史及其与哲学和宗教的关系
原序
第二版序
第三版序
第四版序
绪论
起源
第一章古代世界的科学
第二章中世纪
第三章文艺复兴
第四章牛顿时代
第五章18世纪
第六章19世纪的物理学
第七章19世纪的生物学
第八章19世纪的科学与哲学思想
第九章生物学与人类学的进一步发展
第十章物理学的新时代
第十一章恒星宇宙
第十二章科学的哲学及其展望
人名索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>科学史及其与哲学和宗教的关系
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++语言的设计和演化
出版者的话
专家指导委员会
译者序
前言
致读者
第一部分
第1章 C++的史前时代
第2章 带类的C
第3章 C++的诞生
第4章 C++语言设计规则
第5章 1985―1993年表
第二部分
第10章 存储管理
第11章 重载
第12章 多重继承
第13章 类概念的精炼
第14章 强制
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++语言的设计和演化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>战争的本质
前　言 I
序　言
引　言
第一章　古代战争
第二章　从中世纪战争到现代战争
第三章　战争理论及更近的战争史
第四章　战争的起因
第五章　战争的影响
第六章　伦理学、法律与战争
第七章　战争的未来
结　语
尾　注
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>战争的本质
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大众天文学
大众天文学》在中国（新版代序）
译者序言
原出版说明
弗拉马里翁传略
第一篇  地  球
第一章  天空中的地球
第二章  地球怎样围绕着地轴和太阳转动
第三章  地球怎样围绕着太阳转动
第四章  地球的第四种运动——岁差
第五章  地球的摄动和太阳在空间的运行
第六章  地球运动在理论上和实验上的证据
第七章  作为行星和世界的地球
第八章  地球的起源
第二篇  月  亮
第九章  月亮——地球的卫星
第十章  月相
第十一章  月亮围绕地球的运动
第十二章  月亮对于地球的影响
第十三章  月亮的表面状况
第十四章  月食和日食
第三篇  太  阳
第十五章  主宰世界的太阳
第十六章  怎样测量太阳的距离、大小和质量
第十七章  太阳物理概观
第十八章  光球
第十九章  原子与摄谱仪
第二十章  太阳光谱带来的消息
第二十一章  日食
第二十二章  色球与日珥
第二十三章  日冕
第二十四章  太阳与地球
第二十五章  太阳内部
第四篇  行 星 世 界
第二十六章  视运动与真运动
第二十七章  水星
第二十八章  金星——牧羊人的星
第二十九章  火星——小型的地球
第三十章  小行星
第三十一章  巨大的木星
第三十二章  土星——太阳系里的奇观
第三十三章  天王星——颠倒了的世界
第三十四章  太阳系的边界
第五篇  彗星、流星与陨星
第三十五章  历史上的彗星
第三十六章  彗星在空间的运动
第三十七章  彗星的组织
第三十八章  流星与陨星
第六篇  恒 星 宇 宙
第三十九章  星座
第四十章  星的方位测量
第四十一章  星的光亮与星的数目
第四十二章  星的距离
第四十三章  星的自行
第四十四章  双星
第四十五章  星的光谱
第四十六章  视向速度与分光双星
第四十七章  交食双星
第四十八章  星的直径、质量与亮度
第四十九章  变星
第五十章  新星
第五十一章  行星状星云——沃尔夫拉叶星
第五十二章  星团
第五十三章  星的化学结构与演化
第五十四章  弥漫星云
第五十五章  射电天文学
第五十六章  银河系
第五十七章  河外星云
第七篇  天 文 仪 器
第五十八章  天文仪器
附    录
第一章  地球的结构
第二章  地球大气的演化史
第三章  生命的起源与演化
第四章  水星的自转及其表面观测
第五章  金星的自转、大气、温度及其表面观测
第六章  射电天文学的新发展
第七章  新天文学
第八章  新型的河外天体
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大众天文学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计原理与实践
出版者的话
译者序
前言
第0章致读者
01本书结构
011一般方法
012简单练习、 习题等
013进阶学习
02讲授和学习本书的方法
021本书内容顺序的安排
022程序设计和程序设计语言
023可移植性
03程序设计和计算机科学
04创造性和问题求解
05反馈方法
06参考文献
07作者简介
第1章计算机、 人与程序设计
11介绍
12软件
13人
14计算机科学
15计算机已无处不在
151有屏幕和没有屏幕
152船舶
153电信
154医疗
155信息领域
156一种垂直的视角
157与C++程序设计有何联系
16程序员的理想
第一部分基 本 知 识
第2章Hello，  World!
21程序
22经典的第一个程序
23编译
24链接
25编程环境
第3章对象、 类型和值
31输入
32变量
33输入和类型
34运算和运算符
35赋值和初始化
351实例： 删除重复单词
36组合赋值运算符
361实例： 重复单词统计
37命名
38类型和对象
39类型安全
391安全类型转换
392不安全类型转换
第4章计算
41计算
42目标和工具
43表达式
431常量表达式
432运算符
433类型转换
44语句
441选择语句
442循环语句
45函数
451使用函数的原因
452函数声明
46向量
461向量空间增长
462一个数值计算的例子
463一个文本处理的例子
47语言特性
第5章错误
51介绍
52错误的来源
53编译时错误
531语法错误
532类型错误
533警告
54连接时错误
55运行时错误
551调用者处理错误
552被调用者处理错误
553报告错误
56异常
561错误参数
562范围错误
563输入错误
564截断错误
57逻辑错误
58估计
59调试
591实用调试技术
510前置条件和后置条件
5101后置条件
511测试
第6章编写一个程序
61一个问题
62对问题的思考
621程序设计的几个阶段
622策略
63回到计算器问题
631第一步尝试
632单词
633实现单词
634使用单词
635重新开始
64文法
641英文文法
642设计一个文法
65将文法转换为程序
651实现文法规则
652表达式
653项
654基本表达式
66试验第一个版本
67试验第二个版本
68单词流
681实现Token_stream
682读单词
683读数值
69程序结构
第7章完成一个程序
71介绍
72输入和输出
73错误处理
74处理负数
75模运算： %
76清理代码
761符号常量
762使用函数
763代码格式
764注释
77错误恢复
78变量
781变量和定义
782引入单词name
783预定义名字
784我们到达目的地了吗
第8章函数相关的技术细节
81技术细节
82声明和定义
821声明的类别
822变量和常量声明
823默认初始化
83头文件
84作用域
85函数调用和返回
851声明参数和返回类型
852返回一个值
853传值参数
854传常量引用参数
855传引用参数
856传值与传引用的对比
857参数检查和转换
858实现函数调用
86求值顺序
861表达式求值
862全局初始化
87名字空间
871using声明和using指令
第9章类相关的技术细节
91用户自定义类型
92类和成员
93接口和实现
94演化一个类
941结构和函数
942成员函数和构造函数
943保持细节私有性
944定义成员函数
945引用当前对象
946报告错误
95枚举类型
96运算符重载
97类接口
971参数类型
972拷贝
973默认构造函数
974const成员函数
975类成员和“辅助函数”
98Date类
第二部分输入和输出
第10章输入/输出流
101输入和输出
102I/O流模型
103文件
104打开文件
105读写文件
106I/O错误处理
107读取单个值
1071将程序分解为易管理的
子模块
1072将人机对话从函数中分离
108用户自定义输出操作符
109用户自定义输入操作符
1010一个标准的输入循环
1011读取结构化的文件
10111内存表示
10112读取结构化的值
10113改变表示方法
第11章定制输入/输出
111有规律的和无规律的输入和输出
112格式化输出
1121输出整数
1122输入整数
1123输出浮点数
1124精度
1125域
113文件打开和定位
1131文件打开模式
1132二进制文件
1133在文件中定位
114字符串流
115面向行的输入
116字符分类
117使用非标准分隔符
118还有很多未讨论的内容
第12章一个显示模型
121为什么要使用图形用户界面
122一个显示模型
123第一个例子
124使用GUI库
125坐标系
126形状
127使用形状类
1271图形头文件和主函数
1272一个几乎空白的窗口
1273坐标轴
1274绘制函数图
1275Polygon
1276Rectangle
1277填充
1278文本
1279图片
12710还有很多未讨论的内容
128让图形程序运行起来
1281源文件
第13章图形类
131图形类概览
132Point和Line
133Lines
134Color
135Line_style
136Open_polyline
137Closed_polyline
138Polygon
139Rectangle
1310管理未命名对象
1311Text
1312Circle
1313Ellipse
1314Marked_polyline
1315Marks
1316Mark
1317Image
第14章设计图形类
141设计原则
1411类型
1412操作
1413命名
1414可变性
142Shape类
1421一个抽象类
1422访问控制
1423绘制形状
1424拷贝和可变性
143基类和派生类
1431对象布局
1432类的派生和虚函数定义
1433覆盖
1434访问
1435纯虚函数
144面向对象程序设计的好处
第15章绘制函数图和数据图
151介绍
152绘制简单函数图
153Function类
1531默认参数
1532更多的例子
154Axis类
155近似
156绘制数据图
1561读取文件
1562一般布局
1563数据比例
1564构造数据图
第16章图形用户界面
161用户界面的选择
162“Next”按钮
163一个简单的窗口
1631回调函数
1632等待循环
164Button和其他Widget
1641Widget
1642Button
1643In_box和Out_box
1644Menu
165一个实例
166控制流的反转
167添加菜单
168调试GUI代码
第三部分数据结构和算法
第17章向量和自由空间
171介绍
172向量的基本知识
173内存、 地址和指针
1731运算符sizeof
174自由空间和指针
1741自由空间分配
1742通过指针访问数据
1743指针范围
1744初始化
1745空指针
1746自由空间释放
175析构函数
1751生成的析构函数
1752析构函数和自由空间
176访问向量元素
177指向类对象的指针
178类型混用： 无类型指针和指针
类型转换
179指针和引用
1791指针参数和引用参数
1792指针、 引用和继承
1793实例： 列表
1794列表的操作
1795列表的使用
1710this指针
17101关于Link使用的更多讨论
第18章向量和数组
181介绍
182拷贝
1821拷贝构造函数
1822拷贝赋值
1823拷贝术语
183必要的操作
1831显示构造函数
1832调试构造函数与析构函数
184访问向量元素
1841对const对象重载运算符
185数组
1851指向数组元素的指针
1852指针和数组
1853数组初始化
1854指针问题
186实例： 回文
1861使用string实现回文
1862使用数组实现回文
1863使用指针实现回文
第19章向量、 模板和异常
191问题
192改变向量大小
1921方法描述
1922reserve和capacity
1923resize
1924push_back
1925赋值
1926到现在为止我们设计的
vector类
193模板
1931类型作为模板参数
1932泛型编程
1933容器和继承
1934整数作为模板参数
1935模板参数推导
1936一般化vector类
194范围检查和异常
1941附加讨论： 设计上的考虑
1942使用宏
195资源和异常
1951潜在的资源管理问题
1952资源获取即初始化
1953保证
1954auto_ptr
1955vector类的RAII
第20章容器和迭代器
201存储和处理数据
2011处理数据
2012一般化代码
202STL建议
203序列和迭代器
2031回到实例
204链表
2041列表操作
2042迭代
205再次一般化vector
206实例： 一个简单的文本编辑器
2061处理行
2062迭代
207vector、  list和 string
2071insert 和 erase
208调整vector类达到STL版本
的功能
209调整内置数组达到STL版本
的功能
2010容器概览
20101迭代器类别
第21章算法和映射
211标准库中的算法
212最简单的算法： find()
2121一些一般的应用
213通用搜索算法： find_if()
214函数对象
2141函数对象的抽象视图
2142类成员上的谓词
215数值算法
2151累积
2152一般化accumulate()
2153内积
2154一般化inner_product()
216关联容器
2161映射
2162map概览
2163另一个map实例
2164unordered_map
2165集合
217拷贝操作
2171拷贝
2172流迭代器
2173使用集合保持顺序
2174copy_if
218排序和搜索
第四部分拓 宽 视 野
第22章理念和历史
221历史、理念和专业水平
2211程序设计语言的目标和哲学
2212编程理念
2213风格/范型
222程序设计语言历史概览
2221最早的程序语言
2222现代程序设计语言的起源
2223Algol家族
2224Simula
2225C
2226C++
2227今天的程序设计语言
2228参考资源
第23章文本处理
231文本
232字符串
233I/O流
234映射
2341实现细节
235一个问题
236正则表达式的思想
237用正则表达式进行搜索
238正则表达式语法
2381字符和特殊字符
2382字符集
2383重复
2384子模式
2385可选项
2386字符集和范围
2387正则表达式错误
239与正则表达式进行模式匹配
2310参考文献
第24章数值计算
241介绍
242大小、 精度和溢出
2421数值限制
243数组
244C 风格的多维数组
245Matrix库
2451矩阵的维和矩阵访问
2452一维矩阵
2453二维矩阵
2454矩阵I/O
2455三维矩阵
246实例： 求解线性方程组
2461经典的高斯消去法
2462选取主元
2463测试
247随机数
248标准数学函数
249复数
2410参考文献
第25章嵌入式系统程序设计
251嵌入式系统
252基本概念
2521可预测性
2522理想
2523生活在故障中
253内存管理
2531动态内存分配存在的问题
2532动态内存分配的替代方法
2533存储池实例
2534栈实例
254地址、 指针和数组
2541未经检查的类型转换
2542一个问题： 不正常的接口
2543解决方案： 接口类
2544继承和容器
255位、 字节和字
2551位和位运算
2552bitset
2553有符号数和无符号数
2554位运算
2555位域
2556实例： 简单加密
256编码规范
2561编码规范应该是怎样的
2562编码原则实例
2563实际编码规范
第26章测试
261我们想要什么
2611说明
262程序正确性证明
263测试
2631回归测试
2632单元测试
2633算法和非算法
2634系统测试
2635测试类
2636寻找不成立的假设
264测试方案设计
265调试
266性能
2661计时
267参考文献
第27章C语言
271C和C++： 兄弟
2711C/C++兼容性
2712C不支持的C++特性
2713C标准库
272函数
2721不支持函数名重载
2722函数参数类型检查
2723函数定义
2724C++调用C和C调用C++
2725函数指针
273小的语言差异
2731结构标签名字空间
2732关键字
2733定义
2734C风格类型转换
2735void*的转换
2736枚举
2737名字空间
274动态内存分配
275C风格字符串
2751C风格字符串和const
2752字节操作
2753实例： strcpy()
2754一个风格问题
276输入/输出： stdio
2761输出
2762输入
2763文件
277常量和宏
278宏
2781类函数宏
2782语法宏
2783条件编译
279实例： 侵入式容器
术语表
参考书目
第五部分附录
附录AC++语言概要
附录B标准库概要
附录CVisual Studio简要入门教程
附录D安装FLTK
附录EGUI实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白领
代译序
导言
第一部 老式中产阶级
第二部 白领的世界
第三部 生活方式
第四部 权力的路径
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白领
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>CLR via C#
第I部分 CLR基础
第1章 CLR的执行模型 3
1.1 将源代码编译成托管模块 3
1.2 将托管模块合并成程序集 6
1.3 加载公共语言运行时 8
1.4 执行程序集的代码 10
1.4.1 IL和验证 15
1.4.2 不安全的代码 16
1.5 本地代码生成器：NGen.exe 18
1.6 Framework类库 20
1.7 通用类型系统 22
1.8 公共语言规范 24
1.9 与非托管代码的互操作性 28
第2章 生成、打包、部署和管理应用程序及类型 29
2.1 .NET Framework部署目标 29
2.2 将类型生成到模块中 31响应文件 32
2.3 元数据概述 34
2.4 将模块合并成程序集 39
2.4.1 使用Visual Studio IDE将程序集添加到项目中 45
2.4.2 使用程序集链接器 46
.2.4.3 为程序集添加资源文件 48
2.5 程序集版本资源信息 49
2.6 语言文化 53
2.7 简单应用程序部署(私有部署的程序集) 54
2.8 简单管理控制(配置) 55
第3章 共享程序集和强命名程序集 59
3.1 两种程序集，两种部署 60
3.2 为程序集分配强名称 61
3.3 全局程序集缓存 65
3.4 在生成的程序集中引用一个强命名程序集 67
3.5 强命名程序集能防范篡改 69
3.6 延迟签名 70
3.7 私有部署强命名程序集 72
3.8 “运行时”如何解析类型引用 73
3.9 高级管理控制(配置) 76发布者策略控制 78
第II部分 设计类型
第4章 类型基础 83
4.1 所有类型都从System.Object派生 83
4.2 类型转换 85
4.3 命名空间和程序集 89
4.4 运行时的相互联系 92
第5章 基元类型、引用类型和值类型 101
5.1 编程语言的基元类型 101
5.2 引用类型和值类型 108
5.3 值类型的装箱和拆箱 113
5.3.1 使用接口更改已装箱值类型中的字段(以及为什么不应该这样做) 124
5.3.2 对象相等性和同一性 127
5.4 对象哈希码 129
5.5 dynamic基元类型 131
第6章 类型和成员基础 137
6.1 类型的各种成员 137
6.2 类型的可见性 140友元程序集 140
6.3 成员的可访问性 142
6.4 静态类 143
6.5 分部类、结构和接口 145
6.6 组件、多态和版本控制 146
6.6.1 CLR如何调用虚方法、属性和事件 148
6.6.2 合理使用类型的可见性和成员的可访问性 151
6.6.3 对类型进行版本控制时的虚方法的处理 154
第7章 常量和字段 159
7.1 常量 159
7.2 字段 160
第8章 方法 165
8.1 实例构造器和类(引用类型) 165
8.2 实例构造器和结构(值类型) 168
8.3 类型构造器 171
8.4 操作符重载方法 176
8.5 转换操作符方法 179
8.6 扩展方法 182
8.6.1 规则和原则 184
8.6.2 用扩展方法扩展各种类型 185
8.6.3 ExtensionAttribute类 187
8.7 分部方法 188
第9章 参数 191
9.1 可选参数和命名参数 191
9.1.1 规则和原则 192
9.1.2 DefaultParameterValueAttribute和OptionalAttribute 194
9.2 隐式类型的局部变量 194
9.3 以传引用的方式向方法传递参数 196
9.4 向方法传递可变数量的参数 201
9.5 参数和返回类型的指导原则 203
9.6 常量性 205
第10章 属性 207
10.1 无参属性 207
10.1.1 自动实现的属性 210
10.1.2 合理定义属性 211
10.1.3 对象和集合初始化器 214
10.1.4 匿名类型 215
10.1.5 System.Tuple类型 218
10.2 有参属性 220
10.3 调用属性访问器方法时的性能 225
10.4 属性访问器的可访问性 225
10.5 泛型属性访问器方法 225
第11章 事件 227
11.1 设计要公开事件的类型 228
11.1.1 第一步：定义类型来容纳所有需要发送给事件通知接收者的附加信息 229
11.1.2 第二步：定义事件成员 229
11.1.3 第三步：定义负责引发事件的方法来通知事件的登记对象 231
11.1.4 第四步：定义方法将输入转化为期望事件 233
11.2 编译器如何实现事件 233
11.3 设计侦听事件的类型 235
11.4 显式实现事件 237
第12章 泛型 241
12.1 Framework类库中的泛型 245
12.2 Wintellect的Power Collections库 246
12.3 泛型基础结构 247
12.3.1 开放类型和封闭类型 247
12.3.2 泛型类型和继承 249
12.3.3 泛型类型同一性 251
12.3.4 代码爆炸 252
12.4 泛型接口 252
12.5 泛型委托 253
12.6 委托和接口的逆变和协变泛型类型实参 254
12.7 泛型方法 256
12.8 泛型和其他成员 258
12.9 可验证性和约束 259
12.9.1 主要约束 261
12.9.2 次要约束 262
12.9.3 构造器约束 263
12.9.4 其他可验证性问题 264
第Ⅲ部分 基本类型
第13章 接口 267
13.1 类和接口继承 267
13.2 定义接口 268
13.3 继承接口 269
13.4 关于调用接口方法的更多探讨 271
13.5 隐式和显式接口方法实现(幕后发生的事情) 272
13.6 泛型接口 274
13.7 泛型和接口约束 276
13.8 实现多个具有相同方法名和签名的接口 277
13.9 用显式接口方法实现来增强编译时类型安全性 278
13.10 谨慎使用显式接口方法实现 280
13.11 设计：基类还是接口 282
第14章 字符、字符串和文本处理 287
14.1 字符 287
14.2 System.String类型 290
14.2.1 构造字符串 290
14.2.2 字符串是不可变的 292
14.2.3 比较字符串 293
14.2.4 字符串留用 298
14.2.5 字符串池 301
14.2.6 检查字符串中的字符和文本元素 301
14.2.7 其他字符串操作 303
14.3 高效率构造字符串 304
14.3.1 构造StringBuilder对象 304
14.3.2 StringBuilder的成员 305
14.4 获取对象的字符串表示：ToString 307
14.4.1 指定具体的格式和语言文化 308
14.4.2 将多个对象格式成一个字符串 311
14.4.3 提供定制格式化器 313
14.5 解析字符串来获取对象：Parse 315
14.6 编码：字符和字节的相互转换 317
14.6.1 字符和字节流的编码和解码 322
14.6.2 Base-64字符串编码和解码 323
14.7 安全字符串 324
第15章 枚举类型和位标志 327
15.1 枚举类型 327
15.2 位标志 332
15.3 向枚举类型添加方法 335
第16章 数组 337
16.1 初始化数组元素 339
16.2 数组转型 341
16.3 所有数组都隐式派生自System.Array 343
16.4 所有数组都隐式实现IEnumerable，Icollection和IList 344
16.5 数组的传递和返回 345
16.6 创建下限非零的数组 346
16.7 数组的访问性能 347
16.8 不安全的数组访问和固定大小的数组 351
第17章 委托 353
17.1 初识委托 353
17.2 用委托回调静态方法 355
17.3 用委托回调实例方法 357
17.4 委托揭秘 357
17.5 用委托回调许多方法(委托链) 361
17.5.1 C#对委托链的支持 365
17.5.2 取得对委托链调用的更多控制 365
17.6 委托定义太多(泛型委托) 368
17.7 C#为委托提供的简化语法 369
17.7.1 简化语法1：不需要构造委托对象 369
17.7.2 简化语法2：不需要定义回调方法 370
17.7.3 简化语法3：局部变量不需要手动包装到类中即可传给回调方法 373
17.8 委托和反射 375
第18章 定制attribute 379
18.1 使用定制attribute 379
18.2 定义自己的attribute类 382
18.3 attribute的构造器和字段/属性的数据类型 386
18.4 检测定制attribute 387
18.5 两个attribute实例的相互匹配 391
18.6 检测定制attribute时不创建从Attribute派生的对象 393
18.7 条件attribute类 396
第19章 可空值类型 399
19.1 C#对可空值类型的支持 401
19.2 C#的空接合操作符 403
19.3 CLR对可空值类型的特殊支持 404
19.3.1 可空值类型的装箱 404
19.3.2 可空值类型的拆箱 405
19.3.3 通过可空值类型调用GetType 405
19.3.4 通过可空值类型调用接口方法 405
第Ⅳ部分 核心机制
第20章 异常和状态管理 409
20.1 定义“异常” 409
20.2 异常处理机制 411
20.2.1 try块 412
20.2.2 catch块 412
20.2.3 finally块 414
20.3 System.Exception类 417
20.4 FCL定义的异常类 420
20.5 抛出异常 422
20.6 定义自己的异常类 423
20.7 用可靠性换取开发效率 425
20.8 指导原则和最佳实践 433
20.8.1 善用finally块 433
20.8.2 不要什么都捕捉 435
20.8.3 得体地从异常中恢复 436
20.8.4 发生不可恢复的异常时回滚部分完成的操作——维持状态 436
20.8.5 隐藏实现细节来维系契约 437
20.9 未处理的异常 440
20.10 对异常进行调试 444
20.11 异常处理的性能问题 446
20.12 约束执行区域(CER) 448
20.13 代码契约 451
第21章 自动内存管理(垃圾回收) 459
21.1 理解垃圾回收平台的基本工作原理 459
21.2 垃圾回收算法 463
21.3 垃圾回收与调试 466
21.4 使用终结操作来释放本地资源 469
21.4.1 使用CriticalFinalizerObject类型确保终结 470
21.4.2 SafeHandle类型及其派生类型 471
21.4.3 使用SafeHandle类型与非托管代码进行互操作 473
21.5 对托管资源使用终结操作 475
21.6 什么会导致Finalize方法被调用 477
21.7 终结操作揭秘 478
21.8 Dispose模式：强制对象清理资源 481
21.9 使用实现了Dispose模式的类型 485
21.10 C#的using语句 488
21.11 一个有趣的依赖性问题 490
21.12 手动监视和控制对象的生存期 491
21.13 对象复活 501
21.14 代 503
21.15 用于本地资源的其他垃圾回收功能 508
21.16 预测需求大量内存的操作能否成功 512
21.17 编程控制垃圾回收器 513
21.18 线程劫持 516
21.19 垃圾回收模式 517
21.20 大对象 520
21.21 监视垃圾回收 520
第22章 CLR寄宿和AppDomain 523
22.1 CLR寄宿 523
22.2 AppDomain 526
22.3 卸载AppDomain 538
22.4 监视AppDomain 540
22.5 AppDomain FirstChance异常通知 541
22.6 宿主如何使用AppDomain 541
22.6.1 可执行应用程序 542
22.6.2 Microsoft Silverlight富Internet应用程序 542
22.6.3 Microsoft ASP.NET Web窗体和XML Web服务应用程序 542
22.6.4 Microsoft SQL Server 543
22.6.5 更多的用法只局限于你自己的想象力 543
22.7 高级宿主控制 544
22.7.1 使用托管代码管理CLR 544
22.7.2 编写健壮的宿主应用程序 544
22.7.3 宿主如何拿回它的线程 546
第23章 程序集加载和反射 549
23.1 程序集加载 549
23.2 使用反射构建动态可扩展应用程序 554
23.3 反射的性能 555
23.3.1 发现程序集中定义的类型 556
23.3.2 类型对象的准确含义 556
23.3.3 构建Exception派生类型的一个层次结构 558
23.3.4 构造类型的实例 560
23.4 设计支持加载项的应用程序 562
23.5 使用反射发现类型的成员 564
23.5.1 发现类型成员 565
23.5.2 BindingFlags：筛选返回的成员种类 569
23.5.3 发现类型的接口 570
23.5.4 调用类型的成员 571
23.5.5 一次绑定，多次调用 575
23.5.6 使用绑定句柄来减少进程的内存耗用 581
第24章 运行时序列化 585
24.1 序列化/反序列化快速入门 586
24.2 使类型可序列化 590
24.3 控制序列化和反序列化 592
24.4 格式化器如何序列化类型实例 595
24.5 控制序列化/反序列化的数据 597
24.6 流上下文 603
24.7 将类型序列化为不同的类型以及将对象反序列化为不同的对象 604
24.8 序列化代理 606
代理选择器链 609
24.9 反序列化对象时重写程序集和/或类型 610
第Ⅴ部分 线程处理
第25章 线程基础 615
25.1 Windows为什么要支持线程 615
25.2 线程开销 616
25.3 停止疯狂 620
25.4 CPU发展趋势 622
25.5 NUMA架构的机器 623
25.6 CLR线程和Windows线程 625
25.7 使用专用线程执行异步的计算限制操作 625
25.8 使用线程的理由 627
25.9 线程调度和优先级 629
25.10 前台线程和后台线程 634
25.11 继续学习 635
第26章 计算限制的异步操作 637
26.1 CLR线程池基础 638
26.2 执行简单的计算限制操作 639
26.3 执行上下文 640
26.4 协作式取消 642
26.5 任务 645
26.5.1 等待任务完成并获取它的结果 646
26.5.2 取消任务 648
26.5.3 一个任务完成时自动启动一个新任务 649
26.5.4 任务可以启动子任务 651
26.5.5 任务内部揭秘 652
26.5.6 任务工厂 653
26.5.7 任务调度器 655
26.6 Parallel的静态For，ForEach和Invoke方法 657
26.7 并行语言集成查询(PLINQ) 660
26.8 执行定时计算限制操作 663
26.9 线程池如何管理线程 665
26.9.1 设置线程池限制 665
26.9.2 如何管理工作者线程 666
26.10 缓存线和伪共享 667
第27章 I/O限制的异步操作 671
27.1 Windows如何执行I/O操作 671
27.2 CLR的异步编程模型(APM) 675
27.3 AsyncEnumerator类 679
27.4 APM和异常 682
27.5 应用程序及其线程处理模型 683
27.6 异步实现服务器 687
27.7 APM和计算限制的操作 687
27.8 APM的注意事项 689
27.8.1 在没有线程池的前提下使用APM 689
27.8.2 总是调用EndXxx方法，而且只调用一次 690
27.8.3 调用EndXxx方法时总是使用相同的对象 690
27.8.4 为BeginXxx和EndXxx方法使用ref，out和params实参 691
27.8.5 不能取消异步I/O限制操作 691
27.8.6 内存消耗 691
27.8.7 有的I/O操作必须同步完成 691
27.8.8 FileStream特有的问题 692
27.9 I/O请求优先级 693
27.10 将IAsyncResult APM转换为Task 695
27.11 基于事件的异步模式 696
27.11.1 将EAP转换为Task 698
27.11.2 APM和EAP的对比 699
27.12 编程模型的泥沼 700
第28章 基元线程同步构造 703
28.1 类库和线程安全 705
28.2 基元用户模式和内核模式构造 706
28.3 用户模式构造 707
28.3.1 易失构造 708
28.3.2 互锁构造 713
28.3.3 实现简单的Spin Lock 717
28.3.4 Interlocked Anything模式 720
28.4 内核模式构造 722
28.4.1 Event构造 725
28.4.2 Semaphore构造 727
28.4.3 Mutex构造 728
28.4.4 在一个内核构造可用时调用一个方法 730
第29章 混合线程同步构造 733
29.1 一个简单的混合锁 733
29.2 自旋、线程所有权和递归 735
29.3 混合构造的大杂烩 737
29.3.1 ManualResetEventSlim类和SemaphoreSlim类 737
29.3.2 Monitor类和同步块 738
29.3.3 ReaderWriterLockSlim类 743
29.3.4 OneManyLock类 745
29.3.5 CountdownEvent类 747
29.3.6 Barrier类 747
29.3.7 线程同步构造小结 748
29.4 著名的双检锁技术 750
29.5 条件变量模式 754
29.6 用集合防止占有锁太长的时间 756
29.7 并发集合类 760
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>CLR via C#
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解ES6
第1章 块级作用域绑定 1
var声明及变量提升（Hoisting）机制 1
块级声明 3
-- let声明 3
-- 禁止重声明 4
-- const声明 4
-- 临时死区（Temporal Dead Zone） 6
循环中的块作用域绑定 7
-- 循环中的函数 8
-- 循环中的let声明 9
-- 循环中的const声明 10
全局块作用域绑定 12
块级绑定最佳实践的进化 13
小结 13
第2章 字符串和正则表达式 14
更好的Unicode支持 14
-- UTF-16码位 15
-- codePointAt()方法 16
-- String.fromCodePoint()方法 17
-- normalize()方法 17
-- 正则表达式u修饰符 19
其他字符串变更 21
-- 字符串中的子串识别 21
-- repeat()方法 22
其他正则表达式语法变更 23
-- 正则表达式y修饰符 23
-- 正则表达式的复制 26
-- flags属性 27
模板字面量 28
-- 基础语法 28
-- 多行字符串 29
-- 字符串占位符 31
-- 标签模板 32
小结 36
第3章 函数 37
函数形参的默认值 37
-- 在ECMAScript 5中模拟默认参数 38
-- ECMAScript 6中的默认参数值 38
-- 默认参数值对arguments对象的影响 40
-- 默认参数表达式 42
-- 默认参数的临时死区 44
处理无命名参数 46
-- ECMAScript 5中的无命名参数 46
-- 不定参数 47
增强的Function构造函数 49
展开运算符 50
name属性 52
-- 如何选择合适的名称 52
-- name属性的特殊情况 52
明确函数的多重用途 54
-- 在ECMAScript 5中判断函数被调用的方法 54
-- 元属性（Metaproperty）new.target 55
块级函数 57
-- 块级函数的使用场景 58
-- 非严格模式下的块级函数 58
箭头函数 59
-- 箭头函数语法 60
-- 创建立即执行函数表达式 62
-- 箭头函数没有this绑定 63
-- 箭头函数和数组 65
-- 箭头函数没有arguments绑定 66
-- 箭头函数的辨识方法 66
尾调用优化 67
-- ECMAScript 6中的尾调用优化 68
-- 如何利用尾调用优化 69
小结 71
第4章 扩展对象的功能性 72
对象类别 72
对象字面量语法扩展 73
-- 属性初始值的简写 73
-- 对象方法的简写语法 74
-- 可计算属性名（Computed Property Name） 75
新增方法 76
-- Object.is()方法 76
-- Object.assign()方法 77
重复的对象字面量属性 80
自有属性枚举顺序 81
增强对象原型 82
-- 改变对象的原型 82
-- 简化原型访问的Super引用 83
正式的方法定义 86
小结 88
第5章 解构：使数据访问更便捷 89
为何使用解构功能 89
对象解构 90
-- 解构赋值 91
-- 默认值 92
-- 为非同名局部变量赋值 93
-- 嵌套对象解构 94
数组解构 96
-- 解构赋值 97
-- 默认值 99
-- 嵌套数组解构 99
-- 不定元素 99
混合解构 101
解构参数 102
-- 必须传值的解构参数 103
-- 解构参数的默认值 104
小结 106
第6章 Symbol和Symbol属性 107
创建Symbol 107
Symbol的使用方法 109
Symbol共享体系 110
Symbol与类型强制转换 112
Symbol属性检索 112
通过well-known Symbol暴露内部操作 113
-- Symbol.hasInstance方法 114
-- Symbol.isConcatSpreadable属性 116
-- Symbol.match、Symbol.replace、Symbol.search和Symbol.split属性 118
-- Symbol.toPrimitive方法 120
-- Symbol.toStringTag属性 122
-- Symbol.unscopables属性 125
小结 127
第7章 Set集合与Map集合 128
ECMAScript 5中的Set集合与Map集合 129
该解决方案的一些问题 129
ECMAScript 6中的Set集合 131
-- 创建Set集合并添加元素 131
-- 移除元素 133
-- Set集合的forEach()方法 133
-- 将Set集合转换为数组 136
-- Weak Set集合 136
ECMAScript 6中的Map集合 139
-- Map集合支持的方法 140
-- Map集合的初始化方法 141
-- Map集合的forEach()方法 142
-- Weak Map集合 143
小结 147
第8章 迭代器（Iterator）和生成器（Generator） 149
循环语句的问题 149
什么是迭代器 150
什么是生成器 151
-- 生成器函数表达式 153
-- 生成器对象的方法 154
可迭代对象和for-of循环 155
-- 访问默认迭代器 156
-- 创建可迭代对象 157
内建迭代器 158
-- 集合对象迭代器 158
-- 字符串迭代器 163
-- NodeList迭代器 164
展开运算符与非数组可迭代对象 165
高级迭代器功能 166
-- 给迭代器传递参数 166
-- 在迭代器中抛出错误 168
-- 生成器返回语句 170
-- 委托生成器 171
异步任务执行 174
-- 简单任务执行器 174
-- 向任务执行器传递数据 176
-- 异步任务执行器 177
小结 180
第9章 JavaScript中的类 181
ECMAScript 5中的近类结构 181
类的声明 182
-- 基本的类声明语法 182
-- 为何使用类语法 184
类表达式 186
-- 基本的类表达式语法 186
-- 命名类表达式 187
作为一等公民的类 189
访问器属性 190
可计算成员名称 192
生成器方法 193
静态成员 195
继承与派生类 196
-- 类方法遮蔽 199
-- 静态成员继承 199
-- 派生自表达式的类 200
-- 内建对象的继承 203
-- Symbol.species属性 205
在类的构造函数中使用new.target 208
小结 210
第10章 改进的数组功能 211
创建数组 211
-- Array.of()方法 212
-- Array.from()方法 213
为所有数组添加的新方法 216
-- find()方法和findIndex()方法 217
-- fill()方法 217
-- copyWithin()方法 218
定型数组 219
-- 数值数据类型 220
-- 数组缓冲区 221
-- 通过视图操作数组缓冲区 221
定型数组与普通数组的相似之处 228
-- 通用方法 229
-- 相同的迭代器 230
-- of()方法和from()方法 230
定型数组与普通数组的差别 231
-- 行为差异 231
-- 缺失的方法 232
-- 附加方法 233
小结 234
第11章 Promise与异步编程 235
异步编程的背景知识 235
-- 事件模型 236
-- 回调模式 236
Promise的基础知识 239
-- Promise的生命周期 239
-- 创建未完成的Promise 242
-- 创建已处理的Promise 244
-- 执行器错误 247
全局的Promise拒绝处理 248
Node.js环境的拒绝处理 248
浏览器环境的拒绝处理 251
串联Promise 253
-- 捕获错误 254
-- Promise链的返回值 255
-- 在Promise链中返回Promise 256
响应多个Promise 259
-- Promise.all()方法 259
-- Promise.race()方法 260
自Promise继承 262
基于Promise的异步任务执行 263
小结 267
第12章 代理（Proxy）和反射（Reflection）API 269
数组问题 269
代理和反射 270
创建一个简单的代理 271
使用set陷阱验证属性 272
用get陷阱验证对象结构（Object Shape） 274
使用has陷阱隐藏已有属性 275
用deleteProperty陷阱防止删除属性 277
原型代理陷阱 279
-- 原型代理陷阱的运行机制 279
-- 为什么有两组方法 281
对象可扩展性陷阱 282
-- 两个基础示例 283
-- 重复的可扩展性方法 284
属性描述符陷阱 285
-- 给Object.defineProperty()添加限制 286
-- 描述符对象限制 287
-- 重复的描述符方法 288
ownKeys陷阱 290
函数代理中的apply和construct陷阱 291
-- 验证函数参数 292
-- 不用new调用构造函数 294
-- 覆写抽象基类构造函数 296
-- 可调用的类构造函数 297
可撤销代理 298
解决数组问题 299
-- 检测数组索引 300
-- 添加新元素时增加length的值 300
-- 减少length的值来删除元素 302
-- 实现MyArray类 304
将代理用作原型 307
-- 在原型上使用get陷阱 307
-- 在原型上使用set陷阱 308
-- 在原型上使用has陷阱 309
-- 将代理用作类的原型 310
小结 314
第13章 用模块封装代码 315
什么是模块 315
导出的基本语法 316
导入的基本语法 317
-- 导入单个绑定 318
-- 导入多个绑定 318
-- 导入整个模块 318
-- 导入绑定的一个微妙怪异之处 320
导出和导入时重命名 320
模块的默认值 321
-- 导出默认值 321
-- 导入默认值 322
重新导出一个绑定 323
无绑定导入 324
加载模块 325
-- 在Web浏览器中使用模块 325
-- 浏览器模块说明符解析 329
小结 330
附录A ECMAScript 6中较小的改动 331
附录B 了解ECMAScript 7（2016） 337
索引 343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解ES6
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX环境高级编程（第3版）
第1章 UNIX基础知识
1.1 引言
1.2 UNIX体系结构
1.3 登录
1.4 文件和目录
1.5 输入和输出
1.6 程序和进程
1.7 出错处理
1.8 用户标识
1.9 信号
1.10 时间值
1.11 系统调用和库函数
1.12 小结
习题
第2章 UNIX标准及实现
2.1 引言
2.2 UNIX标准化
2.2.1 ISO C
2.2.2 IEEE POSIX
2.2.3 Single UNIX Specification
2.2.4 FIPS
2.3 UNIX系统实现
2.3.1 SVR4
2.3.2 4.4BSD
2.3.3 FreeBSD
2.3.4 Linux
2.3.5 Mac OS X
2.3.6 Solaris
2.3.7 其他UNIX系统
2.4 标准和实现的关系
2.5 限制
2.5.1 ISO C限制
2.5.2 POSIX限制
2.5.3 XSI限制
2.5.4 函数sysconf、pathconf和fpathconf
2.5.5 不确定的运行时限制
2.6 选项
2.7 功能测试宏
2.8 基本系统数据类型
2.9 标准之间的冲突
2.10 小结
习题
第3章 文件I/O
3.1 引言
3.2 文件描述符
3.3 函数open和openat
3.4 函数creat
3.5 函数close
3.6 函数lseek
3.7 函数read
3.8 函数write
3.9 I/O的效率
3.10 文件共享
3.11 原子操作
3.12 函数dup和dup2
3.13 函数sync、fsync和fdatasync
3.14 函数fcntl
3.15 函数ioctl
3.16 /dev/fd
3.17 小结
习题
第4章 文件和目录
4.1 引言
4.2 函数stat、fstat、fstatat和lstat
4.3 文件类型
4.4 设置用户ID和设置组ID
4.5 文件访问权限
4.6 新文件和目录的所有权
4.7 函数access和faccessat
4.8 函数umask
4.9 函数chmod、fchmod和fchmodat
4.10 粘着位
4.11 函数chown、fchown、fchownat和lchown
4.12 文件长度
4.13 文件截断
4.14 文件系统
4.15 函数link、linkat、unlink、unlinkat和remove
4.16 函数rename和renameat
4.17 符号链接
4.18 创建和读取符号链接
4.19 文件的时间
4.20 函数futimens、utimensat和utimes
4.21 函数mkdir、mkdirat和rmdir
4.22 读目录
4.23 函数chdir、fchdir和getcwd
4.24 设备特殊文件
4.25 文件访问权限位小结
4.26 小结
习题
第5章 标准I/O库
5.1 引言
5.2 流和FILE对象
5.3 标准输入、标准输出和标准错误
5.4 缓冲
5.5 打开流
5.6 读和写流
5.7 每次一行I/O
5.8 标准I/O的效率
5.9 二进制I/O
5.10 定位流
5.11 格式化I/O
5.12 实现细节
5.13 临时文件
5.14 内存流
5.15 标准I/O的替代软件
5.16 小结
习题
第6章 系统数据文件和信息
6.1 引言
6.2 口令文件
6.3 阴影口令
6.4 组文件
6.5 附属组ID
6.6 实现区别
6.7 其他数据文件
6.8 登录账户记录
6.9 系统标识
6.10 时间和日期例程
6.11 小结
习题
第7章 进程环境
7.1 引言
7.2 main函数
7.3 进程终止
7.4 命令行参数
7.5 环境表
7.6 C程序的存储空间布局
7.7 共享库
7.8 存储空间分配
7.9 环境变量
7.10 函数setjmp和longjmp
7.11 函数getrlimit和setrlimit
7.12 小结
习题
第8章 进程控制
8.1 引言
8.2 进程标识
8.3 函数fork
8.4 函数vfork
8.5 函数exit
8.6 函数wait和waitpid
8.7 函数waitid
8.8 函数wait3和wait4
8.9 竞争条件
8.10 函数exec
8.11 更改用户ID和更改组ID
8.12 解释器文件
8.13 函数system
8.14 进程会计
8.15 用户标识
8.16 进程调度
8.17 进程时间
8.18 小结
习题
第9章 进程关系
9.1 引言
9.2 终端登录
9.3 网络登录
9.4 进程组
9.5 会话
9.6 控制终端
9.7 函数tcgetpgrp、tcsetpgrp和tcgetsid
9.8 作业控制
9.9 shell执行程序
9.10 孤儿进程组
9.11 FreeBSD实现
9.12 小结
习题
第10章 信号
10.1 引言
10.2 信号概念
10.3 函数signal
10.4 不可靠的信号
10.5 中断的系统调用
10.6 可重入函数
10.7 SIGCLD语义
10.8 可靠信号术语和语义
10.9 函数kill和raise
10.10 函数alarm和pause
10.11 信号集
10.12 函数sigprocmask
10.13 函数sigpending
10.14 函数sigaction
10.15 函数sigsetjmp和siglongjmp
10.16 函数sigsuspend
10.17 函数abort
10.18 函数system
10.19 函数sleep、nanosleep和clock_nanosleep
10.20 函数sigqueue
10.21 作业控制信号
10.22 信号名和编号
10.23 小结
习题
第11章 线程
11.1 引言
11.2 线程概念
11.3 线程标识
11.4 线程创建
11.5 线程终止
11.6 线程同步
11.6.1 互斥量
11.6.2 避免死锁
11.6.3 函数pthread_mutex_timedlock
11.6.4 读写锁
11.6.5 带有超时的读写锁
11.6.6 条件变量
11.6.7 自旋锁
11.6.8 屏障
11.7 小结
习题
第12章 线程控制
12.1 引言
12.2 线程限制
12.3 线程属性
12.4 同步属性
12.4.1 互斥量属性
12.4.2 读写锁属性
12.4.3 条件变量属性
12.4.4 屏障属性
12.5 重入
12.6 线程特定数据
12.7 取消选项
12.8 线程和信号
12.9 线程和fork
12.10 线程和I/O
12.11 小结
习题
第13章 守护进程
13.1 引言
13.2 守护进程的特征
13.3 编程规则
13.4 出错记录
13.5 单实例守护进程
13.6 守护进程的惯例
13.7 客户进程-服务器进程模型
13.8 小结
习题
第14章 高级I/O
14.1 引言
14.2 非阻塞I/O
14.3 记录锁
14.4 I/O多路转接
14.4.1 函数select和pselect
14.4.2 函数poll
14.5 异步I/O
14.5.1 System V异步I/O
14.5.2 BSD异步I/O
14.5.3 POSIX异步I/O
14.6 函数readv和writev
14.7 函数readn和writen
14.8 存储映射I/O
14.9 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX环境高级编程（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机系统概论
出版者的话
专家指导委员会
译者序
代序
第2版前言
第1版前言
第1章 欢迎阅读本书
1.1 我们的目标
1.2 怎么才能做到
1.3 两个反复出现的理念
1.3.1 抽象之理念
1.3.2 硬件与软件
1.4 计算机系统简述
1.5 两个非常重要的思想
1.6 计算机：通用计算设备
1.7 从问题描述到电子运转
1.7.1 问题的提出
1.7.2 算法
1.7.3 程序
1.7.4 指令集结构
1.7.5 微结构
1.7.6 逻辑电路
1.7.7 器件
1.7.8 小结
1.8 习题
第2章 bit、数据类型及其运算
2.1 bit和数据类型
2.1.1 bit——信息的基本单位
2.1.2 数据类型
2.2 整数数据类型
2.2.1 无符号整数
2.2.2 有符号整数
2.3 补码
2.4 二进制数与十进制数之间的转换
2.4.1 二进制数转换为十进制数
2.4.2 十进制数转换为二进制数
2.5 bit运算之一：算术运算
2.5.1 加法和减法
2.5.2 符号扩展
2.5.3 溢出
2.6 bit运算之二：逻辑运算
2.6.1 “与”运算
2.6.2 “或”运算
2.6.3 “非”运算
2.6.4 “异或”运算
2.7 其他类型
2.7.1 位矢量
2.7.2 浮点数
2.7.3 ASCⅡ码
2.7.4 十六进制计数法
2.8 习题
第3章 数字逻辑
3.1 MOS晶体管
3.2 逻辑门
3.2.1 非门
3.2.2 或门、或非门
3.2.3 与门、与非门
3.2.4 摩根定律
3.2.5 多输入门
3.3 组合逻辑
3.3.1 译码器
3.3.2 多路复用器
3.3.3 全加器
3.3.4 可编程逻辑阵列
3.3.5 逻辑完备性
3.4 存储单元
3.4.1 R-S锁存器
3.4.2 门控D锁存器
3.4.3 寄存器
3.5 内存的概念
3.5.1 寻址空间
3.5.2 寻址能力
3.5.3 例子：22x3内存
3.6 时序电路
3.6.1 组合密码锁
3.6.2 状态的概念
3.6.3 有限状态机
3.6.4 有限状态机的实现
3.7 LC-3计算机的数据通路
3.8 习题
第4章 冯·诺伊曼模型
4.1 基本部件
4.1.1 内存
4.1.2 处理单元
4.1.3 输入和输出单元
4.1.4 控制单元
4.2 LC-3：一台冯·诺伊曼机器
4.3 指令处理
4.3.1 指令
4.3.2 指令周期
4.4 改变执行顺序
4.5 停机操作
4.6 习题
第5章 LC-3结构
5.1 ISA概述
5.1.1 内存组织
5.1.2 寄存器
5.1.3 指令集
5.1.4 操作码
5.1.5 数据类型
5.1.6 寻址模式
5.1.7 条件码
5.2 操作指令
5.3 数据搬移指令
5.3.1 PC相对寻址
5.3.2 间接寻址
5.3.3 基址偏移寻址
5.3.4 立即数寻址
5.3.5 一个例子
5.4 控制指令
5.4.1 条件跳转指令
5.4.2 一个例子
5.4.3 循环控制的两种方法
5.4.4 例子：哨兵法数组求和
5.4.5 JMP指令
5.4.6 TRAP指令
5.5 例子：字符数统计
5.6 总结：数据通路(LC-3)
5.6.1 数据通路的基本部件
5.6.2 指令周期
5.7 习题
第6章 编程
6.1 问题求解
6.1.1 系统分解
6.1.2 三种结构：顺序、条件、循环
6.1.3 实现三种结构的LC-3指令
6.1.4 回顾字符数统计例子
6.2 调试
6.2.1 调试的基本操作
6.2.2 交互式调试器的使用
6.3 习题
第7章 汇编语言
7.1 汇编语言编程——更上一层
7.2 一个汇编程序
7.2.1 指令
7.2.2 伪操作
7.2.3 例子：字符数统计程序
7.3 汇编过程
7.3.1 概述
7.3.2 两遍扫描
7.3.3 第1遍：创建符号表
7.3.4 第2遍：生成机器语言程序
7.4 相关知识
7.4.1 可执行映像
7.4.2 多目标文件
7.5 习题
第8章 输入/输出
8.1 输入/输出的基本概念
8.1.1 设备寄存器
8.1.2 内存映射I/O与专用I/O指令
8.1.3 异步I/O与同步I/O
8.1.4 中断驱动与轮询
8.2 键盘输入
8.2.1 基本输入寄存器
8.2.2 基本输入服务程序
8.2.3 内存映射输入的实现
8.3 显示器输出
8.3.1 基本输出寄存器(DDR和DSR)
8.3.2 基本输出服务程序
8.3.3 内存映射输出的实现
8.3.4 例子：键盘回显
8.4 一个更复杂的输入程序
8.5 中断驱动I/O
8.5.1 什么是中断驱动I/O
8.5.2 为什么要引入中断驱动I/O
8.5.3 中断信号的产生
8.6 内存映射I/O的回顾
8.7 习题
第9章 TRAP程序和子程序
9.1 LC-3 TRAP程序
9.1.1 概述
9.1.2 TRAP机制
9.1.3 TRAP指令
9.1.4 完整机制
9.1.5 I/O中断处理程序
9.1.6 HALT中断程序
9.1.7 寄存器内容的保存和恢复
9.2 子程序
9.2.1 调用/返回机制
9.2.2 JSR(R)指令
9.2.3 字符输入的TRAP程序
9.2.4 PUTS：写字符串
9.2.5 库程序
9.3 习题
第10章 栈
10.1 栈的基本结构
10.1.1 抽象数据类型：栈
10.1.2 两个实现例子
10.1.3 内存中的实现
10.1.4 小结
10.2 中断驱动I/O(第二部分)
10.2.1 启动和执行
10.2.2 中断返回
10.2.3 例子：嵌套中断
10.3 基于栈的算术运算
10.3.1 栈的临时存储作用
10.3.2 例子：算术表达式
10.3.3 加、乘和取反
10.4 数据类型转换
10.4.1 一个错误结果的例子：2+3=e
10.4.2 ASCⅡ/二进制转换
10.4.3 二进制/ASCⅡ转换
10.5 模拟计算器
10.6 习题
第11章 C语言编程概述
11.1 我们的目标
11.2 软硬件结合
11.3 高级语言翻译
11.3.1 解释执行
11.3.2 编译执行
11.3.3 两种方法的优缺点
11.4 C编程语言
11.5 一个简单的C程序
11.5.1 main函数
11.5.2 编程风格
11.5.3 C预处理器
11.5.4 输入和输出
11.6 小结
11.7 习题
第12章 变量和运算符
12.1 概述
12.2 变量
12.2.1 三种基本数据类型：int、char、double
12.2.2 标识符的选择
12.2.3 局部变量和全局变量
12.2.4 更多的例子
12.3 运算符
12.3.1 表达式和语句
12.3.2 赋值运算符
12.3.3 算术运算符
12.3.4 算术优先级
12.3.5 位运算符
12.3.6 关系运算符
12.3.7 逻辑运算符
12.3.8 递增/递减运算符
12.3.9 运算符混合表达式
12.4 基于运算符的问题求解
12.5 编译器处理
12.5.1 符号表
12.5.2 变量的空间分配
12.5.3 完整的例子
12.6 补充话题
12.6.1 三种基本类型的变种
12.6.2 文字常量、常量和符号值
12.6.3 存储类型
12.6.4 更多的C运算符
12.7 小结
12.8 习题
第13章 控制结构
13.1 概述
13.2 条件结构
13.2.1 if语句
13.2.2 ifelse语句
13.3 循环结构
13.3.1 while语句
13.3.2 for语句
13.3ac电脑的选择 25
2.3.1 最小系统需求 25
2.3.2 选择操作系统 26
2.3.3 了解电脑配件 26
2.4 电脑配件的选择 29
2.4.1 硬盘的选择 29
2?E-mail地址
13.5 其他C语言控制结构
13.5.1 switch语句
13.5.2 break和continue语句
13.5.3 简单计算器的例子
13.6 小结
13.7 习题
第14章 函数
14.1 概述
14.2 C语言中的函数
14.2.1 带参数的函数
14.2.2 求解圆面积
14.3 C语言中函数的实现
14.3.1 运行时栈
14.3.2 实现机制
14.3.3 汇总
14.4 问题求解
14.4.1 例1：大小写转换
14.4.2 例2：毕达哥拉斯三角形
14.5 小结
14.6 习题
第15章 测试与调试技术
15.1 概述
15.2 错误类型
15.2.1 语法错误
15.2.2 语义错误
15.2.3 算法错误
15.3 测试
15.3.1 黑盒测试
15.3.2 白盒测试
15.4 调试
15.4.1 特定方法
15.4.2 源码级调试工具
15.4.3 断点
15.5 正确的编程方法
15.5.1 明确规格说明
15.5.2 模块化设计
15.5.3 预防错误式编程
15.6 小结
15.7 习题
第16章 指针和数组
16.1 概述
16.2 指针
16.2.1 声明指针变量
16.2.2 指针运算符
16.2.3 指针传递一个引用
16.2.4 空指针
16.2.5 语法
16.2.6 指针例程
16.3 数组
16.3.1 数组声明
16.3.2 数组应用
16.3.3 数组参数
16.3.4 C语言的字符串
16.3.5 数组与指针的关系
16.3.6 实例：插入排序
16.3.7 C语言数组的不足
16.4 小结
16.5 习题
第17章 递归
17.1 概述
17.2 什么是递归
17.3 递归与循环
17.4 汉诺塔
17.5 斐波纳契数列
17.6 二分查找
17.7 整数转换为ASCⅡ字符串
17.8 小结
17.9 习题
笫18章 C语言中的I/O
18.1 概述
18.2 C标准库函数
18.3 字符I/O操作
18.3.1 I/O流
18.3.2 putchar函数
18.3.3 getchai函数
18.3.4 缓冲I/O
18.4 格式化I/O
18.4.1 printf
18.4.2 scanf
18.4.3 可变长参数
18.5 文件I/O
18.6 小结
18.7 习题
第19章 数据结构
19.1 概述
19.2 结构体
19.2.1 typedef
19.2.2 结构体在C中的实现
19.3 结构体数组
19.4 动态内存分配
19.5 链表
19.6 小结
19.7 习题
附录A LC-3指令集结构
附录B 从LC-3到x86
附录C LC-3的微结构
附录D C编程语言
附录E 常用表
附录F 部分习题答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机系统概论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全球经济史
致谢
1 巨大的差异
2 西方的崛起
3 工业革命
4 富国之路
5 庞大的帝国
6 美洲
7 非洲
8 标准模式与后发工业化
9 “大推进”式工业化
后记
索引
英文原文
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全球经济史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>邻里东京
说明
序言
第一章 宫本町概述
第二章 一个邻里的发展
第三章 地方政治和行政
第四章 社区服务和邻里活动
第五章 参与和权力的正式层级结构
第六章 朋友和邻居
第七章 节日和社会秩序
结论
附录A 宫本町的人口
附录B 柳木宫本町会
附录C 节庆委员会干部花名册(1980年)
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>邻里东京
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计新思维
第一部分 开发环境
第1章 准备方便的编译环境	3
1.1 使用包管理器	4
1.2 在Windows下编译C	6
1.2.1 Windows中的POSIX环境	7
1.2.2 在POSIX下编译C	8
1.2.3 不在POSIX环境中编译C	9
1.3 库的路径	10
1.3.1 一些我喜欢的选项	11
1.3.2 路径	13
1.3.3 运行时连接	15
1.4 使用Makefile	16
1.4.1 设定变量	17
1.4.2 规则	19
1.5 以源文件利用库	23
1.6 以源文件利用库（即使你的系统管理员不想叫你这么做）	24
1.7 通过本地文档来编译C程序	26
1.7.1 在命令行里包含头文件	26
1.7.2 统一的头文件	27
1.7.3 嵌入文档	28
1.7.4 从stdin中编译	29
第2章 调试、测试和文档	31
2.1 使用调试器	31
2.1.1 GDB变量	35
2.1.2 打印结构	36
2.2 利用Valgrind检查错误	40
2.3 单元测试	41
2.3.1 把程序用作库	44
2.3.2 测试覆盖	45
2.4 编制文档	46
2.4.1 Doxygen	46
2.4.2 用CWEB解释代码	48
2.5 错误检查	50
2.5.1 在错误中的用户参与是什么	50
2.5.2 用户工作的上下文环境	52
2.5.3 如何返回错误信息	53
第3章 打包项目	55
3.1 Shell	56
3.1.1 用shell命令的输出来替换命令	56
3.1.2 用shell的循环来处理一组文件	58
3.1.3 针对文件的测试	60
3.1.4 fc	62
3.2 makefile还是shell脚本	64
3.3 用Autotools打包代码	67
3.3.1 一个Autotools的示例	68
3.3.2 用makefile.am来描述makefile	71
3.3.3 配置脚本	76
第4章 版本控制	80
4.1 通过diff查看差异	81
4.2 Git的对象	82
4.3 树和它们的枝	86
4.3.1 融合	88
4.3.2 迁移	89
4.4 远程版本库	90
第5章 和谐共处	93
5.1 过程	93
5.1.1 作为外来语言写程序	93
5.1.2 包装函数	94
5.1.3 跨越边境的代理数据结构	94
5.1.4 连接	96
5.2 与Python一起工作	96
5.2.1 编译与连接	98
5.2.2 Automake的条件子目录	98
5.2.3 Autotools支持下的Distutils	100
第二部分 语言
第6章 玩转指针	106
6.1 自动、静态和手工内存	106
6.2 持久性的状态变量	109
6.3 不使用malloc的指针	110
6.3.1 结构被复制，数组创建别名	111
6.3.2 malloc和内存操纵	114
6.3.3 错误来源于星号	115
6.3.4 你需要知道的各种指针运算	116
第7章 可以忽略的C语法	121
7.1 不需要明确地从main函数返回	122
7.2 让声明流动	122
在运行时设置数组的长度	124
7.3 减少类型转换	125
7.4 枚举和字符串	126
7.5 标签、goto、switch和break	128
7.5.1 考虑goto	129
7.5.2 switch	130
7.6 被摒弃的float	132
第8章 障碍和机遇	136
8.1 营造健壮和繁盛的宏	136
预处理器技巧	140
8.2 static和extern链接	143
只在头文件中声明外部链接的元素	145
8.3 const关键字	147
8.3.1 名词-形容词形式	148
8.3.2 压力	149
8.3.3 深度	150
8.3.4 char const **问题	150
第9章 文本	154
9.1 使用asprintf，使字符串的处理不再痛苦	154
9.1.1 安全	156
9.1.2 常量字符串	156
9.1.3 用asprintf扩展字符串	158
9.1.4 strtok的赞歌	159
9.2 Unicode	163
9.2.1 C代码的编码	165
9.2.2 Unicode函数库	167
9.2.3 示例代码	168
第10章 更好的结构	171
10.1 复合文字	172
通过复合文字进行初始化	173
10.2 可变参数宏	173
10.3 安全终止的列表	175
10.4 Foreach	176
10.5 函数的向量化	176
10.6 指定的初始化值	178
10.7 用零初始化数组和结构	180
10.8 typedef可以化繁为简	181
10.9 从函数返回多个数据项	183
10.10 灵活的函数输入	187
10.10.1 把函数声明为printf风格	187
10.10.2 可选参数和命名参数	189
10.10.3 使无聊的函数焕发光彩	191
10.11 void指针以及它所指向的结构	197
10.11.1 具有通用输入的函数	197
10.11.2 通用结构	201
第11章 C语言的面向对象编程	206
11.1 你所不明白的（以及为什么你不能不明白）	207
11.1.1 作用域	207
11.1.2 用操作符重载进行重载	210
11.2 扩展结构和字典	214
11.2.1 扩展一个结构	215
11.2.2 实现一个字典	219
11.2.3 基于指向对象的指针编码	223
11.3 你结构中的函数	224
11.4 引用计数	228
11.4.1 示例：一个子字符串对象	229
11.4.2 一个基于代理的组构造模型	233
第12章 库	240
12.1 GLib	240
12.2 POSIX	241
12.2.1 为巨大的数据集合使用mmap	241
12.2.2 用Pthreads轻松实现线程	243
12.3 GNU科学计算库	251
12.4 SQLite	254
12.5 libxml和cURL	256
后记	261
术语表	262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计新思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>抗争政治
目　录
前言………………………………………………………………………………………………
第一章　提出要求…………………………………………………………………………………
第二章　如何分析抗争……………………………………………………………………………
第三章　政权、剧目与机遇………………………………………………………………………
第四章　抗争互动…………………………………………………………………………………
第五章　动员与遣散………………………………………………………………………………
第六章　社会运动…………………………………………………………………………………
第七章　致命性冲突………………………………………………………………………………
第八章　混合政权中的抗争………………………………………………………………………
第九章　抗争的现在与未来………………………………………………………………………
附录Ａ　概念与方法………………………………………………………………………………
附录Ｂ　抗争之流、抗争片段、机制及过程……………………………………………………
参考文献……………………………………………………………………………………………
索　引………………………………………………………………………………………………
译后记………………………………………………………………………………………………
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>抗争政治
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大卫·休谟传
1980 年版序言............1
1954 年版序言............4
缩写目录及参考文献............9
第一部分　人性的研究者，1711—1744
第一章　文人............13
第二章　九泉的休谟家............16
第三章　九泉的童年............30
第四章　爱丁堡的学生时代............45
第五章　法律抑或文学？ ............63
第六章　学者病............78
第七章　宣泄与康复............94
第八章　法国的宁静............105
第九章　出版的焦躁............119
第十章　《人性论》............130
第十一章　《道德和政治随笔》............148
第二部分　人性的观察者，1744—1749
第十二章　学术幻影............169
第十三章　不幸的家庭教师............180
第十四章　目击叛乱............194
第十五章　一次军事突袭............206
第十六章　一次军事参访............224
第三部分　杰出的文人，1749—1763
第十七章　大展宏图............243
第十八章　休闲与欢笑............252
第十九章　爱丁堡公民............262
第二十章　《政治论衡》............280
第二十一章　教会治下的和平............297
第二十二章　反对者集结............313
第二十三章　《英国史》............331
第二十四章　《论文四篇》............352
第二十五章　教士鼓............370
第二十六章　游吟诗人和教会............390
第二十七章　苏格兰的奥古斯都时代............406
第二十八章　英格兰的冷漠............429
第四部分　世界公民，1763—1769
第二十九章　永住苏格兰？ ............449
第三十章　法兰西的召唤............463
第三十一章　法兰西的奉承............481
第三十二章　巴芙勒伯爵夫人............496
第三十三章　哲学家............516
第三十四章　大使秘书............531
第三十五章　让–雅克• 卢梭............549
第三十六章　副国务大臣............575
第五部分　苏格兰的圣大卫，1769—1776
第三十七章　秋日的宁静............601
第三十八章　和平的侵扰者............620
第三十九章　哲人之死............632
第四十章　人性的尊严............647
附录............653
文本补录............668
参考文献............689
索引............711
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大卫·休谟传
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>财务管理分析
第一部分 评估企业财务健康状况
第一章 财务报表分析
第一节 现金流量循环3
第二节 资产负债表5
一、流动资产与流动负债8
二、股东权益8
第三节 利润表9
利润的计量9
第四节 资金来源与运用表J3二指法14
第五节 现金流量表14
第六节 财务报表与价值问题18
一、市场价值与账面价值18
二、经济利润与会计利润20
三、应计成本20
本章摘要22
补充资料22
网址23
本章习题23
第二章 财务业绩评价
第一节 财务业绩杠杆26
第二节 股东权益收益率27
一、ROE的三项决定因素27
二、销售利润率28
三、资产周转率3口
四、财务杠杆34
第三节 ROE是一个值得信赖的财务尺度吗38
一、时效问题38
二、风险问题39
三、价值问题40
四、ROE与市价41
第四节 比率分析43
一、有效地使用比率钉
二、哈利一戴维森公司的比率分析44
附录财务结构的国际间差异51
在美国市场交易的外国公司比较51
公众公司53
趋同于国际会计准则54
本章摘要55
补充资料56
软件56
网址56
商业比率资料57
本章习题57
第二部分　计划未来的财务工作
第三章 财务预测
第一节 模拟财务报表63
一、销售百分比预测法64
二、利息费用68
三、季节性69
第二节 模拟财务报表与财务计划69
第三节 基于计算机的预测71
第四节 妥善处理不确定性73
一、敏感性分析73
二、场景分析74
三、模拟74
第五节 现金流量预测76
第六节 现金预算76
第七节 预测方法比较79
第八节 大公司的计划制订79
本章摘要81
补充资料81
软件82
网站82
本章习题82
第四章 管理增长
第一节 可持续增长87
可持续增长方程式88
第二节 增长太多90
一、平衡增长90
二、Biosite公司的可持续增长率91
三、“倘若……将会怎样”问题92
第三节 当实际增长超过可持续增长时怎么办93
一、发售新股94
二、提高财务杠杆94
三、削减股利支付比率95
四、有益的剥离95
五、外包96
六、定价96
七、合并是否就是答案96
第四节 增长太少97
第五节 当可持续增长超过实际增长时怎么办98
一、忽略问题98
二、把钱还给股东99
三、买人增长99
第六节 可持续增长与通货膨胀100
第七节 可持续增长和模拟预测101
第八节 新股筹资101
一、发售新股101
二、为什么美国公司不发行更多的股票JD3
本章摘要104
补充材料105
网址105
本章习题105
第三部分　筹资运作
第五章 筹资工具与市场
第一节 筹资工具112
一、债券112
二、普通股116
三、优先股121
第二节 金融市场121
一、私募权益122
二、首次公开发行123
三、季节性发行（seasonedissues）124
四、发行成本126
第三节 有效市场128
一、什么是有效市场128
二、有效性的意义130
附录利用金融市场来管理公司风险131
一、远期市场132
二、货币和资本市场的套期保值135
三、期权套期保值135
四、金融市场套期保值的局限性137
五、期权价值评估139
本章摘要141
补充资料142
网址142
本章习题143
第六章 筹资决策
第一节 财务杠杆146
第二节 衡量杠杆对企业的作用149
一、财务杠杆与风险150
二、财务杠杆与收益152
第三节 借贷的限度154
一、无关论154
二、税收利益156
三、财务困境成本156
四、财务弹性159
五、市场信号传递161
六、管理层激励163
七、筹资决策与增长163
第四节 选择到期期限结构166
通货膨胀与筹资策略166
附录无关论定理167
一、无税情况167
二、有税情况168
本章摘要169
补充材料170
网址170
本章习题171
第四部分
投资机会评估
第七章 现金流量贴现技术
第一节 价值数字177
一、回收期与会计收益率178
二、货币的时间价值179
三、约当值182
四、净现值182
五、效益一成本比率182
六、内部收益率184
七、若干应用和扩展187
八、互斥选择和资本限额190
九、正确认识IRR190
第二节 确定相关现金流量191
一、折旧192
二、流动资金与自发性资源194
三、沉没成本194
四、间接成本195
五、生产能力过剩196
六、筹资成本197
附录互斥选择和资本限额198
一、互斥选择和资本限额198
二、其余57．8万美元究竟怎么了199
三、不等长寿命199
四、资本限额201
五、未来机会问题202
六、决策树203
本章摘要203
补充资料204
软件204
网址204
本章习题205
第八章 投资决策的风险分析
第一节 风险的定义209
风险与多样化经营270
第二节 估计投资风险212
估计投资风险的三项技术213
第三节 包含风险的投资评估213
风险调整贴现率213
第四节 资本成本215
一、资本成本的定义215
二、哈利一戴维森公司的资本成本217
三、投资评估中的资本成本224
四、多重目标收益率224
第五节 利用现金流量贴现技术的四个陷阱226
一、企业角度与权益角度227
二、通货膨胀228
三、实物期权229
四、过度风险调整231
第六节 附加经济价值232
一、EVA与投资分析233
二、EVA的引人入胜之处234
第七节 一个注意事项234
附录资产贝塔与可调整现值235
一、贝塔与财务杠杆235
二、利用资产贝塔估计权益贝塔236
三、资产贝塔与可调整现值237
本章摘要239
补充资料240
网址240
本章习题240
第九章 公司价值评估与重组
第一节 公司价值评估245
一、资产或权益246
二、消亡或存活246
三、少数股权或控制权247
第二节 现金流量贴现价值评估248
一、自由现金流量249
二、终值249
三、一个实例251
四、以现值法评估价值的问题253
第三节 基于可比交易的价值评估254缺少变现性257
第四节 控制权市场257
一、控股制溢价257
二、重组的财务原因260
三、经验证据264
四、戴姆勒一克莱斯勒公司合并案265
附录风险资本的价值评估方法267
一、风险资本价值评估方法——单阶段融资268
二、风险资本价值评估方法——多阶段融资270
三、为何风险资本家要求如此之高的收益率271
本章摘要272
补充资料273
网址273
本章习题273
附录A278
附录B280
重要词汇中英文对照表282
奇数题参考答案288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>财务管理分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>农民的道义经济学
前言
导论
第一章 生存伦理的经济学与社会学
第二章 农民的选择和价值标准中的生存保障
第三章 风险分配与殖民地变革
第四章 作为勒索者的政府
第五章 经济萧条导致的起义
第六章 剥削的分析意义：互惠与生存的公正
第七章 反叛、幸存和镇压
索引
译后感言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>农民的道义经济学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>电影史：理论与实践（最新修订版）
作者序
第一部分　阅读、研究和撰写电影史
第一章　作为历史的电影史
第二章　研究电影史
第三章　阅读电影史
第二部分　传统的电影史研究方法
第四章　美学电影史
第五章　技术电影史
第六章　经济电影史
第七章　社会电影史
第三部分　做电影史
第八章　撰写电影史
第九章　重新整合电影史
第十章　选读指导
交响与争鸣:重构中国电影史学
上篇　观念与方法
下篇　实践
译编后记
跋（代） 　电影研究的“历史转向”：理论与方法   by孙绍谊
出版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>电影史：理论与实践（最新修订版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计语言
出版者的话
专家指导委员会
中文版序
译者序
序
第2版序
第1版序
导论
第1章 致读者
1.1 本书的结构
1.1.1 例子和参考
1.1.2 练习
1.1.3 有关实现的注记
1.2 学习C++
1.3 C++ 的设计
1.3.1 效率和结构
1.3.2 哲学注记
1.4 历史注记
1.5 C++ 的使用
1.6 C和C++
1.6.1 给C程序员的建议
1.6.2 给C++程序员的建议
1.7 有关在C++里编程的思考
1.8 忠告
1.9 参考文献
第2章 C++概览
2.1 为什么是C++
2.2 程序设计范型
2.3 过程式程序设计
2.3.1 变量和算术
2.3.2 检测和循环
2.3.3 指针和数组
2.4 模块程序设计
2.4.1 分别编译
2.4.2 异常处理
2.5 数据抽象
2.5.1 定义类型的模块
2.5.2 用户定义类型
2.5.3 具体类型
2.5.4 抽象类型
2.5.5 虚函数
2.6 面向对象的程序设计
2.6.1 具体类型的问题
2.6.2 类层次结构
2.7 通用型程序设计
2.7.1 容器
2.7.2 通用型算法
2.8 附言
2.9 忠告
第3章 标准库概览
3.1 引言
3.2 Hello, world！
3.3 标准库名字空间
3.4 输出
3.5 字符串
3.5.1 C风格的字符串
3.6 输入
3.7 容器
3.7.1 向量—vector
3.7.2 范围检查
3.7.3 表—list
3.7.4 映射—map
3.7.5 标准容器
3.8 算法
3.8.1 迭代器的使用
3.8.2 迭代器类型
3.8.3 迭代器和I/O
3.8.4 遍历和谓词
3.8.5 使用成员函数的算法
3.8.6 标准库算法
3.9 数学
3.9.1 复数
3.9.2 向量算术
3.9.3 基本数值支持
3.10 标准库功能
3.11 忠告
第一部分 基本功能
第4章 类型和声明
4.1 类型
4.1.1 基本类型
4.2 布尔量
4.3 字符类型
4.3.1 字符文字量
4.4 整数类型
4.4.1 整数文字量
4.5 浮点类型
4.5.1 浮点文字量
4.6 大小
4.7 void
4.8 枚举
4.9 声明
4.9.1 声明的结构
4.9.2 声明多个名字
4.9.3 名字
4.9.4 作用域
4.9.5 初始化
4.9.6 对象和左值
4.9.7 typedef
4.10 忠告
4.11 练习
第5章 指针、数组和结构
5.1 指针
5.1.1 零
5.2 数组
5.2.1 数组初始化
5.2.2 字符串文字量
5.3 到数组的指针
5.3.1 在数组里漫游
5.4 常量
5.4.1 指针和常量
5.5 引用
5.6 指向void的指针
5.7 结构
5.7.1 类型等价
5.8 忠告
5.9 练习
第6章 表达式和语句
6.1 一个桌面计算器
6.1.1 分析器
6.1.2 输入函数
6.1.3 低级输入
6.1.4 错误处理
6.1.5 驱动程序
6.1.6 头文件
6.1.7 命令行参数
6.1.8 有关风格的注记
6.2 运算符概览
6.2.1 结果
6.2.2 求值顺序
6.2.3 运算符优先级
6.2.4 按位逻辑运算符
6.2.5 增量和减量
6.2.6 自由存储
6.2.7 显式类型转换
6.2.8 构造函数
6.3 语句概览
6.3.1 声明作为语句
6.3.2 选择语句
6.3.3 迭代语句
6.3.4 goto
6.4 注释和缩进编排
6.5 忠告
6.6 练习
第7章 函数
7.1 函数声明
7.1.1 函数定义
7.1.2 静态变量
7.2 参数传递
7.2.1 数组参数
7.3 返回值
7.4 重载函数名
7.4.1 重载和返回类型
7.4.2 重载与作用域
7.4.3 手工的歧义性解析
7.4.4 多参数的解析
7.5 默认参数
7.6 未确定数目的参数
7.7 指向函数的指针
7.8 宏
7.8.1 条件编译
7.9 忠告
7.10 练习
第8章 名字空间和异常
8.1 模块化和界面
8.2 名字空间
8.2.1 带限定词的名字
8.2.2 使用声明
8.2.3 使用指令
8.2.4 多重界面
8.2.5 避免名字冲突
8.2.6 名字查找
8.2.7 名字空间别名
8.2.8 名字空间组合
8.2.9 名字空间和老代码
8.3 异常
8.3.1 抛出和捕捉
8.3.2 异常的辨识
8.3.3 在计算器中的异常
8.4 忠告
8.5 练习
第9章 源文件和程序
9.1 分别编译
9.2 连接
9.2.1 头文件
9.2.2 标准库头文件
9.2.3 单一定义规则
9.2.4 与非C++代码的连接
9.2.5 连接与指向函数的指针
9.3 使用头文件
9.3.1 单一头文件
9.3.2 多个头文件
9.3.3 包含保护符
9.4 程序
9.4.1 非局部变量的初始化
9.5 忠告
9.6 练习
第二部分 抽象机制
第10章 类
10.1 引言
10.2 类
10.2.1 成员函数
10.2.2 访问控制
10.2.3 构造函数
10.2.4 静态成员
10.2.5 类对象的复制
10.2.6 常量成员函数
10.2.7 自引用
10.2.8 结构和类
10.2.9 在类内部的函数定义
10.3 高效的用户定义类型
10.3.1 成员函数
10.3.2 协助函数
10.3.3 重载的运算符
10.3.4 具体类型的意义
10.4 对象
10.4.1 析构函数
10.4.2 默认构造函数
10.4.3 构造和析构
10.4.4 局部变量
10.4.5 自由存储
10.4.6 类对象作为成员
10.4.7 数组
10.4.8 局部静态存储
10.4.9 非局部存储
10.4.10 临时对象
10.4.11 对象的放置
10.4.12 联合
10.5 忠告
10.6 练习
第11章 运算符重载
11.1 引言
11.2 运算符函数
11.2.1 二元和一元运算符
11.2.2 运算符的预定义意义
11.2.3 运算符和用户定义类型
11.2.4 名字空间里的运算符
11.3 一个复数类型
11.3.1 成员运算符和非成员运算符
11.3.2 混合模式算术
11.3.3 初始化
11.3.4 复制
11.3.5 构造函数和转换
11.3.6 文字量
11.3.7 另一些成员函数
11.3.8 协助函数
11.4 转换运算符
11.4.1 歧义性
11.5 友元
11.5.1 友元的寻找
11.5.2 友元和成员
11.6 大型对象
11.7 基本运算符
11.7.1 显式构造函数
11.8 下标
11.9 函数调用
11.10 间接
11.11 增量和减量
11.12 一个字符串类
11.13 忠告
11.14 练习
第12章 派生类
12.1 引言
12.2 派生类
12.2.1 成员函数
12.2.2 构造函数和析构函数
12.2.3 复制
12.2.4 类层次结构
12.2.5 类型域
12.2.6 虚函数
12.3 抽象类
12.4 类层次结构的设计
12.4.1 一个传统的层次结构
12.4.2 抽象类
12.4.3 其他实现方式
12.4.4 对象创建的局部化
12.5 类层次结构和抽象类
12.6 忠告
12.7 练习
第13章 模板
13.1 引言
13.2 一个简单的String模板
13.2.1 定义一个模板
13.2.2 模板实例化
13.2.3 模板参数
13.2.4 类型等价
13.2.5 类型检查
13.3 函数模板
13.3.1 函数模板的参数
13.3.2 函数模板的重载
13.4 用模板参数描述策略
13.4.1 默认模板参数
13.5 专门化
13.5.1 专门化的顺序
13.5.2 模板函数的专门化
13.6 派生和模板
13.6.1 参数化和继承
13.6.2 成员模板
13.6.3 继承关系
13.7 源代码组织
13.8 忠告
13.9 练习
第14章 异常处理
14.1 错误处理
14.1.1 关于异常的其他观点
14.2 异常的结组
14.2.1 派生的异常
14.2.2 多个异常的组合
14.3 捕捉异常
14.3.1 重新抛出
14.3.2 捕捉所有异常
14.4 资源管理
14.4.1 构造函数和析构函数的使用
14.4.2 auto_ptr
14.4.3 告诫
14.4.4 异常和new
14.4.5 资源耗尽
14.4.6 构造函数里的异常
14.4.7 析构函数里的异常
14.5 不是错误的异常
14.6 异常的描述
14.6.1 对异常描述的检查
14.6.2 未预期的异常
14.6.3 异常的映射
14.7 未捕捉的异常
14.8 异常和效率
14.9 处理错误的其他方式
14.10 标准异常
14.11 忠告
14.12 练习
第15章 类层次结构
15.1 引言和概述
15.2 多重继承
15.2.1 歧义性解析
15.2.2 继承和使用声明
15.2.3 重复的基类
15.2.4 虚基类
15.2.5 使用多重继承
15.3 访问控制
15.3.1 保护成员
15.3.2 对基类的访问
15.4 运行时类型信息
15.4.1 dynamic_cast
15.4.2 在类层次结构中漫游
15.4.3 类对象的构造与析构
15.4.4 typeid和扩展的类型信息
15.4.5 RTTI的使用和误用
15.5 指向成员的指针
15.5.1 基类和派生类
15.6 自由存储
15.6.1 数组分配
15.6.2 虚构造函数
15.7 忠告
15.8 练习
第三部分 标 准 库
第16章 库组织和容器
16.1 标准库的设计
16.1.1 设计约束
16.1.2 标准库组织
16.1.3 语言支持
16.2 容器设计
16.2.1 专门化的容器和迭代器
16.2.2 有基类的容器
16.2.3 STL容器
16.3 向量
16.3.1 类型
16.3.2 迭代器
16.3.3 元素访问
16.3.4 构造函数
16.3.5 堆栈操作
16.3.6 表操作
16.3.7 元素定位
16.3.8 大小和容量
16.3.9 其他成员函数
16.3.10 协助函数
16.3.11 vector[bool]
16.4 忠告
16.5 练习
第17章 标准容器
17.1 标准容器
17.1.1 操作综述
17.1.2 容器综述
17.1.3 表示
17.1.4 对元素的要求
17.2 序列
17.2.1 向量—vector
17.2.2 表—list
17.2.3 双端队列—deque
17.3 序列适配器 1
17.3.1 堆栈—stack 1
17.3.2 队列—queue
17.3.3 优先队列—priority_queue
17.4 关联容器
17.4.1 映射—map
17.4.2 多重映射—multimap
17.4.3 集合—set
17.4.4 多重集合—multiset
17.5 拟容器
17.5.1 串—string
17.5.2 值向量—valarray
17.5.3 位集合—bitset
17.5.4 内部数组
17.6 定义新容器
17.6.1 散列映射—hash_map
17.6.2 表示和构造
17.6.3 其他散列关联容器
17.7 忠告
17.8 练习
第18章 算法和函数对象
18.1 引言
18.2 标准库算法综述
18.3 序列和容器
18.3.1 输入序列
18.4 函数对象
18.4.1 函数对象的基类
18.4.2 谓词
18.4.3 算术函数对象
18.4.4 约束器、适配器和否定器
18.5 非修改性序列算法
18.5.1 对每个做—for_each
18.5.2 查找族函数
18.5.3 计数
18.5.4 相等和不匹配
18.5.5 搜索
18.6 修改性序列算法
18.6.1 复制
18.6.2 变换
18.6.3 惟一化
18.6.4 取代
18.6.5 删除
18.6.6 填充和生成
18.6.7 反转和旋转
18.6.8 交换
18.7 排序的序列
18.7.1 排序
18.7.2 二分检索
18.7.3 归并
18.7.4 划分
18.7.5 序列上的集合运算
18.8 堆
18.9 最小和最大
18.10 排列
18.11 C风格算法
18.12 忠告
18.13 练习
第19章 迭代器和分配器
19.1 引言
19.2 迭代器和序列
19.2.1 迭代器的操作
19.2.2 迭代器特征类—iterator_traits
19.2.3 迭代器类别
19.2.4 插入器
19.2.5 反向迭代器
19.2.6 流迭代器
19.3 带检查迭代器
19.3.1 异常、容器和算法
19.4 分配器
19.4.1 标准分配器
19.4.2 一个用户定义分配器
19.4.3 广义的分配器
19.4.4 未初始化的存储
19.4.5 动态存储
19.4.6 C风格的分配
19.5 忠告
19.6 练习
第20章 串
20.1 引言
20.2 字符
20.2.1 字符特征类—char_traits
20.3 基础串类—basic_string
20.3.1 类型
20.3.2 迭代器
20.3.3 元素访问
20.3.4 构造函数
20.3.5 错误
20.3.6 赋值
20.3.7 到C风格字符串的转换
20.3.8 比较
20.3.9 插入
20.3.10 拼接
20.3.11 查找
20.3.12 替换
20.3.13 子串
20.3.14 大小和容量
20.3.15 I/O操作
20.3.16 交换
20.4 C标准库
20.4.1 C风格字符串
20.4.2 字符分类
20.5 忠告
20.6 练习
第21章 流
21.1 引言
21.2 输出
21.2.1 输出流
21.2.2 内部类型的输出
21.2.3 用户定义类型的输出
21.3 输入
21.3.1 输入流
21.3.2 内部类型的输入
21.3.3 流状态
21.3.4 字符的输入
21.3.5 用户定义类型的输入
21.3.6 异常
21.3.7 流的联结
21.3.8 哨位
21.4 格式化
21.4.1 格式状态
21.4.2 整数输出
21.4.3 浮点数输出
21.4.4 输出域
21.4.5 域的调整
21.4.6 操控符
21.5 文件流与字符串流
21.5.1 文件流
21.5.2 流的关闭
21.5.3 字符串流
21.6 缓冲
21.6.1 输出流和缓冲区
21.6.2 输入流和缓冲区
21.6.3 流和缓冲区
21.6.4 流缓冲区
21.7 现场
21.7.1 流回调
21.8 C输入/输出
21.9 忠告
21.10 练习
第22章 数值
22.1 引言
22.2 数值的限制
22.2.1 表示限制的宏
22.3 标准数学函数
22.4 向量算术
22.4.1 valarray的构造
22.4.2 valarray的下标和赋值
22.4.3 成员操作
22.4.4 非成员函数
22.4.5 切割
22.4.6 切割数组—slice_array
22.4.7 临时量、复制和循环
22.4.8 广义切割
22.4.9 屏蔽
22.4.10 间接数组—indirect_array
22.5 复数算术
22.6 通用数值算法
22.6.1 累积—accumulate
22.6.2 内积—inner_product
22.6.3 增量变化
22.7 随机数
22.8 忠告
22.9 练习
第四部分 用C++ 做设计
第23章 开发和设计
23.1 概述
23.2 引言
23.3 目的与手段
23.4 开发过程
23.4.1 开发循环
23.4.2 设计目标
23.4.3 设计步骤
23.4.4 试验和分析
23.4.5 测试
23.4.6 软件维护
23.4.7 效率
23.5 管理
23.5.1 重用
23.5.2 规模
23.5.3 个人
23.5.4 混成设计
23.6 带标注的参考文献
23.7 忠告
第24章 设计和编程
24.1 概述
24.2 设计和程序设计语言
24.2.1 忽视类
24.2.2 忽视继承
24.2.3 忽视静态类型检查
24.2.4 忽视程序设计
24.2.5 排他性地使用类层次结构
24.3 类
24.3.1 类表示什么
24.3.2 类层次结构
24.3.3 包容关系
24.3.4 包容和继承
24.3.5 使用关系
24.3.6 编入程序里的关系
24.3.7 类内的关系
24.4 组件
24.4.1 模板
24.4.2 界面和实现
24.4.3 肥大的界面
24.5 忠告
第25章 类的作用
25.1 类的种类
25.2 具体类型
25.2.1 具体类型的重用
25.3 抽象类型
25.4 结点
25.4.1 修改界面
25.5 动作
25.6 界面类
25.6.1 调整界面
25.7 句柄类
25.7.1 句柄上的操作
25.8 应用框架
25.9 忠告
25.10 练习
附录和索引
附录A 语法
附录B 兼容性
附录C 技术细节
附录D 现场
附录E 标准库的异常时安全性
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++标准库（第2版）
第 2 版译序	xxi
第 2 版序言	xxiii
第 2 版致谢	xxiv
第 1 版序言	xxv
第 1 版致谢	xxvi
1 关于本书	1
1.1 缘起	1
1.2 阅读前的必要基础	2
1.3 本书风格与结构	2
1.4 如何阅读本书	4
1.5 目前发展情势	5
1.6 范例代码及额外信息	5
1.7 反馈	5
2 C++ 及标准库简介	7
2.1 C++ Standard 的历史	7
2.1.1 C++11 Standard 常见疑问	8
2.1.2 C++98 和 C++11 的兼容性	9
2.2 复杂度与 Big-O 标记	10
3 语言新特性	13
3.1 C++11 语言新特性	13
3.1.1 微小但重要的语法提升	13
3.1.2 以auto完成类型自动推导	14
3.1.3 一致性初始化（Uniform Initialization）与初值列（Initializer List）	15
3.1.4 Range-Based for循环	17
3.1.5 Move 语义和 Rvalue Reference	19
3.1.6 新式的字符串字面常量（String Literal）	23
3.1.7 关键字noexcept	24
3.1.8 关键字constexpr	26
3.1.9 崭新的 Template 特性	26
3.1.10 Lambda	28
3.1.11 关键字decltype	32
3.1.12 新的函数声明语法（New Function Declaration Syntax）	32
3.1.13 带领域的（Scoped） Enumeration	32
3.1.14 新的基础类型（New Fundamental Data Type）	33
3.2 虽旧犹新的语言特性	33
3.2.1 基础类型的明确初始化（Explicit Initialization for Fundamental Type）	37
3.2.2 main()定义式	37
4 一般概念	39
4.1 命名空间（Namespace）std	39
4.2 头文件（Header File）	40
4.3 差错和异常（Error and Exception）的处理	41
4.3.1 标准的 Exception Class（异常类）	41
4.3.2 异常类（Exception Class）的成员	44
4.3.3 以 Class exception_ptr传递异常	52
4.3.4 抛出标准异常	53
4.3.5 自标准异常类派生	54
4.4 Callable Object（可被调用的对象）	54
4.5 并发与多线程	55
4.6 分配器（Allocator）	57
5 通用工具	59
5.1 Pair 和 Tuple	60
5.1.1 Pair	60
5.1.2 Tuple（不定数的值组）	68
5.1.3 Tuple 的输入/输出	74
5.1.4 tuple和pair转换	75
5.2 Smart Pointer（智能指针）	76
5.2.1 Class shared_ptr	76
5.2.2 Class weak_ptr	84
5.2.3 误用 Shared Pointer	89
5.2.4 细究 Shared Pointer 和 Weak Pointer	92
5.2.5 Class unique_ptr	98
5.2.6 细究 Class unique_ptr	110
5.2.7 Class auto_ptr	113
5.2.8 Smart Pointer 结语	114
5.3 数值的极值（Numeric Limit）	115
5.4 Type Trait 和 Type Utility	122
5.4.1 Type Trait 的目的	122
5.4.2 细究 Type Trait	125
5.4.3 Reference Wrapper（外覆器）	132
5.4.4 Function Type Wrapper（外覆器）	133
5.5 辅助函数	134
5.5.1 挑选最小值和最大值	134
5.5.2 两值互换（Swapping）	136
5.5.3 增补的“比较操作符”（Comparison Operator）	138
5.6 Class ratio<>的编译期分数运算	140
5.7 Clock 和 Timer	143
5.7.1 Chrono 程序库概观	143
5.7.2 Duration（时间段）	144
5.7.3 Clock（时钟）和 Timepoint（时间点）	149
5.7.4 C 和 POSIX 提供的 Date/Time 函数	157
5.7.5 以计时器停滞线程（Blocking with Timer）	160
5.8 头文件<cstddef>、<cstdlib>和<cstring>	161
5.8.1 <cstddef>内的各项定义	161
5.8.2 <cstdlib>内的各种定义	162
5.8.3 <cstring>中的定义式	163
6 标准模板库	165
6.1 STL 组件（Component）	165
6.2 容器（Container）	167
6.2.1 序列式容器（Sequence Container）	169
6.2.2 关联式容器（Associative Container）	177
6.2.3 无序容器（Unordered Container）	180
6.2.4 关联式数组（Associative Array）	185
6.2.5 其他容器	187
6.2.6 容器适配器（Container Adapter）	188
6.3 迭代器（Iterator）	188
6.3.1 关联式（ Associative ）及无序（ Unordered ）容器的更多实例	193
6.3.2 迭代器种类（Iterator Category）	198
6.4 算法（Algorithm）	199
6.4.1 区间（Range）	203
6.4.2 处理多重区间（Multiple Ranges）	207
6.5 迭代器之适配器（Iterator Adapter）	210
6.5.1 Insert Iterator（安插型迭代器）	210
6.5.2 Stream Iterator（串流迭代器）	212
6.5.3 Reverse Iterator（反向迭代器）	214
6.5.4 Move Iterator（搬移迭代器）	216
6.6 用户自定义的泛型函数（User-Defined Generic Function）	216
6.7 更易型算法（Manipulating Algorithm）	217
6.7.1 移除（Removing）元素	218
6.7.2 更易 Associative（关联式）和 Unordered（无序）容器	221
6.7.3 算法 vs. 成员函数	223
6.8 以函数作为算法的实参	224
6.8.1 以函数作为算法实参的实例示范	224
6.8.2 判断式（Predicate）	226
6.9 使用 Lambda	229
6.10 函数对象（Function Object）	233
6.10.1 定义一个函数对象	233
6.10.2 预定义的函数对象	239
6.10.3 Binder	241
6.10.4 函数对象 vs. Lambda	243
6.11 容器内的元素	244
6.11.1 容器元素的必要条件	244
6.11.2 Value 语义 vs. Reference 语义	245
6.12 STL 内部的错误和异常	245
6.12.1 错误处理（Error Handling）	246
6.12.2 异常处理（Exception Handling）	248
6.13 扩展 STL	250
6.13.1 整合更多 Type	250
6.13.2 派生自 STL Type	251
7 STL 容器	253
7.1 容器的共通能力和共通操作	254
7.1.1 容器的共通能力	254
7.1.2 容器的共通操作	254
7.1.3 容器提供的类型	260
7.2 Array	261
7.2.1 Array 的能力	261
7.2.2 Array 的操作	263
7.2.3 把array当成 C-Style Array	267
7.2.4 异常处理（ Exception Handling ）	268
7.2.5 Tuple 接口	268
7.2.6 Array 运用实例	268
7.3 Vector	270
7.3.1 Vector 的能力	270
7.3.2 Vector 的操作	273
7.3.3 将 Vector 当作 C-Style Array 使用	278
7.3.4 异常处理（ Exception Handling ）	278
7.3.5 Vector 使用实例	279
7.3.6 Class vector<bool>	281
7.4 Deque	283
7.4.1 Deque 的能力	284
7.4.2 Deque 的操作函数	284
7.4.3 Exception Handling	288
7.4.4 Deque 运用实例	288
7.5 List	290
7.5.1 List 的能力	290
7.5.2 List 的操作	291
7.5.3 异常处理（ Exception Handling ）	296
7.5.4 List 运用实例	298
7.6 Forward List	300
7.6.1 Forward List 的能力	300
7.6.2 Forward List 的操作	302
7.6.3 异常处理（ Exception Handling ）	311
7.6.4 Forward List 运用实例	312
7.7 Set 和 Multiset	314
7.7.1 Set 和 Multiset 的能力	315
7.7.2 Set and Multiset 的操作函数	316
7.7.3 异常处理（ Exception Handling ）	325
7.7.4 Set 和 Multiset 运用实例	325
7.7.5 运行期指定排序准则	328
7.8 Map 和 Multimap	331
7.8.1 Map 和 Multimap 的能力	332
7.8.2 Map 和 Multimap 的操作函数	333
7.8.3 将 Map 视为关联式数组（ Associative Array ）	343
7.8.4 异常处理（ Exception Handling ）	345
7.8.5 Map 和 Multimap 运用实例	345
7.8.6 综合实例：运用 Map、 String 并于运行期指定排序准则	351
7.9 无序容器（ Unordered Container ）	355
7.9.1 Unordered 容器的能力	357
7.9.2 创建和控制 Unordered 容器	359
7.9.3 Unordered 容器的其他操作	367
7.9.4 Bucket 接口	374
7.9.5 使用 Unordered Map 作为 Associative Array	374
7.9.6 异常处理（ Exception Handling ）	375
7.9.7 Unordered 容器的运用实例	375
7.10 其他 STL 容器	385
7.10.1 String 作为一种 STL 容器	385
7.10.2 C-Style Array 作为一种 STL 容器	386
7.11 实现 Reference 语义	388
7.12 各种容器的使用时机	392
8 细探 STL 容器成员	397
8.1 容器内的类型	397
8.2 创建、复制和销毁（ Create, Copy, and Destroy ）	400
8.3 非更易型操作（ Nonmodifying Operation ）	403
8.3.1 大小相关操作（ Size Operation ）	403
8.3.2 元素比较（ Comparison Operation ）	404
8.3.3 Associative 和 Unordered 容器特有的非更易型操作	404
8.4 赋值（ Assignment ）	406
8.5 元素直接访问（ Direct Element Access ）	408
8.6 “产出迭代器”之各项操作	410
8.7 安插和移除（ Inserting and Removing ）元素	411
8.7.1 安插单一元素（ Inserting Single Element ）	411
8.7.2 安插多重元素（ Inserting Multiple Elements ）	416
8.7.3 移除元素（ Removing Element ）	417
8.7.4 重设大小（ Resizing ）	420
8.8 List 和 Forward List 的特殊成员函数	420
8.8.1 特殊成员函数（针对 List 和 Forward List ）	420
8.8.2 特殊成员函数（只针对 Forward List ）	423
8.9 容器的策略接口（ Policy Interface ）	427
8.9.1 非更易型策略函数（ Nonmodifying Policy Function ）	427
8.9.2 更易型策略函数（ Modifying Policy Function ）	428
8.9.3 Unordered 容器的 Bucket 相关接口	429
8.10 对分配器（ Allocator ）的支持	430
8.10.1 基本的分配器成员（ Fundamental Allocator Member ）	430
8.10.2 带有“可选之分配器参数”的构造函数	430
9 STL 迭代器	433
9.1 迭代器头文件（ Header Files for Iterators ）	433
9.2 迭代器种类（ Iterator Category ）	433
9.2.1 Output 迭代器	433
9.2.2 Input 迭代器	435
9.2.3 Forward（前向）迭代器	436
9.2.4 Bidirectional（双向）迭代器	437
9.2.5 Random-Access（随机访问）迭代器	438
9.2.6 Vector 迭代器的递增（ Increment ）和递减（ Decrement ）	440
9.3 迭代器相关辅助函数	441
9.3.1 advance()	441
9.3.2 next()和prev()	443
9.3.3 distance()	445
9.3.4 iter_swap()	446
9.4 迭代器适配器（ Iterator Adapter ）	448
9.4.1 Reverse（反向）迭代器	448
9.4.2 Insert（安插型）迭代器	454
9.4.3 Stream（串流）迭代器	460
9.4.4 Move（搬移）迭代器	466
9.5 Iterator Trait（迭代器特性）	466
9.5.1 为迭代器编写泛型函数（ Generic Function ）	468
9.6 用户自定义（ User-Defined ）迭代器	471
10 STL 函数对象及 Lambda	475
10.1 Function Object（函数对象）的概念	475
10.1.1 以 Function Object 为排序准则（ Sorting Criterion ）	476
10.1.2 Function Object 拥有内部状态（ Internal State ）	478
10.1.3 for_each()的返回值	482
10.1.4 Predicate（判断式） vs. Function Object（函数对象）	483
10.2 预定义的 Function Object 和 Binder	486
10.2.1 预定义的 Function Object	486
10.2.2 Function Adapter 和 Binder	487
10.2.3 以 Function Adapter 搭配用户自定义的 Function Object	495
10.2.4 过时的（ Deprecated ） Function Adapter	497
10.3 运用 Lambda	499
10.3.1 Lambda vs. Binder	499
10.3.2 Lambda vs. 带有状态的（ Stateful ） Function Object	500
10.3.3 Lambda 调用全局函数和成员函数	502
10.3.4 Lambda 作为 Hash 函数、排序准则或相等准则	504
11 STL 算法	505
11.1 算法头文件（Header File）	505
11.2 算法概观	505
11.2.1 扼要介绍	506
11.2.2 算法分门别类	506
11.3 辅助函数	517
11.4 for_each()算法	519
11.5 非更易型算法（Nonmodifying Algorithm）	524
11.5.1 元素计数	524
11.5.2 最小值和最大值	525
11.5.3 查找元素（Searching Element）	528
11.5.4 区间的比较	542
11.5.5 Predicate 用以检验区间	550
11.6 更易型算法（Modifying Algorithm）	557
11.6.1 复制元素（Copying Element）	557
11.6.2 搬移元素（Moving Element）	561
11.6.3 转换和结合元素（Transforming and Combining Element）	563
11.6.4 互换元素（Swapping Elements）	566
11.6.5 赋值（Assigning New Value）	568
11.6.6 替换元素（Replacing Element）	571
11.7 移除型算法（Removing Algorithm）	575
11.7.1 移除某些元素	575
11.7.2 移除重复元素	578
11.8 变序型算法（Mutating Algorithm）	583
11.8.1 反转元素次序（Reversing the Order of Elements）	583
11.8.2 旋转元素（Rotating Elements）	584
11.8.3 排列元素（Permuting Elements）	587
11.8.4 对元素重新洗牌（Shuffling Elements）	589
11.8.5 将元素向前搬（Moving Elements to the Front）	592
11.8.6 划分为两个子区间（Partition into Two Subranges）	594
11.9 排序算法（Sorting Algorithm）	596
11.9.1 对所有元素排序	596
11.9.2 局部排序（Partial Sorting）	599
11.9.3 根据第 {\itshape n} 个元素排序	602
11.9.4 Heap 算法	604
11.10 已序区间算法（Sorted-Range Algorithm）	608
11.10.1 查找元素（Searching Element）	608
11.10.2 合并元素（Merging Elements）	614
11.11 数值算法（Numeric Algorithm）	623
11.11.1 运算后产生结果	623
11.11.2 相对数列和绝对数列之间的转换	627
12 特殊容器	631
12.1 Stack（堆栈）	632
12.1.1 核心接口	633
12.1.2 Stack 运用实例	633
12.1.3 一个用户自定义的 Stack Class	635
12.1.4 细究 Class stack<>	637
12.2 Queue（队列）	638
12.2.1 核心接口	639
12.2.2 Queue 运用实例	640
12.2.3 一个用户自定义的 Queue Class	641
12.2.4 细究 Class queue<>	641
12.3 Priority Queue（带优先级的队列）	641
12.3.1 核心接口	643
12.3.2 Priority Queue 运用实例	643
12.3.3 细究 Class priority_queue<>	644
12.4 细究 Container Adapter	645
12.4.1 类型定义	645
12.4.2 构造函数（Constructor）	646
12.4.3 Priority Queue 额外提供的构造函数	646
12.4.4 各项操作（Operation）	647
12.5 Bitset	650
12.5.1 Bitset 运用实例	651
12.5.2 细究 Class bitset	653
13 字符串	655
13.1 String Class 的目的	656
13.1.1 例一：提炼临时文件名	656
13.1.2 例二：提炼单词并反向打印	660
13.2 String Class 细节描述	663
13.2.1 String 的各种相关类型	663
13.2.2 操作函数概览	666
13.2.3 构造函数和析构函数（Constructor and Destructor）	667
13.2.4 String 和 C-String	668
13.2.5 大小和容量（Size and Capacity）	669
13.2.6 元素访问（Element Access）	671
13.2.7 比较（Comparison）	672
13.2.8 更改内容（Modifier）	673
13.2.9 子字符串（Substring）及字符串接合（String Concatenation）	676
13.2.10 I/O 操作符	677
13.2.11 搜索和查找（Searching and Finding）	678
13.2.12 npos的意义	680
13.2.13 数值转换（Numeric Conversion）	681
13.2.14 String 对迭代器的支持	684
13.2.15 国际化（Internationalization）	689
13.2.16 效率（Performance）	692
13.2.17 String 和 Vector	692
13.3 细究 String Class	693
13.3.1 类型定义和静态值	693
13.3.2 创建、复制、销毁（Create, Copy, and Destroy）	694
13.3.3 大小和容量（Size and Capacity）	696
13.3.4 比较（Comparison）	697
13.3.5 字符访问	699
13.3.6 产生 C-String 和字符数组（Character Array）	700
13.3.7 “改动”之相关操作（Modifying Operation）	700
13.3.8 查找（Searching and Finding）	708
13.3.9 子字符串（Substring）及字符串接合（String Concatenation）	711
13.3.10 I/O函数	712
13.3.11 数值转换（Numeric Conversion）	713
13.3.12 生成 Iterator	714
13.3.13 对 Allocator 的支持	715
14 正则表达式	717
14.1 Regex 的匹配和查找接口（Match and Search Interface）	717
14.2 处理“次表达式”（Subexpression）	720
14.3 Regex Iterator	726
14.4 Regex Token Iterator	727
14.5 用于替换的正则表达式	730
14.6 Regex Flag	732
14.7 Regex 的异常（Exception）	735
14.8 Regex ECMAScript 文法	738
14.9 其他文法	739
14.10 细究 Basic Regex 签名式	740
15 以 Stream 完成 I/O	743
15.1 I/O Stream 的共通基础（Common Background）	744
15.1.1 Stream 对象	744
15.1.2 Stream Class	744
15.1.3 全局的 Stream 对象	745
15.1.4 Stream 操作符	745
15.1.5 操控器（Manipulator）	746
15.1.6 一个简单例子	746
15.2 基本 Stream Class 和其对象	748
15.2.1 Class 及其层次体系	748
15.2.2 全局性的 Stream 对象	751
15.2.3 头文件	752
15.3 标准的 Stream 操作符<<和>>	753
15.3.1 Output 操作符<<	753
15.3.2 Input 操作符>>	754
15.3.3 特殊类型的 I/O	755
15.4 Stream 的状态（State）	758
15.4.1 表示“ Stream 状态”的常量	758
15.4.2 用来“处理 Stream 状态”的成员函数	759
15.4.3 Stream 状态与 Boolean 条件测试	760
15.4.4 Stream 的状态和异常	762
15.5 标准 I/O 函数	767
15.5.1 Input 相关函数	768
15.5.2 Output 相关函数	771
15.5.3 实例	772
15.5.4 sentry对象	772
15.6 操控器（Manipulator）	774
15.6.1 操控器概览	774
15.6.2 操控器如何运作	776
15.6.3 用户自定义的操控器	777
15.7 格式化（Formatting）	779
15.7.1 Format Flag（格式标志）	779
15.7.2 Boolean 的 I/O 格式	781
15.7.3 栏位宽度、填充字符、位置调整	781
15.7.4 正号与大写	784
15.7.5 数值基底（Numeric Base）	785
15.7.6 浮点数（Floating-Point）表示法	787
15.7.7 一般格式（General Formatting）定义	789
15.8 国际化（Internationalization）	790
15.9 文件访问（File Access）	791
15.9.1 File Stream Class	791
15.9.2 File Stream 的 Rvalue 和 Move 语义	795
15.9.3 File Flag（文件标志）	796
15.9.4 随机访问（Random Access）	799
15.9.5 使用文件描述器（File Descriptor）	801
15.10 为 String 而设计的 Stream Class	802
15.10.1 String Stream Class	802
15.10.2 String Stream 的 Move 语义	806
15.10.3 char* Stream Class	807
15.11 “用户自定义类型”之 I/O 操作符	810
15.11.1 实现一个 Output 操作符	810
15.11.2 实现一个 Input 操作符	812
15.11.3 以辅助函数完成 I/O	814
15.11.4 用户自定义之 Format Flag（格式标志）	815
15.11.5 用户自定义 I/O 操作符的规约（Convention）	818
15.12 连接 Input 和 Output Stream	819
15.12.1 以tie()完成松耦合（Loose Coupling）	819
15.12.2 以 Stream 缓冲区完成紧耦合（Tight Coupling）	820
15.12.3 将标准 Stream 重定向（Redirecting）	822
15.12.4 可读可写的 Stream	824
15.13 Stream Buffer Class	826
15.13.1 Stream 缓冲区接口	826
15.13.2 Stream 缓冲区的 Iterator	828
15.13.3 用户自定义之 Stream 缓冲区	832
15.14 关于效能（Performance）	844
15.14.1 与 C 标准串流同步（Synchronization with C's Standard Streams）	845
15.14.2 Stream 缓冲区内的缓冲机制	845
15.14.3 直接使用 Stream 缓冲区	846
16 国际化	849
16.1 字符编码和字符集	850
16.1.1 多字节（Multibyte）和宽字符（Wide-Character）文本	850
16.1.2 不同的字符集	851
16.1.3 在 C++ 中处理字符集	852
16.1.4 Character Trait	853
16.1.5 特殊字符的国际化	857
16.2 Locale（地域）概念	857
16.2.1 使用 Locale	858
16.2.2 Locale Facet	864
16.3 细究 Locale	866
16.4 细究 Facet	869
16.4.1 数值格式化（Numeric Formatting）	870
16.4.2 货币符号格式化（Monetary Formatting）	874
16.4.3 时间和日期格式化（Time and Date Formatting）	884
16.4.4 字符的分类和转换	891
16.4.5 字符串校勘（String Collation）	904
16.4.6 消息国际化（Internationalized Message）	905
17 数值	907
17.1 随机数及分布（Random Number and Distribution）	907
17.1.1 第一个例子	908
17.1.2 引擎（Engine）	912
17.1.3 细说引擎（Engine）	915
17.1.4 分布（Distribution）	917
17.1.5 细说分布（Distribution）	921
17.2 复数（Complex Number）	925
17.2.1 Class complex<>一般性质	925
17.2.2 Class complex<>运用实例	926
17.2.3 复数的各项操作	928
17.2.4 细说 Class complex<>	935
17.3 全局数值函数（Global Numeric Function）	941
17.4 Valarray	943
18 并发	945
18.1 高级接口：async()和 Future	946
18.1.1 async()和 Future 的第一个用例	946
18.1.2 实例：等待两个 Task	955
18.1.3 Shared Future	960
18.2 低层接口：Thread 和 Promise	964
18.2.1 Class std::thread	964
18.2.2 Promise	969
18.2.3 Class packaged_task<>	972
18.3 细说启动线程（Starting a Thread）	973
18.3.1 细说async()	974
18.3.2 细说 Future	975
18.3.3 细说 Shared Future	976
18.3.4 细说 Class std::promise	977
18.3.5 细说 Class std::packaged_task	977
18.3.6 细说 Class std::thread	979
18.3.7 Namespace this_thread	981
18.4 线程同步化与 Concurrency（并发）问题	982
18.4.1 当心 Concurrency（并发）	982
18.4.2 Concurrent Data Access 为什么造成问题	983
18.4.3 什么情况下可能出错	983
18.4.4 解决问题所需要的性质（Feature）	987
18.5 Mutex 和 Lock	989
18.5.1 使用 Mutex 和 Lock	989
18.5.2 细说 Mutex 和 Lock	998
18.5.3 只调用一次	1000
18.6 Condition Variable（条件变量）	1003
18.6.1 Condition Variable（条件变量）的意图	1003
18.6.2 Condition Variable（条件变量）的第一个完整例子	1004
18.6.3 使用 Condition Variable（条件变量）实现多线程 Queue	1006
18.6.4 细说 Condition Variable（条件变量）	1009
18.7 Atomic	1012
18.7.1 Atomic 用例	1012
18.7.2 细说 Atomic 及其高级接口	1016
18.7.3 Atomic 的 C-Style 接口	1019
18.7.4 Atomic 的低层接口	1019
19 分配器	1023
19.1 以应用程序开发者的角度使用 Allocator	1023
19.2 用户自定义的 Allocator	1024
19.3 以程序库开发者的角度使用 Allocator	1026
参考书目	1031
新闻组及论坛（ Newsgroup and Forum ）	1031
书籍和网站	1032
索引	1037
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++标准库（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力精英
目 录
CONTENTS
第1 章 上流阶层…………………………… 1
第2 章 地方社会………………………… 24
第3 章 大都会400 家族………………… 38
第4 章 名人……………………………… 58
第5 章 超级富豪………………………… 79
第6 章 公司高管………………………… 100
第7 章 大公司里的富豪………………… 125
第8 章 军界领袖………………………… 145
第9 章 军方的崛起……………………… 169
第10 章 政治领导体制… ……………… 191
第11 章 平衡理论… …………………… 206
第12 章 权力精英… …………………… 228
第13 章 大众社会… …………………… 254
第14 章 保守情绪… …………………… 278
第15 章 高层的不道德… ……………… 293
后 记… ………………………………… 309
延伸阅读………………………………… 326
注 释… ………………………………… 329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力精英
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Essential C++中文版
第一章 C++编程基础
第二章 面向过程的编程风格
第三章 泛型编程风格
第四章 基于对象的编程风格
第五章 面向对象编程风格
第六章 以TEMPLATE进行编程
第七章 异常处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Essential C++中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++编程思想（第1卷）
第一章  对象导言
第二章  对象的创建于使用
第三章  C++中的C
第四章  数据抽象
第五章  隐藏实现
第六章  初始化与清除
第七章  函数重载于默认参数
第八章  常量
第九章  内联函数
第十章  名字控制
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++编程思想（第1卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>申不害
前 言 1
第一章 申不害是谁 1
第二章 背景 7
第三章 生平 17
第四章 旨趣 35
第五章 中国行政系统 38
第六章 君主 48
第七章 大臣 66
第八章 名学 88
第九章 技术 104
第十章 申不害与“法家” 114
第十一章 申不害与道家 139
第十二章 汉代以前的影响 165
第十三章 汉代影响 195
第十四章 后世影响 231
附录一 申不害史料考述 245
附录二 《申子》辑佚 279
附录三 申不害佚文 283
参考文献 317
索 引 333
译后记 廿载覃思,垂范汉学 347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>申不害
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++GUI Qt4编程
第一部 分Ql基础============================================
第1章 Qt入门
1.1 Hello Qt
第2章 创建对话框
2.1 子类化QI)ialog
2.2 深入介绍信号和槽
第3章 创建主窗口
第4章 实现应用程序的功能
4.1 中央窗口部件
第5章 创建自定义窗口部件
第二部分 Ot中级============================================
第6章 布局管理
第7章 事件处理
第8章 二维图形
第9章 拖放
第10章 项视图类
第11章 容器类
第12章 输入与输出
12.1 读取和写入二进制数据
第13章 数据库
第14章 多线程
第15章 网络
15.1写FTP客户端
第16章 XML
16.1 使用QXmlStreamReader读取XML
第17章 提供在线帮助
第三部分 Qt高级============================================
第18章 国际化
第19章 自定义外观
第20章 三维图形
第21章 创建插件
第22章 应用程序脚本
第23章 平台相关特性
第24章 嵌入式编程
24.1 从Ot／Embedded Linux开始
第四部分 附录
附录A Qt的获取和安装
附录B 编译Qt应用程序
附录C Qt Jambi简介
附录D 面向Java和C#程序员的C++简介
D.1 C++入门
D.2 主要语言之间的差异
D.3 c++标准库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++GUI Qt4编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++大学教程
第1章 计算机、Internet和万维网简介
第2章 C++编程入门
第3章 类和对象介绍
第4章 控制语句（第Ⅰ部分）
第5章 控制语句（第Ⅱ部分）
第6章 函数和递归入门
第7章 数组与CC+标准库类模板vector
第8章 指针和基于指针的字符串
第9章 类的深入剖析（第Ⅰ部分）
第10章 类的深入剖析（第Ⅱ部分）
第11章 运算符重载：字符串和数组对象
第12章 面向对象编程：继承
第13章 面向对象编程：多态性
第14章 模板
第15章 输入/输出流
第16章 异常处理
第17章 文件处理
第18章 String类和字符串流处理
第19章 Web编程
第20章 搜索和排序
第21章 数据结构
第22章 位、字符、C字符串和结构体
第23章 标准模板库
第24章 其他主题
附录A 运算符的优先级与结合律
附录B ASCII字符集
附录C 基本数据类型
附录D 计数系统
附录E C语言遗留代码问题
附录F 预处理器
附录G ATM实例研究代码
附录H 其他的UML2示图类型
附录I Internet和万维网上的C++资源
附录J XHTML简介
附录K XHTML和特殊字符
附录L 使用Visual Studio.NET调试器
附录M 使用GNU C++调试器
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++大学教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计的抽象思维
写给学生
写给教师
致　　谢
第一部分　预备知识
第1章　ANSI C概述2
1.1　什么是C2
1.2　C程序的结构4
1.2.1　注释5
1.2.2　包含的库文件5
1.2.3　程序级的定义6
1.2.4　函数原型6
1.2.5　主程序6
1.2.6　函数定义7
1.3　变量、值和类型8
1.3.1　变量8
1.3.2　命名规则8
1.3.3　局部变量和全局变量9
1.3.4　数据类型的概念9
1.3.5　整数类型9
1.3.6　浮点类型10
1.3.7　文本类型11
1.3.8　布尔类型12
1.3.9　简单输入输出12
1.4　表达式13
1.4.1　优先级与结合性14
1.4.2　表达式中的类型混合15
1.4.3　整数除法和求余运算15
1.4.4　类型转换16
1.4.5　赋值运算符16
1.4.6　递增与递减运算符17
1.4.7　布尔运算符18
1.5　语句20
1.5.1　简单语句20
1.5.2　块20
1.5.3　if语句21
1.5.4　switch语句21
1.5.5　while语句23
1.5.6　for语句25
1.6　函数26
1.6.1　返回函数结果27
1.6.2　函数定义和原型27
1.6.3　函数调用过程的机制28
1.6.4　逐步求精28
1.7　总结28
1.8　复习题29
1.9　编程练习30
第2章　C的数据类型34
2.1　枚举类型34
2.1.1　枚举类型的内部表示35
2.1.2　标量类型36
2.1.3　理解typedef36
2.2　数据和内存37
2.2.1　位、字节、字37
2.2.2　内存地址38
2.3　指针39
2.3.1　把地址当作数值40
2.3.2　声明指针变量40
2.3.3　基本的指针运算41
2.3.4　特殊指针NULL43
2.3.5　传递引用43
2.4　数组46
2.4.1　声明数组46
2.4.2　数组选择47
2.4.3　分配的空间和利用的空间48
2.4.4　把数组作为参数48
2.4.5　初始化数组51
2.4.6　多维数组52
2.5　指针和数组53
2.5.1　指针运算54
2.5.2　指针的自加和自减56
2.5.3　指针和数组的关系56
2.6　记录58
2.6.1　定义一种新的结构类型58
2.6.2　声明结构变量59
2.6.3　记录选择59
2.6.4　初始化纪录59
2.6.5　记录的指针60
2.7　动态分配61
2.7.1　类型void61
2.7.2　对内存限制的处理62
2.7.3　动态数组63
2.7.4　动态记录64
2.8　总结65
2.9　复习题66
2.10　编程练习68
第3章　库和接口74
3.1　接口的概念74
3.1.1　接口和实现75
3.1.2　包和抽象75
3.1.3　良好的接口设计规则76
3.2　随机数字76
3.2.1　random.h接口的结构77
3.2.2　构造一个客户程序80
3.2.3　ANSI中有关随机数字的函数82
3.2.4　实现random.c83
3.3　字符串86
3.3.1　字符的底层表示86
3.3.2　数据类型string88
3.3.3　ANSI字符串库89
3.3.4　接口strlib.h92
3.4　标准的I/O库98
3.4.1　数据文件98
3.4.2　在C中使用文件99
3.4.3　标准文件100
3.4.4　字符I/O100
3.4.5　从输入文件中重读字符101
3.4.6　更新文件102
3.4.7　面向行的I/O103
3.4.8　格式化的I/O103
3.4.9　scanf函数104
3.5　其他ANSI库105
3.6　总结107
3.7　复习题107
3.8　编程练习109
第二部分　递归和算法分析
第4章　递归入门116
4.1　一个简单的递归示例116
4.2　阶乘函数118
4.2.1　Fact的递归公式118
4.2.2　追踪递归过程119
4.2.3　递归跳跃的信任122
4.3　费波那契函数123
4.3.1　计算费波那契序列123
4.3.2　增进实现递归的信心125
4.3.3　递归实现的效率125
4.3.4　不应该责备递归126
4.4　其他递归示例127
4.4.1　探测回文128
4.4.2　二分查找130
4.4.3　交互递归131
4.5　递归的思考133
4.5.1　保持整体观133
4.5.2　避免常见的陷阱133
4.6　总结134
4.7　复习题135
4.8　编程练习137
第5章　递归过程140
5.1　汉诺塔140
5.1.1　分解问题141
5.1.2　寻找递归策略142
5.1.3　证实递归策略143
5.1.4　编码解决方案144
5.1.5　追踪递归过程144
5.2　产生排列148
5.3　递归的绘图应用150
5.3.1　绘图库150
5.3.2　电脑艺术示例152
5.3.3　不规则碎片形155
5.4　总结159
5.5　复习题160
5.6　编程练习161
第6章　回溯算法168
6.1　用递归回溯解决迷宫问题168
6.1.1　右手规则168
6.1.2　寻找递归方法169
6.1.3　识别简单情景170
6.1.4　迷宫解决方案算法编码171
6.1.5　确信解决方案可以正确运行175
6.2　回溯与对策176
6.2.1　拿子游戏177
6.2.2　一般化的双人游戏程序183
6.2.3　最小最大策略184
6.2.4　实现最小最大化算法185
6.2.5　在具体的游戏中采用一般化策略187
6.3　总结199
6.4　复习题199
6.5　编程练习200
第7章　算法分析206
7.1　排序问题206
7.1.1　选择排序算法207
7.1.2　性能的经验度量208
7.1.3　分析选择排序的性能209
7.2　计算复杂度210
7.2.1　大O符号210
7.2.2　大O的标准简化211
7.2.3　排序算法的计算复杂度211
7.2.4　根据代码结构预测计算复杂度212
7.2.5　最差情况复杂度与平均情况复杂度213
7.2.6　大O的正式定义214
7.3　递归帮助215
7.3.1　分治策略的威力215
7.3.2　合并两个数组216
7.3.3　合并排序算法216
7.3.4　合并排序的计算复杂度218
7.3.5　比较N2和NlogN的性能219
7.4　标准复杂度类型220
7.5　快速排序算法221
7.5.1　分割数组223
7.5.2　分析快速排序的性能225
7.6　数学归纳法225
7.7　总结227
7.8　复习题228
7.9　编程练习230
第三部分　数据抽象
第8章　抽象数据类型236
8.1　栈236
8.1.1　栈的基本概念237
8.1.2　栈和函数调用237
8.1.3　栈和袖珍计算器237
8.2　定义栈的ADT238
8.2.1　定义栈抽象的类型238
8.2.2　不透明类型240
8.2.3　定义stack.h接口240
8.3　在应用中使用栈244
8.4　实现栈抽象247
8.4.1　定义具体类型247
8.4.2　实现栈操作247
8.4.3　不透明类型的优点249
8.4.4　改进stack.c的实现250
8.5　定义一个scannerADT251
8.5.1　封装状态的危险252
8.5.2　抽象数据类型作为封装状态的替代252
8.5.3　实现扫描器抽象256
8.6　总结261
8.7　复习题262
8.8　编程练习263
第9章　效率与ADT273
9.1　编辑器缓冲区的概念273
9.2　定义缓冲区抽象274
9.2.1　接口buffer.h中的函数275
9.2.2　为编辑器应用编写代码277
9.3　用数组实现编辑器279
9.3.1　定义具体类型279
9.3.2　实现缓冲区的操作280
9.3.3　数组实现的计算复杂度283
9.4　用栈实现编辑器284
9.4.1　定义基于栈的缓冲区的具体结构284
9.4.2　实现缓冲区的操作284
9.4.3　比较计算复杂度287
9.5　用链表实现编辑器288
9.5.1　链表的概念288
9.5.2　设计链表数据结构289
9.5.3　使用链表表示缓冲区290
9.5.4　链表缓冲区中的插入291
9.5.5　链表缓冲区中的删除292
9.5.6　链表表示中的光标移动293
9.5.7　链表的习惯用法295
9.5.8　完成缓冲区实现296
9.5.9　链表缓冲区的计算复杂度299
9.5.10　双向链表300
9.5.11　时间空间的权衡300
9.6　总结301
9.7　复习题301
9.8　编程练习302
第10章　线性结构307
10.1　栈回顾307
10.2　队列313
10.2.1　接口queue.h的结构313
10.2.2　基于数组的队列实现316
10.2.3　队列的链表实现320
10.3　使用队列的仿真324
10.3.1　仿真与模型324
10.3.2　排队模型324
10.3.3　离散时间325
10.3.4　仿真时间中的事件325
10.3.5　实现仿真325
10.4　总结331
10.5　复习题332
10.6　编程练习333
第11章　符号表338
11.1　定义符号表抽象338
11.1.1　选择值和键的类型339
11.1.2　表示未定义项340
11.1.3　符号表接口的初始版本340
11.2　散列342
11.2.1　实现散列表策略342
11.2.2　选择散列函数347
11.2.3　确定桶的数量348
11.3　初级接口的限制348
11.4　使用函数作为数据350
11.4.1　一个一般测绘函数351
11.4.2　声明函数指针与函数类352
11.4.3　实现PlotFunction352
11.4.4　qsort函数352
11.5　映射函数356
11.5.1　映射符号表中的所有项357
11.5.2　实现MapSymbolTable359
11.5.3　向回调函数传递客户数据360
11.6　迭代器361
11.6.1　使用迭代器361
11.6.2　定义迭代器接口362
11.6.3　实现符号表的迭代器抽象363
11.7　命令分派表366
11.8　总结368
11.9　复习题369
11.10　编程练习370
第四部分　递归数据
第12章　递归列表376
12.1　链表的递归表述377
12.2　定义抽象链表类型378
12.2.1　不变类型380
12.2.2　操纵链表结构的函数381
12.2.3　连接多个链表383
12.2.4　不变类型间的内部共享385
12.3　使用链表表示大整数386
12.3.1　bigint.h 接口386
12.3.2　表示类型bigIntADT388
12.3.3　实现bigint包389
12.3.4　使用bigint.h包394
12.4　总结395
12.5　复习题396
12.6　编程练习397
第13章　树400
13.1　家谱树401
13.1.1　描述树的术语401
13.1.2　树的递归特性401
13.1.3　用C语言表示家谱树402
13.2　二叉搜索树403
13.2.1　使用二叉搜索树的底层动机403
13.2.2　在二叉搜索树中查找节点405
13.2.3　在二叉搜索树中插入新节点405
13.2.4　树的遍历408
13.3　平衡树409
13.3.1　树的平衡策略410
13.3.2　举例说明AVL的思想411
13.3.3　单旋转412
13.3.4　双旋转414
13.3.5　实现AVL算法414
13.4　为二叉搜索树定义一般化接口418
13.4.1　允许用户定义节点结构421
13.4.2　一般化用作键的类型424
13.4.3　删除节点424
13.4.4　实现二叉搜索树包425
13.4.5　使用二叉树实现symtab.h接口431
13.5　总结432
13.6　复习题433
13.7　编程练习435
第14章　表达式树442
14.1　解释器概述443
14.2　表达式的抽象结构445
14.2.1　表达式的递归定义445
14.2.2　多义性446
14.2.3　表达式树447
14.2.4　定义表达式的抽象接口448
14.3　定义具体表达式类型451
14.3.1　联合类型451
14.3.2　使用标记的联合表示表达式453
14.3.3　可视化具体表示454
14.3.4　实现构建器和选择器函数456
14.4　语法分析表达式458
14.4.1　语法分析和语法458
14.4.2　不考虑优先级的语法分析459
14.4.3　在语法分析器中加入优先级462
14.5　计算表达式464
14.6　总结467
14.7　复习题467
14.8　编程练习468
第15章　集合479
15.1　为数学抽象的集合479
15.1.1　成员资格480
15.1.2　集合运算480
15.1.3　集合恒等式481
15.2　设计集合接口482
15.2.1　定义元素类型483
15.2.2　编写set.h 接口484
15.2.3　字符集合488
15.2.4　使用指针集合来避免重复488
15.3　实现集合包490
15.4　设计多态迭代器497
15.4.1　泛化迭代器函数的原型497
15.4.2　在迭代器实现中加入多态性497
15.4.3　导出聚集类型498
15.4.4　编码迭代器包502
15.4.5　foreach的习惯用法506
15.5　提高整型集合的效率506
15.5.1　特征向量507
15.5.2　压缩的位数组507
15.5.3　位运算符508
15.5.4　使用位操作符实现特征向量510
15.5.5　实现高级集合操作512
15.5.6　使用混合实现513
15.6　总结513
15.7　复习题514
15.8　编程练习517
第16章　图521
16.1　图的结构521
16.1.1　有向图和无向图523
16.1.2　路径和环524
16.1.3　连通性524
16.2　图的实现策略525
16.2.1　使用邻接列表表示连接526
16.2.2　使用邻接矩阵表示连接529
16.3　扩展图抽象532
16.3.1　将数据与节点和图关联532
16.3.2　显式弧532
16.3.3　迭代和图533
16.3.4　分层抽象534
16.3.5　基于集合的图接口534
16.4　图的遍历543
16.4.1　深度优先遍历543
16.4.2　广度优先搜索545
16.5　寻找最短路径548
16.6　总结554
16.7　复习题555
16.8　编程练习556
第17章　Java的未来563
17.1　面向对象范例563
17.1.1　面向对象编程的历史564
17.1.2　对象、类和方法565
17.1.3　类层次与继承566
17.2　Java入门567
17.2.1　Web结构567
17.2.2　applet568
17.2.3　执行Java applet572
17.3　Java的结构573
17.3.1　Java的语法574
17.3.2　Java中的原子类型575
17.3.3　定义新类575
17.3.4　构造器方法576
17.3.5　this关键字577
17.3.6　定义方法577
17.3.7　定义子类579
17.4　Java中的预定义类586
17.4.1　String类586
17.4.2　Hashtable类587
17.4.3　原子类型的对象包装器589
17.4.4　Vector类590
17.4.5　Stack类591
17.5　创建交互applet的工具592
17.5.1　组件与容器592
17.5.2　action方法593
17.5.3　用于画图形的简单applet594
17.5.4　更进一步602
17.6　总结602
17.7　复习题602
17.8　编程练习604
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计的抽象思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>汉娜·阿伦特：活在黑暗时代
1  艾希曼在耶路撒冷  1961—1963
2  生父之死  柯尼斯堡，1906—1923
3  初恋情人  海德格尔在马尔堡，1924—1932
4  我们这些流亡者  1930年代的柏林和巴黎
5  安全与声誉  《极权主义的起源》和纽约的圈子，1941—1961
6  艾希曼之后  纽约，1963—1975年
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>汉娜·阿伦特：活在黑暗时代
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>终极之问
何光沪序——在世界上，谁能快乐？张越序——为什么需要“终极之问”？前言第一部分 人应当有信仰吗？  第一章 两位主角——弗洛伊德与C.S.路易斯的生平  第二章 造物者——宇宙中可有神的存在？  第三章 良知——宇宙中存在道德律吗？  第四章 峰回路转——哪一条路通向真？第二部分 人应当怎样活着？  第五章 快乐——生命中最大的欢乐之源是什么？  第六章 性——追求享乐是唯一的目的？  第七章 爱——所有的爱都是性的升华？  第八章 痛苦——人生的苦难如何解决？  第九章 死亡——死亡是我们的命数吗？后记参考书目附录一 美国公共电视网PBS同名纪录片附录二 C.S.路易斯传记电影《影子大地》赏析附录三 《人生观的故事》中有关《终极之问》的章节
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>终极之问
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计教程学习辅导
第一部分　《C程序设计》习题和参考解答　第1章　C语言概述　第2章　数据类型、运算符与表达式　第3章　最简单的C程序设计——顺序程序设计　第4章　选择结构程序设计　第5章　循环结构程序设计　第6章　数组　第7章　函数调用　第8章　使用指针　第9章　用户建立的数据类型　第10章　文件操作第二部分　常见错误分析和程序调试　第11章　常见错误分析　第12章　程序的调试与测试    12.1　程序的调试    12.2　程序错误的类型    12.3　程序的测试第三部分　C语言上机指南　第13章　Turbo C 2.O的上机操作    13.1  Turbo C的安装    13.2　进入Turbo C　　13.3　Turbo C的工作窗口　　13.4　编辑一个新文件　　13.5　编辑一个已存在的文件　　13.6　改变用户工作目录　　13.7　确立Turbo C工作环境　　13.8　编译和连接　 　13.8.1　对单文件程序进行编译和连接　   13.8.2　对多文件程序进行编译和连接　   13.8.3　编译和连接过程中的显示信息　   13.8.4　停止编译的方式    13.9　运行　第14章　Turbo C++3.0的上机操作　　14.1　进入Turbo C++3.0集成环境　　14.2　C源文件的建立和程序的编辑　　14.3　程序的编译和连接　　14.4　运行程序　　14.5　退出Turbo C十+3.0环境　　14.6　对多文件程序进行编译和连接　　14.7　程序动态调试方法      14.7.1　按步执行方法      14.7.2　设置断点方法　第15章　Visual C++的上机操作　　15.1  Visual C++的安装和启动　　15.2　输入和编辑源程序      15.2.1　新建一个C源程序的方法      15.2.2　打开一个已有的程序      15.2.3　通过已有的程序建立一个新程序的方法　　15.3　编译、连接和运行      15.3.1　程序的编译      15.3.2　程序的调试      15.3.3　程序的连接　    15.3.4　程序的执行　　15.4　建立和运行包含多个文件的程序的方法      15.4.1 由用户建立项目工作区和项目文件      15.4.2  用户只建立项目文件第四部分  上机实验安排  第16章  实验指导    16.1  上机实验的目的    16.2  上机实验前的准备工作    16.3  上机实验的步骤    16.4  实验报告    16.5  实验内容安排的原则  第17章  实验安排    17.1  实验1C程序的运行环境和运行C程序的方法    17.2  实验2数据类型、运算符与表达式    17.3  实验3最简单的C程序设计——顺序程序设计    17.4  实验4选择结构程序设计    17.5  实验5循环结构程序设计    17.6  实验6数组    17.7  实验7函数(一)    17.8  实验8函数(二)    17.9  实验9指针(一)    17.10  实验10指针(二)    17.11  实验11结构体和共用体    17.12  实验12文件操作
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计教程学习辅导
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Effective C++（中文版）
译序（侯捷）
导读（introduction）
基础议题（basics）
条款1：仔细区别 pointers 和 references
distinguish between pointers and references.
条款2：最好使用 c++ 转型操作符
prefer c++-style casts.
条款3：绝对不要以多态（polymorphically）方式处理数组
never treat arrays polymorphically.
条款4：非必要不提供 default constructor
avoid gratuitous default constructors.
操作符（operators）
条款5：对定制的“类型转换函数”保持警觉
be wary of user-defined conversion functions.
条款6：区别 increment/decrement 操作符的
前置（prefix）和后置（postfix）形式
distinguish between prefix and postfix forms of increment
and decrement operators.
条款7：千万不要重载＆＆，和, 操作符
never overload ＆＆, , or ,.
.条款8：了解各种不同意义的 new 和 delete
understand the different meanings of new and delete
异常（exceptions）
条款9：利用 destructors 避免泄漏资源
use destructors to prevent resource leaks.
条款10：在 constructors 内阻止资源泄漏（resource leak）
prevent resource leaks in constructors.
条款11：禁止异常（exceptions）流出 destructors 之外
prevent exceptions from leaving destructors.
条款12：了解“抛出一个 exception”与“传递一个参数”
或“调用一个虚函数”之间的差异
understand how throwing an exception differs from
passing a parameter or calling a virtual function.
条款13：以 by reference 方式捕捉 exceptions
catch exceptions by reference.
条款14：明智运用 exception specifications
use exception specifications judiciously.
条款15：了解异常处理（exception handling）的成本
understand the costs of exception handling.
效率（efficiency）
条款16：谨记 80-20 法则
remember the 80-20 rule.
条款17：考虑使用 lazy evaluation（缓式评估）
consider using lazy evaluation.
条款18：分期摊还预期的计算成本
amortize the cost of expected computations.
条款19：了解临时对象的来源
understand the origin of temporary objects.
条款20：协助完成“返回值优化（rvo）”
facilitate the return value optimization.
条款21：利用重载技术（overload）避免隐式类型转换（implict type conversions）
overload to avoid implicit type conversions.
条款22：考虑以操作符复合形式（op=）取代其独身形式（op）
consider using op= instead of stand-alone op.
条款23：考虑使用其他程序库
consider alternative libraries.
条款24：了解 virtual functions、multiple inheritance、virtual base classes、
runtime type identification 的成本
understand the costs of virtual functions, multiple inheritance,
virtual base classes, and rtti.
技术（techniques, idioms, patterns）
条款25：将 constructor 和 non-member functions 虚化
virtualizing constructors and non-member functions.
条款26：限制某个 class 所能产生的对象数量
limiting the number of objects of a class.
条款27：要求（或禁止）对象产生于 heap 之中
requiring or prohibiting heap-based objects.
条款28：smart pointers（智能指针）
条款29：reference counting（引用计数）
条款30：proxy classes（替身类、代理类）
条款31：让函数根据一个以上的对象类型来决定如何虚化
making functions virtual with respect to more than one object.
杂项讨论（miscellany）
条款32：在未来时态下发展程序
program in the future tense.
条款33：将非尾端类（non-leaf classes）设计为
抽象类（abstract classes）
make non-leaf classes abstract.
条款34：如何在同一个程序中结合 c++ 和 c
understand how to combine c++ and c in the same program.
条款35：让自己习惯于标准 c++ 语言
familiarize yourself with the language standard.
推荐读物
auto_ptr 实现代码
索引（一）（general index）
索引（二）（index of example classes，functions，and templtes）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Effective C++（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>共同基金常识
推荐序1  时间是最好的朋友
高瓴资本创始人兼首席执行官 张 磊

推荐序2  以开放的视野拓展中国基金业发展新途径
中国人民保险集团副董事长、总裁、副书记 缪建民
译者序  回归常识
中国银行业协会首席经济学家 香港交易所首席中国经济学家 巴曙松
10周年纪念版序  见证全球基金业十年蜕变
耶鲁大学首席投资官 大卫·斯文森
原版序  为何本书如此与众不同
美国著名金融史学家 彼得·伯恩斯坦
10周年纪念版前言
原版前言
第一部分 投资策略
第1章 长期投资：强斯和花园
第2章 回报的本质：奥卡姆剃刀原则
第3章 资产配置：业绩归因之谜
第4章 简单化：如何到达应去之地
第二部分 投资选择
第5章 指数化：经验对希望的胜利
第6章 股票投资风格：井字游戏
第7章 债券投资：逐渐被遗忘
第8章 全球投资：钻石之邦
第9章 选择优质基金：寻找圣杯
第三部分 投资业绩
第10章 均值回复：牛顿对华尔街的报复
第11章 投资相对主义：幸福还是不幸
第12章 基金资产规模：胜利是最大的失败
第13章 税收的影响：视差的启示
第14章 时间的作用：第四维度，魔法还是专制
第四部分 基金管理
第15章 投资原则：重要的原则不可动摇
第16章 基金营销：信息即媒介
第17章 现代科技：又有何益
第18章 基金董事：一仆事二主
第19章 基金治理结构：策略规则
第五部分 基金精神
第20章 企业家精神：创造的喜悦
第21章 领导力：目标意识
第22章 人性化：客户和员工
后记
附录一：2010年年初对股票市场的一些思考
附录二：1999年年初对股票市场的一些思考
10周年纪念版致谢
原版致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>共同基金常识
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++反汇编与逆向分析技术揭秘
前言
第一部分　准备工作
第1章　熟悉工作环境和相关工具 / 2
1.1　调试工具Microsoft Visual C++ 6.0和OllyDBG / 2
1.2　反汇编静态分析工具IDA / 5
1.3　反汇编引擎的工作原理 / 11
1.4　本章小结 / 16
第二部分　C++反汇编揭秘
第2章　基本数据类型的表现形式 / 18
2.1　整数类型 / 18
2.1.1　无符号整数 / 18
2.1.2　有符号整数 / 18
2.2　浮点数类型 / 20
2.2.1　浮点数的编码方式 / 21
2.2.2　基本的浮点数指令 / 23
2.3　字符和字符串 / 26
2.3.1　字符的编码 / 27
2.3.2　字符串的存储方式 / 28
2.4　布尔类型 / 29
2.5　地址、指针和引用 / 29
2.5.1　指针和地址的区别 / 30
2.5.2　各类型指针的工作方式 / 31
2.5.3　引用 / 34
2.6　常量 / 35
2.6.1　常量的定义 / 36
2.6.2　#define和const的区别 / 37
2.7　本章小结 / 38
第3章　认识启动函数，找到用户入口 / 40
3.1　程序的真正入口 / 40
3.2　了解VC++ 6.0的启动函数 / 40
3.3　main函数的识别 / 44
3.4　本章小结 / 46
第4章　观察各种表达式的求值过程 / 47
4.1　算术运算和赋值 / 47
4.1.1　各种算术运算的工作形式 / 47
4.1.2　算术结果溢出 / 82
4.1.3　自增和自减 / 83
4.2　关系运算和逻辑运算 / 85
4.2.1　关系运算和条件跳转的对应 / 85
4.2.2　表达式短路 / 86
4.2.3　条件表达式 / 88
4.3　位运算 / 92
4.4　编译器使用的优化技巧 / 94
4.4.1　流水线优化规则 / 97
4.4.2　分支优化规则 / 101
4.4.3　高速缓存（cache）优化规则 / 101
4.5　一次算法逆向之旅 / 102
4.6　本章小结 / 109
第5章　流程控制语句的识别 / 110
5.1　if语句 / 110
5.2　if…else…语句 / 112
5.3　用if构成的多分支流程 / 115
5.4　switch的真相 / 119
5.5　难以构成跳转表的switch / 128
5.6　降低判定树的高度 / 133
5.7　do/while/for的比较 / 137
5.8　编译器对循环结构的优化 / 143
5.9　本章小结 / 148
第6章　函数的工作原理 / 149
6.1　栈帧的形成和关闭 / 149
6.2　各种调用方式的考察 / 152
6.3　使用ebp或esp寻址 / 155
6.4　函数的参数 / 158
6.5　函数的返回值 / 160
6.6　回顾 / 163
6.7　本章小结 / 165
第7章　变量在内存中的位置和访问方式 / 166
7.1　全局变量和局部变量的区别 / 166
7.2　局部静态变量的工作方式 / 169
7.3　堆变量 / 173
7.4　本章小结 / 177
第8章　数组和指针的寻址 / 178
8.1　数组在函数内 / 178
8.2　数组作为参数 / 181
8.3　数组作为返回值 / 185
8.4　下标寻址和指针寻址 / 189
8.5　多维数组 / 193
8.6　存放指针类型数据的数组 / 199
8.7　指向数组的指针变量 / 201
8.8　函数指针 / 204
8.9　本章小结 / 206
第9章　结构体和类 / 207
9.1　对象的内存布局 / 207
9.2　this指针 / 212
9.3　静态数据成员 / 217
9.4　对象作为函数参数 / 219
9.5　对象作为返回值 / 226
9.6　本章小结 / 231
第10章　关于构造函数和析构函数 / 233
10.1　构造函数的出现时机 / 233
10.2　每个对象都有默认的构造函数吗 / 243
10.3　析构函数的出现时机 / 245
10.4　本章小结 / 254
第11章　关于虚函数 / 256
11.1　虚函数的机制 / 256
11.2　虚函数的识别 / 261
11.3　本章小结 / 268
第12章　从内存角度看继承和多重继承 / 269
12.1　识别类和类之间的关系 / 270
12.2　多重继承   / 292
12.3　虚基类 / 298
12.4　菱形继承 / 299
12.5　本章小结 / 307
第13章　异常处理 / 308
13.1　异常处理的相关知识 / 308
13.2　异常类型为基本数据类型的处理流程 / 314
13.3　异常类型为对象的处理流程 / 323
13.4　识别异常处理 / 329
13.5　本章小结 / 341
第三部分　逆向分析技术应用
第14章　PEiD的工作原理分析 / 344
14.1　开发环境的识别 / 344
14.2　开发环境的伪造 / 353
14.3　本章小结 / 356
第15章　“熊猫烧香”病毒逆向分析 / 357
15.1　调试环境配置 / 357
15.2　病毒程序初步分析 / 358
15.3　“熊猫烧香”的启动过程分析 / 360
15.4　“熊猫烧香”的自我保护分析 / 366
15.5　“熊猫烧香”的感染过程分析 / 369
15.6　本章小结 / 379
第16章　调试器OllyDBG的工作原理分析 / 380
16.1　INT3断点 / 380
16.2　内存断点 / 385
16.3　硬件断点 / 390
16.4　异常处理机制 / 396
16.5　加载调试程序 / 402
16.6　本章小结 / 406
第17章　反汇编代码的重建与编译 / 407
17.1　重建反汇编代码 / 407
17.2　编译重建后的反汇编代码 / 410
17.3　本章小结 / 411
参考文献 / 412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++反汇编与逆向分析技术揭秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>谁来守护公正
目 录
译者导言
序 言
约翰•罗伯茨：我们并非政府的一个政治分支
安东宁•斯卡利亚：我只喜欢大功告成的感觉
安东尼•肯尼迪：说服自己，才能说服别人
克拉伦斯•托马斯：我更喜欢聆听和安静地思考
露丝•巴德•金斯伯格：全力以赴，办好下一个案子
斯蒂芬•布雷耶：这里没有党派纷争与拉帮结派
塞缪尔•阿利托：我不喜欢模棱两可的语气
索尼娅•索托马约尔：这里肯定没有公众想象的那么轻松
艾琳娜•卡根：穿上法袍，你就不再是平时的你
约翰•保罗•斯蒂文斯：我只是很喜欢这份工作
桑德拉•戴•奥康纳：对法官的批评之声让我忧心忡忡
戴维•苏特：这使得每个人都有了真正的参与感
附录一：他们了解最高法院
琼•比斯丘皮克（《今日美国》记者）：最大的挑战是向公众解释判决内容
德鲁•戴斯三世（前首席政府律师、资深律师）：这不是我的辩论，是大法官们的辩论
莱尔•丹尼斯顿（最高法院记者团团长）：我对最高法院报道的前景比较悲观
莫琳•马奥尼（前法官助理、知名律师）：那些胜诉的案子，是我本来就该打赢的案子
詹姆斯•奥哈马（最高法院历史学家）：走进最高法院历史深处
威廉•苏特（最高法院书记官）：法庭需要我做什么，我就去做什么
附录二：如何了解最高法院
了解最高法院资讯的网络资源
美国最高法院大法官年表
C-SPAN近期关于公众对最高法院认识的民意调查
申请最高法院审理案件数及最高法院实际审理案件数（1980年-2010年）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>谁来守护公正
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解C#（第3版）
第一部分　基础知识
第1章　C#开发的进化史　　2
1.1 　从简单的数据类型开始　　3
1.1.1 　C# 1中定义的产品类型　　3
1.1.2 　C# 2中的强类型集合　　4
1.1.3 　C# 3中自动实现的属性　　5
1.1.4 　C# 4中的命名实参　　6
1.2 　排序和过滤　　7
1.2.1 　按名称对产品进行排序　　7
1.2.2 　查询集合　　10
1.3 　处理未知数据　　12
1.3.1 　表示未知的价格　　12
1.3.2 　可选参数和默认值　　13
1.4 　LINQ简介　　14
1.4.1 　查询表达式和进程内查询　　14
1.4.2 　查询XML　　15
1.4.3 　LINQ to SQL　　16
1.5 　COM和动态类型　　17
1.5.1 　简化COM互操作　　17
1.5.2 　与动态语言互操作　　18
1.6 　轻松编写异步代码　　19
1.7 　剖析.NET平台　　20
1.7.1 　C#语言　　20
1.7.2 　运行时　　21
1.7.3 　框架库　　21
1.8 　怎样写出超炫的代码　　22
1.8.1 　采用代码段形式的全能代码　　22
1.8.2 　教学代码不是产品代码　　23
1.8.3 　你的新朋友：语言规范　　23
1.9 　小结　　24
第2章　C# 1所搭建的核心基础　　25
2.1 　委托　　25
2.1.1 　简单委托的构成　　26
2.1.2 　合并和删除委托　　30
2.1.3 　对事件的简单讨论　　32
2.1.4 　委托总结　　33
2.2 　类型系统的特征　　33
2.2.1 　C#在类型系统世界中的位置　　34
2.2.2 　C# 1的类型系统何时不够用　　36
2.2.3 　类型系统特征总结　　39
2.3 　值类型和引用类型　　39
2.3.1 　现实世界中的值和引用　　39
2.3.2 　值类型和引用类型基础知识　　40
2.3.3 　走出误区　　41
2.3.4 　装箱和拆箱　　43
2.3.5 　值类型和引用类型小结　　44
2.4 　C# 1之外：构建于坚实基础之上的新
特性　　44
2.4.1 　与委托有关的特性　　44
2.4.2 　与类型系统有关的特性　　46
2.4.3 　与值类型有关的特性　　48
2.5 　小结　　49
第二部分　C# 2 ：解决C# 1 的问题
第3章　用泛型实现参数化类型　　52
3.1 　为什么需要泛型　　53
3.2 　日常使用的简单泛型　　54
3.2.1 　通过例子来学习：泛型字典　　54
3.2.2 　泛型类型和类型参数　　56
3.2.3 　泛型方法和判读泛型声明　　59
3.3 　深化与提高　　62
3.3.1 　类型约束　　62
3.3.2 　泛型方法类型实参的类型推断　　67
3.3.3 　实现泛型　　68
3.4 　高级泛型　　73
3.4.1 　静态字段和静态构造函数　　73
3.4.2 　JIT编译器如何处理泛型　　75
3.4.3 　泛型迭代　　77
3.4.4 　反射和泛型　　79
3.5 　泛型在C#和其他语言中的限制　　82
3.5.1 　泛型可变性的缺乏　　83
3.5.2 　缺乏操作符约束或者“数值”约束　　87
3.5.3 　缺乏泛型属性、索引器和其他成员类型　　88
3.5.4 　同C++模板的对比　　89
3.5.5 　和Java泛型的对比　　90
3.6 　小结　　91
第4章　可空类型　　93
4.1 　没有值时怎么办　　93
4.1.1 　为什么值类型的变量不能是
null　　94
4.1.2 　在C# 1中表示空值的模式　　94
4.2 　System.Nullable<T>和System.
Nullable　　96
4.2.1 　Nullable<T>简介　　96
4.2.2 　Nullable<T>装箱和拆箱　　99
4.2.3 　Nullable<T>实例的相等性　　100
4.2.4 　来自非泛型Nullable类的
支持　　101
4.3 　C# 2为可空类型提供的语法糖　　101
4.3.1 　?修饰符　　102
4.3.2 　使用null进行赋值和比较　　103
4.3.3 　可空转换和操作符　　105
4.3.4 　可空逻辑　　108
4.3.5 　对可空类型使用as操作符　　109
4.3.6 　空合并操作符　　110
4.4 　可空类型的新奇用法　　112
4.4.1 　尝试一个不使用输出参数的
操作　　113
4.4.2 　空合并操作符让比较不再痛苦　　115
4.5 　小结　　117
第5章　进入快速通道的委托　　118
5.1 　向笨拙的委托语法说拜拜　　119
5.2 　方法组转换　　120
5.3 　协变性和逆变性　　122
5.3.1 　委托参数的逆变性　　122
5.3.2 　委托返回类型的协变性　　123
5.3.3 　不兼容的风险　　124
5.4 　使用匿名方法的内联委托操作　　125
5.4.1 　从简单的开始：处理一个参数　　126
5.4.2 　匿名方法的返回值　　128
5.4.3 　忽略委托参数　　129
5.5 　匿名方法中的捕获变量　　131
5.5.1 　定义闭包和不同类型的变量　　131
5.5.2 　捕获变量的行为　　132
5.5.3 　捕获变量到底有什么用处　　133
5.5.4 　捕获变量的延长生存期　　134
5.5.5 　局部变量实例化　　135
5.5.6 　共享和非共享的变量混合使用　　137
5.5.7 　捕获变量的使用规则和小结　　139
5.6 　小结　　140
第6章　实现迭代器的捷径　　141
6.1 　C# 1：手写迭代器的痛苦　　142
6.2 　C# 2：利用yield语句简化迭代器　　144
6.2.1 　迭代器块和yield return
简介　　145
6.2.2 　观察迭代器的工作流程　　146
6.2.3 　进一步了解迭代器执行流程　　148
6.2.4 　具体实现中的奇特之处　　151
6.3 　真实的迭代器示例　　152
6.3.1 　迭代时刻表中的日期　　152
6.3.2 　迭代文件中的行　　153
6.3.3 　使用迭代器块和谓词对项进行延迟过滤　　156
6.4 　使用CCR实现伪同步代码　　157
6.5 　小结　　160
第7章　结束C# 2的讲解：最后的一些
特性　　161
7.1 　分部类型　　162
7.1.1 　在多个文件中创建一个类型　　162
7.1.2 　分部类型的使用　　164
7.1.3 　C# 3独有的分部方法　　166
7.2 　静态类型　　167
7.3 　独立的取值方法/赋值方法属性访问
器　　169
7.4 　命名空间别名　　170
7.4.1 　限定的命名空间别名　　171
7.4.2 　全局命名空间别名　　172
7.4.3 　外部别名　　173
7.5 　pragma指令　　174
7.5.1 　警告pragma　　174
7.5.2 　校验和pragma　　175
7.6 　非安全代码中固定大小的缓冲区　　176
7.7 　把内部成员暴露给选定的程序集　　178
7.7.1 　简单情况下的友元程序集　　178
7.7.2 　为什么使用Internals-
VisibleTo　　179
7.7.3 　InternalsVisibleTo和签名程序集　　179
7.8 　小结　　180
第三部分　C# 3 ：革新写代码的方式
第8章　用智能的编译器来防错　　182
8.1 　自动实现的属性　　183
8.2 　隐式类型的局部变量　　185
8.2.1 　用var声明局部变量　　185
8.2.2 　隐式类型的限制　　187
8.2.3 　隐式类型的优缺点　　188
8.2.4 　建议　　189
8.3 　简化的初始化　　190
8.3.1 　定义示例类型　　190
8.3.2 　设置简单属性　　191
8.3.3 　为嵌入对象设置属性　　192
8.3.4 　集合初始化程序　　193
8.3.5 　初始化特性的应用　　196
8.4 　隐式类型的数组　　197
8.5 　匿名类型　　198
8.5.1 　第一次邂逅匿名类型　　198
8.5.2 　匿名类型的成员　　200
8.5.3 　投影初始化程序　　201
8.5.4 　重点何在　　202
8.6 　小结　　203
第9章　Lambda表达式和表达式树　　204
9.1 　作为委托的Lambda表达式　　205
9.1.1 　准备工作：Func<...>委托类型简介　　205
9.1.2 　第一次转换成Lambda表达式　　206
9.1.3 　用单一表达式作为主体　　207
9.1.4 　隐式类型的参数列表　　207
9.1.5 　单一参数的快捷语法　　208
9.2 　使用List<T>和事件的简单例子　　209
9.2.1 　列表的过滤、排序和操作　　210
9.2.2 　在事件处理程序中进行记录　　211
9.3 　表达式树　　212
9.3.1 　以编程方式构建表达式树　　213
9.3.2 　将表达式树编译成委托　　214
9.3.3 　将C# Lambda表达式转换成
表达式树　　215
9.3.4 　位于LINQ核心的表达式树　　218
9.3.5 　LINQ之外的表达式树　　220
9.4 　类型推断和重载决策的改变　　221
9.4.1 　改变的起因：精简泛型方法
调用　　221
9.4.2 　推断匿名函数的返回类型　　222
9.4.3 　分两个阶段进行的类型推断　　223
9.4.4 　选择正确的被重载的方法　　227
9.4.5 　类型推断和重载决策　　229
9.5 　小结　　229
第10章　扩展方法　　230
10.1 　未引入扩展方法之前的状态　　231
10.2 　扩展方法的语法　　233
10.2.1 　声明扩展方法　　233
10.2.2 　调用扩展方法　　234
10.2.3 　扩展方法是怎样被发现的　　235
10.2.4 　在空引用上调用方法　　236
10.3 　.NET 3.5中的扩展方法　　238
10.3.1 　从Enumerable开始起步　　238
10.3.2 　用Where过滤并将方法调
用链接到一起　　240
10.3.3 　插曲：似曾相识的Where
方法　　241
10.3.4 　用Select方法和匿名类型进行投影　　242
10.3.5 　用OrderBy方法进行排序　　243
10.3.6 　涉及链接的实际例子　　244
10.4 　使用思路和原则　　245
10.4.1  “扩展世界”和使接口更
丰富　　246
10.4.2 　流畅接口　　246
10.4.3 　理智使用扩展方法　　248
10.5 　小结　　249
第11章　查询表达式和LINQ to
Objects　　250
11.1 　LINQ介绍　　251
11.1.1 　LINQ中的基础概念　　251
11.1.2 　定义示例数据模型　　255
11.2 　简单的开始：选择元素　　256
11.2.1 　以数据源作为开始，以选择作为结束　　257
11.2.2 　编译器转译是查询表达式基础的转译　　257
11.2.3 　范围变量和重要的投影　　260
11.2.4 　Cast、OfType和显式类型的范围变量　　262
11.3 　对序列进行过滤和排序　　264
11.3.1 　使用where子句进行过滤　　264
11.3.2 　退化的查询表达式　　265
11.3.3 　使用orderby子句进行
排序　　265
11.4 　let子句和透明标识符　　267
11.4.1 　用let来进行中间计算　　267
11.4.2 　透明标识符　　268
11.5 　连接　　270
11.5.1 　使用join子句的内连接　　270
11.5.2 　使用join...into子句进行分组连接　　274
11.5.3 　使用多个from子句进行交
叉连接和合并序列　　276
11.6 　分组和延续　　279
11.6.1 　使用group...by子句进
行分组　　279
11.6.2 　查询延续　　282
11.7 　在查询表达式和点标记之间作出
选择　　285
11.7.1 　需要使用点标记的操作　　285
11.7.2 　使用点标记可能会更简单的查询表达式　　286
11.7.3 　选择查询表达式　　286
11.8 　小结　　287
第12章　超越集合的LINQ　　289
12.1 　使用LINQ to SQL查询数据库　　290
12.1.1 　数据库和模型　　290
12.1.2 　用查询表达式访问数据库　　292
12.1.3 　包含连接的查询　　294
12.2 　用IQueryable和IQueryProvider
进行转换　　296
12.2.1 　IQueryable<T>和相关接
口的介绍　　297
12.2.2 　模拟接口实现来记录调用　　298
12.2.3 　把表达式粘合在一起：Queryable的扩展方法　　300
12.2.4 　模拟实际运行的查询提
供器　　302
12.2.5 　包装IQueryable　　303
12.3 　LINQ友好的API和LINQ to XML　　303
12.3.1 　LINQ to XML中的核心
类型　　304
12.3.2 　声明式构造　　305
12.3.3 　查询单个节点　　308
12.3.4 　合并查询操作符　　309
12.3.5 　与LINQ和谐共处　　310
12.4 　用并行LINQ代替LINQ to Objects　　311
12.4.1 　在单线程中绘制曼德博罗
特集　　311
12.4.2 　ParallelEnumerable、ParallelQuery和AsParallel　　313
12.4.3 　调整并行查询　　315
12.5 　使用LINQ to Rx反转查询模型　　316
12.5.1 　IObservable<T>和IObserver<T>　　316
12.5.2 　简单的开始　　318
12.5.3 　查询可观察对象　　319
12.5.4 　意义何在　　321
12.6 　扩展LINQ to Objects　　321
12.6.1 　设计和实现指南　　322
12.6.2 　示例扩展：选择随机元素　　323
12.7 　小结　　324
第四部分　C# 4 ：良好的交互性
第13章　简化代码的微小修改　　328
13.1 　可选参数和命名实参　　328
13.1.1 　可选参数　　329
13.1.2 　命名实参　　334
13.1.3 　两者相结合　　337
13.2 　改善COM互操作性　　341
13.2.1 　在C# 4之前操纵Word是
十分恐怖的　　342
13.2.2 　可选参数和命名实参的
复仇　　342
13.2.3 　按值传递ref参数　　343
13.2.4 　调用命名索引器　　344
13.2.5 　链接主互操作程序集　　345
13.3 　接口和委托的泛型可变性　　348
13.3.1 　可变性的种类：协变性和逆变性　　348
13.3.2 　在接口中使用可变性　　349
13.3.3 　在委托中使用可变性　　352
13.3.4 　复杂情况　　353
13.3.5 　限制和说明　　354
13.4 　对锁和字段风格的事件的微小改变　　357
13.4.1 　健壮的锁　　357
13.4.2 　字段风格的事件　　358
13.5 　小结　　359
第14章　静态语言中的动态绑定　　360
14.1 　何谓、何时、为何、如何　　361
14.1.1 　何谓动态类型　　361
14.1.2 　动态类型什么时候有用，为什么　　362
14.1.3 　C# 4如何提供动态类型　　363
14.2 　关于动态的快速指南　　364
14.3 　动态类型示例　　366
14.3.1 　COM和Office　　367
14.3.2 　动态语言　　368
14.3.3 　纯托管代码中的动态类型　　372
14.4 　幕后原理　　377
14.4.1 　DLR简介　　378
14.4.2 　DLR核心概念　　379
14.4.3 　C#编译器如何处理动态　　382
14.4.4 　更加智能的C#编译器　　385
14.4.5 　动态代码的约束　　388
14.5 　实现动态行为　　390
14.5.1 　使用ExpandoObject　　391
14.5.2 　使用DynamicObject　　394
14.5.3　　实现IDynamicMetaObject-
Provider　　400
14.6 　小结　　404
第五部分　C# 5：简化的异步编程
第15章　使用async/await进行异步
编程　　406
15.1 　异步函数简介　　407
15.1.1 　初识异步类型　　408
15.1.2 　分解第一个示例　　409
15.2 　思考异步编程　　410
15.2.1 　异步执行的基础　　410
15.2.2 　异步方法　　412
15.3 　语法和语义　　413
15.3.1 　声明异步方法　　413
15.3.2 　异步方法的返回类型　　414
15.3.3 　可等待模式　　415
15.3.4 　await表达式的流　　418
15.3.5 　从异步方法返回　　421
15.3.6 　异常　　422
15.4 　异步匿名函数　　429
15.5 　实现细节：编译器转换　　431
15.5.1 　生成的代码　　432
15.5.2 　骨架方法的结构　　434
15.5.3 　状态机的结构　　435
15.5.4 　一个入口搞定一切　　436
15.5.5 　围绕await表达式的控制　　438
15.5.6 　跟踪栈　　439
15.5.7 　更多内容　　440
15.6 　高效地使用async/await　　441
15.6.1 　基于任务的异步模式　　441
15.6.2 　组合异步操作　　444
15.6.3 　对异步代码编写单元测试　　447
15.6.4 　可等待模式的归来　　450
15.6.5 　在WinRT中执行异步操作　　451
15.7 　小结　　452
第16章　C# 5附加特性和结束语　　453
16.1 　foreach循环中捕获变量的变化　　453
16.2 　调用者信息特性　　454
16.2.1 　基本行为　　454
16.2.2 　日志　　456
16.2.3 　实现INotifyProperty-
Changed　　456
16.2.4 　在非.NET 4.5环境下使用调用者信息特性　　457
16.3 　结束语　　458
附录A 　LINQ标准查询操作符　　460
附录B 　.NET中的泛型集合　　471
附录C 　版本总结　　483

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解C#（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数学史（上下）
上册目录
前言1
修订版序1
初版序1
第1章起源
数的概念/早期的基数/数字语言与计算的起源/几何学的起源/
第2章埃及
早期记录/象形文字的符号/阿美斯纸草书/单分数/
算术运算/代数题/几何问题/三角比/莫斯科纸草书/埃及数学的不足/
第3章美索不达米亚
楔形文字记录/位置记数法/以六十为底的分数/基本运算/代数问题/二次方程/三次方程/毕达哥拉斯三元数组/多边形的面积/作为应用数学的几何学/美索不达米亚数学的不足/
第4章爱奥尼亚与毕达哥拉斯学派
希腊的起源/米利都的泰勒斯/萨摩斯岛的毕达哥拉斯/
毕达哥拉斯学派的五角星/数字神秘主义/算术与宇宙论/图形数字/比例/雅典记数法/爱奥尼亚记数法/
算术与逻辑/
第5章英雄时代
活动中心/克拉左美奈的阿那克萨哥拉/三大著名难题/
求月牙形面积/连比/厄利斯城的希庇亚斯/塔伦图姆的菲洛劳斯和阿契塔/倍立方//不可公度性/黄金分割/芝诺悖论/演绎推理/几何代数/阿伯德拉的德谟克利特/
第6章柏拉图和亚里士多德时代
文科七艺/苏格拉底/柏拉图多面体/昔兰尼的西奥多
罗斯/柏拉图的算术与几何/分析学的起源/尼多斯的欧多克索斯/穷举法/数学天文学/门奈赫莫斯/立方体加倍/狄诺斯特拉图与化圆为方皮坦尼的奥托利科斯/亚里士多德/古希腊时期的终结/
第7章亚历山大城的欧几里得
《几何原本》的作者/其他作品/《几何原本》的目的/定义与公设/第一卷的范围/几何代数/第三卷和第四卷/比例理论/数论/素数与完全数/不可公度性/立体几何/伪书/《几何原本》的影响/
第8章叙拉古的数学
叙拉古的围攻/杠杆原理/流体静力学原理/《数沙术》/
圆的度量/三等分角/抛物线段的面积/抛物线体的体积/球截体/《论球和圆柱》/《引理集》/半正多面体和三角学/《方法》/球的体积/《方法》的复原/
第9章阿波罗尼奥斯
失传的作品/恢复失传作品/阿波罗尼奥斯问题/圆与
周转圆/《圆锥曲线论》/圆锥截面的名称/双叶圆锥/基本属性/共轭直径/切线与调和分割/三线和四线轨迹/相交的圆锥曲线/最大与最小，切线与正交线/相似圆锥曲线/圆锥曲线的焦点/坐标的使用/
第10章希腊的三角学与测量学
早期的三角学/萨摩斯岛的阿里斯塔克斯/昔兰尼的埃拉
托斯特尼/尼西亚的希帕克斯/亚历山大城的梅涅劳斯/托勒密的《至大论》/360度圆/三角函数表的构建/托勒密的天文学/托勒密的其他作品/光学与占星术/亚历山大城的海伦/最短距离原则/希腊数学的衰落/
第11章希腊数学的复兴和衰微
应用数学/亚历山大城的丢番图/尼科马库斯/丢番
图的《算术》/丢番图难题/丢番图在代数学中的位置/亚历山大城的帕普斯/《数学汇编》/帕普斯的定理/帕普斯问题/《解析宝典》/帕普斯—古尔丁定理/亚历山大城的普罗克洛斯/波伊提乌/亚历山大时期的终结/《希腊诗文选》/公元六世纪的拜占庭数学/
第12章中国和印度
最古老的文献/《九章算术》/幻方/筹数/算盘
和十进制小数/π值/代数与霍纳法/十三世纪的数学/算术三角形/印度的早期数学/《绳法经》/《悉昙多》/阿利耶毗陀/印度的数字/代表零的符号/印度的三角学/印度的乘法/长除法/婆罗摩笈多/婆罗摩笈多公式/不定方程/婆什迦罗/《丽罗娃提》/拉马努金/
第13章阿拉伯的霸权
阿拉伯的征服/智慧宫/《代数学》/二次方程/
代数之父/几何基础/代数问题/一个源自海伦的问题/图尔克/塔比·伊本-库拉/阿拉伯数字/阿拉伯的三角学/阿卜尔·维法与凯拉吉/阿尔比鲁尼与阿尔哈曾/奥马·海亚姆/平行公设/纳西尔丁/阿尔·卡西/
第14章中世纪的欧洲
从亚洲到欧洲/拜占庭的数学/黑暗时代/阿尔昆与
吉尔伯特/翻译的世纪/印度—阿拉伯数字的传播/《算盘书》/斐波那契数列/三次方程的解/数论与几何/约丹努斯/诺瓦拉的坎帕努斯/十三世纪的学术/中世纪的运动学/托马斯·布雷德沃丁/尼科尔·奥雷斯姆/形相的纬度/无穷级数/中世纪学术的衰微/
第15章文艺复兴时期
人文主义/库萨的尼古拉/雷格蒙塔努斯/代数在几何
学中的应用/一个过渡人物/尼古拉斯·丘凯的《算术三篇》/卢卡·帕乔利的《概要》/列奥纳多·达芬奇/德国代数/卡尔达诺的《大衍术》/三次方程的解法/费拉里的四次方程的解法/不可化简的三次方程和复数/罗伯特·雷科德/尼古拉·哥白尼/乔治·约希姆·雷蒂库斯/彼得吕斯·拉米斯/邦别利的《代数学》/约翰尼斯·维尔纳/透视理论/制图学/
第16章现代数学的前奏
弗朗索瓦·韦达/参数的概念/解析技术/根与系数
之间的关系/托马斯·哈里奥特与威廉·奥特雷德/又见霍纳法/三角学与积化和差/方程的三角解法/约翰·纳皮尔/对数的发明/亨利·布里格斯/乔伯斯特·布尔基/应用数学与十进制小数/代数符号表示法/伽利略/π值/复原阿波罗尼奥斯的《论相切》/无穷小分析/约翰·开普勒/伽利略的《两门新科学》/伽利略与无穷/博纳文图拉·卡瓦列里/螺线与抛物线/
下册目录
第17章费马与笛卡尔的时代
当年最重要的数学家/《方法论》/解析几何的发明/
几何的算术化/几何代数/曲线的分类/求曲线的长度/圆锥曲线的识别/法线与切线/笛卡尔的几何概念/费马的轨迹/高维解析几何/费马的微分法/费马的积分法/圣文森特的格列戈里/数论/费马定理/罗伯瓦尔/托里拆利/新曲线/德扎格/
射影几何/帕斯卡尔/概率/摆线/
第18章过渡时期
菲利普·德·拉海尔/乔治·莫尔/彼得罗·门戈利/
弗兰斯·范·斯霍滕/让·德·维特/约翰·许德/勒内·弗朗索瓦·德·斯吕塞/摆钟/渐伸线与渐屈线/约翰·沃利斯/《圆锥曲线论》/《无穷算术》/克里斯托弗·雷恩/沃利斯公式/詹姆斯·格列戈里/格列戈里级数/麦凯特尔与布龙克尔/巴罗的切线方法/
第19章牛顿与莱布尼茨
牛顿的早期作品/二项式定理/无穷级数/《流数法》/
《原理》/莱布尼茨与调和三角形/微分三角形与无穷级数/微分学/行列式、符号表示法和虚数/逻辑代数/平方反比定律/圆锥曲线定理/光学与曲线/极坐标及其他坐标/牛顿法与牛顿平行四边形/《广义算术》/晚年/
第20章伯努利时代
伯努利的家庭/对数螺线/概率与无穷级数/洛必达法则/
指数微积分/负数的对数/圣彼得堡悖论/亚伯拉罕·棣莫弗/棣莫弗定理/罗杰·科茨/詹姆斯·斯特林/科林·麦克劳林/泰勒级数/《分析学家》论战/克莱姆法则/契恩豪斯变换/立体解析几何/
米歇尔·罗尔与皮埃尔·瓦利农/意大利的数学/平行公设/发散级数/
第21章欧拉时代
欧拉的生平/符号/分析学的基础/无穷级数/
收敛级数与发散级数/达朗贝尔的生平/欧拉恒等式/
达朗贝尔与极限/微分方程/克莱罗兄弟/黎卡提父子/概率论/数论/教科书/综合几何/立体解析几何/朗伯与平行公设/裴蜀与消元法/
第22章法国大革命时期的数学
革命的时代/最重要的数学家/1789年之前的出版物/
拉格朗日与行列式/度量衡委员会/孔多塞论教育/作为行政管理者和教师的蒙日/画法几何与解析几何/教科书/拉克鲁瓦论解析几何/胜利的组织者/微积分与几何的形而上学/《位置几何》/截线/勒让德的《几何原理》/椭圆积分/数论/函数理论/变分法/拉格朗日乘数/拉普拉斯与概率论/天体力学与算子/政治变化/
第23章高斯与柯西的时代
十九世纪综述/高斯：早期作品/数论/《算术研究》
所受到的对待/高斯对天文学的贡献/高斯的中年/微分几何的肇始/高斯的晚期工作/19世纪20年代的巴黎/柯西/高斯与柯西比较/非欧几何/阿贝尔与雅可比/伽罗华/扩散/英国和普鲁士的改革/
第24章几何学
蒙日学派/射影几何：蓬斯莱与沙勒/综合度量几何学：
施泰纳/综合非度量几何学：施陶特/解析几何/黎曼几何/高维空间/费利克斯·克莱因/后雷曼时代的代数几何/
第25章分析学
十九世纪中叶的柏林和哥廷根/黎曼在哥廷根/几何学中的
数学物理学/说英语国家的数学物理学/魏尔斯特拉斯和他的学生们/分析学的算术化/康托尔与戴德金/法国的分析学/
第26章代数学
引言/英国的代数学和函数的运算微积分/布尔与逻辑
代数/德·摩根/哈密顿/格拉斯曼与《线性扩张论》/凯莱与西尔维斯特/线性结合代数/代数几何/代数整数和算术整数/算术公理/
第27章庞加莱与希尔伯特
世纪之交综览/庞加莱/数学物理学及其他应用/拓扑学
/其他领域和遗产/希尔伯特/不变量理论/希尔伯特的《代数数域理论》/几何学的基础/希尔伯特问题/希尔伯特与分析学/华林问题与希尔伯特1909年之后的工作/
第28章二十世纪的方方面面
概览/积分与测度/泛函分析与一般拓扑学/代数学/
微分几何与张量分析/1930年代与第二次世界大战/概率论/同调代数与范畴论/布尔巴基/逻辑与计算/未来展望/
参考文献
总书目
人名、地名译名索引
...(展开全部)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数学史（上下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>引爆社群
推荐语
前言
第1章　移动互联网时代的“4C法则”　∥1
第1节　新环境下，营销需要换一个大脑　∥2
第2节　什么是新4C法则　∥3
第3节　从一个简单的案例看新4C理论　∥5
第4节　场景能让营销信息更有效地深入人心　∥8
第5节　营销要精准，就必须深入目标客户的社群　∥9
第6节　内容是一切营销传播的本质　∥12
第7节　轻轻一推，引爆社群传播链条　∥14
第2章　充满魅力的场景　∥17
第1节　什么是营销中的场景　∥18
第2节　从帮汪峰上头条看场景选择　∥20
第3节　时间上的场景　∥22
第4节　从脑白金的营销看时间在场景中的重要性　∥26
第5节　挖掘日常场景中蕴含的机会　∥30
第6节　地点是场景的灵魂　∥34
第7节　基于位置的营销　∥41
第8节　如何截取人流　∥44
第9节　让业务回归本地　∥47
第10节　如何在场景中洞察消费者的购买时机　∥51
第11节　情绪也是一种场景　∥53
本章实践思考题　∥57
第3章　从个体思维转向社群思维　∥58
第1节　什么是社群　∥59
第2节　解构社群　∥61
第3节　找到目标客户所在的社群并引爆它　∥68
第4节　社群的互联网入口　∥71
第5节　用社群思路区分不同类型的消费者　∥76
第6节　巧妙地构建目标客户社群　∥79
第7节　免费“雇佣”你的消费者　∥81
第8节　社群运营的8个策略　∥83
第9节　小米如何点燃社群　∥90
第10节　微博和微信营销努力的方向都是构建社群　∥96
本章实践思考题　∥99
第4章　有传播力的内容　∥100
第1节　优秀的内容是互联网的根　∥101
第2节　不仅要生产内容，更要规划内容　∥103
第3节　做客户想要的内容，并扩大影响　∥110
第4节　好的标题　∥117
第5节　友善对话的内容风格正流行　∥120
第6节　让内容走得更远　∥121
第7节　好的内容一定有故事　∥124
第8节　B2B企业如何做内容营销　∥128
第9节　从消费者购买流程做内容　∥131
第10节　做有传播力的内容，并进行要素梳理　∥135
本章实践思考题　∥136
第5章　人与人的连接　∥137
第1节　大众传播渠道与人际传播渠道只有一步之遥　∥138
第2节　引爆流行的核心是撬动中心节点　∥140
第3节　找到影响力的按钮，然后启动　∥143
第4节　激发和保护传播的动力　∥151
第5节　引爆社群背后的社会动力学　∥155
第6节　寻找那些已经在讨论我们的人　∥157
第7节　引爆新用户的秘密—裂变　∥159
第8节　设置病毒流行机制　∥162
第9节　新产品在人群中扩散的规律　∥167
第10节　擦亮眼睛寻找早期采用者　∥170
第11节　点燃社交关系链，让人与人动起来　∥172
第12节　社交网络中口碑和人际传播模式被放大　∥176
本章实践思考题　∥180
第6章　4C的外延和思考　∥181
第1节　社群的外延和思考　∥182
第2节　场景的外延和思考　∥183
第3节　内容的外延和思考　∥185
第4节　人与人连接的外延和思考　∥187
第5节　融合的4C原则　∥188
参考文献　∥193
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>引爆社群
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自制编程语言 基于C语言
第0章　一些可能令人迷惑的问题　1
0.0　成功的基石不是坚持，而是“不放弃”　1
0.1　你懂编程语言的“心”吗　2
0.2　编程语言的来历　2
0.3　语言一定要用更底层的语言来编写吗　2
0.4　编译型程序和脚本程序的异同　8
0.5　脚本语言的分类　10
0.6　为什么CPU要用数字而不是字符串作为指令　11
0.7　为什么脚本语言比编译型语言慢　11
0.8　既然脚本语言比较慢，为什么大家还要用　12
0.9　什么是中间代码　12
0.10　什么是编译器的前端、后端　13
0.11　词法分析、语法分析、语义分析和生成代码并不是串行执行　13
0.12　什么是符号表　14
0.13　什么是关系中的闭包　14
0.14　什么是程序中的闭包　15
0.15　什么是字母表　16
0.16　什么是语言　17
0.17　正规式就是正则表达式　17
0.18　什么是正规（表达）式和正规集　17
0.19　什么是有穷自动机　18
0.20　有穷自动机与词法分析的关系　19
0.21　词法分析用有穷自动机（有穷状态自动机）的弊端　19
0.22　什么是文法　20
0.23　BNF和EBNF，非终结符和终结符，开始符号及产生式　21
0.24　什么是句型、句子、短语　23
0.25　什么是语法分析　24
0.26　语法分析中的推导和归约为什么都要最“左”　25
0.27　什么是语义分析　26
0.28　什么是语法制导　27
0.29　词法分析器吃的是lex，挤出来的是token　27
0.30　什么是“遍”　28
0.31　文法为什么可以变换　28
0.32　为什么消除左递归和提取左因子　28
0.33　FIRST集、FOLLOW集、LL(1)文法　29
0.34　最右推导、最左归约、句柄　31
0.35　算符优先分析法　32
0.36　算符优先文法　33
0.37　非终结符中常常定义的因子和项是什么　33
0.38　什么是抽象语法树　33
0.39　编译器如何使用或实现文法中的产生式　34
0.40　程序计数器pc与ip的区别　35
第　1章 设计一种面向对象脚本语言　36
1.1　脚本语言的功能　36
1.2　关键字　37
1.3　脚本的执行方式　38
1.4　“纯手工”的开发环境　38
1.5　定义sparrow语言的文法　38
第２章　实现词法分析器　46
2.1　柔性数组　46
2.2　什么是字节序　47
2.3　一些基础的数据结构（本节源码stepByStep/c2/a）　48
2.4　定义虚拟机结构（本节源码stepByStep/c2/b）　56
2.5　实现源码读取（本节源码stepByStep/c2/c）　57
2.6　unicode与UTF-8　59
2.6.1　什么是unicode　59
2.6.2　什么是UTF-8　59
2.6.3　UTF-8编码规则　60
2.6.4　实现UTF-8编码、解码（本节源码stepByStep/c2/d）　61
2.7　实现词法分析器parser（本节源码stepByStep/c2/e）　66
2.7.1　lex和token　66
2.7.2　字符串和字符串内嵌表达式　66
2.7.3　单词识别流程　67
2.7.4　定义token和parser　68
2.7.5　解析关键字及获取字符　71
2.7.6　解析标识符和unicode码点　73
2.7.7　解析字符串、内嵌表达式、转义字符　75
2.7.8　跳过注释和空行　77
2.7.9　获取token　79
2.7.10　token匹配和初始化parser　84
2.8　构建主程序（本节源码stepByStep/c2/f）　85
2.9　编译、测试（本节源码stepByStep/c2/f）　88
2.9.1　一个简单的makefile　88
2.9.2　测试paser　92
第3章　类与对象　95
3.1　对象在C语言中的概貌　95
3.2　实现对象头（本节源码stepByStep/c3/a）　96
3.3　实现class定义（本节源码stepByStep/c3/a）　99
3.4　实现字符串对象（本节源码stepByStep/c3/a）　101
3.5　模块对象和实例对象（本节源码stepByStep/c3/a）　103
3.6　upvalue、openUpvalue和closedUpvalue　106
3.7　实现函数对象、闭包对象与调用框架（本节源码stepByStep/c3/a）　107
3.8　完善词法分析器之数字解析（本节源码stepByStep/c3/b）　111
3.9　完善词法分析器之字符串解析和获取token（本节源码stepByStep/c3/b）　114
3.10　最终版词法分析器的功能验证（本节源码stepByStep/c3/b）　116
3.11　实现list列表对象（本节源码stepByStep/c3/c）　118
3.12　range对象（本节源码stepByStep/c3/c）　121
3.13　迟到的class.c（本节源码stepByStep/c3/c）　122
3.14　map对象（本节源码stepByStep/c3/c）　124
3.14.1　哈希表　124
3.14.2　map对象头文件及entry　125
3.14.3　冲突探测链与伪删除　126
3.14.4　map对象的实现　128
3.15　线程对象（本节源码stepByStep/c3/c）　134
3.15.1　线程、协程浅述　134
3.15.2　运行时栈　137
3.15.3　用户线程的实现　138
第4章　原生方法及基础实现　142
4.1　解释器流程（本节源码stepBystep/c4/a）　142
4.2　符号表　144
4.2.1　模块的符号表　144
4.2.2　类方法的符号表　144
4.2.3　模块变量符号表　146
4.2.4　局部变量符号表　147
4.2.5　常量符号表　147
4.3　方法在运行时栈中的参数　147
4.4　定义模块变量（本节源码stepByStep/c4/b）　148
4.5　原生方法（本节源码stepByStep/c4/b）　154
4.5.1　定义裸类　154
4.5.2　定义返回值与方法绑定的宏　155
4.5.3　定义原生方法　157
4.5.4　符号表操作　159
4.5.5　定义类、绑定方法、绑定基类　160
4.6　元类及实现（本节源码stepByStep/c4/b）　161
4.6.1　meta-class类、class类、object类　161
4.6.2　创建元类，绑定类方法　163
4.7　加载模块（本节源码stepByStep/c4/c）　164
4.8　虚拟机简介　166
4.8.1　虚拟机分类及优缺点　166
4.8.2　为什么要采用虚拟机　168
4.8.3　虚拟机的简单优化　170
4.9　字节码　171
第5章　自上而下算符优先——TDOP　177
5.1　自上而下算符优先—TDOP　177
5.2　来自Douglas Crockford的教程　177
5.3　TDOP原理　194
5.3.1　一些概念　194
5.3.2　一个小例子　196
5.3.3　expression的思想　197
5.3.4　while（rbp < token.lbp）的意义　200
5.3.5　进入expression时当前token的类别　201
5.3.6　TDOP总结　202
第6章　实现语法分析与语义分析　204
6.1　定义指令（本节源码stepByStep/c6/a）　204
6.2　核心脚本（本节源码stepByStep/c6/a）　206
6.3　写入指令（本节源码stepByStep/c6/a）　212
6.4　编译模块（本节源码stepByStep/c6/a）　216
6.5　语义分析的本质　218
6.6　注册编译函数（本节源码stepByStep/c6/b）　218
6.7　赋值运算的条件　221
6.8　实现expression及其周边（本节源码stepByStep/c6/c）　223
6.9　局部变量作用域管理　228
6.10　变量声明、中缀、前缀及混合运算符方法签名（本节源码stepByStep/c6/d）　229
6.11　解析标识符（本节源码stepByStep/c6/e）　233
6.11.1　处理参数列表及相关　233
6.11.2　实现运算符和标识符的签名函数　235
6.11.3　upvalue的查找与添加　239
6.11.4　变量的加载与存储　242
6.11.5　编译代码块及结束编译单元　243
6.11.6　各种方法调用　246
6.11.7　标识符的编译　249
6.12　编译内嵌表达式（本节源码stepByStep/c6/f）　256
6.13　编译bool及null（本节源码stepByStep/c6/g）　258
6.14　this、继承、基类（本节源码stepByStep/c6/h）　259
6.15　编译小括号、中括号及list列表字面量（本节源码stepByStep/c6/i）　260
6.16　编译方法调用和map字面量（本节源码stepByStep/c6/j）　263
6.17　编译数学运算符（本节源码stepByStep/c6/k）　266
6.18　编译变量定义（本节源码stepByStep/c6/l）　270
6.19　编译语句　274
6.19.1　编译if语句（本节源码stepByStep/c6/m）　274
6.19.2　编译while语句（本节源码stepByStep/c6/n）　275
6.19.3　编译return、break和continue语句（本节源码stepByStep/c6/o）　280
6.19.4　编译for循环语句（本节源码stepByStep/c6/p）　284
6.19.5　编译代码块及单一语句（本节源码stepByStep/c6/q）　288
6.20　编译类定义（本节源码stepByStep/c6/r）　289
6.20.1　方法的声明与定义　289
6.20.2　构造函数与创建对象　291
6.20.3　编译方法　293
6.20.4　编译类定义　296
6.21　编译函数定义（本节源码stepByStep/c6/s）　298
6.22　编译模块导入（本节源码stepByStep/c6/t）　300
第7章　虚拟机　306
7.1　创建类与堆栈框架（本节源码stepByStep/c7/a）　306
7.2　upvalue的创建与关闭（本节源码stepByStep/c7/b）　309
7.3　修正操作数（本节源码stepByStep/c7/c）　312
7.4　执行指令（本节源码stepByStep/c7/d）　314
7.4.1　一些基础工作　314
7.4.2　解码、译码、执行（本节源码stepByStep/c7/d）　316
7.5　运行虚拟机（本节源码stepByStep/c7/e）　334
第8章　内建类及其方法　337
8.1　Bool类及其方法（本节源码stepByStep/c8/a）　337
8.2　线程类及其方法（本节源码stepByStep/c8/b）　338
8.3　函数类及其方法和函数调用重载（本节源码stepByStep/c8/c）　345
8.4　Null类及其方法（本节源码stepByStep/c8/d）　347
8.5　Num类及其方法（本节源码stepByStep/c8/e）　348
8.6　String类及其方法（本节源码stepByStep/c8/f）　355
8.7　List类及其方法（本节源码stepByStep/c8/g）　369
8.8　Map类及其方法（本节源码stepByStep/c8/h）　374
8.9　range类及其方法（本节源码stepByStep/c8/i）　380
8.10　System类及其方法（本节源码stepByStep/c8/j）　383
8.11　收尾与测试（本节源码stepByStep/c8/k）　388
第9章　垃圾回收　393
9.1　垃圾回收浅述　393
9.2　理论基础　395
9.3　标记—清扫回收算法　396
9.4　一些基础结构（本节源码stepByStep/c9/a）　397
9.5　实现GC（本节源码stepByStep/c9/a）　400
9.6　添加临时根对象与触发GC　411
第　10章 命令行及调试　415
10.1　释放虚拟机（本节源码stepByStep/c10/a）　415
10.2　简单的命令行界面（本节源码stepByStep/c10/a）　415
10.3　调试（本节源码stepByStep/c10/b）　417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自制编程语言 基于C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++语言的设计与演化
第0章  致读者1
第1部分
第1章  C++的史前时代17
1.1  Simula和分布式系统17
1.2  C与系统程序设计19
1.3  一般性的背景20
第2章  C with Classes23
2.1  C with Classes的诞生23
2.2  特征概览25
2.3  类26
2.4  运行时的效率28
2.5  连接模型30
2.5.1  纯朴的实现32
2.5.2  对象连接模型33
2.6  静态类型检查35
2.6.1  窄转换36
2.6.2  警告的使用36
2.7  为什么是C37
2.8  语法问题39
2.8.1  C声明的语法39
2.8.2  结构标志与类型名41
2.8.3  语法的重要性42
2.9  派生类42
2.9.1  没有虚函数时的多态性43
2.9.2  没有模板时的容器类44
2.9.3  对象的布局模型45
2.9.4  回顾46
2.10  保护模型46
2.11  运行时的保证48
2.11.1  构造函数与析构函数49
2.11.2  存储分配和构造函数49
2.11.3  调用函数和返回函数50
2.12  次要特征50
2.12.1  赋值的重载50
2.12.2  默认实参51
2.13  考虑过，但是没有提供的特征52
2.14  工作环境52
第3章  C++的诞生55
3.1  从C with Classes到C++55
3.2  目标57
3.3  Cfront58
3.3.1  生成C59
3.3.2  分析C++60
3.3.3  连接问题61
3.3.4  Cfront发布61
3.4  语言特征63
3.5  虚函数63
3.5.1  对象布局模型66
3.5.2  覆盖和虚函数匹配67
3.5.3  基成员的遮蔽68
3.6  重载68
3.6.1  基本重载70
3.6.2  成员和友元71
3.6.3  运算符函数73
3.6.4  效率和重载73
3.6.5  变化和新运算符75
3.7  引用75
3.8  常量78
3.9  存储管理80
3.10  类型检查81
3.11  次要特征82
3.11.1  注释82
3.11.2  构造函数的记法82
3.11.3  限定83
3.11.4  全局变量的初始化84
3.11.5  声明语句87
3.12  与经典C的关系88
3.13  语言设计工具91
3.14  《C++程序设计语言》（第一版）92
3.15  有关“什么是”的论文93
第4章  C++语言设计规则96
4.1  规则和原理96
4.2  一般性规则97
4.3  设计支持规则100
4.4  语言的技术性规则103
4.5  低级程序设计支持规则106
4.6  最后的话108
第5章  1985—1993年表109
5.1  引言109
5.2  Release 2.0110
5.3  带标注的参考手册（ARM）112
5.4  ANSI和ISO标准化114
第6章  标准化118
6.1  什么是标准118
6.1.1  实现细节119
6.1.2  现实的检查120
6.2  委员会如何运作121
6.3  净化123
6.3.1  查找问题123
6.3.2  临时量的生存期127
6.4  扩充130
6.4.1  评价准则133
6.4.2  状况134
6.4.3  好扩充的问题136
6.4.4  一致性137
6.5  扩充建议实例137
6.5.1  关键词实参137
6.5.2  受限指针141
6.5.3  字符集142
第7章  关注和使用146
7.1  关注和使用的爆炸性增长146
7.1.1  C++市场的缺位147
7.1.2  会议148
7.1.3  杂志和书籍148
7.1.4  编译器149
7.1.5  工具和环境149
7.2  C++的教与学150
7.3  用户和应用156
7.3.1  早期用户156
7.3.2  后来的用户156
7.4  商业竞争157
7.4.1  传统语言158
7.4.2  更新一些的语言158
7.4.3  期望和看法159
第8章  库162
8.1  引言162
8.2  C++库设计162
8.2.1  库设计的折中163
8.2.2  语言特征和库的构造164
8.2.3  处理库的多样性164
8.3  早期的库165
8.3.1  I/O流库166
8.3.2  并行支持168
8.4  其他库171
8.4.1  基础库171
8.4.2  持续性和数据库172
8.4.3  数值库172
8.4.4  专用库172
8.5  一个标准库173
第9章  展望175
9.1  引言175
9.2  回顾176
9.2.1  C++在其预期领域取得了成功吗？176
9.2.2  C++是不是一种统一的语言？177
9.2.3  什么是最大失误？180
9.3  仅仅是一座桥梁吗？180
9.3.1  在一个很长的时期我们还需要这座桥梁180
9.3.2  如果C++是答案，那么问题是什么？181
9.4  什么能使C++更有效184
9.4.1  稳定性和标准184
9.4.2  教育和技术185
9.4.3  系统方面的问题185
9.4.4  在文件和语法之外186
9.4.5  总结187
第2部分
第10章  存储管理189
10.1  引言189
10.2  将存储分配和初始化分离190
10.3  数组分配191
10.4  放置192
10.5  存储释放问题193
10.6  存储器耗尽195
10.7  自动废料收集196
10.7.1  可选的废料收集196
10.7.2  可选择的废料收集应该是什么样子的？198
第11章  重载200
11.1  引言200
11.2  重载的解析201
11.2.1  细粒度解析201
11.2.2  歧义控制203
11.2.3  空指针205
11.2.4  overload关键字207
11.3  类型安全的连接208
11.3.1  重载和连接208
11.3.2  C++连接的一种实现209
11.3.3  回顾210
11.4  对象的建立和复制212
11.4.1  对复制的控制212
11.4.2  对分配的控制213
11.4.3  对派生的控制213
11.4.4  按成员复制214
11.5  记法约定215
11.5.1  灵巧指针216
11.5.2  灵巧引用217
11.5.3  增量和减量的重载219
11.5.4  重载 ->*221
11.5.5  重载逗号运算符221
11.6  给C++增加运算符221
11.6.1  指数运算符221
11.6.2  用户定义运算符223
11.6.3  复合运算符225
11.7  枚举226
11.7.1  基于枚举的重载227
11.7.2  布尔类型227
第12章  多重继承229
12.1  引言229
12.2  普通基类230
12.3  虚基类231
12.4  对象布局模型235
12.4.1  虚基布局237
12.4.2  虚基类和强制237
12.5  方法组合238
12.6  有关多重继承的论战239
12.7  委托242
12.8  重命名243
12.9  基类和成员初始化245
第13章  类概念的精练247
13.1  引言247
13.2  抽象类247
13.2.1  为处理错误而用的抽象类248
13.2.2  抽象类型249
13.2.3  语法250
13.2.4  虚函数和构造函数251
13.3  const成员函数253
13.3.1  强制去掉const254
13.3.2  const定义的精练254
13.3.3  可变性与强制255
13.4  静态成员函数256
13.5  嵌套的类257
13.6  Inherited::258
13.7  放松覆盖规则260
13.8  多重方法264
13.9  保护成员267
13.10  改进代码生成268
13.11  指向成员的指针269
第14章  强制转换271
14.1  主要扩充271
14.2  运行时类型信息272
14.2.1  问题273
14.2.2  dynamic_cast运算符273
14.2.3  RTTI的使用和误用278
14.2.4  为什么提供一个“危险特征”280
14.2.5  typeid()运算符281
14.2.6  对象布局模型284
14.2.7  一个例子：简单的对象I/O285
14.2.8  考虑过的其他选择287
14.3  强制的一种新记法290
14.3.1  问题290
14.3.2  static_cast运算符292
14.3.3  reinterpret_cast运算符293
14.3.4  const_cast运算符295
14.3.5  新风格强制的影响296
第15章  模板298
15.1  引言298
15.2  模板299
15.3  类模板301
15.4  对模板参数的限制303
15.4.1  通过派生加以限制304
15.4.2  通过使用加以限制305
15.5  避免代码重复306
15.6  函数模板307
15.6.1  函数模板参数的推断308
15.6.2  描述函数模板的参数309
15.6.3  函数模板的重载311
15.7  语法313
15.8  组合技术315
15.8.1  表述实现策略316
15.8.2  描述顺序关系316
15.9  模板类之间的关系318
15.9.1  继承关系318
15.9.2  转换320
15.9.3  成员模板321
15.10  模板的实例化322
15.10.1  显式的实例化323
15.10.2  实例化点325
15.10.3  专门化329
15.10.4  查找模板定义331
15.11  模板的作用333
15.11.1  实现与界面的分离334
15.11.2  灵活性和效率334
15.11.3  对C++其他部分的影响335
第16章  异常处理337
16.1  引言337
16.2  目标和假设338
16.3  语法339
16.4  结组340
16.5  资源管理341
16.6  唤醒与终止343
16.7  非同步事件346
16.8  多层传播347
16.9  静态检查347
16.10  不变式350
第17章  名称空间351
17.1  引言351
17.2  问题352
17.3  解决方案的思想354
17.4  一个解决方案：名称空间355
17.4.1  有关使用名称空间的观点357
17.4.2  使名称空间投入使用358
17.4.3  名称空间的别名359
17.4.4  利用名称空间管理版本问题360
17.4.5  细节361
17.5  对于类的影响366
17.5.1  派生类366
17.5.2  使用基类368
17.5.3  清除全局的static368
17.6  与C语言的兼容性369
第18章  C语言预处理器371
索引375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++语言的设计与演化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>信息论、推理与学习算法
前言
译者序
序言
第1章 信息论导论
第2章 概率、熵与推理
第3章 有关推理的更多内容
第一部分 数据压缩
第4章 信源编码定理
第5章 符号码
第6章 符号流码
第7章 整数的码
第二部分 噪声信道编码
第8章 相关随机变量
第9章 噪声信道上的通信
第10章 噪声信道编码定理
第11章 纠错码与实际信道
第三部分 信息论中的更多专题
第12章 散列码：用于有效信息检索的码
第13章 二进制码
第14章 存在很好的线性码
第15章 有关信息论的更多习题
第16章 消息传递
第17章 受限无噪信道上的通信
第18章 纵横字谜与密码破译
第19章 为何有性?信息获取与进化
第四部分 概率与推理
第20章 一个推理任务示例：聚类
第2l章 基于完全枚举的精确推理
第22章 最大似然与聚类
第23章 有用的概率分布
第24章 精确边缘化
第25章 网格中的精确边缘化
第26章 图中的精确边缘化
第27章 拉普拉斯方法
第28章 模型比较与奥卡姆剃刀原理
第29章 蒙特卡罗方法
第30章 有效的蒙特卡罗方法
第31章 伊辛模型
第32章 精确蒙特卡罗采样
第33章 变参法
第34章 独立元素分析与隐含变量建模
第35章 有关随机推理的专题
第36章 决策论
第37章 贝叶斯推理与抽样理论
第五部分 神经网络
第38章 神经网络引言
第39章 单神经元分类器
第40章 单神经元的容量
第41章 以学习作推理
第42章 HopfieId网络
第43章 玻耳兹曼机
第44章 多层网络的有监督学习
第45章 高斯过程
第46章 反卷积
第六部分 稀疏图码
第47章 低密度奇偶校验码
第48章 卷积码与Turbo码
第49章 重复累加码
第50章 数字喷泉码
第七部分 附录
附录A 记号
附录B 一些物理知识
附录C 一些数学知识
英汉词汇表
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>信息论、推理与学习算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>功利主义
目录
功利主义伦理学体系纲要 /J. J. C. 斯玛特
1. 导言
2. 行为功利主义与规则功利主义
3. 享乐型功利主义与非享乐型功利主义
4. 平均幸福与总体幸福
5. 消极的功利主义
6. 行为的正确与错误
7. 行为功利主义中规则的位置
8. 博弈论技术的简单适用
9. 功利主义与未来
10. 功利主义与正义
对功利主义的批判 /伯纳德·威廉斯
1. 导言
2. 结果主义的结构
3. 消极的责任：以及两个事例
4. 远期效果的两种类型
5. 人格完整性
6. 对功利的间接追求
7. 社会选择
参考文献 /J. J. C. 斯玛特
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>功利主义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Nginx模块开发指南
目录
第0章  导读	1
0.1  关于本书	1
0.2  读者对象	2
0.3  读者要求	3
0.4  运行环境	3
0.5  本书的结构	4
0.6  如何阅读本书	6
0.7  本书的源码	6
第1章  Nginx入门	7
1.1  关于Nginx	7
1.1.1  历史	8
1.1.2  特点	8
1.1.3  进程模型	9
1.1.4  版本	10
1.2  安装Nginx	11
1.2.1  准备工作	11
1.2.2  快速安装	11
1.2.3  运行命令	12
1.2.4  验证安装	13
1.2.5  定制安装	14
1.3  配置Nginx	15
1.3.1  配置文件格式	16
1.3.2  进程配置	17
1.3.3  运行日志配置	18
1.3.4  http配置	18
1.3.5  server配置	19
1.3.6  location配置	20
1.3.7  文件访问配置	21
1.3.8  upstream配置	22
1.3.9  变量	22
1.4  总结	24
第2章  Nginx开发准备	25
2.1  开发环境	25
2.1.1  C++标准	25
2.1.2  Boost程序库	26
2.2  Nginx的目录结构	26
2.3  Nginx源码的特点	27
2.3.1  代码风格	28
2.3.2  代码优化	28
2.3.3  面向对象思想	28
2.4  在Nginx里使用C++	29
2.4.1  实现原则	29
2.4.2  代码风格	29
2.4.3  编译脚本	30
2.5  基本的C++包装类	32
2.5.1  类定义	32
2.5.2  构造和析构	33
2.5.3  成员函数	33
2.6  总结	34
第3章  Nginx基础设施	35
3.1  头文件	35
3.2  整数类型	36
3.2.1  标准整数类型	36
3.2.2  自定义整数类型	36
3.2.3  无效值	37
3.2.4  C++封装	38
3.3  错误处理	41
3.3.1  错误码定义	41
3.3.2  C++异常	41
3.4  内存池	44
3.4.1  结构定义	44
3.4.2  操作函数	45
3.4.3  C++封装	45
3.4.4  清理机制	48
3.4.5  C++内存分配器	50
3.5  字符串	52
3.5.1  结构定义	52
3.5.2  操作函数	53
3.5.3  C++封装	55
3.6  时间与日期	58
3.6.1  时间结构定义	58
3.6.2  时间操作函数	58
3.6.3  日期结构定义	59
3.6.4  日期操作函数	60
3.6.5  C++封装时间	61
3.6.6  C++封装日期	62
3.7  运行日志	64
3.7.1  结构定义	65
3.7.2  操作函数	65
3.7.3  C++封装	66
3.8  总结	68
第4章  Nginx高级数据结构	71
4.1  动态数组	71
4.1.1  结构定义	71
4.1.2  操作函数	73
4.1.3  C++封装	73
4.2  单向链表	76
4.2.1  结构定义	77
4.2.2  操作函数	78
4.2.3  C++迭代器	79
4.2.4  C++封装链表	81
4.3  双端队列	84
4.3.1  结构定义	84
4.3.2  操作函数	85
4.3.3  C++节点	87
4.3.4  C++迭代器	89
4.3.5  C++封装队列	90
4.4  缓冲区	95
4.4.1  结构定义	95
4.4.2  操作函数	97
4.4.3  C++封装	98
4.5  数据块链	100
4.5.1  结构定义	100
4.5.2  操作函数	101
4.5.3  C++节点	101
4.5.4  C++迭代器	103
4.5.5  C++封装数据块链	105
4.6  键值对	107
4.6.1  简单键值对	107
4.6.2  散列表键值对	107
4.7  总结	108
第5章  Nginx开发综述	111
5.1  最简单的Nginx模块	111
5.1.1  模块设计	112
5.1.2  配置解析	112
5.1.3  处理函数	114
5.1.4  模块集成	116
5.1.5  编译脚本和命令	117
5.1.6  测试验证	118
5.2  Nginx开发基本流程	119
5.2.1  设计	119
5.2.2  开发	119
5.2.3  编译	120
5.2.4  测试验证	120
5.2.5  调优	121
5.3  Nginx的模块	121
5.3.1  模块的数据结构	121
5.3.2  模块的种类	123
5.3.3  http模块	124
5.3.4  模块的类图	124
5.3.5  模块的组织形式	125
5.4  Nginx的配置	127
5.4.1  结构定义	128
5.4.2  配置解析的基本流程	131
5.4.3  配置数据的存储模型	133
5.4.4  访问配置数据	138
5.4.5  确定配置数据的位置	138
5.4.6  配置解析函数	140
5.4.7  配置数据的合并	141
5.4.8  配置指令的类型	142
5.5  Nginx模块源码分析	143
5.5.1  ngx_core_module	143
5.5.2  ngx_errlog_module	146
5.6  Nginx的编译脚本	147
5.6.1  运行机制	147
5.6.2  使用的变量	148
5.7  C++封装模块信息	149
5.7.1  NgxModuleConfig	149
5.7.2  NgxModule	153
5.8  C++封装配置解析	155
5.8.1  NgxCommand	155
5.8.2  NgxTake	155
5.8.3  NGX_MODULE_NULL	157
5.9  C++开发Nginx模块	158
5.9.1  C++模块的基本组成	158
5.9.2  配置信息类	159
5.9.3  业务逻辑类	160
5.9.4  模块集成类	162
5.9.5  实现源文件	164
5.9.6  增加更多功能	164
5.10  总结	165
第6章  Nginx HTTP框架综述	169
6.1  HTTP框架简介	169
6.1.1  模块分类	169
6.1.2  处理流程	170
6.1.3  请求结构体	172
6.1.4  请求的处理阶段	173
6.1.5  请求的环境数据	175
6.2  HTTP处理引擎	176
6.2.1  处理函数原型	176
6.2.2  处理函数的存储方式	176
6.2.3  内容处理函数	177
6.2.4  引擎的数据结构	178
6.2.5  引擎的初始化	179
6.2.6  引擎的运行机制	181
6.2.7  日志阶段的处理	182
6.3  HTTP过滤引擎	183
6.3.1  过滤函数原型	183
6.3.2  过滤函数链表	184
6.3.3  过滤函数的顺序	185
6.3.4  过滤链表的运行机制	187
6.3.5  请求体过滤	188
6.4  Nginx模块源码分析	188
6.4.1  ngx_http_static_module	188
6.4.2  ngx_http_not_modified_filter_ module	189
6.5  C++封装	190
6.5.1  NgxModuleCtx	191
6.5.2  NgxHttpCoreModule	193
6.5.3  NgxFilter	195
6.6  总结	197
第7章  Nginx HTTP请求处理	199
7.1  HTTP状态码	199
7.2  请求结构体	200
7.3  请求行	201
7.3.1  请求方法	201
7.3.2  协议版本号	202
7.3.3  资源标识符	202
7.4  请求头	203
7.5  请求体	204
7.5.1  结构定义	205
7.5.2  操作函数	205
7.6  响应头	206
7.6.1  结构定义	206
7.6.2  操作函数	207
7.7  响应体	207
7.8  C++封装	208
7.8.1  NgxHeaders	208
7.8.2  NgxRequestBody	211
7.8.3  NgxRequest	212
7.8.4  NgxResponse	213
7.9  开发HTTP处理模块	216
7.9.1  模块设计	216
7.9.2  配置信息类	217
7.9.3  业务逻辑类	217
7.9.4  模块集成类	219
7.9.5  实现源文件	221
7.9.6  编译脚本	221
7.9.7  测试验证	221
7.10  开发HTTP过滤模块	222
7.10.1  模块设计	222
7.10.2  配置信息类	222
7.10.3  环境数据类	223
7.10.4  业务逻辑类	223
7.10.5  模块集成类	227
7.10.6  实现源文件	228
7.10.7  编译脚本	228
7.10.8  测试验证	228
7.11  总结	229
第8章  Nginx HTTP请求转发	231
8.1  upstream框架简介	231
8.1.1  工作原理	232
8.1.2  请求结构体	233
8.1.3  上游结构体	234
8.1.4  上游配置参数	236
8.2  upstream运行机制	237
8.2.1  回调函数	237
8.2.2  初始化upstream	239
8.2.3  设置upstream	239
8.2.4  启动upstream	241
8.2.5  处理upstream数据	241
8.3  load-balance运行机制	242
8.3.1  结构定义	243
8.3.2  初始化模块入口	247
8.3.3  初始化IP地址列表	248
8.3.4  初始化算法	250
8.3.5  执行算法	251
8.4  Nginx模块源码分析	251
8.4.1  ngx_http_memcached_module	251
8.4.2  ngx_http_upstream_ip_hash_ module	254
8.5  C++封装	257
8.5.1  NgxUpstream	257
8.5.2  NgxUpstreamHelper	259
8.5.3  NgxHttpUpstreamModule	261
8.5.4  NgxLoadBalance	263
8.6  开发upstream模块	264
8.6.1  模块设计	264
8.6.2  配置信息类	264
8.6.3  业务逻辑类	265
8.6.4  模块集成类	268
8.6.5  实现源文件	269
8.6.6  编译脚本	269
8.6.7  测试验证	269
8.7  开发load-balance模块	270
8.7.1  模块设计	271
8.7.2  配置信息类	271
8.7.3  业务逻辑类	271
8.7.4  模块集成类	273
8.7.5  实现源文件	275
8.7.6  编译脚本	275
8.7.7  测试验证	275
8.8  总结	276
第9章  Nginx HTTP子请求	277
9.1  子请求简介	277
9.1.1  工作原理	278
9.1.2  请求结构体	279
9.1.3  回调函数	280
9.1.4  待处理请求链表	282
9.1.5  子请求存储结构	282
9.2  子请求运行机制	283
9.2.1  创建子请求	283
9.2.2  处理引擎	287
9.2.3  数据整理	288
9.3  C++封装	290
9.3.1  NgxSubRequestHandler	290
9.3.2  NgxSubRequest	292
9.4  数据回传模块	293
9.4.1  模块设计	293
9.4.2  环境数据类	293
9.4.3  业务逻辑类	295
9.4.4  模块集成类	297
9.4.5  编译脚本	298
9.5  在模块里使用子请求	299
9.5.1  模块设计	299
9.5.2  配置信息类	299
9.5.3  业务逻辑类	300
9.5.4  测试验证	303
9.6  总结	304
第10章  Nginx变量	305
10.1  结构定义	305
10.1.1  变量值	305
10.1.2  变量访问对象	306
10.1.3  变量的存储	307
10.1.4  请求结构体	307
10.2  运行机制	308
10.2.1  注册变量	308
10.2.2  获取变量	309
10.3  C++封装	310
10.3.1  NgxVariableValue	310
10.3.2  NgxVariable	311
10.3.3  NgxVariables	312
10.3.4  NgxVarManager	313
10.3.5  NgxVariableValueProxy	314
10.4  在模块里使用变量	315
10.4.1  添加变量	316
10.4.2  读写变量	317
10.5  总结	317
第11章  Nginx辅助设施	319
11.1  摘要算法	319
11.1.1  MD5	319
11.1.2  SHA-1	320
11.1.3  MurmurHash	321
11.1.4  C++封装	321
11.2  编码和解码	324
11.2.1  CRC校验	324
11.2.2  Base64编码解码	325
11.2.3  URI编码解码	326
11.2.4  HTML和JSON编码	327
11.3  正则表达式	327
11.4  共享内存	328
11.4.1  结构定义	328
11.4.2  操作函数	329
11.4.3  C++共享内存	329
11.5  定时器	331
11.5.1  结构定义	331
11.5.2  操作函数	332
11.5.3  C++定时器事件	332
11.5.4  C++定时器工厂	333
11.6  总结	335
第12章  Nginx与设计模式	337
12.1  设计模式简介	337
12.2  框架级别的模式	337
12.3  业务级别的模式	339
12.4  代码级别的模式	340
12.5  总结	342
第13章  结束语	343
13.1  本书的遗憾	343
13.2  下一步	344
13.3  临别赠言	345
附录A  推荐书目	347
附录B  GDB调试简介	349
附录C  Nginx的字符串格式化	351
附录D  Nginx里的void*变量	353
附录E  Nginx C++模块简介	355
附录F  Nginx Lua模块简介	357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Nginx模块开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货及其他衍生产品(原书第9版)
推荐序一
推荐序二
译者序
前言
作者简介
译者简介
第1章 引言 1
1.1 交易所市场 ／2
1.2 场外市场 ／3
1.3 远期合约 ／5
1.4 期货合约 ／7
1.5 期权合约 ／7
1.6 交易员的种类 ／9
1.7 对冲者 ／10
1.8 投机者 ／11
1.9 套利者 ／13
1.10 危险 ／14
小结 ／15
推荐阅读 ／15
练习题 ／15
作业题 ／17
第2章 期货市场的运作机制 19
2.1 背景知识 ／19
2.2 期货合约的规格 ／21
2.3 期货价格收敛到即期价格 ／22
2.4 保证金账户的运作 ／23
2.5 场外市场 ／26
2.6 市场报价 ／29
2.7 交割 ／30
2.8 交易员类型和交易指令类型 ／31
2.9 制度 ／32
2.10 会计和税收 ／33
2.11 远期与期货合约的比较 ／34
小结 ／35
推荐阅读 ／36
练习题 ／36
作业题 ／38
第3章 利用期货的对冲策略 39
3.1 基本原理 ／39
3.2 拥护与反对对冲的观点 ／41
3.3 基差风险 ／43
3.4 交叉对冲 ／46
3.5 股指期货 ／49
3.6 向前滚动对冲 ／53
小结 ／54
推荐阅读 ／55
练习题 ／56
作业题 ／57
附录3A 资本资产定价模型 ／58
第4章 利率 60
4.1 利率的种类 ／60
4.2 利率的度量 ／62
4.3 零息利率 ／64
4.4 债券定价 ／64
4.5 确定国库券零息利率 ／65
4.6 远期利率 ／67
4.7 远期利率合约 ／69
4.8 久期 ／71
4.9 曲率 ／74
4.10 利率期限结构理论 ／74
小结 ／76
推荐阅读 ／77
练习题 ／77
作业题 ／78
第5章 如何确定远期和期货价格 80
5.1 投资资产与消费资产 ／80
5.2 卖空交易 ／80
5.3 假设与符号 ／82
5.4 投资资产的远期价格 ／82
5.5 提供已知中间收入的资产 ／85
5.6 收益率为已知的情形 ／86
5.7 对远期合约定价 ／87
5.8 远期和期货价格相等吗 ／89
5.9 股指期货价格 ／89
5.10 货币的远期和期货合约 ／91
5.11 商品期货 ／93
5.12 持有成本 ／95
5.13 交割选择 ／96
5.14 期货价格与预期未来即期价格 ／96
小结 ／98
推荐阅读 ／99
练习题 ／99
作业题 ／100
第6章 利率期货 102
6.1 天数计算和报价惯例 ／102
6.2 美国国债期货 ／104
6.3 欧洲美元期货 ／108
6.4 基于久期的期货对冲策略 ／112
6.5 对于资产与负债组合的对冲 ／114
小结 ／114
推荐阅读 ／115
练习题 ／115
作业题 ／116
第7章 互换 118
7.1 互换合约的机制 ／119
7.2 天数计算惯例 ／123
7.3 确认书 ／123
7.4 相对优势的观点 ／124
7.5 互换利率的本质 ／127
7.6 确定LIBOR／互换零息利率 ／127
7.7 利率互换的定价 ／128
7.8 期限结构的效应 ／131
7.9 固定息与固定息货币互换 ／131
7.10 固定息与固定息货币互换的定价 ／134
7.11 其他货币互换 ／136
7.12 信用风险 ／136
7.13 其他类型的互换 ／138
小结 ／140
推荐阅读 ／140
练习题 ／140
作业题 ／142
第8章 证券化与2007年信用危机 144
8.1 证券化 ／144
8.2 美国住房市场 ／147
8.3 问题出在哪里 ／150
8.4 危机的后果 ／151
小结 ／153
推荐阅读 ／153
练习题 ／153
作业题 ／154
第9章 OIS贴现、信用以及资金费用 1559.1 无风险利率 ／155
9.2 OIS利率 ／157
9.3 当用OIS贴现时互换和远期利率合约的价值 ／159
9.4 OIS还是LIBOR：哪一个正确 ／160
9.5 信用风险：CVA和DVA ／161
9.6 融资费用 ／162
小结 ／163
推荐阅读 ／164
练习题 ／164
作业题 ／165
第10章 期权市场机制 166
10.1 期权类型 ／166
10.2 期权头寸 ／168
10.3 标的资产 ／169
10.4 股票期权的细节 ／169
10.5 交易 ／173
10.6 佣金 ／174
10.7 保证金 ／174
10.8 期权结算公司 ／176
10.9 监管制度 ／176
10.10 税收 ／177
10.11 认股权证、雇员股票期权和可转换债券 ／178
10.12 场外市场 ／178
小结 ／179
推荐阅读 ／179
练习题 ／179
作业题 ／181
第11章 股票期权的性质 182
11.1 影响期权价格的因素 ／182
11.2 假设与记号 ／185
11.3 期权价格的上限与下限 ／185
11.4 看跌—看涨平价关系式 ／188
11.5 无股息股票上看涨期权 ／190
11.6 无股息股票上看跌期权 ／192
11.7 股息对于期权的影响 ／193
小结 ／194
推荐阅读 ／194
练习题 ／195
作业题 ／196
第12章 期权交易策略 197
12.1 保本债券 ／197
12.2 包括单一期权与股票的策略 ／199
12.3 差价 ／200
12.4 组合 ／207
12.5 具有其他收益形式的组合 ／209
小结 ／209
推荐阅读 ／210
练习题 ／210
作业题 ／211
第13章 二叉树 213
13.1 一步二叉树模型与无套利方法 ／213
13.2 风险中性定价 ／216
13.3 两步二叉树 ／218
13.4 看跌期权例子 ／220
13.5 美式期权 ／220
13.6 Delta ／221
13.7 选取u和d使二叉树与波动率吻合 ／221
13.8 二叉树公式 ／223
13.9 增加二叉树的步数 ／224
13.10 使用DerivaGem软件 ／224
13.11 其他标的资产上的期权 ／225
小结 ／227
推荐阅读 ／228
练习题 ／228
作业题 ／229
附录13A 由二叉树模型推导布莱克—斯科尔斯—默顿期权定价公式 ／230
第14章 维纳过程和伊藤引理 234
14.1 马尔科夫性质 ／234
14.2 连续时间随机过程 ／235
14.3 描述股票价格的过程 ／239
14.4 参数 ／241
14.5 相关过程 ／242
14.6 伊藤引理 ／242
14.7 对数正态分布的性质 ／244
小结 ／244
推荐阅读 ／245
练习题 ／245
作业题 ／246
附录14A 伊藤引理的推导 ／247
第15章 布莱克—斯科尔斯—默顿模型 249
15.1 股票价格的对数正态分布性质 ／250
15.2 收益率的分布 ／251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货及其他衍生产品(原书第9版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大衰退年代：宏观经济学的另一半与全球化的宿命
大道至简悟在天成——译者的话
前言
第1章 “宏观经济学的另一半”导论
第2章 造成借款人短缺的资产负债表问题
第3章 阻退借款人的投资机会缺乏问题l
第4章 经济发展三阶段中的宏观经济政策
第5章 发达国家保持发达地位面对的挑战
第6章 直升机上撤钱与量化宽松政策陷阱
第7章 欧洲重犯20世纪30年代的错误
第8章 宏观经济学另一半中的银行问题
第9章 特朗普现象、自由资本流动与自由贸易j中突l
第10章 关于经济学的再思考
参考文献与参考书目
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大衰退年代：宏观经济学的另一半与全球化的宿命
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>痛苦的奥秘
序言
引言
第一章  上帝的全能
第二章  上帝的良善
第三章  人类的邪恶
第四章  人类的堕落
第五章  人类的痛苦
第六章  人类的痛苦（续编）
第七章  地狱
第八章  动物的痛苦
第九章  天堂
附录
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>痛苦的奥秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#图解教程
目　录

第1章　C#和.NET框架　　1
1.1　 在.NET之前　　1
1.1.1　 20世纪90年代末的Windows编程　　1
1.1.2　 下一代平台服务的目标　　2
1.2　 .NET时代　　2
1.2.1　 .NET框架的组成　　2
1.2.2　 大大改进的编程环境　　3
1.3　 编译成CIL　　5
1.4　 编译成本机代码并执行　　6
1.5　 CLR　　7
1.6　 CLI　　8
1.7　 各种缩写　　9
1.8　 C#的演化　　9
第2章　C#编程概述　　10
2.1　 一个简单的C#程序　　10
2.2　 标识符　　12
2.3　 关键字　　12
2.4　 Main：程序的起始点　　13
2.5　 空白　　13
2.6　 语句　　14
2.7　 从程序中输出文本　　15
2.7.1　 Write　　15
2.7.2　 WriteLine　　15
2.7.3　 格式字符串　　16
2.7.4　 多重标记和值　　16
2.7.5　 格式化数字字符串　　17
2.8　 注释：为代码添加注解　　20
2.8.1　 关于注释的补充　　21
2.8.2　 文档注释　　21
2.8.3　 注释类型总结　　22
第3章　类型、存储和变量　　23
3.1　 C#程序是一组类型声明　　23
3.2　 类型是一种模板　　24
3.3　 实例化类型　　24
3.4　 数据成员和函数成员　　25
3.5　 预定义类型　　26
3.6　 用户定义类型　　27
3.7　 栈和堆　　28
3.7.1　 栈　　28
3.7.2　 堆　　29
3.8　 值类型和引用类型　　30
3.8.1　 存储引用类型对象的成员　　31
3.8.2　 C#类型的分类　　31
3.9　 变量　　32
3.9.1　 变量声明　　32
3.9.2　 多变量声明　　34
3.9.3　 使用变量的值　　34
3.10　 静态类型和dynamic关键字　　34
3.11　 可空类型　　35
第4章　类的基本概念　　36
4.1　 类的概述　　36
4.2　 程序和类：一个快速示例　　37
4.3　 声明类　　38
4.4　 类成员　　38
4.4.1　 字段　　38
4.4.2　 方法　　40
4.5　 创建变量和类的实例　　41
4.6　 为数据分配内存　　41
4.7　 实例成员　　42
4.8　 访问修饰符　　43
4.9　 从类的内部访问成员　　45
4.10　 从类的外部访问成员　　46
4.11　 综合应用　　47
第5章　方法　　49
5.1　 方法的结构　　49
5.2　 方法体内部的代码执行　　50
5.3　 本地变量　　51
5.3.1　 类型推断和var关键字　　52
5.3.2　 嵌套块中的本地变量　　52
5.4　 本地常量　　53
5.5　 控制流　　54
5.6　 方法调用　　55
5.7　 返回值　　56
5.8　 返回语句和void方法　　57
5.9　 参数　　59
5.9.1　 形参　　59
5.9.2　 实参　　59
5.10　 值参数　　61
5.11　 引用参数　　63
5.12　 引用类型作为值参数和引用参数　　65
5.13　 输出参数　　68
5.14　 参数数组　　70
5.14.1　 方法调用　　71
5.14.2　 用数组作为实参　　73
5.15　 参数类型总结　　74
5.16　 方法重载　　74
5.17　 命名参数　　75
5.18　 可选参数　　76
5.19　 栈帧　　79
5.20　 递归　　81
第6章　深入理解类　　83
6.1　 类成员　　83
6.2　 成员修饰符的顺序　　84
6.3　 实例类成员　　85
6.4　 静态字段　　86
6.5　 从类的外部访问静态成员　　86
6.5.1　 静态字段示例　　87
6.5.2　 静态成员的生存期　　87
6.6　 静态函数成员　　88
6.7　 其他静态类成员类型　　89
6.8　 成员常量　　90
6.9　 常量与静态量　　90
6.10　 属性　　91
6.10.1　 属性声明和访问器　　92
6.10.2　 属性示例　　93
6.10.3　 使用属性　　94
6.10.4　 属性和关联字段　　94
6.10.5　 执行其他计算　　96
6.10.6　 只读和只写属性　　96
6.10.7　 属性与公共字段　　97
6.10.8　 计算只读属性示例　　97
6.10.9　 自动实现属性　　98
6.10.10　 静态属性　　99
6.11　 实例构造函数　　100
6.11.1　 带参数的构造函数　　101
6.11.2　 默认构造函数　　102
6.12　 静态构造函数　　102
6.13　 对象初始化语句　　104
6.14　 析构函数　　105
6.15　 readonly修饰符　　105
6.16　 this关键字　　106
6.17　 索引器　　107
6.17.1　 什么是索引器　　108
6.17.2　 索引器和属性　　108
6.17.3　 声明索引器　　109
6.17.4　 索引器的set访问器　　110
6.17.5　 索引器的get访问器　　110
6.17.6　 关于索引器的补充　　111
6.17.7　 为Employee示例声明索引器　　111
6.17.8　 另一个索引器的示例　　112
6.17.9　 索引器重载　　113
6.18　 访问器的访问修饰符　　114
6.19　 分部类和分部类型　　115
6.20　 分部方法　　116
第7章　类和继承　　118
7.1　 类继承　　118
7.2　 访问继承的成员　　119
7.3　 所有类都派生自object类　　120
7.4　 屏蔽基类的成员　　121
7.5　 基类访问　　123
7.6　 使用基类的引用　　124
7.6.1　 虚方法和覆写方法　　125
7.6.2　 覆写标记为override的
方法　　127
7.6.3　 覆盖其他成员类型　　130
7.7　 构造函数的执行　　130
7.7.1　 构造函数初始化语句　　132
7.7.2　 类访问修饰符　　134
7.8　 程序集间的继承　　134
7.9　 成员访问修饰符　　136
7.9.1　 访问成员的区域　　137
7.9.2　 公有成员的可访问性　　138
7.9.3　 私有成员的可访问性　　138
7.9.4　 受保护成员的可访问性　　138
7.9.5　 内部成员的可访问性　　139
7.9.6　 受保护内部成员的可访问性　　139
7.9.7　 成员访问修饰符小结　　140
7.10　 抽象成员　　141
7.11　 抽象类　　142
7.11.1　 抽象类和抽象方法的示例　　142
7.11.2　 抽象类的另一个例子　　143
7.12　 密封类　　144
7.13　 静态类　　144
7.14　 扩展方法　　145
7.15　 命名约定　　148
第8章　表达式和运算符　　150
8.1　 表达式　　150
8.2　 字面量　　151
8.2.1　 整数字面量　　152
8.2.2　 实数字面量　　153
8.2.3　 字符字面量　　153
8.2.4　 字符串字面量　　154
8.3　 求值顺序　　156
8.3.1　 优先级　　156
8.3.2　 结合性　　157
8.4　 简单算术运算符　　157
8.5　 求余运算符　　158
8.6　 关系比较运算符和相等比较运算符　　159
8.7　 递增运算符和递减运算符　　160
8.8　 条件逻辑运算符　　162
8.9　 逻辑运算符　　163
8.10　 移位运算符　　164
8.11　 赋值运算符　　165
8.12　 条件运算符　　167
8.13　 一元算术运算符　　168
8.14　 用户定义的类型转换　　169
8.15　 运算符重载　　172
8.15.1　 运算符重载的限制　　172
8.15.2　 运算符重载的示例　　173
8.16　 typeof运算符　　174
8.17　 其他运算符　　176
第9章　语句　　177
9.1　 什么是语句　　177
9.2　 表达式语句　　178
9.3　 控制流语句　　179
9.4　 if语句　　179
9.5　 if...else语句　　180
9.6　 while循环　　181
9.7　 do循环　　182
9.8　 for循环　　183
9.8.1　 for语句中变量的作用域　　185
9.8.2　 初始化和迭代表达式中的多表达式　　185
9.9　 switch语句　　186
9.9.1　 分支示例　　187
9.9.2　 switch语句的补充　　188
9.9.3　 分支标签　　189
9.10　 跳转语句　　189
9.11　 break语句　　190
9.12　 continue语句　　190
9.13　 标签语句　　191
9.13.1　 标签　　191
9.13.2　 标签语句的作用域　　192
9.14　 goto语句　　192
9.15　 using语句　　193
9.15.1　 资源的包装使用　　194
9.15.2　 using语句的示例　　195
9.15.3　 多个资源和嵌套　　196
9.15.4　 using语句的另一种形式　　197
9.16　 其他语句　　197
第10章　结构　　198
10.1　 什么是结构　　198
10.2　 结构是值类型　　199
10.3　 对结构赋值　　200
10.4　 构造函数和析构函数　　201
10.4.1　 实例构造函数　　201
10.4.2　 静态构造函数　　202
10.4.3　 构造函数和析构函数小结　　203
10.5　 字段初始化语句是不允许的　　203
10.6　 结构是密封的　　203
10.7　 装箱和拆箱　　203
10.8　 结构作为返回值和参数　　204
10.9　 关于结构的其他信息　　204
第11章　枚举　　205
11.1　 枚举　　205
11.1.1　 设置底层类型和显式值　　206
11.1.2　 隐式成员编号　　207
11.2　 位标志　　208
11.2.1　 Flags特性　　210
11.2.2　 使用位标志的示例　　212
11.3　 关于枚举的补充　　213
第12章　数组　　216
12.1　 数组　　216
12.1.1　 定义　　216
12.1.2　 重要细节　　217
12.2　 数组的类型　　217
12.3　 数组是对象　　218
12.4　 一维数组和矩形数组　　219
12.5　 实例化一维数组或矩形数组　　220
12.6　 访问数组元素　　220
12.7　 初始化数组　　221
12.7.1　 显式初始化一维数组　　222
12.7.2　 显式初始化矩形数组　　222
12.7.3　 初始化矩形数组的语法点　　223
12.7.4　 快捷语法　　223
12.7.5　 隐式类型数组　　223
12.7.6　 综合内容　　224
12.8　 交错数组　　224
12.8.1　 声明交错数组　　225
12.8.2　 快捷实例化　　225
12.8.3　 实例化交错数组　　226
12.8.4　 交错数组中的子数组　　227
12.9　 比较矩形数组和交错数组　　228
12.10　 foreach语句　　229
12.10.1　 迭代变量是只读的　　230
12.10.2　 foreach语句和多维数组　　231
12.11　 数组协变　　232
12.12　 数组继承的有用成员　　233
12.13　 比较数组类型　　236
第13章　委托　　237
13.1　 什么是委托　　237
13.2　 委托概述　　239
13.3　 声明委托类型　　240
13.4　 创建委托对象　　241
13.5　 给委托赋值　　242
13.6　 组合委托　　243
13.7　 为委托添加方法　　243
13.8　 从委托移除方法　　244
13.9　 调用委托　　244
13.10　 委托的示例　　245
13.11　 调用带返回值的委托　　246
13.12　 调用带引用参数的委托　　247
13.13　 匿名方法　　248
13.13.1　 使用匿名方法　　249
13.13.2　 匿名方法的语法　　249
13.13.3　 变量和参数的作用域　　250
13.14　 Lambda表达式　　252
第14章　事件　　255
14.1　 发布者和订阅者　　255
14.2　 源代码组件概览　　257
14.3　 声明事件　　257
14.4　 订阅事件　　258
14.5　 触发事件　　259
14.6　 标准事件的用法　　261
14.6.1　 通过扩展EventArgs来传递数据　　262
14.6.2　 移除事件处理程序　　264
14.7　 事件访问器　　265
第15章　接口　　267
15.1　 什么是接口　　267
15.2　 声明接口　　272
15.3　 实现接口　　273
15.4　 接口是引用类型　　275
15.5　 接口和as运算符　　276
15.6　 实现多个接口　　276
15.7　 实现具有重复成员的接口　　277
15.8　 多个接口的引用　　279
15.9　 派生成员作为实现　　280
15.10　 显式接口成员实现　　281
15.11　 接口可以继承接口　　283
15.12　 不同类实现一个接口的示例　　284
第16章　转换　　286
16.1　 什么是转换　　286
16.2　 隐式转换　　287
16.3　 显式转换和强制转换　　288
16.4　 转换的类型　　289
16.5　 数字的转换　　290
16.5.1　 隐式数字转换　　290
16.5.2　 溢出检测上下文　　291
16.5.3　 显式数字转换　　292
16.6　 引用转换　　295
16.6.1　 隐式引用转换　　296
16.6.2　 显式引用转换　　297
16.6.3　 有效显式引用转换　　298
16.7　 装箱转换　　299
16.7.1　 装箱是创建副本　　300
16.7.2　 装箱转换　　300
16.8　 拆箱转换　　301
16.9　 用户自定义转换　　302
16.9.1　 用户自定义转换的约束　　302
16.9.2　 用户自定义转换的示例　　302
16.9.3　 评估用户自定义转换　　304
16.9.4　 多步用户自定义转换的示例　　304
16.10　 is运算符　　305
16.11　 as运算符　　306
第17章　泛型　　308
17.1　 什么是泛型　　308
17.2　 C#中的泛型　　310
17.3　 泛型类　　311
17.4　 声明泛型类　　312
17.5　 创建构造类型　　312
17.6　 创建变量和实例　　313
17.6.1　 使用泛型的栈的示例　　315
17.6.2　 比较泛型和非泛型栈　　316
17.7　 类型参数的约束　　317
17.7.1　 Where子句　　317
17.7.2　 约束类型和次序　　318
17.8　 泛型方法　　319
17.8.1　 声明泛型方法　　319
17.8.2　 调用泛型方法　　320
17.8.3　 泛型方法的示例　　321
17.9　 扩展方法和泛型类　　322
17.10　 泛型结构　　323
17.11　 泛型委托　　323
17.12　 泛型接口　　325
17.12.1　 使用泛型接口的示例　　326
17.12.2　 泛型接口的实现必须唯一　　327
17.13　 协变　　328
17.14　 逆变　　330
17.14.1　 接口的协变和逆变　　332
17.14.2　 有关可变性的更多内容　　333
第18章　枚举器和迭代器　　335
18.1　 枚举器和可枚举类型　　335
18.2　 IEnumerator接口　　337
18.3　 泛型枚举接口　　341
18.4　 迭代器　　343
18.4.1　 迭代器块　　343
18.4.2　 使用迭代器来创建枚举器　　344
18.4.3　 使用迭代器来创建可枚举类型　　346
18.5　 常见迭代器模式　　347
18.6　 产生多个可枚举类型　　348
18.7　 将迭代器作为属性　　349
18.8　 迭代器实质　　350
第19章　LINQ　　352
19.1　 什么是LINQ　　352
19.2　 LINQ提供程序　　353
19.3　 方法语法和查询语法　　355
19.4　 查询变量　　356
19.5　 查询表达式的结构　　357
19.5.1　 from子句　　358
19.5.2　 join子句　　359
19.5.3　 什么是联结　　360
19.5.4　 查询主体中的from...let...where片段　　362
19.5.5　 orderby子句　　365
19.5.6　 select...group子句　　366
19.5.7　 查询中的匿名类型　　367
19.5.8　 group子句　　368
19.5.9　 查询延续：into子句　　369
19.6　 标准查询运算符　　370
19.6.1　 标准查询运算符的签名　　373
19.6.2　 查询表达式和标准查询运算符　　374
19.6.3　 将委托作为参数　　375
19.6.4　 LINQ预定义的委托类型　　376
19.6.5　 使用委托参数的示例　　377
19.6.6　 使用Lambda表达式参数的示例　　378
19.7　 LINQ to XML　　379
19.7.1　 标记语言　　379
19.7.2　 XML基础　　379
19.7.3　 XML类　　381
19.7.4　 使用XML特性　　387
19.7.5　 节点的其他类型　　389
19.7.6　 使用LINQ to XML的LINQ查询　　390
第20章　异步编程　　393
20.1　 什么是异步　　393
20.2　 async/await特性的结构　　398
20.3　 什么是异步方法　　399
20.3.1　 异步方法的控制流　　402
20.3.2　 await表达式　　404
20.3.3　 取消一个异步操作　　407
20.3.4　 异常处理和await表达式　　409
20.3.5　 在调用方法中同步地等待任务　　410
20.3.6　 在异步方法中异步地等待任务　　413
20.3.7　 Task.Delay方法　　415
20.4　 在GUI程序中执行异步操作　　416
20.5　 使用异步Lambda表达式　　420
20.6　 完整的GUI程序　　421
20.7　 BackgroundWorker类　　423
20.8　 并行循环　　428
20.9　 其他异步编程模式　　430
20.10　 BeginInvoke和EndInvoke　　431
20.10.1　 等待—直到结束模式　　432
20.10.2　 AsyncResult类　　433
20.10.3　 轮询模式　　434
20.10.4　 回调模式　　435
20.11　 计时器　　438
第21章　命名空间和程序集　　440
21.1　 引用其他程序集　　440
21.2　 命名空间　　444
21.2.1　 命名空间名称　　447
21.2.2　 命名空间的补充　　447
21.2.3　 命名空间跨文件伸展　　448
21.2.4　 嵌套命名空间　　449
21.3　 using指令　　450
21.3.1　 using命名空间指令　　450
21.3.2　 using别名指令　　451
21.4　 程序集的结构　　451
21.5　 程序集标识符　　453
21.6　 强命名程序集　　453
21.7　 程序集的私有方式部署　　455
21.8　 共享程序集和GAC　　455
21.8.1　 把程序集安装到GAC　　455
21.8.2　 GAC内的并肩执行　　456
21.9　 配置文件　　457
21.10　 延迟签名　　457
第22章　异常　　459
22.1　 什么是异常　　459
22.2　 try语句　　460
22.3　 异常类　　461
22.4　 catch子句　　462
22.5　 使用特定catch子句的示例　　462
22.6　 catch子句段　　463
22.7　 finally块　　464
22.8　 为异常寻找处理程序　　465
22.9　 更进一步搜索　　466
22.9.1　 一般法则　　466
22.9.2　 搜索调用栈的示例　　467
22.10　 抛出异常　　469
22.11　 不带异常对象的抛出　　470
第23章　预处理指令　　472
23.1　 什么是预处理指令　　472
23.2　 基本规则　　472
23.3　 #define和#undef指令　　473
23.4　 条件编译　　474
23.5　 条件编译结构　　475
23.6　 诊断指令　　476
23.7　 行号指令　　477
23.8　 区域指令　　478
23.9　 #pragma warning指令　　479
第24章　反射和特性　　480
24.1　 元数据和反射　　480
24.2　 Type类　　480
24.3　 获取Type对象　　482
24.4　 什么是特性　　484
24.5　 应用特性　　485
24.6　 预定义的保留的特性　　485
24.6.1　 Obsolete特性　　485
24.6.2　 Conditional特性　　486
24.6.3　 调用者信息特性　　488
24.6.4　 DebuggerStepThrough特性　　488
24.6.5　 其他预定义特性　　489
24.7　 有关应用特性的更多内容　　490
24.7.1　 多个特性　　490
24.7.2　 其他类型的目标　　490
24.7.3　 全局特性　　491
24.8　 自定义特性　　491
24.8.1　 声明自定义特性　　492
24.8.2　 使用特性的构造函数　　492
24.8.3　 指定构造函数　　492
24.8.4　 使用构造函数　　493
24.8.5　 构造函数中的位置参数和命名参数　　493
24.8.6　 限制特性的使用　　494
24.8.7　 自定义特性的最佳实践　　495
24.9　 访问特性　　496
24.9.1　 使用IsDefined方法　　496
24.9.2　 使用GetCustomAttributes方法　　497
第25章　其他主题　　499
25.1　 概述　　499
25.2　 字符串　　499
25.3　 使用StringBuilder类　　501
25.4　 把字符串解析为数据值　　502
25.5　 关于可空类型的更多内容　　503
25.5.1　 为可空类型赋值　　505
25.5.2　 使用空接合运算符　　505
25.5.3　 使用可空用户自定义类型　　506
25.6　 Main方法　　508
25.7　 文档注释　　509
25.7.1　 插入文档注释　　510
25.7.2　 使用其他XML标签　　510
25.8　 嵌套类型　　511
25.8.1　 嵌套类的示例　　512
25.8.2　 可见性和嵌套类型　　513
25.9　 析构函数和dispose模式　　514
25.9.1　 标准dispose模式　　515
25.9.2　 比较构造函数和析构函数　　517
25.10　 和COM的互操作　　518
索引　　521

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#图解教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C陷阱与缺陷
第零章 导读
第一章 词法“陷阱”
第二章 语法“陷阱”
第三章 语义“陷阱”
第四章 连接
第五章 库函数
第六章 预处理器
第七章 可移植性缺陷
第八章 建议与答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C陷阱与缺陷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和指针
第1章 快速上手第2章 基本概念

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和指针
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>100倍超级强势股
本书的25大看点
前  言 IT泡沫破裂后个人投资第一人
自 序  “交易牛仔”的“面包加黄油”式投资
第1章	惊心动魄：从账户巨幅缩水到戏剧性翻盘
“熟悉的股票”让我只赔不赚
在一场怪病中“偶遇”超级股
哈！又一只大牛股……
让股票涨一会儿
黑色2008
“迷你退休”是为了东山再起
正规教育可谋生，自我教育可发财
第2章 最危险的安全感：“大家一起死”的群体思维
做个“促使事情发生的投资者”
直面可预测的风险
99%VS1%
做对事VS发大财？
“大家一起死”听上去很安全？
第3章	逆向投资：媒体向左，财富向右
媒体杂音导致交易量上升
媒体关注惨淡的过去，财富青睐光明的未来
通过新闻头条揣测大众情绪，然后逆向操作！
第4章 操纵市场：华尔街最糟糕的秘密
媒体操纵
市场操纵之王：高盛集团
第5章 投资天才：1%的选股灵感+ 99%的心理控制
与优秀的交易者同行
打好股市心理战
学会构想股票的走势
坚信你的股票会大涨
自律精神
坦然接受亏损
保持耐心，伺机出动
保持“心流”状态
健康的身体和均衡的饮食
工作环境很重要
第6章 化繁为简：让交易系统和你的指纹一样独一无二
“优势交易系统”无优势
将100%的精力投入到20%的重要变量上
股票走势图就是大众“心电图”
放弃“喜爱”的公司，选择赚钱的股票
第7章 火箭速度：飞涨的“超级强势股”
选择超级强势股5条重要指标
其他3个必要选股指标
分析基本面的12大最重要法则
其他12条次重要基本面分析法则
小心潜在的二次发售
以空头视角看问题
第8章 降低下跌概率：等待遍地黄金的机会，然后捡起
目标价位和回报风险比
低风险的机会窗口
等待合适时机再买入
只关注价格，绝不要“爱上”某只股票
像马克·库班那样精准把握时机
第9章 超级买入法则：掌握安全买点的艺术
安全买入点的6大超级法则
其他低风险潜在买入点
其他4条低风险移动平均线
如何确定头寸规模
让盈利股自由奔跑
在股市春天来临前，不要冒险
不要关注整体市场和每日账户波动
第10章 超级卖出法则：掌握高风险卖点的艺术
存在技术性风险时，卖出股票的16大超级法则
存在基本面风险时，卖出股票的5大超级法则
次级卖出信号
第11章 懒人指南：一分钟伏击超级强势股
超级强势股的构成要素
买入时机：高回报低风险的买点
卖出时机
第12章  实况回放：改变我人生的11套走势图
Dynamic Materials公司（BOOM）
Viropharma（VPHM）
Forward Industries ( FORD）
DXP Enterprises(DXPE)
Air Methods Corporation(AIRM)
Empire Resources(ERS)
Aldila Corporation(ALDA)
Freightcar America(RAIL)
Local Corporation(LOCM)
苹果电脑公司（AAPL）
鼓励奖获得者：TRM Corporation (TRMM)
第13章 他山之石：与超级强势股有关的资源
《笑傲股市》
《交易心理分析》
第14章  历史不再重演：倾囊相授我的失败教训
不要相信“热门股”，不要投资不了解的股票
放下“酷爱牌饮料”心态
永远别碰日内交易！
不要做“金字塔交易”（追涨）或过度使用杠杆
避免不计代价的“功能蔓延”
不要做指数交易
不要跟随不成功的交易员做交易
不要交易难以变现的股票，不要坚定持有
不要让预期的市场走向影响个人的交易决策
坚定持有你的大牛股
最重要的是学习如何卖出！
请遵守以下禁忌！
要正确地看待一切事物
第15章  投资成功：必须学会在16个方面与众不同
持续研究卖出的艺术
关注周线图和月线图
周线图处于横盘期时是最佳买点
买入沿“神奇支撑线”展开的股票
仅关注小盘股
趁热打铁
共同基金经理的投资风格不可取
用“孤岛思维”指导投资
做一名“波段交易者”
购买股价在3～15美元的股票
购买个股，不要购买主流 ETF 基金或共同基金
不要投资你熟悉的公司
一切尽在图表中
成为情绪的主人
选择在股价上涨期间获利了结
不要让媒体左右你的生活
后记  市场的马拉松没有终点
致谢
附录I   如何识别全球股市拐点及神秘的“煤矿中的金丝雀”指标
附录II 如何识别主要商品价格的高点和低点
附录III 我的2010～2013年度全球股市预测
附录IV 有的东西，终究永远不会改变
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>100倍超级强势股
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
第一章 C语言概述
第二章 数据类型、运算符与表达式
第三章 最简单的C程序设计――顺序程序设计
第四章 选择结构程序设计
第五章 循环控制
第六章 数组
第七章 函数
第八章 预处理命令
第九章 指针
第十章 结构体与共用体
第十一章 位运算
第十二章 文件
第十三章 常见错误和程序调试
附录I 常用字符与ASCII代码对照表
……
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++沉思录
第0章 序幕
第一篇 动机
第1章 为什么我用C++
第2章 为什么用C++工作
第3章 生活在现实世界中
第二篇 类和继承
第4章 类设计者的核查表
第5章 代理类
第6章 句柄：第一部分
第7章 句柄：第二部分
第8章 一个面向对象程序范例
第9章 一个课堂练习的分析（上）
第10章 一个课堂练习的分析（下）
第11章 什么时候不应当使用虚函数
第三篇 模板
第12章 设计容器类
第13章 访问容器中的元素
第14章 迭代器
第15章 序列
第16章 作为接口的模板
第17章 模板和泛型算法
第18章 泛型迭代器
第19章 使用泛型迭代器
第20章 迭代器配接器
第21章 函数对象
第22章 函数配接器
第四篇 库
第23章 日常使用的库
第24章 一个库接口设计实例
第25章 库设计就是语言设计
第26章 语言设计就是库设计
第五篇 技术
第27章 自己跟踪自己的类
第28章 在簇中分配对象
第29章 应用器、操纵器和函数对
第30章 将应用程序库从输入输出中分离出来
第六篇 总结
第31章 通过复杂性获取简单性
第32章 说了HELLO WORLD后再做什么
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++沉思录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计进阶教程
出版者的话
译者序
序
前言
第一部分　计算机存储：内存和文件
第1章　程序的执行 2
1.1　编译 2
1.2　重定向输出 6
第2章　栈内存 7
2.1　值和地址 7
2.2　栈 8
2.3　调用栈 9
2.3.1　返回位置 9
2.3.2　函数实参 12
2.3.3　局部变量 14
2.3.4　值地址 15
2.3.5　数组 16
2.3.6　获取地址 17
2.4　可见度 17
2.5　习题 20
2.5.1　绘制调用栈I 20
2.5.2　绘制调用栈II 20
2.5.3　地址 21
2.6　习题解答 21
2.6.1　绘制调用栈I 21
2.6.2　绘制调用栈II 22
2.6.3　地址 22
2.7　在DDD（命令行调试程序）上检测调用栈 22
第3章　预防、检测及消除bug 26
3.1　开发软件≠编码 26
3.1.1　编程前 26
3.1.2　编程中 27
3.1.3　编程后 28
3.2　常见错误 28
3.2.1　未初始化变量 28
3.2.2　错误数组下标 28
3.2.3　错误数据类型 28
3.3　后执行式和交互式调试 28
3.4　生产代码与测试代码分离 29
第4章　指针 30
4.1　作用域 30
4.2　swap函数 31
4.3　指针 33
4.4　再论swap函数 37
4.5　类型错误 39
4.6　数组和指针 40
4.7　类型规则 43
4.8　指针运算 44
4.9　习题 47
4.9.1　swap函数1 47
4.9.2　swap函数2 48
4.9.3　swap函数3 48
4.9.4　swap函数4 48
4.9.5　swap函数5 49
4.9.6　15 552种变化 49
4.10　习题解答 50
4.10.1　swap函数1 50
4.10.2　swap函数2 50
4.10.3　swap函数3 51
4.10.4　swap函数4 51
4.10.5　swap函数5 51
第5章　编写和测试程序 52
5.1　不同的数组元素 52
5.1.1　main函数 52
5.1.2　areDistinct函数 53
5.1.3　编译和链接 54
5.1.4　make工具 55
5.2　使用Makefile测试 57
5.2.1　生成测试用例 58
5.2.2　重定向输出 58
5.2.3　使用diff去比较输出 58
5.2.4　添加测试到Makefile 59
5.3　无效的内存访问 60
5.4　使用valgrind检查内存访问错误 62
5.5　测试覆盖 64
5.6　限制内核大小 67
5.7　带有死循环的程序 67
第6章　字符串 69
6.1　字符数组 69
6.2　C语言中的字符串函数 72
6.2.1　复制函数：strcpy 72
6.2.2　比较函数：strcmp 73
6.2.3　寻找子字符串函数：strstr 73
6.2.4　寻找字符函数：strchr 74
6.3　理解argv 74
6.4　对子字符串计数 77
第7章　编程问题和调试 80
7.1　实现字符串函数 80
7.1.1　C语言库 80
7.1.2　头文件 80
7.1.3　mystring.h 82
7.1.4　创建输入和正确输出 82
7.1.5　Makefile 86
7.1.6　mystring.c 86
7.1.7　使用const 88
7.2　调试 89
7.2.1　找到死循环 90
7.2.2　找到无效内存访问 91
7.2.3　检测无效内存访问 92
第8章　堆内存 94
8.1　用malloc函数创建数组 94
8.2　栈和堆 96
8.3　返回堆地址的函数 98
8.4　C语言中的二维数组 99
8.5　指针和参数 101
第9章　使用堆内存的编程问题 104
9.1　对数组排序 104
9.1.1　生成测试输入和期望输出 104
9.1.2　重定向输入 105
9.1.3　整数排序 107
9.1.4　使用valgrind检测内存泄漏 110
9.2　使用qsort进行排序 111
9.2.1　qsort 111
9.2.2　比较函数 112
9.2.3　执行范例 114
9.2.4　对字符串排序 115
第10章　读写文件 118
10.1　通过argv传递一个文件名 118
10.2　读取文件 119
10.2.1　读取字符型：fgetc 119
10.2.2　读取整型：fscanf(...%d...) 121
10.3　写入文件 123
10.4　读写字符串 125
第11章　编程解决使用文件的问题 128
11.1　对文件中的整数进行排序 128
11.2　计算字符出现的次数 130
11.3　计算单词出现的次数 132
11.4　如何注释程序 134
第二部分　递归
第12章　递归 138
12.1　在限制条件下选取小球 138
12.1.1　双色球问题 138
12.1.2　三色球问题 139
12.1.3　附加限制条件 140
12.2　单行道 142
12.3　汉诺塔 143
12.4　计算整数分拆 145
12.4.1　计算“1”的个数 147
12.4.2　仅使用奇数进行分拆 148
12.4.3　使用递增数进行分拆 148
12.4.4　交替使用奇偶数进行分拆 149
12.4.5　整数分拆问题的推广 151
12.4.6　解决分拆问题的错误方法 151
第13章　递归函数 152
13.1　在限制条件下选取小球 152
13.2　单行道 155
13.3　汉诺塔 156
13.4　整数分拆 158
13.5　阶乘 159
13.6　斐波那契数列 161
13.7　利用gprof进行性能分析 165
第14章　整数分拆 167
14.1　堆内存和栈内存 168
14.2　追踪递归函数调用 176
14.3　约束条件下的分拆 178
14.3.1　仅使用奇数进行分拆 179
14.3.2　使用递增数进行分拆 179
14.3.3　交替使用奇偶数进行分拆 180
14.3.4　使用gprof和gcov查找性能瓶颈 180
第15章　使用递归解决问题 187
15.1　二分搜索 187
15.2　快速排序 189
15.3　排列组合 195
15.4　栈排序 198
15.4.1　例子1 199
15.4.2　例子2 199
15.4.3　例子3 199
15.4.4　例子4 199
15.4.5　可排序栈 200
15.5　追踪递归函数 203
15.6　一个存在错误的递归函数 205
第三部分　结构
第16章　程序员可定义数据类型 208
16.1　结构体和对象 208
16.2　作为实参传递对象 212
16.3　对象和指针 214
16.3.1　返回一个对象 216
16.3.2　对象和malloc 216
16.4　构造函数和析构函数 218
16.5　结构中的结构 224
16.6　二进制文件和对象 226
第17章　使用结构的编程问题 230
17.1　个人信息库排序 230
17.2　压缩十进制数位 235
17.2.1　数制 235
17.2.2　用1字节表达2个十进制数位 236
17.2.3　位运算 236
17.2.4　压缩和恢复十进制 239
17.2.5　十进制压缩编程 239
17.3　二进制文件和指针 243
第18章　链表 245
18.1　可扩展类型 245
18.2　链表 246
18.3　链表的插入 246
18.4　链表的查找 248
18.5　从链表中删除 249
18.6　打印链表 252
18.7　链表的销毁 253
第19章　使用链表的编程问题 256
19.1　队列 256
19.2　数字排序 256
19.3　稀疏数组 257
19.4　单链表反转 262
第20章　二叉搜索树 264
20.1　二叉搜索树 265
20.2　二叉搜索树的插入 266
20.3　二叉搜索树的搜索 269
20.4　二叉搜索树的遍历 269
20.5　二叉搜索树的删除 272
20.6　二叉搜索树的销毁 274
20.7　主函数main 274
20.8　链接器Makefike 275
20.9　不同的二叉树结构 275
第21章　线程并行编程 278
21.1　并行编程 278
21.2　多任务处理 278
21.3　POSIX线程 279
21.4　子集和 280
21.4.1　生成测试实例 281
21.4.2　字典顺序处理 283
21.4.3　多线程处理 287
21.5　多线程处理过程的交叉运行 289
21.6　线程同步 293
21.7　阿姆达尔定律 295
第四部分　应用
第22章　寻找迷宫出口 298
22.1　迷宫的文件格式 298
22.2　读取迷宫文件 299
22.3　迷宫结构体 303
22.4　逃跑策略 306
22.5　策略的实现 308
22.5.1　canMove函数 308
22.5.2　getOut函数 309
22.5.3　打印访问过的位置 313
第23章　图像处理 316
23.1　图像结构体 316
23.2　图像处理 321
23.2.1　图像像素和颜色 321
23.2.2　处理函数 322
23.2.3　应用一个颜色滤波器 322
23.2.4　图像颜色反转 324
23.2.5　边缘检测 324
23.2.6　颜色均衡 326
第24章　霍夫曼压缩 329
24.1　例程 329
24.2　编码 330
24.2.1　计算频率 330
24.2.2　按频率排序 332
24.2.3　构建编码树 334
24.2.4　创建编码本 342
24.2.5　压缩文件 346
24.2.6　位压缩 349
24.3　解码 353
附录A　Linux 370
附录B　版本控制 373
附录C　集成开发环境 376
索引 385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计进阶教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人之废
中译导言：道与意识形态
译文说明
无胸之人
道
人之废
附录：道之例证
译附：C.S.路易斯：《主观论之毒害》
答谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人之废
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++并发编程实战
目录
第1章 你好，C++并发世界 1
1.1 什么是并发 2
1.1.1 计算机系统中的并发 2
1.1.2 并发的途径 3
1.2 为什么使用并发 5
1.2.1 为了划分关注点而使用并发 5
1.2.2 为了性能而使用并发 6
1.2.3 什么时候不使用并发 7
1.3 在C++中使用并发和多线程 8
1.3.1 C++多线程历程 8
1.3.2 新标准中的并发支持 9
1.3.3 C++线程库的效率 9
1.3.4 平台相关的工具 10
1.4 开始入门 11
1.5 小结 12
第2章 管理线程 13
2.1 基本线程管理 13
2.1.1 启动线程 14
2.1.2 等待线程完成 16
2.1.3 在异常环境下的等待 17
2.1.4 在后台运行线程 19
2.2 传递参数给线程函数 20
2.3 转移线程的所有权 23
2.4 在运行时选择线程数量 26
2.5 标识线程 28
2.6 小结 29
第3章 在线程间共享数据 31
3.1 线程之间共享数据的问题 32
3.1.1 竞争条件 33
3.1.2 避免有问题的竞争条件 34
3.2 用互斥元保护共享数据 35
3.2.1 使用C++中的互斥元 35
3.2.2 为保护共享数据精心组织代码 36
3.2.3 发现接口中固有的竞争条件 38
3.2.4 死锁：问题和解决方案 44
3.2.5 避免死锁的进一步指南 46
3.2.6 用std::unique_lock灵活锁定 51
3.2.7 在作用域之间转移锁的所有权 52
3.2.8 锁定在恰当的粒度 54
3.3 用于共享数据保护的替代工具 56
3.3.1 在初始化时保护共享数据 56
3.3.2 保护很少更新的数据结构 59
3.3.3 递归锁 61
3.4 小结 62
第4章 同步并发操作 63
4.1 等待事件或其他条件 63
4.1.1 用条件变量等待条件 65
4.1.2 使用条件变量建立一个线程安全队列 67
4.2 使用future等待一次性事件 71
4.2.1 从后台任务中返回值 72
4.2.2 将任务与future相关联 74
4.2.3 生成(std::)promise 77
4.2.4 为future保存异常 79
4.2.5 等待自多个线程 80
4.3 有时间限制的等待 82
4.3.1 时钟 83
4.3.2 时间段 84
4.3.3 时间点 85
4.3.4 接受超时的函数 86
4.4 使用操作同步来简化代码 88
4.4.1 带有future的函数式编程 88
4.4.2 具有消息传递的同步操作 92
4.5 小结 96
第5章 C++内存模型和原子类型上操作 97
5.1 内存模型基础 98
5.1.1 对象和内存位置 98
5.1.2 对象、内存位置以及并发 99
5.1.3 修改顺序 100
5.2 C++中的原子操作及类型 100
5.2.1 标准原子类型 101
5.2.2 std::atomic_flag上的操作 103
5.2.3 基于std::atomicbool的操作 105
5.2.4 std::atomicT*上的操作：指针算术运算 107
5.2.5 标准原子整型的操作 108
5.2.6 std::atomic初级类模板 109
5.2.7 原子操作的自由函数 111
5.3 同步操作和强制顺序 112
5.3.1 synchronizes-with关系 114
5.3.2 happens-before关系 114
5.3.3 原子操作的内存顺序 116
5.3.4 释放序列和synchronizes-with 133
5.3.5 屏障 135
5.3.6 用原子操作排序非原子操作 137
5.4 小结 138
第6章 设计基于锁的并发数据结构 140
6.1 为并发设计的含义是什么 141
6.2 基于锁的并发数据结构 142
6.2.1 使用锁的线程安全栈 142
6.2.2 使用锁和条件变量的线程安全队列 145
6.2.3 使用细粒度锁和条件变量的线程安全队列 149
6.3 设计更复杂的基于锁的数据结构 160
6.3.1 编写一个使用锁的线程安全查找表 160
6.3.2 编写一个使用锁的线程安全链表 165
6.4 小结 169
第7章 设计无锁的并发数据结构 170
7.1 定义和结果 171
7.1.1 非阻塞数据结构的类型 171
7.1.2 无锁数据结构 172
7.1.3 无等待的数据结构 172
7.1.4 无锁数据结构的优点与缺点 172
7.2 无锁数据结构的例子 173
7.2.1 编写不用锁的线程安全栈 174
7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存 178
7.2.3 用风险指针检测不能被回收的结点 182
7.2.4 使用引用计数检测结点 189
7.2.5 将内存模型应用至无锁栈 194
7.2.6 编写不用锁的线程安全队列 198
7.3 编写无锁数据结构的准则 209
7.3.1 准则：使用std::memory_order_seq_cst作为原型 210
7.3.2 准则：使用无锁内存回收模式 210
7.3.3 准则：当心ABA问题 210
7.3.4 准则：识别忙于等待的循环以及辅助其他线程 211
7.4 小结 211
第8章 设计并发代码 213
8.1 在线程间划分工作的技术 214
8.1.1 处理开始前在线程间划分数据 214
8.1.2 递归地划分数据 215
8.1.3 以任务类型划分工作 219
8.2 影响并发代码性能的因素 222
8.2.1 有多少个处理器 222
8.2.2 数据竞争和乒乓缓存 223
8.2.3 假共享 225
8.2.4 数据应该多紧密 225
8.2.5 过度订阅和过多的任务切换 226
8.3 为多线程性能设计数据结构 226
8.3.1 为复杂操作划分数组元素 227
8.3.2 其他数据结构中的数据访问方式 228
8.4 为并发设计时的额外考虑 230
8.4.1 并行算法中的异常安全 230
8.4.2 可扩展性和阿姆达尔定律 237
8.4.3 用多线程隐藏延迟 238
8.4.4 用并发提高响应性 239
8.5 在实践中设计并发代码 241
8.5.1 std::for_each的并行实现 241
8.5.2 std::find的并行实现 243
8.5.3 std::partial_sum的并行实现 248
8.6 总结 256
第9章 高级线程管理 258
9.1 线程池 259
9.1.1 最简单的线程池 259
9.1.2 等待提交给线程池的任务 261
9.1.3 等待其他任务的任务 265
9.1.4 避免工作队列上的竞争 267
9.1.5 工作窃取 269
9.2 中断线程 273
9.2.1 启动和中断另一个线程 274
9.2.2 检测一个线程是否被中断 275
9.2.3 中断等待条件变量 276
9.2.4 中断在std::condition_variable_ any上的等待 279
9.2.5 中断其他阻塞调用 281
9.2.6 处理中断 281
9.2.7 在应用退出时中断后台任务 282
9.3 总结 284
第10章 多线程应用的测试与调试 285
10.1 并发相关错误的类型 285
10.1.1 不必要的阻塞 286
10.1.2 竞争条件 286
10.2 定位并发相关的错误的技巧 288
10.2.1 审阅代码以定位潜在的错误 288
10.2.2 通过测试定位并发相关的错误 290
10.2.3 可测试性设计 291
10.2.4 多线程测试技术 292
10.2.5 构建多线程的测试代码 295
10.2.6 测试多线程代码的性能 297
10.3 总结 298
附录A 附录A C++11部分
语言特性简明
参考 299
附录B 并发类库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中国文学纵横
编辑说明
校订余话
序言
致谢
I  理解中国文学
中国古典文学——作为传统文化产物在当代的接受
中国小说与美国批评——关于结构、传统与讽刺的反思
论对中国现代文学的「科学」研究——答普实克教授
II  传统戏曲
熊译《西厢记》新序
汤显祖笔下的时间与人生
III  传统与早期现代小说
战争小说初论
书评：《红楼梦的原型与寓言》
文人小说家和中国文化——《镜花缘》新论
新小说的提倡者：严复与梁启超
《老残游记》新论
《玉梨魂》新论
IV  现代小说
《中国现代中短篇小说选》导言
端木蕻良的《科尔沁旗草原》
残存的女性主义——中国共产主义小说中的女性形象
注释
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中国文学纵横
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>股市趋势技术分析(原书第10版)
第10版序言
第9版序言
第8版序言
纪念
第7版序言
第5版序言
第4版序言
第2版序言
序言
第一部分 技术理论
第1章 交易与投资的技术方法 / 2
第2章 图表 / 7
第3章 道氏理论 / 11
第4章 道氏理论的缺陷 / 22
第5章 用约翰·迈吉的基准点法代替道氏理论 / 34
第6章 重要的反转形态 / 47
第7章 重要的反转形态：续 / 64
第8章 重要的反转形态：三角形 / 84
第9章 重要的反转形态：续 / 110
第10章 其他反转现象 / 129
第11章 整固形态 / 161
第12章 缺口 / 181
第13章 支撑和阻力 / 199
第14章 趋势线和通道 / 219
第15章 长线趋势线 / 242
第16章 大宗商品图表技术分析 / 260
第17章 第一部分总结 / 278
第二部分 交易战术
第18章 战术问题 / 317
第19章 一些非常重要的细节 / 329
第20章 投机者青睐的股票 / 333
第21章 选择要跟踪绘图的个股 / 343
第22章 选择要跟踪绘图的个股：续 / 346
第23章 高风险股票的挑选和管理：郁金香股票、互联网板块和投机性狂热 / 352
第24章 股价可能出现的变化 / 369
第25章 两个敏感问题 / 374
第26章 整手还是零股 / 381
第27章 止损指令 / 383
第28章 什么是底部和顶部 / 392
第29章 运行中的趋势线 / 409
第30章 支撑位和阻力位的应用 / 420
第31章 不要将所有鸡蛋放在同一个篮子里 / 426
第32章 技术图表形态的测算目标 / 429
第33章 从战术角度看图表形态 / 432
第34章 战术方法的简要总结 / 458
第35章 技术分析对市场的影响 / 461
第36章 自动化的趋势线：移动平均线 / 464
第37章 旧图重读 / 470
第38章 平衡的多样化配置 / 524
第39章 试错 / 532
第40章 交易中的资金使用量 / 534
第41章 实际资金投入 / 537
第42章 组合风险管理 / 542
第43章 持之以恒 / 556
附录A 实践中的道氏理论 / 558
附录B 资源 / 576
术语表 / 594
参考文献 / 612
译后记 / 614
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>股市趋势技术分析(原书第10版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Accelerated C++中文版
第0章 开始
0.1 注释
0.2 #include指令
0.3 主函数main
0.4 花括号
0.5 使用标准库进行输出
0.6 返回语句
0.7 进一步的深入
0.8 小结
练习
第1章 字符串的使用
1.1 输入
1.2 将姓名装框
1.3 小结
练习
第2章 循环与计数
2.1 问题
2.2 程序的整体结构
2.3 输出数目未知的行
2.4 输出一行
2.5 完整的框架程序
2.6 计数
2.7 小结
练习
第3章 使用批量数据
3.1 计算学生成绩
3.2 用中值代替平均值
3.3 小结
练习
第4章 组织程序和数据
4.1 组织计算
4.2 组织数据
4.3 将各部分代码连接到一起
4.4 将计算成绩的程序分块
4.5 修正后的计算成绩程序
4.6 小结
练习
第5章 使用顺序容器和分析字符串
5.1 将学生进行分类
5.2 迭代器
5.3 用迭代器代替索引
5.4 重新思考数据结构以实现更好的性能
5.5 list类型
5.6 分割字符串
5.7 测试split函数
5.8 连接字符串
5.9 小结
练习
第6章 使用库算法
6.1 分析字符串
6.2 比较计算成绩的方案
6.3 对学生进行分类并回顾我们的问题
6.4 算法、容器以及迭代器
6.5 小结
练习
第7章 使用关联容器
7.1 支持高效查找的容器
7.2 计算单词数量
7.3 生成交叉引用表
7.4 生成语句
7.5 关于性能的一些说明
7.6 小结
练习
第8章 编写泛型函数
8.1 什么是泛型函数
8.2 数据结构独立性
8.3 输入和输出迭代器
8.4 使用迭代器提高适应性
8.5 小结
练习
第9章 定义新类型
9.1 Student_info回顾
9.2 自定义类型
9.3 保护
9.4 Student_info类
9.5 构造函数
9.6 使用Student_info类
9.7 小结
练习
第10章 管理内存与低级数据结构
10.1 指针与数组
10.2 字符串字面量回顾
10.3 初始化字符串指针数组
10.4 main函数的参数
10.5 文件读写
10.6 内存管理的三种方法
10.7 小结
练习
第11章 定义抽象数据类型
11.1 Vec类
11.2 实现Vec类
11.3 复制控制
11.4 动态的Vec类型对象
11.5 灵活的内存管理
11.6 小结
练习
第12章 使类对象获得数值功能
12.1 一个简单的string类
12.2 自动转换
12.3 Str操作
12.4 有些转换是危险的
12.5 类型转换操作函数
12.6 类型转换与内存管理
12.7 小结
练习
第13章 继承与动态绑定的使用
13.1 继承
13.2 多态与虚拟函数
13.3 使用继承解决问题
13.4 一个简单的句柄类
13.5 使用句柄类
13.6 微妙之处
13.7 小结
练习
第14章 近乎自动地管理内存
14.1 用于复制对象的句柄
14.2 引用计数句柄
14.3 可以让您决定何时共享数据的句柄
14.4 可控句柄的一个改进
14.5 小结
练习
第15章 再探字符图形
15.1 设计
15.2 实现
15.3 小结
练习
第16章 学习C++的后续方法
16.1 利用已经掌握的知识
16.2 学习更多的知识
练习
附录A C++语法细节
A.1 声明
A.1.1 指定说明
A.1.2 声明符
A.2 类型
A.2.1 整数类型
A.2.2 浮点类型
A.2.3 常量表达式
A.2.4 类型转换
A.2.5 枚举类型
A.2.6 重载
A.3 表达式
A.4 语句
附录B 标准库一览
B.1 输入-输出
B.2 容器和迭代器
B.2.1 共有的容器操作
B.2.2 顺序容器的操作
B.2.3 其他顺序操作
B.2.4 关联容器的操作
B.2.5 迭代器（iterator）
B.2.6 向量（vector）
B.2.7 链表（list）
B.2.8 字符串（string）
B.2.9 对（pair）
B.2.10 图（map）
B.3 算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Accelerated C++中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国家的视角
鸣　谢……………………………………………………………………………………………1
导　言……………………………………………………………………………………………1
第一部分　清晰化和简单化的国家项目
第一章　自然与空间……………………………………………………………………………3
国家和科学林业：一个寓言……………………………………………………………／4
社会事实：原始的和加工过的…………………………………………………………／21
铸造清晰性的工具：流行的度量，国家的度量………………………………………／24
土地制度：地方实践与财政简况………………………………………………………／36
第二章　城市、人民和语言……………………………………………………………………62
姓的创造…………………………………………………………………………………／76
标准的正式语言的指令…………………………………………………………………／88
交通模式的集权化………………………………………………………………………／90
结论………………………………………………………………………………………／94
第二部分　转变中的视野
第三章　独裁主义的极端现代主义……………………………………………………………107
社会的发现………………………………………………………………………………／112
极端现代主义的激进权威………………………………………………………………／116
20世纪的极端现代主义…………………………………………………………………／121
第四章　极端现代主义的城市：试验与批评…………………………………………………129
总体的城市计划…………………………………………………………………………／131
巴西利亚：建成的最接近极端现代主义的城市………………………………………／150
勒库布西耶的昌迪加尔…………………………………………………………………／164
反对极端现代主义城市规划的一个例子：简•雅各布………………………………／166
第五章　革命的政党：计划和诊断……………………………………………………………185
列宁：革命的建筑师和工程师…………………………………………………………／186
卢森堡：革命的内科医生和助产士……………………………………………………／212
亚历山德拉•科伦泰和工人对列宁的反对……………………………………………／221
第三部分　农村定居和生产中的社会工程
第六章　苏维埃集体化，资本主义梦想………………………………………………………241
苏维埃—美国的迷信：工业化农场……………………………………………………／246
苏维埃俄国的集体化……………………………………………………………………／253
国家控制和征收的景观…………………………………………………………………／274
独裁式极端现代主义的限制……………………………………………………………／277
第七章　坦桑尼亚的强制村庄化：美学和微型化……………………………………………280
东非殖民化的极端现代主义农业………………………………………………………／282
1973年以前坦桑尼亚的村庄和“改进的”农业………………………………………／288
“到村庄中生活，这是命令”…………………………………………………………／295
“理想的”国家村庄：埃塞俄比亚的变异……………………………………………／315
结　论……………………………………………………………………………………／322
第八章　驯化自然：清晰和简单的农业………………………………………………………335
各类农业简单化…………………………………………………………………………／338
极端现代主义农业问答…………………………………………………………………／347
现代主义者的信念与地方实践…………………………………………………………／350
极端现代主义的制度亲和力……………………………………………………………／368
农业科学的简单化假设…………………………………………………………………／370
科学农业的简单化实践…………………………………………………………………／379
比较两个农业逻辑………………………………………………………………………／386
结　论……………………………………………………………………………………／390
第四部分　失去的环节
第九章　薄弱的简单化和实践知识：米提斯…………………………………………………395
米提斯：实践知识的轮廓………………………………………………………………／398
米提斯的社会背景和它的被破坏………………………………………………………／428
一个反对知识帝国主义的例子…………………………………………………………／436
第十章　结语……………………………………………………………………………………439
“那是无知，傻瓜！”…………………………………………………………………／440
为抽象公民做的计划……………………………………………………………………／443
剥开事实见本质…………………………………………………………………………／445
图解的失败和米提斯的角色……………………………………………………………／448
一个亲和米提斯的制度案例……………………………………………………………／451
再版译者后记……………………………………………………………………………………458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国家的视角
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>假如这是真的
在一个夏天，安静睡去
001•还真得相信女主人这番严肃的话给这辆英国旧车留下了非常深刻的印象，因为钥匙一转，它的引擎就发动了起来。美丽的一天开始了。
我会怎样遇见你
023•阿瑟犹豫了一会儿，然后描述道她有一双很大很大的眼睛，一张漂亮的嘴巴，一张与她的行为截然相反的温柔的脸，还说她有一双修长的手，勾画出优雅的动作。
某种隐约的幸福
069•时间在星期日懒洋洋的节奏中一分一秒地过去。太阳与阵雨玩着捉迷藏。他俩几乎没有说什么话。她不时盯着他看，问他是否肯定会继续下去，他不再回答这个问题。
假如生命不曾燃烧
113•这条道路沿着海边的悬崖峭壁通向蒙特瑞海湾，再一直通往卡麦尔。去年初夏的一个早上，劳伦驾驶她那辆凯旋车，原本打算走的也正是这条道。
也许我们该这样相爱
131•一块块宽阔的赭石色的土地上，矗立着意大利五针松、银松、巨杉、石榴树，还有角豆树，这些条形的土地像是一直要流入海洋似的。遍地都是被阳光烤得橙黄的荆棘。
海边的卡麦尔
167•黄昏时分劳伦站在阳台上，凝视着这幕场景。海水变成灰色，驱赶着一堆堆交织着荆棘的海藻。天空转成淡紫色，最后黑了下来。她感到幸福，当大自然终于决定突然发怒的时候，她很喜欢。
我知道，你不会忘记
217•在她说话时，她外表变得透明，皮肤变得水一样清澈。他拥抱着的她的两腋，已渐渐变成虚空，他觉得她正在逐渐消逝。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>假如这是真的
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计（第二版）
1 C语言概述
2 程序的灵魂――算法
3 数据类型、运算符号与表达式
4 最简单的C程序设计――顺序程序设计
5 选择结构程序设计
6 循环控制
7 数组
8 函数
9 预处理命令
10 指针
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计（第二版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧洲中世纪简史
导读
第十版序言
导言
第一部分 中世纪初期：欧洲的诞生，500—1000年
第一章 罗马（帝国）皈依基督教，约公元前31-公元430年
引言
罗马帝国的和平（公元前31-公元180年）
第三和第四个世纪（180—395年）
基督教
小结
第二章 野蛮民族入侵及定居于西欧，约400－500年
引言
野蛮民族与西方帝国
西方帝国的衰落
小结
第三章 早期的西方基督教世界，约500—700年
引言
早期的中世纪社会
早期的中世纪政治
早期的中世纪教会
思想生活
小结
第四章 邻居：拜占廷和伊斯兰，约500—1000年
引言
从东方到拜占庭帝国
拜占庭诸世纪
伊斯兰的崛起
伊斯兰帝国
伊斯兰文化
小结
第五章 加洛林王朝的欧洲，约700－850年
引言
早期的加洛林王朝
查理大帝（768—814年在位）
思想文化复兴
小结
第六章 分裂、入侵及重建，约800—1000年
引言
分裂：晚期的加洛林王朝
入侵：穆斯林、马扎尔人与维京人
重建：新的政治
小结
第二部分 中世纪中期：改革、复兴及扩张，1000-1300年
第七章 经济起飞与社会转变，约1000-1300年
引言
农业革命
村镇、庄园与教区
……
第八章 往神（天主）的新路径，约1000-1250年
第九章 征服、十字军东征及宗教迫害，约1000-1300年
第十章 政教冲突：教皇与罗马帝国，约1125-1300年
第十一章 形成中的国家：英国与法国，约1050-1300年
第十二章 文学、艺术及思想，约1000-1300年
第三部分 中世纪后期：危机与创建，1300-1500年
第十三章 灾荒、瘟疫及复苏，约1300-1500年
第十四章 迈向国家建制，约1300-1500年
第十五章 中世纪后期文化之多元化及活力，约1300-1500年
术语表
引文出处
附录 中世纪欧洲的教皇与君主年表
图片来源
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧洲中世纪简史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>维特根斯坦与哲学
前言
1 生平与性格
2 早期哲学
3 后期哲学
4 维特根斯坦与晚近哲学
索引
英文原文
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>维特根斯坦与哲学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer中文版
译序
前言
第一篇 C++概述
第一章 开始
第二章 C++浏览
第二篇 基本语言
第三章 C++数据类型
第四章 表达式
第五章 语句
……
第三篇 基于过程的程序设计
第七章 函数
第八章 域和生命期
……
第四篇 基于对象的程序设计
第十三章 类
第十四章 类的初始化、赋值和析构
……
第五篇 面向对象的程序设计
第十七章 类继承和子类型
……
英汉对照索引

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C编程
第1部分  入门	1
第1章  读者与本书	3
1.1  C与Objective-C	3
1.2  主要内容及阅读方式	4
1.3  程序员要走的道路	4
第2章  第一个程序	7
2.1  安装Apple开发工具软件	7
2.2  Xcode入门	7
2.3  从哪里开始编写代码	9
2.4  如何运行程序	13
2.5  程序是如何产生的	14
2.6  不要半途而废	15
第2部分  如何编程	17
第3章  变量与类型	19
3.1  类型	19
3.2  使用变量的程序	20
3.3  练习	22
第4章  if和else	23
4.1  布尔变量	24
4.2  else if	25
4.3  深入学习：条件运算符（三元运算符）	25
4.4  练习	26
第5章  函数	27
5.1  应该在何时使用函数	27
5.2  如何编写并使用函数	27
5.3  函数间是如何协同工作的	30
5.4  局部变量、帧和栈	32
5.5  递归	34
5.6  通过调试器查看帧	35
5.7  return	37
5.8  全局变量与静态变量	39
5.9  练习	40
第6章  数字	41
6.1  printf()	41
6.2  整数	42
6.3  浮点数	46
6.4  练习	47
第7章  循环	49
7.1  while循环	49
7.2  for循环	50
7.3  break	51
7.4  continue	52
7.5  do-while循环	53
7.6  练习	54
第8章  地址与指针	55
8.1  获取地址	55
8.2  用指针保存地址	56
8.3  通过地址访问数据	57
8.4  不同类型的数据所占用的字节大小	57
8.5  NULL	58
8.6  指针声明的代码规范	59
8.7  练习	59
第9章  通过引用传递	61
9.1  编写通过引用传递参数的函数	62
9.2  不要对NULL取值	64
第10章  结构	65
10.1  练习	66
第11章  堆	69
第3部分  Objective-C与Foundation	73
第12章  对象	75
12.1  创建并使用对象	75
12.2  消息详解	77
12.3  内存中的对象	79
12.4  id	79
12.5  练习	80
第13章  再谈消息	81
13.1  消息的嵌套发送	81
13.2  多个实参	82
13.3  向nil发送消息	82
13.4  练习	83
第14章  NSString	85
14.1  练习	86
第15章  NSArray	87
15.1  NSMutableArray	89
15.2  练习	90
第16章  开发文档	93
16.1  参考页	94
16.2  快速帮助	96
16.3  其他文档功能和开发资源	98
第17章  第一个自定义类	101
17.1  存取方法	103
17.2  用点号调用存取方法	104
17.2  属性	105
17.4  self	106
17.5  多个实现文件	106
17.6  练习	106
第18章  继承	109
18.1  覆盖方法	112
18.2  super	113
18.3  练习	113
第19章  对象实例变量	115
19.1  对象所有权与ARC	117
19.2  练习	123
第20章  避免内存泄露	125
20.1  Retain循环	127
20.2  弱引用	129
20.3  弱引用的自动置零特性	130
20.4  深入学习：手动引用计数和ARC历史	131
第21章  Collection类	135
21.1  NSArray/NSMutableArray	135
21.2  NSSet/NSMutableSet	138
21.3  NSDictionary/NSMutableDictionary	140
21.4  C语言基本类型	142
21.5  Collection对象与nil	142
21.6  练习	143
第22章  常量	145
22.1  预处理指令	145
22.2  #include与#import	146
22.3  #define	146
22.4  全局变量	147
22.5  比较#define与全局变量	149
第23章  通过NSString和NSData将数据写入文件	151
23.1  将NSString对象写入文件	151
23.2  NSError	152
23.3  通过NSString读取文件	153
23.4  将NSData对象所保存的数据写入文件	154
23.5  从文件读取数据并存入NSData对象	155
第24章  回调	157
24.1  目标-动作对	157
24.2  辅助对象	160
24.3  通告	163
24.4  如何选择	164
24.5  回调与对象所有权	164
第25章  协议	167
第26章  Property List格式	171
26.1  练习	173
第4部分  由事件驱动的应用	175
第27章  第一个iOS应用	177
27.1  创建iTahDoodle	177
27.2  BNRAppDelegate	179
27.3  添加C语言辅助函数	180
27.4  iTahDoodle中的对象	181
27.5  Model-View-Controller	182
27.6  应用委托对象	183
27.7  设置视图	184
27.8  为UITableView对象提供数据	186
27.9  添加新任务	189
27.10  深入学习：main()的作用	190
第28章  第一个Cocoa应用	191
28.1  编辑BNRDocument.h	192
28.2  Interface Builder初探	193
28.3  编辑BNRDocument.xib	194
28.4  创建关联	198
28.5  再探MVC	202
28.6  编辑BNRDocument.m	202
28.7  练习	204
第5部分  Objective-C高级主题	205
第29章  init	207
29.1  编写init方法	207
29.2  实现基本的init方法	208
29.3  在init中使用存取方法	209
29.4  带实参的init方法	210
29.5  禁用init方法	215
第30章  属性	217
30.1  属性的特性	218
30.2  KVC	221
第31章  范畴	225
第32章  Block对象	227
32.1  定义Block对象	227
32.2  使用Block对象	228
32.3  typedef	233
32.4  返回值	233
32.5  内存管理	234
32.6  基于Block的编程是大势所趋	235
32.7  练习	235
第6部分  C语言高级主题	237
第33章  位运算	239
33.1  按位或	240
33.2  按位与	241
33.3  其他位运算符	242
33.4  用enum定义位掩码	245
33.5  占用更多字节的整数类型	245
33.6  练习	245
第34章  C字符串	247
34.1  char	247
34.2  char *	248
34.3  string literal	250
34.4  C字符串和NSString对象的相互转换	251
34.5  练习	252
第35章  C数组	253
第36章  命令行参数	257
第37章  switch语句	261
结束语	263
索引	265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cocoa入门
前言
第一部分　Cocoa概述和基础
第1章　Cocoa介绍
Mac OS X编程环境
Cocoa定义
Cocoa框架
程序语言
Foundation框架
第2章　Cocoa开发工具
安装开发工具
Interface Builder
其他工具
命令行工具
练习
第3章　基于Objective-C语言的面向对象编程
认识对象
创建和使用对象
Objective-C定义的类型
创建新类
方法覆盖
其他概念
练习
第4章　Cocoa Foundation Kit
字符串
集合（Collection）
内存管理
练习
第二部分　单一窗口的应用程序
第5章　图形用户界面
Cocoa的图形用户界面
用MVC模式设计应用程序
创建货币转换器工程
创建界面
改变文本框属性
定义类
连接模型、控制器和视图
构建并运行
练习
第6章　窗口、视图和控件
窗口和窗口系统
视图的层次结构
坐标系
控件、控件单元和格式器
练习
第7章　自定义视图
自定义视图的创建步骤
创建自定义视图
绘制视图内部：幕后工作
在视图中绘制字符串
在视图上绘制线条
练习
第8章　事件处理
事件
Dot View应用程序
事件委托
通告
练习
第9章　模型和数据处理功能
协议
键值编码
表格视图
表格视图示例
保存数据：编码和归档
使用格式器（Formatters）
练习
第三部分　基于文档的应用程序
第10章　多文档架构
架构概述
构建基于文档的应用程序
练习
第11章　多信息文本处理
Cocoa的文本系统
创建多信息文本编辑器
实现字体菜单
文本存储和有属性的文本
实现文本菜单
处理嵌入式图像
练习
第四部分　其他主题
第12章　打印
打印视图
使用打印操作
设置页边距
练习
第13章　文件包和资源
文件包内部一瞥
使用文件包
练习
第14　章本地化
Mac OS X的语言偏好设置
本地化资源
本地化nib文件
本地化字符串
练习
第15章　默认和偏好设置
偏好设置如何工作
使用默认值
通过命令行访问偏好设置
练习
第16章　附属窗口
File’S Owner对象的角色
创建信息窗口
练习
第17章　完善收尾
收拾界面
设定图标
添加帮助
定制关于（About）窗口
调整编译器设置
打包发布
结尾
练习
第五部分　附录
附录A　练习解答
附录B　附加资源
附录C　使用帮助查阅开发文档
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cocoa入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南
目录
第0章  导读	1
0.1  关于本书	1
0.2  读者对象	1
0.3  本书的术语与风格	2
0.4  本书的结构	3
0.5  如何阅读本书	5
第1章  Boost程序库总论	7
1.1  关于Boost	7
1.1.1  什么是Boost	7
1.1.2  安装Boost	8
1.1.3  使用Boost	8
1.2  关于STLport	9
1.2.1  什么是STLport	9
1.2.2  安装STLport	10
1.2.3  使用STLport	10
1.3  开发环境	10
1.3.1  STLport的编译方法	11
1.3.2  Boost的编译方法	11
1.3.3  VisualStudio 2005环境设置	15
第2章  时间与日期	17
2.1  timer库概述	17
2.2  timer	17
2.2.1  用法	18
2.2.2  类摘要	18
2.2.3  使用建议	19
2.3  progress_timer	20
2.3.1  用法	20
2.3.2  类摘要	21
2.3.3  扩展计时精度	21
2.4  progress_display	23
2.4.1  类摘要	24
2.4.2  用法	25
2.4.3  注意事项	26
2.5  date_time库概述	27
2.5.1  编译date_time库	27
2.5.2  date_time库的基本概念	28
2.6  处理日期	29
2.6.1  日期	29
2.6.2  创建日期对象	30
2.6.3  访问日期	31
2.6.4  日期的输出	32
2.6.5  与tm结构的转换	33
2.6.6  日期长度	34
2.6.7  日期运算	35
2.6.8  日期区间	36
2.6.9  日期区间运算	38
2.6.10  日期迭代器	39
2.6.11  其他功能	40
2.6.12  综合运用	40
2.7  处理时间	43
2.7.1  时间长度	43
2.7.2  操作时间长度	45
2.7.3  时间长度的精确度	46
2.7.4  时间点	48
2.7.5  创建时间点对象	48
2.7.6  操作时间点对象	49
2.7.7  与tm、time_t等结构的转换	50
2.7.8  时间区间	51
2.7.9  时间迭代器	51
2.7.10  综合运用	52
2.8  date_time库的高级议题	54
2.8.1  编译配置宏	55
2.8.2  格式化时间	55
2.8.3  本地时间	56
2.8.4  序列化	58
2.9  总结	58
第3章  内存管理	61
3.1  smart_ptr库概述	61
3.1.1  RAII机制	61
3.1.2  智能指针	62
3.2  scoped_ptr	63
3.2.1  类摘要	63
3.2.2  操作函数	64
3.2.3  用法	65
3.2.4  与auto_ptr的区别	66
3.3  scoped_array	67
3.3.1  类摘要	67
3.3.2  用法	68
3.3.3  使用建议	69
3.4  shared_ptr	69
3.4.1  类摘要	70
3.4.2  操作函数	70
3.4.3  用法	72
3.4.4  工厂函数	74
3.4.5  应用于标准容器	75
3.4.6  应用于桥接模式	76
3.4.7  应用于工厂模式	77
3.4.8  定制删除器	78
3.4.9  高级议题	80
3.5  shared_array	81
3.5.1  类摘要	81
3.5.2  用法	82
3.6  weak_ptr	82
3.6.1  类摘要	82
3.6.2  用法	83
3.6.3  获得this的shared_ptr	84
3.7  intrusive_ptr	85
3.8  pool库概述	85
3.9  pool	85
3.9.1  类摘要	86
3.9.2  操作函数	86
3.9.3  用法	87
3.10  object_pool	88
3.10.1  类摘要	88
3.10.2  操作函数	88
3.10.3  用法	89
3.10.4  使用更多的构造参数	90
3.11  singleton_pool	91
3.11.1  类摘要	91
3.11.2  用法	92
3.12  pool_alloc	93
3.13  总结	93
第4章  实用工具	95
4.1  noncopyable	95
4.1.1  原理	96
4.1.2  用法	96
4.2  typeof	97
4.2.1  动机	97
4.2.2  用法	99
4.2.3  向typeof库注册自定义类	100
4.2.4  高级议题	101
4.3  optional	101
4.3.1 “无意义”的值	101
4.3.2  类摘要	102
4.3.3  操作函数	102
4.3.4  用法	103
4.3.5  工厂函数	104
4.3.6  高级议题	105
4.4  assign	106
4.4.1  使用操作符+=向容器
增加元素	106
4.4.2  使用操作符()向容器
增加元素	107
4.4.3  初始化容器元素	108
4.4.4  减少重复输入	110
4.4.5  与非标准容器工作	111
4.4.6  高级用法	112
4.5  swap	113
4.5.1  原理	113
4.5.2  交换数组	114
4.5.3  特化std::swap	114
4.5.4  特化ADL可找到的swap	115
4.5.5  使用建议	116
4.6  singleton	116
4.6.1  boost.pool的单件实现	117
4.6.2  boost.serialzation的
单件实现	119
4.7  tribool	120
4.7.1  类摘要	121
4.7.2  用法	122
4.7.3  为第三态更名	122
4.7.4  输入输出	123
4.7.5  与optional<bool>的区别	124
4.8  operators	125
4.8.1  基本运算概念	126
4.8.2  算术操作符的用法	127
4.8.3  基类链	129
4.8.4  复合运算概念	130
4.8.5  相等与等价	131
4.8.6  解引用操作符	133
4.8.7  下标操作符	134
4.8.8  高级议题	135
4.9  exception	136
4.9.1  标准库中的异常	137
4.9.2  类摘要	137
4.9.3  向异常传递信息	139
4.9.4  更进一步的用法	140
4.9.5  包装标准异常	142
4.9.6  使用函数抛出异常	143
4.9.7  获得更多的调试信息	144
4.9.8  高级议题	145
4.10  uuid	146
4.10.1  类摘要	147
4.10.2  用法	148
4.10.3  生成器	150
4.10.4  增强的uuid类	152
4.10.5  与字符串的转换	153
4.10.6  SHA1摘要算法	154
4.11  config	155
4.11.1  BOOST_STRINGIZE	155
4.11.2  BOOST_STATIC_
CONSTANT	155
4.11.3  禁止编译器警告	156
4.11.4  其他工具	157
4.12  utility	157
4.12.1  BOOST_BINARY	157
4.12.2  BOOST_CURRENT_
FUNCTION	158
4.13  总结	160
第5章  字符串与文本处理	163
5.1  lexical_cast	163
5.1.1  用法	164
5.1.2  异常bad_lexical_cast	165
5.1.3  对转换对象的要求	166
5.1.4  应用于自己的类	166
5.2  format	167
5.2.1  简单的例子	168
5.2.2  输入操作符％	169
5.2.3  类摘要	171
5.2.4  格式化语法	172
5.2.5  format的性能	173
5.2.6  高级用法	173
5.3  string_algo	175
5.3.1  简单的例子	175
5.3.2  string_algo概述	176
5.3.3  大小写转换	177
5.3.4  判断式（算法）	178
5.3.5  判断式（函数对象）	179
5.3.6  分类	180
5.3.7  修剪	181
5.3.8  查找	182
5.3.9  替换与删除	184
5.3.10  分割	186
5.3.11  合并	187
5.3.12  查找（分割）迭代器	188
5.4  tokenizer	189
5.4.1  类摘要	190
5.4.2  用法	190
5.4.3  分词函数对象	191
5.4.4  char_separator	192
5.4.5  escaped_list_separator	193
5.4.6  offset_separator	193
5.4.7  tokenizer库的缺陷	195
5.5  xpressive	196
5.5.1  两种使用方式	197
5.5.2  正则表达式语法简介	197
5.5.3  类摘要	199
5.5.4  匹配	201
5.5.5  查找	203
5.5.6  替换	204
5.5.7  迭代	206
5.5.8  分词	207
5.5.9  与regex的区别	208
5.5.10  高级议题	209
5.6  总结	211
第6章  正确性与测试	213
6.1  assert	213
6.1.1  基本用法	213
6.1.2  禁用断言	214
6.1.3  扩展用法	215
6.1.4  BOOST_VERIFY	216
6.2  static_assert	217
6.2.1  用法	217
6.2.2  使用建议	218
6.3  test	219
6.3.1  编译test库	219
6.3.2  最小化的测试套件	220
6.3.3  单元测试框架简介	221
6.3.4  测试断言	222
6.3.5  测试用例与套件	223
6.3.6  测试实例	224
6.3.7  测试夹具	226
6.3.8  测试日志	228
6.3.9  运行参数	229
6.3.10  函数执行监视器	230
6.3.11  程序执行监视器	233
6.3.12  高级议题	234
6.4  总结	236
第7章  容器与数据结构	239
7.1  array	239
7.1.1  类摘要	240
7.1.2  操作函数	240
7.1.3  用法	241
7.1.4  能力限制	242
7.1.5  array的初始化	242
7.1.6  实现ref_array	243
7.1.7  ref_array的用法	244
7.2  dynamic_bitset	245
7.2.1  类摘要	245
7.2.2  创建与赋值	247
7.2.3  容器操作	248
7.2.4  位运算与比较运算	249
7.2.5  访问元素	249
7.2.6  类型转换	251
7.2.7  集合操作	251
7.2.8  综合运用	252
7.3  unordered	253
7.3.1  散列集合简介	254
7.3.2  散列集合的用法	255
7.3.3  散列映射简介	256
7.3.4  散列映射的用法	256
7.3.5  性能比较	257
7.3.6  高级议题	259
7.4  bimap	261
7.4.1  类摘要	261
7.4.2  基本用法	262
7.4.3  值的集合类型	263
7.4.4  集合类型的用法	264
7.4.5  使用标签类型	266
7.4.6  使用assign库	267
7.4.7  查找与替换	268
7.4.8  投射	269
7.4.9  高级议题	270
7.5  circular_buffer	271
7.5.1  类摘要	271
7.5.2  用法	272
7.5.3  环型缓冲区	273
7.5.4  空间优化型缓冲区	275
7.6  tuple	275
7.6.1  最简单的tuple：pair	276
7.6.2  类摘要	276
7.6.3  创建与赋值	277
7.6.4  访问元素	278
7.6.5  比较操作	279
7.6.6  输入输出	280
7.6.7  连结变量	281
7.6.8  应用于assign库	282
7.6.9  应用于exception库	282
7.6.10  内部结构	282
7.6.11  使用访问者模式	284
7.6.12  高级议题	285
7.7  any	287
7.7.1  类摘要	287
7.7.2  访问元素	288
7.7.3  用法	289
7.7.4  简化的操作函数	290
7.7.5  保存指针	291
7.7.6  输出	292
7.7.7  应用于容器	294
7.8  variant	294
7.8.1  类摘要	294
7.8.2  访问元素	295
7.8.3  用法	296
7.8.4  访问器	297
7.8.5  与any的区别	300
7.8.6  高级议题	300
7.9  multi_array	302
7.9.1  类摘要	302
7.9.2  用法	304
7.9.3  多维数组生成器	306
7.9.4  改变形状和大小	307
7.9.5  创建子视图	308
7.9.6  适配普通数组	310
7.9.7  高级议题	311
7.10  property_tree	314
7.10.1  类摘要	315
7.10.2  读取配置信息	316
7.10.3  写入配置信息	318
7.10.4  更多用法	319
7.10.5  XML数据格式	320
7.10.6  其他数据格式	321
7.10.7  高级议题	323
7.11  总结	324
第8章  算法	327
8.1  foreach	327
8.1.1  用法	328
8.1.2  详细解说	329
8.1.3  使用typeof	329
8.1.4  更优雅的名字	330
8.1.5  支持的序列类型	331
8.1.6  一个小问题	332
8.2  minmax	332
8.2.1  用法	333
8.2.2  使用tuples::tie	334
8.3  minmax_element	334
8.3.1  用法	334
8.3.2  其他函数的用法	335
8.4  总结	336
第9章  数学与数字	337
9.1  integer	337
9.1.1  integer_traits	337
9.1.2  标准整数类型	339
9.1.3  整数类型模板类	341
9.2  rational	344
9.2.1  类摘要	344
9.2.2  创建与赋值	345
9.2.3  算术运算与比较运算	346
9.2.4  类型转换	346
9.2.5  输入输出	347
9.2.6  分子与分母	347
9.2.7  与数学函数工作	347
9.2.8  异常	348
9.2.9  rational的精度	348
9.2.10  实现无限精度的整数类型	348
9.2.11  最大公约数和最小公倍数	353
9.3  crc	353
9.3.1  类摘要	354
9.3.2  预定义的实现类	354
9.3.3  计算CRC	355
9.3.4  CRC函数	356
9.3.5  自定义CRC函数	357
9.4  random	357
9.4.1  伪随机数发生器	358
9.4.2  伪随机数发生器的构造	359
9.4.3  伪随机数发生器的拷贝	360
9.4.4  随机数分布器	360
9.4.5  随机数分布器类摘要	361
9.4.6  随机数分布器用法	363
9.4.7  变量发生器	364
9.4.8  产生随机数据块	365
9.4.9  真随机数发生器	367
9.4.10  实现真随机数发生器	368
9.5  总结	369
第10章  操作系统相关	371
10.1  io_state_savers	371
10.1.1  类摘要	372
10.1.2  用法	372
10.1.3  简化new_progress_timer	374
10.2  system	374
10.2.1  编译system库	375
10.2.2  错误值枚举	375
10.2.3  错误类别	376
10.2.4  错误代码	377
10.2.5  错误异常	379
10.3  filesystem	380
10.3.1  编译filesystem库	380
10.3.2  类摘要	381
10.3.3  路径表示	383
10.3.4  可移植的文件名	384
10.3.5  路径处理	385
10.3.6  异常	387
10.3.7  文件状态	388
10.3.8  文件属性	390
10.3.9  文件操作	391
10.3.10  迭代目录	392
10.3.11  实例1：实现查找文件
功能	394
10.3.12  实例2：实现模糊查找
文件功能	395
10.3.13  实例3：实现拷贝目录
功能	397
10.3.14  文件流操作	399
10.4  program_options	400
10.4.1  编译program_options库	400
10.4.2  概述	401
10.4.3  选项值	403
10.4.4  选项描述器	404
10.4.5  选项描述器的用法	405
10.4.6  分析器	407
10.4.7  存储器	409
10.4.8  使用位置选项值	409
10.4.9  分析环境变量	411
10.4.10  分组选项信息	412
10.4.11  高级用法	414
10.5  总结	417
第11章  函数与回调	419
11.1  result_of	419
11.1.1  原理	420
11.1.2  用法	422
11.2  ref	422
11.2.1  类摘要	423
11.2.2  基本用法	424
11.2.3  工厂函数	425
11.2.4  操作包装	425
11.2.5  综合应用	426
11.2.6  为ref增加函数调用功能	427
11.3  bind	429
11.3.1  工作原理	429
11.3.2  绑定普通函数	430
11.3.3  绑定成员函数	432
11.3.4  绑定成员变量	433
11.3.5  绑定函数对象	433
11.3.6  使用ref库	434
11.3.7  高级议题	435
11.4  function	437
11.4.1  类摘要	437
11.4.2  function的声明	438
11.4.3  操作函数	439
11.4.4  比较操作	440
11.4.5  用法	440
11.4.6  使用ref库	441
11.4.7  用于回调	442
11.4.8  与typeof的区别	445
11.5  signals2	445
11.5.1  类摘要	446
11.5.2  操作函数	447
11.5.3  插槽的连接与调用	448
11.5.4  信号的返回值	449
11.5.5  合并器	450
11.5.6  管理信号的连接	452
11.5.7  更灵活的管理信号连接	453
11.5.8  自动连接管理	455
11.5.9  应用于观察者模式	457
11.5.10  高级议题	460
11.6  总结	464
第12章  并发编程	467
12.1  thread	467
12.1.1  编译thread库	468
12.1.2  使用thread库	468
12.1.3  时间功能	469
12.1.4  互斥量	469
12.1.5  线程对象	472
12.1.6  创建线程	473
12.1.7  操作线程	475
12.1.8  中断线程	476
12.1.9  线程组	479
12.1.10  条件变量	480
12.1.11  共享互斥量	484
12.1.12  future	485
12.1.13  高级议题	488
12.2  asio	493
12.2.1  概述	493
12.2.2  定时器	494
12.2.3  定时器用法	495
12.2.4  网络通信简述	498
12.2.5  IP地址和端点	499
12.2.6  同步socket处理	500
12.2.7  异步socket处理	502
12.2.8  查询网络地址	506
12.2.9  高级议题	507
12.3  总结	511
第13章  编程语言支持	513
13.1  python库概述	513
13.1.1  Python语言简介	514
13.1.2  安装Python环境	515
13.1.3  编译python库	515
13.1.4  使用python库	516
13.2  嵌入Python	517
13.2.1  初始化解释器	517
13.2.2  封装Python对象	518
13.2.3  执行Python语句	520
13.2.4  异常处理	521
13.3  扩展Python	522
13.3.1  最简单的例子	523
13.3.2  导出函数	525
13.3.3  导出重载函数	526
13.3.4  导出类	528
13.3.5  导出类的更多细节	530
13.3.6  高级议题	532
13.4  总结	534
第14章  其他Boost组件	537
14.1  字符串和文本处理	537
14.2  容器与数据结构	538
14.3  迭代器	539
14.4  函数对象与高级编程	539
14.5  泛型编程	540
14.6  模板元编程	541
14.7  预处理元编程	542
14.8  并发编程	542
14.9  数学与数字	543
14.10  TR1实现	543
14.11  输入输出	544
14.12  杂项	544
14.13  总结	546
第15章  Boost与设计模式	547
15.1  创建型模式	547
15.2  结构型模式	549
15.3  行为模式	552
15.4  其他模式	555
15.5  总结	556
第16章  结束语	559
16.1  未臻完美的Boost	559
16.2  让Boost工作得更好	560
16.3  工夫在诗外	563
附录A  推荐书目	565
附录B  网络资源	567
附录C  C++标准简述	569
附录D  STL简述	571
附录E  ref_array实现代码	573
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>男性气概
前　言………………………………………………………………………………………………
第一章　性别中立社会……………………………………………………………………………
第二章　流俗看法中的男性气概…………………………………………………………………
第三章　具有男性气概的坚定主张………………………………………………………………
第四章　具有男性气概的虚无主义………………………………………………………………
第五章　女性的虚无主义…………………………………………………………………………
第六章　具有男性气概的自由主义者……………………………………………………………
第七章　具有男性气概的德行……………………………………………………………………
结　论　未得到应用的男性气概…………………………………………………………………
参考文献……………………………………………………………………………………………
索　引………………………………………………………………………………………………
译后记………………………………………………………………………………………………

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>男性气概
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>社会学的想象力
第一章 前景
第二章 宏大理论
第三章 抽象经验主义
第四章 形形色色的实用性
第五章 科层制气质
第六章 科学哲学
第七章 人类的多样性
第八章 对历史的运用
第九章 论理性和自由
第十章 论政治
附录：论治学之道
致谢
索引
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>社会学的想象力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>惊悦
译者前言
第一章 人之初
第二章 集中营
第三章 蒙特布莱肯与坎贝尔
第四章 拓展心智
第五章 文艺复兴
第六章 血青族
第七章 光与影
第八章 解脱
第九章 伟大的诺克
第十章 命运的垂青
第十一章 戛然而止
第十二章 枪炮和战友
第十三章 新视角
第十四章 将！
第十五章 开端
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>惊悦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言编程魔法书
前言
第一篇　预备知识篇
第1章	C魔法概览 /2
1.1　例说编程语言 2
1.2　用C语言编程的基本注意事项 6
1.3　主流C语言编译器介绍 8
1.4　关于GNU规范的语法扩展 10
1.5　用C语言构建一个可执行程序的流程 11
1.6　本章小结 12
第2章	学习C语言的预备知识 /14
2.1　计算机体系结构简介 14
2.1.1　贮存器 15
2.1.2　存储器 15
2.1.3　寄存器 16
2.1.4　计算单元 16
2.1.5　程序执行流程 16
2.2　整数在计算机中的表示 17
2.2.1　原码表示法 18
2.2.2　补码表示法 19
2.2.3　八进制数与十六进制数 20
2.3　浮点数在计算机中的表示 22
2.4　地址与字节对齐 24
2.5　字符编码 25
2.6　大端与小端 28
2.7　按位逻辑运算 28
2.8　移位操作 30
2.8.1　算术左移与逻辑左移 30
2.8.2　逻辑右移 30
2.8.3　算术右移 31
2.8.4　循环右移 32
2.9　本章小结 32
第3章	C语言编程的环境搭建 /33
3.1　Windows操作系统下搭建C语言编程环境 33
3.1.1　安装Visual Studio Community 2017 34
3.1.2　安装MinGW编译器 40
3.1.3　安装LLVM Clang编译器 43
3.2　macOS系统下搭建C语言编程环境 45
3.3　本章小结 51
第二篇　基础语法篇
第4章	C语言中的基本元素 /54
4.1　C语言中的字符集 55
4.2　C语言中的token 56
4.2.1　C语言中的标识符 57
4.2.2　C语言中的关键字 58
4.2.3　C语言中的常量与字符串字面量 60
4.2.4　C语言中的标点符号 60
4.3　关于C语言中的“对象” 62
4.4　C语言中的“副作用” 63
4.5　C语言标准库中的printf函数 63
4.6　本章小结 65
第5章	基本数据类型 /66
5.1　整数类型 66
5.1.1　int类型 67
5.1.2　short类型 68
5.1.3　long类型 69
5.1.4　long long类型 71
5.1.5　布尔类型 72
5.1.6　字符类型 73
5.1.7　宽字符以及Unicode字符类型 77
5.1.8　size_t与ptrdiff_t类型 81
5.1.9　C语言中的标准整数类型 82
5.2　浮点类型 84
5.3　数据精度与类型转换 86
5.3.1　整数晋升 87
5.3.2　带符号与无符号整数之间的转换 87
5.3.3　浮点数与浮点数的转换以及浮点数与整数之间的转换 90
5.4　C语言基本运算操作符 92
5.4.1　加、减、乘、除与求模运算操作符 92
5.4.2　按位逻辑操作符 93
5.4.3　自增、自减操作符 94
5.4.4　关系操作符、相等性操作符与逻辑操作符 95
5.4.5　移位操作符 96
5.4.6　圆括号操作符 97
5.5　sizeof操作符 98
5.6　投射操作符 99
5.7　本章小结 101
第6章	用户自定义类型 /102
6.1　枚举类型 102
6.2　结构体类型 105
6.2.1　结构体概述 105
6.2.2　用结构体创建对象并访问其成员 107
6.2.3　结构体复合字面量 110
6.3　联合体类型 113
6.4　位域 117
6.4.1　位域的一般特性 118
6.4.2　位域成员的存放与布局 120
6.4.3　匿名位域 122
6.4.4　位域使用示例 124
6.5　字节对齐与字节填充 125
6.5.1　_Alignof操作符 125
6.5.2　_Alignas对齐说明符 126
6.5.3　结构体成员的字节对齐与字节填充 129
6.6　复数类型 133
6.7　本章小结 135
第7章	C语言的数组与指针 /136
7.1　一维数组 136
7.2　多维数组 141
7.3　变长数组 145
7.4　一级指针与对象地址 147
7.4.1　地址与指针的基本概念 148
7.4.2　访问指针对象所指对象的内容 149
7.4.3　指针对象的其他操作 150
7.5　多级指针 153
7.6　指向用户自定义类型的指针 156
7.7　指针与数组的关系 159
7.8　指向数组的指针 162
7.9　void类型、指向void类型的指针与空指针 165
7.10　字符数组与字符串字面量 167
7.11　完整与不完整类型 170
7.12　灵活的数组成员 171
7.13　本章小结 173
第8章	C语言的控制流语句 /174
8.1　逗号表达式 174
8.2　条件表达式 176
8.3　if-else语句 176
8.4　switch-case语句 179
8.5　while与do-while迭代语句 182
8.6　for迭代语句 187
8.7　goto语句 189
8.8　本章小结 192
第9章	C语言的函数 /193
9.1　函数的声明与定义 194
9.2　函数调用与实现 196
9.2.1　函数调用的顺序点 197
9.2.2　函数的栈空间 200
9.2.3　函数的参数传递与返回 201
9.2.4　通过形参修改实参的值 204
9.3　数组类型作为函数形参 205
9.4　带有不定参数类型及个数的函数声明与调用 209
9.5　函数的递归调用 212
9.6　内联函数 218
9.7　函数的返回类型与无返回函数 221
9.8　指向函数的指针 223
9.9　C语言中的主函数main 226
9.10　函数与函数调用作为sizeof操作符 228
9.11　本章小结 229
第10章	C语言预处理器 /230
10.1　宏定义 231
10.1.1　宏的基本使用 232
10.1.2　宏定义中的#操作符 234
10.1.3　宏定义中的##操作符 236
10.1.4　宏替换 238
10.1.5　可变参数的宏定义 240
10.2　C语言中预定义的宏 243
10.2.1　C语言强制要求的预定义宏 243
10.2.2　环境宏 244
10.2.3　条件特征宏 245
10.2.4　主流编译器及平台预定义的宏 246
10.3　条件预编译 247
10.4　源文件包含预处理指示符 251
10.5　#error 预处理指示符 256
10.6　#line 预处理指示符 256
10.7　#undef 预处理指示符 257
10.8　pragma预编译指示符与操作符 258
10.9　空指示符与C语言中的程序注释 260
10.10　本章小结 262
第11章	C语言程序的编译上下文 /263
11.1　C语言程序中的作用域和名字空间 263
11.1.1　文件作用域 264
11.1.2　函数作用域 265
11.1.3　函数原型作用域 266
11.1.4　语句块作用域 267
11.1.5　标识符的重定义与作用域的叠交 269
11.1.6　标识符的名字空间 272
11.2　全局对象与函数 275
11.3　静态对象与函数 277
11.4　局部对象 280
11.5　对象的存储与生命周期 282
11.6　_Thread_local对象 285
11.7　本章小结 286
第三篇　高级语法篇
第12章	C语言中的类型限定符 /290
12.1　const限定符 290
12.1.1　const限定符修饰普通对象 291
12.1.2　const限定符修饰数组元素 293
12.1.3　const限定符修饰指针类型对象 294
12.1.4　const限定符修饰函数形参类型为数组的对象 299
12.1.5　类型限定符的本质含义 301
12.2　volatile限定符 302
12.3　restrict限定符 304
12.4　_Atomic限定符 307
12.5　本章小结 314
第13章	C语言的类型系统 /316
13.1　对象类型与函数类型 316
13.2　对声明符的进一步说明 318
13.3　更复杂的声明 322
13.3.1　将某一类型转换为指向该类型的指针 322
13.3.2　判定当前类型属于哪种对象类型 322
13.3.3　复杂复合类型的判断 324
13.4　typedef类型定义 327
13.4.1　typedef的一般使用 327
13.4.2　typedef与类型限定符相结合的使用 330
13.4.3　用typedef来定义结构体与联合体的类型 332
13.5　本章小结 335
第14章	C11标准中的表达式、左值与求值顺序 /336
14.1　常量表达式 338
14.2　泛型选择表达式 340
14.3　静态断言 343
14.4　C语言中的左值 344
14.5　C语言中表达式的求值顺序 348
14.6　C语言中的语句 352
14.7　本章小结 355
第15章	函数调用约定与ABI /356
15.1　Windows操作系统环境下x86处理器的函数调用约定 357
15.1.1　Windows操作系统下32位x86执行模式的函数调用约定 357
15.1.2　Windows操作系统下64位x86执行模式的函数调用约定 363
15.2　Unix/Linux操作系统环境下x86处理器的函数调用约定 368
15.3　ARM处理器环境下的函数调用约定 370
15.3.1　AArch32架构环境下的函数调用约定 370
15.3.2　AArch64架构环境下的函数调用约定 373
15.4　本章小结 375
第16章	创建静态库与动态库 /376
16.1　Windows系统下创建静态库与动态库 377
16.1.1　Windows系统下创建并使用静态库 377
16.1.2　Windows系统上创建并使用动态库 379
16.2　macOS系统下创建静态库与动态库 382
16.2.1　macOS系统下创建并使用静态库 383
16.2.2　macOS系统下创建并使用动态库 386
16.3　Linux系统下创建并使用静态库与动态库 390
16.3.1　Linux系统下创建并使用静态库文件 390
16.3.2　Linux系统下创建并使用动态库 391
16.4　本章小结 393
第四篇　语法扩展篇
第17章	GCC对C11标准的语法扩展 /396
17.1　在表达式中使用复合语句与声明 397
17.2　声明语句块作用域的跳转标签 398
17.3　跳转标签作为值 401
17.4　嵌套函数 402
17.5　使用typeof来获取对象类型 405
17.6　使用__auto_type做类型自动推导 409
17.7　对复数操作的扩展 411
17.8　半精度浮点类型 412
17.9　长度为零的数组 413
17.10　对可变参数个数的宏的语法扩展 415
17.11　case语句中使用范围表达式 417
17.12　投射到一个联合体类型 418
17.13　使用二进制整数字面量 419
17.14　使用__attribute__指定函数、对象与类型的属性 420
17.14.1　__attribute__用于修饰函数的属性 422
17.14.2　__attribute__用于修饰对象的属性 440
17.14.3　__attribute__用于修饰类型的属性 443
17.15　本章小结 444
第18章	Clang编译器对C11标准的扩展 /445
18.1　特征检查宏 446
18.2　_Nullable与_Nonnull 446
18.3　函数重载 448
18.4　Blocks语法 449
18.5　本章小结 462
第19章	对C语言的未来展望 /463
19.1　C语言中的属性 465
19.2　fallthrough属性 466
19.3　数组片段 467
19.3.1　数组片段的赋值操作 468
19.3.2　数组片段的算术计算操作 470
19.3.3　数组片段用于函数调用的情况 471
19.4　其他语法特性 472
19.5　本章小结 472
第五篇　项目实践篇
第20章	制作UTF-8与UTF-16编码字符串的转码器 /474
20.1　UTF-8字符编码格式 474
20.2　UTF-16字符编码格式 476
20.3　代码示例 478
20.4　本章小结 487
第21章	制作控制台计算器 /488
21.1　对数字的解析 489
21.2　对操作符的优先级处理 489
21.3　代码示例 491
21.4　本章小结 504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言编程魔法书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>意向立场
序言
一走好第一步
二真正的相信者：意向战略以及它为什么有效
反思：真实的模式、深层事实与空洞的问题
三 三类意向心理学
反思：工具主义的再思考
四理解我们自己
反思：青蛙（和其他动物）何时犯错
五超越信念
反思：关于关于性
六心理表征的类型
反思：思想语言的再思考
七认知动物行为学中的意向系统：对“邦葛罗斯范式”的辩护
反思：解释猴子、理论家和基因
八进化、错误和意向性
九快速思考
十期中考试：比较和对比
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>意向立场
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux程序设计
第1章 入门
1.1 UNIX、Linux和GNU简介
1.1.1 什么是UNIX
1.1.2 什么是Linux
1.1.3 GNU项目和自由软件基金会
1.1.4 Linux发行版
1.2 Linux程序设计
1.2.1 Linux程序
1.2.2 文本编辑器
1.2.3 C语言编译器
1.2.4 开发系统导引
1.3 获得帮助
1.4 小结
第2章 shell程序设计
2.1 为什么使用shell编程
2.2 一点哲学
2.3 什么是shell
2.4 管道和重定向
2.4.1 重定向输出
2.4.2 重定向输入
2.4.3 管道
2.5 作为程序设计语言的shell
2.5.1 交互式程序
2.5.2 创建脚本
2.5.3 把脚本设置为可执行
2.6 shell的语法
2.6.1 变量
2.6.2 条件
2.6.3 控制结构
2.6.4 函数
2.6.5 命令
2.6.6 命令的执行
2.6.7 here文档
2.6.8 调试脚本程序
2.7 迈向图形化：dialog工具
2.8 综合应用
2.8.1 需求
2.8.2 设计
2.8.3 应用程序的说明
2.9 小结
第3章 文件操作
3.1 Linux文件结构
3.1.1 目录
3.1.2 文件和设备
3.2 系统调用和设备驱动程序
3.3 库函数
3.4 底层文件访问
3.4.1 write系统调用
3.4.2 read系统调用
3.4.3 open系统调用
3.4.4 访问权限的初始值
3.4.5 其他与文件管理有关的系统调用
3.5 标准I/O库
3.5.1 fopen函数
3.5.2 fread函数
3.5.3 fwrite函数
3.5.4 fclose函数
3.5.5 fflush函数
3.5.6 fseek函数
3.5.7 fgetc、getc和getchar函数
3.5.8 fputc、putc和putchar函数
3.5.9 fgets和gets函数
3.6 格式化输入和输出
3.6.1 printf、fprintf和sprintf函数
3.6.2 scanf、fscanf和sscanf函数
3.6.3 其他流函数
3.6.4 文件流错误
3.6.5 文件流和文件描述符
3.7 文件和目录的维护
3.7.1 chmod系统调用
3.7.2 chown系统调用
3.7.3 unlink、link和symlink系统调用
3.7.4 mkdir和rmdir系统调用
3.7.5 chdir系统调用和getcwd函数
3.8 扫描目录
3.8.1 opendir函数
3.8.2 readdir函数
3.8.3 telldir函数
3.8.4 seekdir函数
3.8.5 closedir函数
3.9 错误处理
3.9.1 strerror函数
3.9.2 perror函数
3.10 /proc文件系统
3.11 高级主题：fcntl和mmap
3.11.1 fcntl系统调用
3.11.2 mmap函数
3.12 小结
第4章 Linux环境
4.1 程序参数
4.1.1 getopt
4.1.2 getopt_long
4.2 环境变量
4.2.1 环境变量的用途
4.2.2 environ变量
4.3 时间和日期
4.4 临时文件
4.5 用户信息
4.6 主机信息
4.7 日志
4.8 资源和限制
4.9 小结
第5章 终端
5.1 对终端进行读写
5.2 与终端进行对话
5.3 终端驱动程序和通用终端接口
5.3.1 概述
5.3.2 硬件模型
5.4 termios结构
5.4.1 输入模式
5.4.2 输出模式
5.4.3 控制模式
5.4.4 本地模式
5.4.5 特殊控制字符
5.4.6 终端速度
5.4.7 其他函数
5.5 终端的输出
5.5.1 终端的类型
5.5.2 识别终端类型
5.5.3 使用terminfo功能标志
5.6 检测击键动作
5.7 虚拟控制台
5.8 伪终端
5.9 小结
第6章 使用curses函数库管理基于文本的屏幕
6.1 用curses函数库进行编译
6.2 curses术语和概念
6.3 屏幕
6.3.1 输出到屏幕
6.3.2 从屏幕读取
6.3.3 清除屏幕
6.3.4 移动光标
6.3.5 字符属性
6.4 键盘
6.4.1 键盘模式
6.4.2 键盘输入
6.5 窗口
6.5.1 WINDOW结构
6.5.2 通用函数
6.5.3 移动和更新窗口
6.5.4 优化屏幕刷新
6.6 子窗口
6.7 keypad模式
6.8 彩色显示
6.9 pad
6.10 CD唱片应用程序
6.10.1 新CD唱片应用程序的开始部分
6.10.2 main函数
6.10.3 建立菜单
6.10.4 操作数据库文件
6.10.5 查询CD数据库
6.11 小结
第7章 数据管理
7.1 内存管理
7.1.1 简单的内存分配
7.1.2 分配大量的内存
7.1.3 滥用内存
7.1.4 空指针
7.1.5 释放内存
7.1.6 其他内存分配函数
7.2 文件锁定
7.2.1 创建锁文件
7.2.2 区域锁定
7.2.3 锁定状态下的读写操作
7.2.4 文件锁的竞争
7.2.5 其他锁命令
7.2.6 死锁
7.3 数据库
7.3.1 dbm数据库
7.3.2 dbm例程
7.3.3 dbm访问函数
7.3.4 其他dbm函数
7.4 CD唱片应用程序
7.4.1 更新设计
7.4.2 使用dbm数据库的CD唱片应用程序
7.5 小结
第8章 MySQL
8.1 安装
8.1.1 MySQL软件包
8.1.2 安装后的配置
8.1.3 安装后的故障修复
8.2 MySQL管理
8.2.1 命令
8.2.2 创建用户并赋予权限
8.2.3 密码
8.2.4 创建数据库
8.2.5 数据类型
8.2.6 创建表
8.2.7 图形化工具
8.3 使用C语言访问MySQL数据
8.3.1 连接例程
8.3.2 错误处理
8.3.3 执行SQL语句
8.3.4 更多的函数
8.4 CD数据库应用程序
8.4.1 创建表
8.4.2 添加数据
8.4.3 使用C语言访问数据
8.5 小结
第9章 开发工具
9.1 多个源文件带来的问题
9.2 make命令和makefile文件
9.2.1 makefile的语法
9.2.2 make命令的选项和参数
9.2.3 makefile文件中的注释
9.2.4 makefile文件中的宏
9.2.5 多个目标
9.2.6 内置规则
9.2.7 后缀和模式规则
9.2.8 用make管理函数库
9.2.9 高级主题：makefile文件和子目录
9.2.10 GNU make和gcc
9.3 源代码控制
9.3.1 RCS
9.3.2 SCCS
9.3.3 RCS和SCCS的比较
9.3.4 CVS
9.3.5 CVS的前端程序
9.3.6 Subversion
9.4 编写手册页
9.5 发行软件
9.5.1 patch程序
9.5.2 其他软件发行工具
9.6 RPM软件包
9.6.1 使用RPM软件包文件
9.6.2 安装RPM软件包
9.6.3 创建RPM软件包
9.7 其他软件包格式
9.8 开发环境
9.8.1 KDevelop
9.8.2 其他开发环境
9.9 小结
第10章 调试
10.1 错误类型
10.2 常用调试技巧
10.2.1 有漏洞的程序
10.2.2 代码检查
10.2.3 取样法
10.2.4 程序的受控执行
10.3 使用gdb进行调试
10.3.1 启动gdb
10.3.2 运行一个程序
10.3.3 栈跟踪
10.3.4 检查变量
10.3.5 列出程序源代码
10.3.6 设置断点
10.3.7 用调试器打补丁
10.3.8 深入学习gdb
10.4 其他调试工具
10.4.1 lint：清理程序中的“垃圾”
10.4.2 函数调用工具
10.4.3 用prof/gprof产生执行存档
10.5 断言
10.6 内存调试
10.6.1 ElectricFence函数库
10.6.2 valgrind
10.7 小结
第11章 进程和信号
11.1 什么是进程
11.2 进程的结构
11.2.1 进程表
11.2.2 查看进程
11.2.3 系统进程
11.2.4 进程调度
11.3 启动新进程
11.3.1 等待一个进程
11.3.2 僵尸进程
11.3.3 输入和输出重定向
11.3.4 线程
11.4 信号
11.4.1 发送信号
11.4.2 信号集
11.5 小结
第12章 POSIX线程
12.1 什么是线程
12.2 线程的优点和缺点
12.3 第一个线程程序
12.4 同时执行
12.5 同步
12.5.1 用信号量进行同步
12.5.2 用互斥量进行同步
12.6 线程的属性
12.7 取消一个线程
12.8 多线程
12.9 小结
第13章 进程间通信：管道
13.1 什么是管道
13.2 进程管道
13.3 将输出送往popen
13.3.1 传递更多的数据
13.3.2 如何实现popen
13.4 pipe调用
13.5 父进程和子进程
13.5.1 管道关闭后的读操作
13.5.2 把管道用作标准输入和标准输出
13.6 命名管道：FIFO
13.6.1 访问FIFO文件
13.6.2 高级主题：使用FIFO的客户/服务器应用程序
13.7 CD数据库应用程序
13.7.1 目标
13.7.2 实现
13.7.3 客户接口函数
13.7.4 服务器接口server.c
13.7.5 管道
13.7.6 对CD数据库应用程序的总结
13.8 小结
第14章 信号量、共享内存和消息队列
14.1 信号量
14.1.1 信号量的定义
14.1.2 一个理论性的例子
14.1.3 Linux的信号量机制
14.1.4 使用信号量
14.2 共享内存
14.2.1 shmget函数
14.2.2 shmat函数
14.2.3 shmdt
14.2.4 shmctl
14.3 消息队列
14.3.1 msgget函数
14.3.2 msgsnd函数
14.3.3 msgrcv函数
14.3.4 msgctl函数
14.4 CD数据库应用程序
14.4.1 修改服务器函数
14.4.2 修改客户函数
14.5 IPC状态命令
14.5.1 显示信号量状态
14.5.2 显示共享内存状态
14.5.3 显示消息队列状态
14.6 小结
第15章 套接字
15.1 什么是套接字
15.2 套接字连接
15.2.1 套接字属性
15.2.2 创建套接字
15.2.3 套接字地址
15.2.4 命名套接字
15.2.5 创建套接字队列
15.2.6 接受连接
15.2.7 请求连接
15.2.8 关闭套接字
15.2.9 套接字通信
15.2.10 主机字节序和网络字节序
15.3 网络信息
15.3.1 因特网守护进程(xinetd/inetd)
15.3.2 套接字选项
15.4 多客户
15.4.1 select系统调用
15.4.2 多客户
15.5 数据报
15.6 小结
第16章 用GTK+进行GNOME编程
16.1 X视窗系统简介
16.1.1 X服务器
16.1.2 X客户端
16.1.3 X协议
16.1.4 Xlib库
16.1.5 X工具包
16.1.6 窗口管理器
16.1.7 创建GUI的其他方法——平台无关的窗囗API
16.2 GTK+简介
16.2.1 GLib类型系统
16.2.2 GTK+对象系统
16.2.3 GNOME简介
16.2.4 安装GNOME/GTK+开发库
16.3 事件、信号和回调函数
16.4 组装盒构件
16.5 GTK+构件
16.5.1 GtkWindow
16.5.2 GtkEntry
16.5.3 GtkSpinButton
16.5.4 GtkButton
16.5.5 GtkTreeView
16.6 GNOME构件
16.7 GNOME菜单
16.8 对话框
16.8.1 GtkDialog
16.8.2 模式对话框
16.8.3 非模式对话框
16.8.4 GtkMessageDialog
16.9 CD数据库应用程序
16.10 小结
第17章 用Qt进行KDE编程
17.1 KDE和Qt简介
17.2 安装Qt
17.3 信号和槽
17.4 Qt构件
17.4.1 QLineEdit
17.4.2 Qt按钮
17.4.3 QComboBox
17.4.4 QListView
17.5 对话框
17.5.1 QDialog
17.5.2 QMessageBox
17.5.3 QInputDialog
17.5.4 使用qmake简化makefile文件的编写
17.6 KDE的菜单和工具栏
17.7 使用KDE/Qt编写CD数据库应用程序
17.7.1 主窗口
17.7.2 AddCdDialog
17.7.3 LogonDialog
17.7.4 main.cpp
17.8 小结
第18章 Linux标准
18.1 C编程语言
18.1.1 发展历史简介
18.1.2 GNU编译器集
18.1.3 gcc选项
18.2 接口和LSB
18.2.1 LSB标准函数库
18.2.2 LSB用户和组
18.2.3 LSB系统初始化
18.3 文件系统层次结构标准
18.4 更多标准
18.5 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>投资分析与组合管理
上册  第一部分 投资背景知识    第1章 投资环境设定    第2章 资产配置决策    第3章 在全球市场选择投资工具    第4章 证券市场的组织与运作    第5章 证券市场指数  第二部分 投资理论的发展    第6章 有效资本市场    第7章 资产组合管理导论    第8章 资产定价模型导论    第9章 风险与收益率的多因子模型  第三部分 估值原理与实践    第10章 财务报表分析    第11章 证券估值导论  第四部分 普通股股票的分析与管理    第12章 股票市场的宏观分析和微观估值    第13章 行业分析    第14章 公司分析与股票估值    第15章 技术分析    第16章 股票组合管理策略下册  第五部分 债券分析与管理    第17章 债券基础知识    第18章 债券分析与估值    第19章 债券组合管理策略  第六部分 衍生证券分析    第20章 衍生市场与衍生证券导论    第21章 远期和期货合约    第22章 期权合约    第23章 互换合约、可转换证券和其他嵌入式金融衍生工具  第七部分 资产管理规范与评估    第24章 专业资产管理    第25章 投资组合业绩评估  附录全部参考文献列表词汇表索引后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>投资分析与组合管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>我们为什么会生病
第1章  疾病之谜
第2章  自然选择产生的演化
第3章  感染病的体征和症状
第4章  不断升级的“军备竞赛”
第5章  受伤
第6章  毒素：生生不息，无处不在
第7章  基因与疾病：缺陷、脱轨以及妥协
第8章  衰老是青春的代价
第9章  演化的历史遗产
第10章  文明病
第11章  过敏反应
第12章  癌症
第13章  性与生育
第14章  精神病是病吗
第 15章  医学的演化
注释
再版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>我们为什么会生病
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>CLR via C#
第1部分CLR基础
第1章CLR的执行模型
第2章生成、打包、部署和管理应用程序及类型
第3章共享程序集和强命名程序集
第2部分设计类型
第4章类型基础
第5章基元类型、引用类型和值类型
第6章类型和成员基础
第7章常量和字段
第8章方法
第9章参数
第10章属性
第11章事件
第12章泛型
第13章接口
第3部分基本类型
第14章字符、字符串和文本处理
第15章枚举类型和位标志
第16章数组
第17章委托
第18章定制特性
第19章可空值类型
第4部分核心机制
第20章异常和状态管理
第21章托管堆和垃圾回收
第22章CLR寄宿和AppDomain
第23章程序集加载和反射
第24章运行时序列化
第25章与WinRT组件互操作
第5部分线程处理
第26章线程基础
第27章计算限制的异步操作
第28章I/O限制的异步操作
第29章基元线程同步构造
第30章混合线程同步构造
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>CLR via C#
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
第一部分　敏捷开发
第1章　敏捷实践
1.1　敏捷联盟
1.1.1　人和交互重于过程和工具
1.1.2　可以工作的软件重于面面俱到的文档
1.1.3　客户合作重于合同谈判
1.1.4　随时应对变化重于遵循计划
1.2　原则
1.3　结论
1.4　参考文献
第2章　极限编程概述
2.1　极限编程实践
2.1.1　完整团队
2.1.2　用户故事
2.1.3　短交付周期
2.1.4　验收测试
2.1.5　结对编程
2.1.6　测试驱动开发
2.1.7　集体所有权
2.1.8　持续集成
2.1.9　可持续的开发速度
2.1.10　开放的工作空间
2.1.11　计划游戏
2.1.12　简单设计
2.1.13　重构
2.1.14　隐喻
2.2　结论
2.3　参考文献
第3章　计划
3.1　初始探索
3.2　发布计划
3.3　迭代计划
3.4　定义“完成”
3.5　任务计划
3.6　迭代
3.7　跟踪
3.8　结论
3.9　参考文献
第4章　测试
4.1　测试驱动开发
4.1.1　测试优先设计的例子
4.1.2　测试促使模块之间隔离
4.1.3　意外获得的解耦合
4.2　验收测试
4.3　意外获得的构架
4.4　结论
4.5　参考文献
第5章　重构
5.1　素数产生程序：一个简单的重构示例
5.1.1　单元测试
5.1.2　重构
5.1.3　最后审视
5.2　结论
5.3　参考文献
第6章　一次编程实践
6.1　保龄球比赛
6.2　结论
第二部分　敏捷设计
第7章　什么是敏捷设计
7.1　设计臭味
7.1.1　设计臭味——腐化软件的气味
7.1.2　僵化性
7.1.3　脆弱性
7.1.4　顽固性
7.1.5　粘滞性
7.1.6　不必要的复杂性
7.1.7　不必要的重复
7.1.8　晦涩性
7.2　软件为何会腐化
7.3　Copy程序
7.3.1　熟悉的场景
7.3.2　Copy程序的敏捷设计
7.4　结论
7.5　参考文献
第8章　SRP：单一职责原则
8.1　定义职责
8.2　分离耦合的职责
8.3　持久化
8.4　结论
8.5　参考文献
第9章　OCP：开放－封闭原则
9.1　OCP概述
9.2　Shape应用程序
9.2.1　违反OCP
9.2.2　遵循OCP
9.2.3　预测变化和“贴切的”结构
9.2.4　放置吊钩
9.2.5　使用抽象获得显式封闭
9.2.6　使用“数据驱动”的方法获取封闭性
9.3　结论
9.4　参考文献
第10章　LSP：Liskov替换原则
10.1　违反LSP的情形
10.1.1　简单例子
10.1.2　更微妙的违反情形
10.1.3　实际的例子
10.2　用提取公共部分的方法代替继承
10.3　启发式规则和习惯用法
10.4　结论
10.5　参考文献
第11章　DIP：依赖倒置原则
11.1　层次化
11.1.1　倒置的接口所有权
11.1.2　依赖于抽象
11.2　简单的DIP示例
11.3　熔炉示例
11.4　结论
11.5　参考文献
第12章　ISP：接口隔离原则
12.1　接口污染
12.2　分离客户就是分离接口
12.3　类接口与对象接口
12.3.1　使用委托分离接口
12.3.2　使用多重继承分离接口
12.4　ATM用户界面的例子
12.5　结论
12.6　参考文献
第13章　C#程序员UML概观
13.1　类图
13.2　对象图
13.3　顺序图
13.4　协作图
13.5　状态图
13.6　结论
13.7　参考文献
第14章　使用UML
14.1　为什么建模
14.1.1　为什么构建软件模型
14.1.2　编码前应该构建面面俱到的设计吗
14.2　有效使用UML
14.2.1　与他人交流
14.2.2　脉络图
14.2.3　项目结束文档
14.2.4　要保留的和要丢弃的
14.3　迭代式改进
14.3.1　行为优先
14.3.2　检查结构
14.3.3　想象代码
14.3.4　图的演化
14.4　何时以及如何绘制图示
14.4.1　何时要画图，何时不要画图
14.4.2　CASE 工具
14.4.3　那么，文档呢
14.5　结论
第15章　状态图
15.1　基础知识
15.1.1　特定事件
15.1.2　超状态
15.1.3　初始伪状态和结束伪状态
15.2　使用FSM图示
15.3　结论
第16章　对象图
16.1　即时快照
16.2　主动对象
16.3　结论
第17章　用例
17.1　编写用例
17.1.1　备选流程
17.1.2　其他东西呢
17.2　用例图
17.3　结论
17.4　参考文献
第18章　顺序图
18.1　基础知识
18.1.1　对象、生命线、消息及其他
18.1.2　创建和析构
18.1.3　简单循环
18.1.4　时机和场合
18.2　高级概念
18.2.1　循环和条件
18.2.2　耗费时间的消息
18.2.3　异步消息
18.2.4　多线程
18.2.5　主动对象
18.2.6　向接口发送消息
18.3　结论
第19章　类图
19.1　基础知识
19.1.1　类
19.1.2　关联
19.1.3　继承
19.2　类图示例
19.3　细节
19.3.1　类衍型
19.3.2　抽象类
19.3.3　属性
19.3.4　聚集
19.3.5　组合
19.3.6　多重性
19.3.7　关联衍型
19.3.8　内嵌类
19.3.9　关联类
19.3.10　关联修饰符
19.4　结论
19.5　参考文献
第20章　咖啡的启示
20.1　Mark IV型专用咖啡机
20.1.1　规格说明书
20.1.2　常见的丑陋方案
20.1.3　虚构的抽象
20.1.4　改进方案
20.1.5　实现抽象模型
20.1.6　这个设计的好处
20.2　面向对象过度设计
20.3　参考文献
第三部分　薪水支付案例研究
第21章　COMMAND模式和ACTIVE OBJECT模式：多功能与多任务
21.1　简单的Command
21.2　事务
21.2.1　实体上解耦和时间上解耦
21.2.2　时间上解耦
21.3　Undo()方法
21.4　ACTIVE OBJECT模式
21.5　结论
21.6　参考文献
第22章　TEMPLATE METHOD模式和STRATEGY模式：继承和委托
22.1　TEMPLATE METHOD模式
22.1.1　滥用模式
22.1.2　冒泡排序
22.2　STRATEGY模式
22.3　结论
22.4　参考文献
第23章　FACADE模式和MEDIATOR模式
23.1　FACADE模式
23.2　MEDIATOR模式
23.3　结论
23.4　参考文献
第24章　SINGLETON模式和MONOSTATE模式
24.1　SINGLETON模式
24.1.1　SINGLETON模式的好处
24.1.2　SINGLETON模式的代价
24.1.3　运用SINGLETON模式
24.2　MONOSTATE模式
24.2.1　MONOSTATE模式的好处
24.2.2　MONOSTATE模式的代价
24.2.3　运用MONOSTATE模式
24.3　结论
24.4　参考文献
第25章　NULL OBJECT模式
25.1　描述
25.2　结论
25.3　参考文献
第26章　薪水支付案例研究：第一次迭代开始
26.1　初步的规格说明
26.2　基于用例分析
26.2.1　增加新雇员
26.2.2　删除雇员
26.2.3　登记考勤卡
26.2.4　登记销售凭条
26.2.5　登记工会服务费
26.2.6　更改雇员明细
26.2.7　发薪日
26.3　反思：找出底层的抽象
26.3.1　雇员支付类别抽象
26.3.2　支付时间表抽象
26.3.3　支付方式
26.3.4　从属关系
26.4　结论
26.5　参考文献
第27章　薪水支付案例研究：实现
27.1　事务
27.1.1　增加雇员
27.1.2　删除雇员
27.1.3　考勤卡、销售凭条以及服务费用
27.1.4　更改雇员属性
27.1.5　犯了什么晕
27.1.6　支付雇员薪水
27.1.7　支付领月薪的雇员薪水
27.1.8　支付钟点工薪水
27.2　主程序
27.3　数据库
27.4　结论
27.5　关于本章
27.6　参考文献
第四部分　打包薪水支付系统
第28章　包和组件的设计原则
28.1　包和组件
28.2　组件的内聚性原则：粒度
28.2.1　重用—发布等价原则
28.2.2　共同重用原则
28.2.3　共同封闭原则
28.2.4　组件内聚性总结
28.3　组件的耦合性原则：稳定性
28.3.1　无环依赖原则
28.3.2　稳定依赖原则
28.3.3　稳定抽象原则
28.4　结论
第29章　FACTORY模式
29.1　依赖问题
29.2　静态类型与动态类型
29.3　可替换的工厂
29.4　对测试支架使用对象工厂
29.5　工厂的重要性
29.6　结论
29.7　参考文献
第30章　薪水支付案例研究：包分析
30.1　组件结构和符号
30.2　应用CCP
30.3　应用REP
30.4　耦合和封装
30.5　度量
30.6　度量薪水支付应用程序
30.6.1　对象工厂
30.6.2　重新思考内聚的边界
30.7　最终的包结构
30.8　结论
30.9　参考文献
第31章　COMPOSITE模式
31.1　组合命令
31.2　多重性还是非多重性
31.3　结论
第32章　OBSERVER——演化至模式
32.1　数字时钟
32.2　OBSERVER模式
32.2.1　模型
32.2.2　面向对象设计原则的运用
32.3　结论
32.4　参考文献
第33章　ABSTRACT SERVER模式、 ADAPTER模式和BRIDGE模式
33.1　ABSTRACT SERVER模式
33.2　ADAPTER模式
33.2.1　类形式的ADAPTER模式
33.2.2　调制解调器问题、适配器以及LSP
33.3　BRIDGE模式
33.4　结论
33.5　参考文献
第34章　PROXY模式和GATEWAY模式：管理第三方API
34.1　PROXY模式
34.1.1　实现PROXY模式
34.1.2　小结
34.2　数据库、中间件以及其他第三方接口
34.3　TABLE DATA GATEWAY
34.3.1　测试和内存TDG
34.3.2　测试DbGateWay
34.4　可以用于数据库的其他模式
34.5　结论
34.6　参考文献
第35章　VISITOR模式
35.1　VISITOR模式
35.2　ACYCLIC VISITOR模式
35.3　DECORATOR模式
35.4　EXTENSION OBJECT模式
35.5　结论
35.6　参考文献
第36章　STATE模式
36.1　嵌套switch/case语句
36.1.1　内部作用域的状态变量
36.1.2　测试动作
36.1.3　代价和收益
36.2　迁移表
36.2.1　使用表解释
36.2.2　代价和收益
36.3　STATE模式
36.3.1　STATE模式和 STRATEGY模式
36.3.2　代价和收益
36.4　状态机编译器
36.4.1　SMC生成的Turnstile.cs以及其他支持文件
36.4.2　代价和收益
36.5　状态机应用的场合
36.5.1　作为GUI中的高层应用策略
36.5.2　GUI交互控制器
36.5.3　分布式处理
36.6　结论
36.7　参考文献
第37章　薪水支付案例研究：数据库
37.1　构建数据库
37.2　一个代码设计缺陷
37.3　增加雇员
37.4　事务
37.5　加载Employee对象
37.6　还有什么工作
第38章　薪水支付系统用户界面：Model-View-Presenter
38.1　界面
38.2　实现
38.3　构建窗口
38.4　Payroll窗口
38.5　真面目
38.6　结论
38.7　参考文献
附录A　双公司记
Rufus公司：“日落”项目
Rupert工业公司：“朝晖”项目
附录B　什么是软件
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>啊哈C！思考快你一步
第1章  编程改变思维	1
第1节  为什么要学习编程	1
第2节  本书是讲什么的、写给谁看的	4
第2章  梦想起航	7
第1节  编程的魔力	7
第2节  让计算机开口说话	9
第3节  多彩一点	18
第4节  让计算机做加法	21
第5节  数字的家——变量	25
第6节  数据输出——我说咋地就咋地	30
第7节  数据输入——我说算啥就算啥	33
第8节  究竟有多少种小房子	36
第9节  拨开云雾见月明	39
第10节  逻辑挑战1：交换小房子中的数	41
第11节  天啊！这怎么能看懂	44
第3章  较量才刚刚开始	48
第1节  大于、小于还是等于	48
第2节  判断正数	49
第3节  偶数判断	52
第4节  神器else	53
第5节  请告诉我谁大	55
第6节  逻辑挑战2：3个数怎么办	58
第7节  逻辑挑战3：我要排序	62
第8节  运算符总结	66
第9节  1＞2究竟对不对	67
第10节  讨厌的嵌套	69
第11节  if-else语法总结	72
第4章  重量级选手登场	74
第1节  永不停止的哭声	74
第2节  我说几遍就几遍	78
第3节  if对while说：我对你很重要	82
第4节  求和！求和！！求和！！！	85
第5节  逻辑挑战4：60秒倒计时开始	89
第6节  这个有点晕——循环嵌套来了	93
第7节  逻辑挑战5：奔跑的字母	97
第8节  究竟循环了多少次	101
第9节  逻辑挑战6：奔跑的小人	103
第10节  for隆重登场	107
第5章  好戏在后面	111
第1节  程序的3种结构	111
第2节  啰嗦一下	112
第3节  逻辑挑战7：判读质数很简单	113
第4节  更快一点：break	117
第5节  continue	119
第6节  逻辑挑战8：验证哥德巴赫猜想	120
第7节  逻辑挑战9：水仙花数	123
第8节  逻辑挑战10：解决奥数难题	127
第9节  逻辑挑战11：猜数游戏	130
第10节  逻辑挑战12：你好坏，关机啦	134
第6章  天啊！一大串数正在接近	136
第1节  逆序输出	136
第2节  申请100个小房子怎么办	137
第3节  100个数的逆序	139
第4节  逻辑挑战13：陶陶摘苹果	140
第5节  逻辑挑战14：一个萝卜一个坑	143
第6节  逻辑挑战15：选择排序	148
第7节  二维数组	151
第8节  剩下的一些东西	153
第7章  有了它你能做更多的事	157
第1节  字符的妙用	157
第2节  多余的回车键	159
第3节  字符的本质	162
第4节  人名怎么存储呢	163
第5节  逻辑挑战16：字母的排序	167
第6节  逻辑挑战17：字典序	169
第7节  多行字符	170
第8节  存储一个迷宫	173
第8章  游戏时间到了	176
第1节  走迷宫	176
第2节  推箱子	186
附录A  标识符命名规则	188
附录B  运算符的优先级和结合性	190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>啊哈C！思考快你一步
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>浪漫主义革命
【导论 定义浪漫】
【彩色插图】
【第一章 理性时代的危机 】
去万塞讷路上的卢梭
卢梭的恋人：从模仿的美学到表达的美学
自然与自然的法则
天才崇拜
艺术与艺术家独享的殿堂
庸俗大众
【第二章 明月的阴面】
梦与噩梦
神奇的夜世界
理性的昏睡
艺术家的鸦片
大智慧一定与疯癫相连
浪漫主义的男女主人公
【第三章 语言、历史与神话】
人民的语言
人民的历史
中世纪精神
风景与神话
保守派与革命派
【结论：消亡与变迁】
【注释】
【译者后记】
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>浪漫主义革命
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Essential C++中文版
满汉全席之外（译序/侯捷） ........................................................................................ v
前言Preface ................................................................................................................... xi
结构与组织 ............................................................................................................... xiii
关于源代码 ............................................................................................................... xiii
致谢 .......................................................................................................................... xiv
更多读物 ................................................................................................................... xiv
排版约定 .................................................................................................................... xv
第1 章 C++编程基础 Basic C++ Programming ........................................................... 1
1.1 如何撰写C++程序 ............................................................................................ 1
1.2 对象的定义与初始化 ......................................................................................... 7
1.3 撰写表达式 ....................................................................................................... 10
1.4 条件语句和循环语句 ....................................................................................... 15
1.5 如何运用Array 和Vector ................................................................................ 22
1.6 指针带来弹性 ................................................................................................... 26
1.7 文件的读写 ....................................................................................................... 30
第2 章 面向过程的编程风格 Procedural Programming ........................................ 35
2.1 如何编写函数 ................................................................................................... 35
2.2 调用函数 ........................................................................................................... 41
2.3 提供默认参数值 ............................................................................................... 50
2.4 使用局部静态对象 ........................................................................................... 53
2.5 声明inline 函数 ................................................................................................ 55
2.6 提供重载函数 ................................................................................................... 56
2.7 定义并使用模板函数 ....................................................................................... 58
2.8 函数指针带来更大的弹性 ............................................................................... 60
2.9 设定头文件 ....................................................................................................... 63
第3 章 泛型编程风格 Generic Programming ........................................................ 67
3.1 指针的算术运算 ............................................................................................... 68
3.2 了解Iterator（泛型指针） .............................................................................. 73
3.3 所有容器的共通操作 ....................................................................................... 76
3.4 使用顺序性容器 ............................................................................................... 77
3.5 使用泛型算法 ................................................................................................... 81
3.6 如何设计一个泛型算法 ................................................................................... 83
3.7 使用Map .......................................................................................................... 90
3.8 使用Set ............................................................................................................. 91
3.9 如何使用Iterator Inserter ................................................................................. 93
3.10 使用iostream Iterator ....................................................................................... 95
第4 章 基于对象的编程风格 Object-Based Programming ...................................... 99
4.1 如何实现一个Class ....................................................................................... 100
4.2 什么是构造函数和析构函数 ......................................................................... 104
4.3 何谓mutable（可变）和const（不变） .................................................. 109
4.4 什么是this 指针 ........................................................................................... 113
4.5 静态类成员 ..................................................................................................... 115
4.6 打造一个Iterator Class .................................................................................. 118
4.7 合作关系必须建立在友谊的基础上 ............................................................. 123
4.8 实现一个copy assignment operator ............................................................... 125
4.9 实现一个function object ................................................................................ 126
4.10 重载iostream 运算符 ..................................................................................... 128
4.11 指针，指向Class Member Function .............................................................. 130
第5 章 面向对象编程风格 Object-Oriented Programming ..................................... 135
5.1 面向对象编程概念 ......................................................................................... 135
5.2 漫游：面向对象编程思维 ............................................................................. 138
5.3 不带继承的多态 ............................................................................................. 142
5.4 定义一个抽象基类 ......................................................................................... 145
5.5 定义一个派生类 ............................................................................................. 148
5.6 运用继承体系 ................................................................................................. 155
5.7 基类应该多么抽象 ......................................................................................... 157
5.8 初始化、析构、复制 ..................................................................................... 158
5.9 在派生类中定义一个虚函数 ......................................................................... 160
5.10 运行时的类型鉴定机制 ................................................................................. 164
第6 章 以template 进行编程 Programming with Templates .................................... 167
6.1 被参数化的类型 ............................................................................................. 169
6.2 Class Template 的定义 ................................................................................... 171
6.3 Template 类型参数的处理 ............................................................................. 172
6.4 实现一个Class Template ............................................................................... 174
6.5 一个以Function Template 完成的Output 运算符 ........................................ 180
6.6 常量表达式与默认参数值 ............................................................................. 181
6.7 以Template 参数作为一种设计策略 ............................................................ 185
6.8 Member Template Function ............................................................................ 187
第7 章 异常处理 Exception Handling .................................................................. 191
7.1 抛出异常 ......................................................................................................... 191
7.2 捕获异常 ......................................................................................................... 193
7.3 提炼异常 ......................................................................................................... 194
7.4 局部资源管理 ................................................................................................. 198
7.5 标准异常 ......................................................................................................... 200
附录A 习题解答 Exercises Solutions ............................................................................ 205
附录B 泛型算法参考手册 Generic Algorithms Handbook .................................. 255
附录C 中英术语对照 侯捷 ..................................................................................... 271
英文术语的采用原则 .............................................................................................. 271
中英术语对照（按字母顺序排列） ...................................................................... 272
索引 Index ................................................................................................................. 277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Essential C++中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>世界哲学简史
序　　言
第一部分　世界秩序的追寻：古代哲学
第二部分　神与哲学家：宗教哲学与中世纪哲学
第三部分　在科学与宗教之间：现代哲学与启蒙运动
第四部分　20世纪：从现代主义到后现代主义
参考书目
人物年表
出版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>世界哲学简史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C高级编程
前言
第1章 C语言的探讨 1
1.1 C的编译链接与文件引用 3
1.1.1 一个小程序 3
1.1.2 链接与文件引用 5
1.2 函数、数据与作用域 8
1.2.1 全局函数与局部函数 8
1.2.2 数据与数据的类别 9
1.2.3 数据存储空间 11
1.3 类型与操作 17
1.3.1 基础类型及其操作和重定义 17
1.3.2 结构体类型 20
1.3.3 指针常量、指针与连续空间 21
1.3.4 函数接口类型、可变参类型和执行跳转 26
1.4 预处理操作 31
1.4.1 C语言的词法与预处理 31
1.4.2 宏判断的应用 37
1.4.3 宏定义与模板函数 40
1.4.4 预处理的杂项 43
1.4.5 宏与代码的自动化构建 47
1.5 小模块与函数内的模块化 52
1.5.1 参数判断小模块 52
1.5.2 goto与函数内的模块化 54
1.6 结束语 63
第2章 标准库、自有基础库与delog模块 64
2.1 标准库 65
2.1.1 assert.h、errno.h 66
2.1.2 setjmp.h跨函数的跳转 67
2.1.3 stdarg.h 69
2.1.4 stdio.h 74
2.1.5 stdlib.h 82
2.1.6 string.h 86
2.1.7 time.h 90
2.2 构建自有基础库 91
2.2.1 基础操作 93
2.2.2 char的表 99
2.2.3 UTF-8的基础表 106
2.2.4 慢一点的字符串操作 112
2.3 delog模块 118
2.3.1 实体模块 118
2.3.2 delog模块利用的系统库函数 119
2.4 结束语 133
第3章 make、工具与文档组织 134
3.1 依赖与make 135
3.2 自有工具库 146
3.2.1 lex/flex的入门应用 147
3.2.2 参数配置的子模块 153
3.2.3 自己构造自己的小工具 175
3.3 工程文档的组织 190
3.3.1 makefile的补充设计 190
3.3.2 模块目录与工具 193
3.3.3 整体的工程目录 203
3.4 结束语 211
第4章 抽象逻辑与虚拟模块、索引模块 213
4.1 抽象与宏 214
4.1.1 抽象的描述 214
4.1.2 抽象的对象与操作 217
4.1.3 抽象的函数 221
4.2 虚拟模块 228
4.2.1 抽象类型的定义 228
4.2.2 抽象操作和模板函数的组织方式 232
4.2.3 模板函数的引用 234
4.3 索引模块 241
4.3.1 索引链及其基础操作 243
4.3.2 索引模块的构建 246
4.3.3 索引节点的存储单元 249
4.4 结束语 252
第5章 空间资源的组织 253
5.1 资源的申请与利用 254
5.1.1 动态空间的获取 254
5.1.2 基于POSIX的共享空间 259
5.1.3 基于POSIX的信号量 263
5.2 连续空间的组织 268
5.2.1 连续空间的组织信息 270
5.2.2 通用数据空间类型_BUF与_P 272
5.3 两个空间管理模块 278
5.3.1 jx_buf模块 278
5.3.2 jx_sharebuf 的子模块 301
5.3.3 jx_sharebuf共享空间管理模块 309
5.4 结束语 320
第6章 数据的集合化组织 321
6.1 集合化空间的组织 323
6.1.1 集合的元素节点 324
6.1.2 集合的组织 325
6.1.3 节点空间的组织 329
6.2 虚拟模块jx_sets 331
6.2.1 jx_SetsType.h和jx_SetsDef.h 332
6.2.2 模板函数头文件jx_SetsTemp.h 334
6.2.3 模板化虚拟模块的实例 354
6.3 集合化空间的扩展 359
6.3.1 散列集合化空间的组织方式 359
6.3.2 散列集合化空间的操作 363
6.3.3 散列集合化空间的测试 370
6.4 结束语 373
第7章 复杂的数据集合化 375
7.1 树集合化空间 376
7.1.1 树的结构与基础操作 377
7.1.2 树集合化空间管理模块 382
7.1.3 相对复杂的树操作 392
7.2 有向关系集合化空间 399
7.2.1 有向关系结构与基础操作 400
7.2.2 关系集合化空间的基础操作 404
7.3 有向图的集合化空间 416
7.3.1 模块的类型和定义 418
7.3.2 模板函数 424
7.3.3 可配置的遍历与搜索 432
7.4 结束语 441
第8章 进程与通信 442
8.1 多进程的创建 443
8.1.1 使用fork创建进程 444
8.1.2 创建新会话 447
8.1.3 调整文件的关联 449
8.2 socket方式的进程间通信 452
8.2.1 socket通信 452
8.2.2 jx_socket模块 456
8.2.3 会话与测试 469
8.3 基于共享空间的进程间通信 472
8.3.1 基于共享空间的队列模式 473
8.3.2 基于共享空间的多端口模式 481
8.3.3 多端口模式的应用场景 492
8.4 结束语 496
第9章 模块化的系统设计 497
9.1 系统与模块 498
9.1.1 什么是系统 498
9.1.2 什么是模块 500
9.1.3 模块化与关联 503
9.2 模块化的分析与设计方法 506
9.2.1 角色与任务 506
9.2.2 框架与层次 509
9.2.3 协同对接与系统整合 511
9.3 C语言与模块化 512
9.3.1 进程与模块 513
9.3.2 模块封装与接口协议 516
9.3.3 各种模块与抽象、复用 519
9.4 结束语 521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C高级编程
第1章 自动引用计数　　1
1.1 　什么是自动引用计数　　2
1.2 　内存管理/引用计数　　2
1.2.1 　概要　　2
1.2.2 　内存管理的思考方式　　5
1.2.3 　alloc/retain/release/dealloc实现　　13
1.2.4 　苹果的实现　　17
1.2.5 　autorelease　　20
1.2.6 　autorelease实现　　24
1.2.7 　苹果的实现　　26
1.3 　ARC规则　　29
1.3.1 　概要　　29
1.3.2 　内存管理的思考方式　　30
1.3.3 　所有权修饰符　　30
1.3.4 　规则　　50
1.3.5 　属性　　62
1.3.6 　数组　　63
1.4 　ARC的实现　　65
1.4.1 　__strong修饰符　　65
1.4.2 　__weak修饰符　　67
1.4.3 　__autoreleasing修饰符　　75
1.4.4 　引用计数　　76
第2章 Blocks　　79
2.1 　Blocks概要　　80
2.1.1 　什么是Blocks　　80
2.2 　Blocks模式　　83
2.2.1 　Block语法　　83
2.2.2 　Block类型变量　　85
2.2.3 　截获自动变量值　　88
2.2.4 　__block说明符　　88
2.2.5 　截获的自动变量　　89
2.3 　Blocks的实现　　91
2.3.1 　Block的实质　　91
2.3.2 　截获自动变量值　　99
2.3.3 　__block说明符　　102
2.3.4 　Block存储域　　108
2.3.5 　__block变量存储域　　117
2.3.6 　截获对象　　121
2.3.7 　__block变量和对象　　126
2.3.8 　Block循环引用　　128
2.3.9 　copy/release　　134
第3章 Grand Central Dispatch　　137
3.1 　Grand Central Dispatch（GCD）概要　　138
3.1.1 　什么是GCD　　138
3.1.2 　多线程编程　　140
3.2 　GCD的API　　144
3.2.1 　Dispatch Queue　　144
3.2.2 　dispatch_queue_create　　147
3.2.3 　Main Dispatch Queue/Global Dispatch Queue　　150
3.2.4 　dispatch_set_target_queue　　153
3.2.5 　dispatch_after　　154
3.2.6 　Dispatch Group　　155
3.2.7 　dispatch_barrier_async　　157
3.2.8 　dispatch_sync　　160
3.2.9 　dispatch_apply　　161
3.2.10 　dispatch_suspend / dispatch_resume　　163
3.2.11 　Dispatch Semaphore　　164
3.2.12 　dispatch_once　　166
3.2.13 　Dispatch I/O　　167
3.3 　GCD实现　　169
3.3.1 　Dispatch Queue　　169
3.3.2 　Dispatch Source　　171
附录A 　ARC、Blocks、GCD使用范例　　176
附录B 　参考资料　　182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法笔记
前言
第1章 如何使用本书 1
1.1 本书的基本内容 1
1.2 如何选择编程语言和编译器 1
1.3 在线评测系统 2
1.4 常见的评测结果 3
1.5 如何高效地做题 4
第2章 C/C++快速入门 5
2.1 基本数据类型 7
2.1.1 变量的定义 7
2.1.2 变量类型 7
2.1.3 强制类型转换 11
2.1.4 符号常量和const常量 12
2.1.5 运算符 14
2.2 顺序结构 17
2.2.1 赋值表达式 17
2.2.2 使用scanf和printf输入/输出 18
2.2.3 使用getchar和putchar输入/输出字符 23
2.2.4 注释 24
2.2.5 typedef 24
2.2.6 常用math函数 25
2.3 选择结构 28
2.3.1 if语句 28
2.3.2 if语句的嵌套 31
2.3.3 switch语句 32
2.4 循环结构 34
2.4.1 while语句 34
2.4.2 do while语句 35
2.4.3 for语句 36
2.4.4 break和continue语句 38
2.5 数组 39
2.5.1 一维数组 39
2.5.2 冒泡排序 41
2.5.3 二维数组 43
2.5.4 memset——对数组中每一个元素赋相同的值 46
2.5.5 字符数组 47
2.5.6 string.h头文件 50
2.5.7 sscanf与sprintf 53
2.6 函数 55
2.6.1 函数的定义 55
2.6.2 再谈main函数 58
2.6.3 以数组作为函数参数 58
2.6.4 函数的嵌套调用 59
2.6.5 函数的递归调用 60
2.7 指针 61
2.7.1 什么是指针 61
2.7.2 指针变量 62
2.7.3 指针与数组 63
2.7.4 使用指针变量作为函数参数 65
2.7.5 引用 68
2.8 结构体（struct）的使用 70
2.8.1 结构体的定义 70
2.8.2 访问结构体内的元素 71
2.8.3 结构体的初始化 72
2.9 补充 74
2.9.1 cin与cout 74
2.9.2 浮点数的比较 75
2.9.3 复杂度 78
2.10 黑盒测试 80
2.10.1 单点测试 80
2.10.2 多点测试 80
第3章 入门篇（1）——入门模拟 85
3.1 简单模拟 85
3.2 查找元素 87
3.3 图形输出 89
3.4 日期处理 91
3.5 进制转换 93
3.6 字符串处理 95
第4章 入门篇（2）——算法初步 99
4.1 排序 99
4.1.1 选择排序 99
4.1.2 插入排序 100
4.1.3 排序题与sort函数的应用 101
4.2 散列 106
4.2.1 散列的定义与整数散列 106
4.2.2 字符串hash初步 109
4.3 递归 111
4.3.1 分治 111
4.3.2 递归 112
4.4 贪心 118
4.4.1 简单贪心 118
4.4.2 区间贪心 122
4.5 二分 124
4.5.1 二分查找 124
4.5.2 二分法拓展 131
4.5.3 快速幂 134
4.6 two pointers 137
4.6.1 什么是two pointers 137
4.6.2 归并排序 139
4.6.3 快速排序 142
4.7 其他高效技巧与算法 146
4.7.1 打表 146
4.7.2 活用递推 147
4.7.3 随机选择算法 149
第5章 入门篇（3）——数学问题 152
5.1 简单数学 152
5.2 最大公约数与最小公倍数 154
5.2.1 最大公约数 154
5.2.2 最小公倍数 156
5.3 分数的四则运算 156
5.3.1 分数的表示和化简 157
5.3.2 分数的四则运算 157
5.3.3 分数的输出 159
5.4 素数 159
5.4.1 素数的判断 160
5.4.2 素数表的获取 160
5.5 质因子分解 165
5.6 大整数运算 170
5.6.1 大整数的存储 170
5.6.2 大整数的四则运算 171
5.7 扩展欧几里得算法 176
5.8 组合数 181
5.8.1 关于n!的一个问题 181
5.8.2 组合数的计算 183
第6章 C++标准模板库（STL）介绍 191
6.1 vector的常见用法详解 191
6.2 set的常见用法详解 197
6.3 string的常见用法详解 202
6.4 map的常用用法详解 213
6.5 queue的常见用法详解 218
6.6 priority_queue的常见用法详解 221
6.7 stack的常见用法详解 227
6.8 pair的常见用法详解 230
6.9 algorithm头文件下的常用函数 232
6.9.1 max()、min()和abs() 232
6.9.2 swap() 233
6.9.3 reverse() 233
6.9.4 next_permutation() 234
6.9.5 fill() 235
6.9.6 sort() 235
6.9.7 lower_bound()和upper_bound() 242
第7章 提高篇（1）——数据结构专题（1） 245
7.1 栈的应用 245
7.2 队列的应用 251
7.3 链表处理 253
7.3.1 链表的概念 253
7.3.2 使用malloc函数或new运算符为链表结点分配内存空间 254
7.3.3 链表的基本操作 256
7.3.4 静态链表 260
第8章 提高篇（2）——搜索专题 269
8.1 深度优先搜索（DFS） 269
8.2 广度优先搜索（BFS） 274
第9章 提高篇（3）——数据结构专题（2） 283
9.1 树与二叉树 283
9.1.1 树的定义与性质 283
9.1.2 二叉树的递归定义 284
9.1.3 二叉树的存储结构与基本操作 285
9.2 二叉树的遍历 289
9.2.1 先序遍历 289
9.2.2 中序遍历 290
9.2.3 后序遍历 291
9.2.4 层序遍历 292
9.2.5 二叉树的静态实现 298
9.3 树的遍历 302
9.3.1 树的静态写法 302
9.3.2 树的先根遍历 303
9.3.3 树的层序遍历 303
9.3.4 从树的遍历看DFS与BFS 304
9.4 二叉查找树（BST） 310
9.4.1 二叉查找树的定义 310
9.4.2 二叉查找树的基本操作 310
9.4.3 二叉查找树的性质 314
9.5 平衡二叉树（AVL树） 319
9.5.1 平衡二叉树的定义 319
9.5.2 平衡二叉树的基本操作 320
9.6 并查集 328
9.6.1 并查集的定义 328
9.6.2 并查集的基本操作 328
9.6.3 路径压缩 330
9.7 堆 335
9.7.1 堆的定义与基本操作 335
9.7.2 堆排序 339
9.8 哈夫曼树 342
9.8.1 哈夫曼树 342
9.8.2 哈弗曼编码 345
第10章 提高篇（4）——图算法专题 347
10.1 图的定义和相关术语 347
10.2 图的存储 348
10.2.1 邻接矩阵 348
10.2.2 邻接表 348
10.3 图的遍历 350
10.3.1 采用深度优先搜索（DFS）法遍历图 350
10.3.2 采用广度优先搜索（BFS）法遍历图 359
10.4 最短路径 367
10.4.1 Dijkstra算法 367
10.4.2 Bellman-Ford算法和SPFA算法 391
10.4.3 Floyd算法 398
10.5 最小生成树 400
10.5.1 最小生成树及其性质 400
10.5.2 prim算法 401
10.5.3 kruskal算法 409
10.6 拓扑排序 414
10.6.1 有向无环图 414
10.6.2 拓扑排序 415
10.7 关键路径 417
10.7.1 AOV网和AOE网 417
10.7.2 最长路径 419
10.7.3 关键路径 419
第11章 提高篇（5）——动态规划专题 425
11.1 动态规划的递归写法和递推写法 425
11.1.1 什么是动态规划 425
11.1.2 动态规划的递归写法 425
11.1.3 动态规划的递推写法 426
11.2 最大连续子序列和 429
11.3 最长不下降子序列（LIS） 432
11.4 最长公共子序列（LCS） 434
11.5 最长回文子串 436
11.6 DAG最长路 439
11.7 背包问题 442
11.7.1 多阶段动态规划问题 442
11.7.2 01背包问题 443
11.7.3 完全背包问题 446
11.8 总结 447
第12章 提高篇（6）——字符串专题 449
12.1 字符串hash进阶 449
12.2 KMP算法 455
12.2.1 next数组 456
12.2.2 KMP算法 458
12.2.3 从有限状态自动机的角度看待KMP算法 463
第13章 专题扩展 465
13.1 分块思想 465
13.2 树状数组（BIT） 470
13.2.1 lowbit运算 470
13.2.2 树状数组及其应用 470
参考文献 481
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>伟大指挥家
前言
一、综述
二、从埃利亚斯·萨洛蒙到分权领导制
三、巴赫和亨德尔
四、海顿、莫扎特和贝多芬
五、乐团、调音和观众
六、指挥棒的到来
七、韦伯和斯蓬蒂尼
八、弗朗索瓦·安托万一阿伯内克
九、埃克托·柏辽兹
十、门德尔松和德国学派
十一、理查德．瓦格纳
十二、英格兰舞台
十三、弗朗兹·李斯特
十四、汉斯·冯·彪罗
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>伟大指挥家
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>华尔街证券分析：股票分析与公司估值（原书第2版）
丛书序
丛书序（英文版）
丛书介绍
致中国读者
序言
第一部分投 资 环 境
第1章为什么进行证券分析/2
证券分析的起源/2
并非盈利的保证/4
日常交易与证券分析/5
羊群效应与证券分析/5
趋势投资者/7
博弈论与证券分析/7
证券分析的前提/9
科学的方法/10
证券分析技巧/12
基本估值方法/12
其他估值方法/15
小结/16
第2章谁在从事证券分析和企业评估/18
证券公司及其分析师/19
大型的机构投资者/22
一门濒危的艺术？/23
指数基金和交易所交易基金/26
小型资产管理公司/26
评级机构/28
个人投资者：一个特殊的群体/29
企业价值评估/30
小结/30
第3章寻求公平的竞争环境/31
证券监管历史概述/33
最高监管机构：证券交易委员会/35
销售和交易行为/37
保证金管理/39
新发行股票的生命周期/40
小结/52
第4章信息的其他来源/53
商业媒体/54
免费的互联网/55
有偿服务的互联网/56
行业协会、咨询公司、政府出版物和金融组织/57
信用评级机构/57
证券公司研究报告/57
通讯社/58
独立专家服务/59
小结/59
第二部分证券分析及撰写研究报告
第5章为什么进行证券分析/62
证券分析的流程/63
研究报告范本/64
分析师的职责/65
层层递进的预测/66
选择股票来研究：自上而下与自下而上/68
有限的时间和资源/69
安全边际/69
小结/70
第6章行业分析/72
背景/73
行业分析解构/74
行业分类/75
外部因素/80
需求分析/86
行业研究中的供给分析/92
获利能力、定价和行业分析/93
国际竞争与市场/95
小结/97
第7章具体公司分析/98
系统方法和竞争优势/99
概述和业务描述/105
产品和市场部分/106
生产和分销/109
竞争分析/112
业务评论中的其他主题/113
小结/116
第8章公司财务报表分析/118
开始调查/119
分析的原始素材/120
财务报表分析手段的演变/121
基本方法展示/122
内曼·马库斯公司财务分析的总结/135
小结/137
第9章会计数据的局限性/138
基本会计问题/140
国际性问题/140
有关特定公司的问题/143
上市公司的基本目标/147
案例研究：稳定公司/148
小结/162
第10章财务分析和公司分类/164
公司分类/165
成熟型公司/165
成长型公司/166
周期型公司/169
衰退型公司/175
转型公司/175
先锋型公司/176
财务游戏/177
新增发行在外的股份数？/180
小结/180
第11章财务预测指标/182
预测的流程/183
典型的财务预测/183
其他预测方法/184
对亨斯迈化工预测的评论/187
准备预测/188
周期型公司预测/191
曲棍球棒现象/192
小结/194
第三部分评估及投资决策
第12章评估方法/196
评估每种方法/197
使用多种方法/198
小结/199
第13章内在价值与现金流量折现/200
应用现金流量折现法时的问题/201
现金流量折现法与相对价值评估/204
现金流量折现和市盈率比率/204
现金流量折现估值的过程/206
小结/209
第14章现金流量折现法：选择正确的折现率/210
贝塔系数/212
用以计算股东权益收益率的方法——积层法/214
特殊案例/215
小结/217
第15章相对估值法/218
房地产的类比/219
案例研究：现代派遣服务业/220
为首次公开发行进行估值/223
资产负债表项目和相对价值/223
多高算是高/224
小结/224
第16章边缘公司的业绩评估/226
如何定义“存在问题的公司”/227
小型公司和相对价值/234
小结/234
第17章并购市场、证券分析和估值/235
理解杠杆收购/237
杠杆收购的运作机制/238
案例研究：KEANE公司/239
私募股权公司应该支付多少钱/240
杠杆收购估值以及对上市公司的证券分析/242
战略型收购估值/242
小结/243
第18章分部加总法/244
背景介绍/245
税收更有利于资产分拆而非现金出售/246
分部加总法举例/247
业务部门的估值/247
非经营性资产和负债/250
揭开分部加总法价值的面纱/251
小结/252
第19章投资建议/253
自上而下分析过程摘要/255
折现现金流法估值/258
相对价值法/分部加总估值法/260
收购价值/262
杠杆收购法/263
投资推荐意见和结论/265
小结/266
第四部分特 殊 情 况
第20章私募股权投资/268
行业细分和规模大小/269
费用结构/270
私募股权基金并没有跑赢标普500指数/271
私募股权基金和信息的收集/271
私募股权基金对上市公司的估值方法做出修改/272
对流动性和控制权的调整/273
小结/276
第21章自然资源类公司/278
一般方法论/278
自然资源类公司的财务报告/280
案例研究：Encore Acquisition Company/283
矿业公司/289
小结/291
第22章金融行业个股/292
产品线/295
金融资产的性质/296
两种技能/297
贷款机构/298
大型商业银行/305
小结/307
第23章保险公司/308
总体背景/308
保险公司的基本职能/309
保险公司的监管/311
财务报表分析：财产险与意外事故险公司/312
财务报表比率/317
人寿保险公司/317
小结/320
第24章高度投机性股票/321
背景/322
折现现金流/323
案例研究：巴拉德动力/324
风险投资资本加价与IPO/329
历史的视角/330
证券分析、高科技股票、投资组合/331
小结/331
第25章问题证券与转折期公司/332
投资机会/333
筛选技巧/334
接受转型公司失败的可能性/336
对出现杠杆问题的公司进行财务分析/337
投资决策/339
对转型公司的评估/340
清算/343
小结/344
第26章国际股票/345
证券分析的作用/346
美国证券存托凭证/348
发达国家市场/348
相对价值乘数/352
小结/353
第27章新兴市场/354
新兴市场与证券分析/356
股票定价原则/360
财务预测/364
新兴市场股票贴现率/365
新兴市场上的相对价值分析法/368
小结/369
第五部分结论
第28章资产的繁荣和萧条/372
2008年金融危机：起因/372
美国房地产泡沫的破灭/373
裁判员的失败/375
另一场危机的必然性/379
证券分析师和企业估值会如何变化/381
小结/382
第29章结束语/383
注释/387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>华尔街证券分析：股票分析与公司估值（原书第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哲学的快乐
序言
导言　丰盈和干瘪的哲学 1
哲学家素描 6
论作为批判的哲学 8
哲学的恒久问题 12
赞美苏格拉底 15
第一章　激情的生活 21
爱作为一种德性：驳康德的典范 30
情爱的德性 34
权力意志作为德性 39
论诸德性的优点 45
第二章　情感的政治 53
被贬损的情感 56
何谓情感？（走向一种政治观） 60
两种情感典范 65
超越笛卡尔的传统 67
情感的（诸）目的 70
情感的政治 74
情感的政治与合理性 84
第三章　合理性及其兴衰　　89
合理性的不同视角 94
怀疑（理性）的一些理由 97
从求和到利己 102
情感的理性与理性的情感基础 106
第四章　正义、同情、复仇 121
正义与复仇：缺失的典范 125
正义vs.复仇：毫无根据的对立 130
正义的善柔一面 134
正义的肮脏一面：为怨恨一辩 140
作为正义的复仇：报复的合理性 144
正义如何令人满意 151
第五章　生活的悲剧感 157
悲剧的替代：责备与权利资格 164
恶的问题 168
谴责受害者：“自由意志”的解决方 172
返回的俄狄浦斯：悲剧之死 176
命运、简便命运与看不见的手 180
好运气、坏运气以及毫无运气 187
悲剧的意义 193
第六章　直面死亡的思考 199
死亡恋癖、病态的唯我论 199
直面死亡的思考 203
拒斥死亡：简史 207
从拒斥死亡到死亡恋癖 212
大胆的设想：“死亡什么也不是” 217
干瘪的死神：作为悖谬的死亡 222
恐惧死亡：害怕什么呢？ 225
超越病态的唯我论 231
第七章　人格同一性的复兴 237
困惑的进展 243
人格同一性与存在的社会自我 247
人格同一性与德性伦理学 250
人格同一性与文化多元主义 257
爱中的人格同一性 261
人格同一性的复兴 264
第八章　哲学中的欺骗、自我与自欺 271
为什么是真理？ 273
哲学意义上的真理与谎言 275
欺骗、自欺与自我 280
纠缠之网 286
表里不一的自我与自欺的自我 290
后记　“分析哲学”毁了哲学吗？ 299
索引　　311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哲学的快乐
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>怎样玩转信息
前言
入门
信息过载
第一章 流程
随时随地搜集和使用正确信息的步骤
第二章 信息的组织与查找原理
基本常识
第三章 信息搜索与图书馆编目系统
理解信息搜索
第四章 期刊和数据库
第五章 在开放网络中搜索信息
第六章 评估信息资源
第七章 信息使用道德
结语
致谢
重要词汇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>怎样玩转信息
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++编程思想（两卷合订本）
出版者的话
出版说明
第1卷   标准C++导引
译者序	3
前言	5
第1章   对象导言	11
1.1   抽象的过程	11
1.2   对象有一个接口	12
1.3   实现的隐藏	14
1.4   实现的重用	15
1.5   继承：重用接口	15
1.5.1   is-a 关系和is-like-a 关系	18
1.6   具有多态性的可互换对象	18
1.7   创建和销毁对象	21
1.8   异常处理：应对错误	22
1.9   分析和设计	22
1.9.1   第0阶段：制定计划	24
1.9.2   第1阶段：我们在做什么	24
1.9.3   第2阶段：我们将如何建立对象	26
1.9.4   第3阶段：创建核心	28
1.9.5   第4阶段：迭代用例	29
1.9.6   第5阶段：进化	29
1.9.7   计划的回报	30
1.10   极限编程	30
1.10.1   先写测试	31
1.10.2   结对编程	32
1.11   为什么C++会成功	32
1.11.1   一个较好的C	32
1.11.2   延续式的学习过程	33
1.11.3   效率	33
1.11.4   系统更容易表达和理解	33
1.11.5   尽量使用库	33
1.11.6   利用模板的源代码重用	34
1.11.7   错误处理	34
1.11.8   大型程序设计	34
1.12   为向OOP转变而采取的策略	34
1.12.1   指导方针	35
1.12.2   管理的障碍	35
1.13   小结	37
第2章   对象的创建与使用	38
2.1   语言的翻译过程	38
2.1.1   解释器	38
2.1.2   编译器	39
2.1.3   编译过程	39
2.2   分段编译工具	40
2.2.1   声明与定义	40
2.2.2   连接	44
2.2.3   使用库文件	44
2.3   编写第一个C++程序	45
2.3.1   使用iostream类	45
2.3.2   名字空间	46
2.3.3   程序的基本结构	47
2.3.4 “Hello, World!”	47
2.3.5   运行编译器	48
2.4   关于输入输出流	48
2.4.1   字符数组的拼接	49
2.4.2   读取输入数据	49
2.4.3   调用其他程序	50
2.5   字符串简介	50
2.6   文件的读写	51
2.7   vector简介	52
2.8   小结	55
2.9   练习	56
第3章   C++中的C	57
3.1   创建函数	57
3.1.1   函数的返回值	58
3.1.2   使用C的函数库	59
3.1.3   通过库管理器创建自己的库	59
3.2   执行控制语句	60
3.2.1   真和假	60
3.2.2   if-else语句	60
3.2.3   while语句	61
3.2.4   do-while语句	61
3.2.5   for语句	62
3.2.6   关键字break 和 continue	63
3.2.7   switch语句	64
3.2.8   使用和滥用goto	65
3.2.9   递归	65
3.3   运算符简介	66
3.3.1   优先级	66
3.3.2   自增和自减	67
3.4   数据类型简介	67
3.4.1   基本内建类型	67
3.4.2   bool类型与true和false	68
3.4.3   说明符	69
3.4.4   指针简介	70
3.4.5   修改外部对象	72
3.4.6   C++引用简介	74
3.4.7   用指针和引用作为修饰符	75
3.5   作用域	76
3.5.1   实时定义变量	77
3.6   指定存储空间分配	78
3.6.1   全局变量	78
3.6.2   局部变量	79
3.6.3   静态变量	80
3.6.4   外部变量	81
3.6.5   常量	82
3.6.6   volatile变量	83
3.7    运算符及其使用	83
3.7.1   赋值	83
3.7.2   数学运算符	83
3.7.3   关系运算符	85
3.7.4   逻辑运算符	85
3.7.5   位运算符	85
3.7.6   移位运算符	86
3.7.7   一元运算符	88
3.7.8   三元运算符	88
3.7.9   逗号运算符	89
3.7.10   使用运算符时的常见问题	89
3.7.11   转换运算符	90
3.7.12   C++的显式转换	90
3.7.13   sizeof—独立运算符	93
3.7.14   asm 关键字	94
3.7.15   显式运算符	94
3.8   创建复合类型	94
3.8.1   用typedef命名别名	95
3.8.2   用struct把变量结合在一起	95
3.8.3   用enum提高程度清晰度	97
3.8.4   用union节省内存	98
3.8.5   数组	99
3.9   调试技巧	106
3.9.1   调试标记	106
3.9.2   把变量和表达式转换成字符串	108
3.9.3   C语言assert( )宏	108
3.10   函数地址	109
3.10.1   定义函数指针	109
3.10.2   复杂的声明和定义	109
3.10.3   使用函数指针	110
3.10.4   指向函数的指针数组	111
3.11   make：管理分段编译	111
3.11.1   make的行为	112
3.11.2   本书中的makefile	114
3.11.3   makefile的一个例子	114
3.12   小结	116
3.13   练习	116
第4章   数据抽象	119
4.1   一个袖珍C库	119
4.1.1   动态存储分配	122
4.1.2   有害的猜测	124
4.2   哪儿出问题	125
4.3   基本对象	126
4.4   什么是对象	130
4.5   抽象数据类型	131
4.6   对象细节	131
4.7   头文件形式	132
4.7.1   头文件的重要性	132
4.7.2   多次声明问题	133
4.7.3   预处理器指示#define、#ifdef
和#endif	134
4.7.4   头文件的标准	134
4.7.5   头文件中的名字空间	135
4.7.6   在项目中使用头文件	135
4.8   嵌套结构	136
4.8.1   全局作用域解析	138
4.9   小结	139
4.10   练习	139
第5章   隐藏实现	142
5.1   设置限制	142
5.2   C++的访问控制	142
5.2.1   protected说明符	144
5.3   友元	144
5.3.1   嵌套友元	146
5.3.2   它是纯面向对象的吗	148
5.4   对象布局	148
5.5   类	149
5.5.1   用访问控制来修改Stash	151
5.5.2   用访问控制来修改Stack	151
5.6   句柄类	152
5.6.1   隐藏实现	152
5.6.2   减少重复编译	152
5.7   小结	154
5.8   练习	154
第6章   初始化与清除	156
6.1   用构造函数确保初始化	156
6.2   用析构函数确保清除	157
6.3   清除定义块	159
6.3.1   for循环	160
6.3.2   内存分配	161
6.4   带有构造函数和析构函数的Stash	162
6.5   带有构造函数和析构函数的Stack	164
6.6   聚合初始化	166
6.7   默认构造函数	168
6.8   小结	169
6.9   练习	169
第7章   函数重载与默认参数	171
7.1   名字修饰	172
7.1.1   用返回值重载	172
7.1.2   类型安全连接	172
7.2   重载的例子	173
7.3   联合	176
7.4   默认参数	178
7.4.1   占位符参数	179
7.5   选择重载还是默认参数	180
7.6   小结	183
7.7   练习	183
第8章   常量	185
8.1   值替代	185
8.1.1   头文件里的const	186
8.1.2   const的安全性	186
8.1.3   聚合	187
8.1.4   与C语言的区别	187
8.2   指针	188
8.2.1   指向const的指针	189
8.2.2   const指针	189
8.2.3   赋值和类型检查	190
8.3   函数参数和返回值	191
8.3.1   传递const值	191
8.3.2   返回const值	191
8.3.3   传递和返回地址	193
8.4   类	195
8.4.1   类里的const	196
8.4.2   编译期间类里的常量	198
8.4.3   const对象和成员函数	200
8.5   volatile	204
8.6   小结	205
8.7   练习	205
第9章   内联函数	207
9.1   预处理器的缺陷	207
9.1.1   宏和访问	209
9.2   内联函数	210
9.2.1   类内部的内联函数	210
9.2.2   访问函数	211
9.3   带内联函数的Stash和Stack	215
9.4   内联函数和编译器	218
9.4.1   限制	219
9.4.2   向前引用	219
9.4.3   在构造函数和析构函数里隐藏行为	220
9.5   减少混乱	220
9.6   预处理器的更多特征	221
9.6.1   标志粘贴	222
9.7   改进的错误检查	222
9.8   小结	225
9.9   练习	225
第10章   名字控制	227
10.1   来自C语言中的静态元素	227
10.1.1   函数内部的静态变量	227
10.1.2   控制连接	230
10.1.3   其他存储类型说明符	232
10.2   名字空间	232
10.2.1   创建一个名字空间	232
10.2.2   使用名字空间	234
10.2.3   名字空间的使用	237
10.3   C++中的静态成员	238
10.3.1   定义静态数据成员的存储	238
10.3.2   嵌套类和局部类	241
10.3.3   静态成员函数	242
10.4   静态初始化的相依性	244
10.4.1   怎么办	245
10.5   替代连接说明	250
10.6   小结	250
10.7   练习	251
第11章   引用和拷贝构造函数	254
11.1   C++中的指针	254
11.2   C++中的引用	254
11.2.1   函数中的引用	255
11.2.2   参数传递准则	257
11.3   拷贝构造函数	257
11.3.1   按值传递和返回	257
11.3.2   拷贝构造函数	261
11.3.3   默认拷贝构造函数	265
11.3.4   替代拷贝构造函数的方法	266
11.4   指向成员的指针	267
11.4.1   函数	269
11.5   小结	271
11.6   练习	271
第12章   运算符重载	274
12.1   两个极端	274
12.2   语法	274
12.3   可重载的运算符	275
12.3.1   一元运算符	276
12.3.2   二元运算符	279
12.3.3   参数和返回值	288
12.3.4   不常用的运算符	290
12.3.5   不能重载的运算符	295
12.4   非成员运算符	296
12.4.1   基本方针	297
12.5   重载赋值符	297
12.5.1   operator=的行为	298
12.6   自动类型转换	306
12.6.1   构造函数转换	306
12.6.2   运算符转换	307
12.6.3   类型转换例子	309
12.6.4   自动类型转换的缺陷	310
12.7   小结	312
12.8   练习	312
第13章   动态对象创建	315
13.1   对象创建	315
13.1.1   C从堆中获取存储单元的方法	316
13.1.2   operator new	317
13.1.3   operator delete	317
13.1.4   一个简单的例子	318
13.1.5   内存管理的开销	318
13.2   重新设计前面的例子	319
13.2.1   使用delete void*可能会出错	319
13.2.2   对指针的清除责任	320
13.2.3   指针的Stash	320
13.3   用于数组的new和delete	324
13.3.1   使指针更像数组	325
13.4   耗尽内存	325
13.5   重载new和delete	326
13.5.1   重载全局new和delete	327
13.5.2   对于一个类重载new和delete	328
13.5.3   为数组重载new和delete	330
13.5.4   构造函数调用	332
13.5.5   定位new和delete	333
13.6   小结	334
13.7   练习	334
第14章   继承和组合	336
14.1   组合语法	336
14.2   继承语法	337
14.3   构造函数的初始化表达式表	339
14.3.1   成员对象初始化	339
14.3.2   在初始化表达式表中的内建类型	339
14.4   组合和继承的联合	340
14.4.1   构造函数和析构函数调用的次序	341
14.5   名字隐藏	343
14.6   非自动继承的函数	346
14.6.1   继承和静态成员函数	349
14.7   组合与继承的选择	349
14.7.1  子类型设置	350
14.7.2   私有继承	352
14.8   protected	353
14.8.1   protected继承	353
14.9   运算符的重载与继承	353
14.10   多重继承	355
14.11   渐增式开发	355
14.12   向上类型转换	356
14.12.1   为什么要“向上类型转换”	357
14.12.2   向上类型转换和拷贝构造函数	357
14.12.3   组合与继承（再论）	359
14.12.4   指针和引用的向上类型转换	360
14.12.5   危机	360
14.13   小结	361
14.14   练习	361
第15章   多态性和虚函数	364
15.1   C++程序员的演变	364
15.2   向上类型转换	365
15.3   问题	366
15.3.1   函数调用捆绑	366
15.4   虚函数	366
15.4.1   扩展性	367
15.5   C++如何实现晚捆绑	369
15.5.1   存放类型信息	370
15.5.2   虚函数功能图示	371
15.5.3   撩开面纱	372
15.5.4   安装vpointer	373
15.5.5   对象是不同的	373
15.6   为什么需要虚函数	374
15.7   抽象基类和纯虚函数	375
15.7.1   纯虚定义	378
15.8   继承和VTABLE	378
15.8.1   对象切片	380
15.9   重载和重新定义	382
15.9.1   变量返回类型	383
15.10   虚函数和构造函数	385
15.10.1   构造函数调用次序	385
15.10.2   虚函数在构造函数中的行为	386
15.11   析构函数和虚拟析构函数	386
15.11.1   纯虚析构函数	388
15.11.2   析构函数中的虚机制	389
15.11.3   创建基于对象的继承	390
15.12   运算符重载	392
15.13   向下类型转换	394
15.14   小结	396
15.15   练习	397
第16章   模板介绍	400
16.1   容器	400
16.1.1   容器的需求	401
16.2   模板综述	402
16.2.1   模板方法	403
16.3   模板语法	404
16.3.1   非内联函数定义	405
16.3.2   作为模板的IntStack	406
16.3.3   模板中的常量	408
16.4   作为模板的Stash和Stack	409
16.4.1   模板化的指针Stash	411
16.5   打开和关闭所有权	415
16.6   以值存放对象	417
16.7   迭代器简介	418
16.7.1   带有迭代器的栈	425
16.7.2   带有迭代器的PStash	427
16.8   为什么使用迭代器	432
16.8.1   函数模板	434
16.9   小结	435
16.10   练习	435
附录A   编码风格
附录B   编程准则
附录C   推荐读物
第2卷   实用编程技术
译者序	441
前言	442
第一部分   建立稳定的系统
第1章   异常处理	448
1.1   传统的错误处理	448
1.2   抛出异常	450
1.3   捕获异常	451
1.3.1   try块	451
1.3.2   异常处理器	451
1.3.3   终止和恢复	452
1.4   异常匹配	453
1.4.1   捕获所有异常	454
1.4.2   重新抛出异常	454
1.4.3   不捕获异常	455
1.5   清理	456
1.5.1   资源管理	457
1.5.2   使所有事物都成为对象	458
1.5.3   auto_ptr	460
1.5.4   函数级的try块	461
1.6   标准异常	462
1.7   异常规格说明	464
1.7.1   更好的异常规格说明	467
1.7.2   异常规格说明和继承	467
1.7.3   什么时候不使用异常规格说明	468
1.8   异常安全	468
1.9   在编程中使用异常	471
1.9.1   什么时候避免异常	471
1.9.2   异常的典型应用	472
1.10   使用异常造成的开销	474
1.11   小结	476
1.12   练习	476
第2章   防御性编程	478
2.1   断言	480
2.2   一个简单的单元测试框架	482
2.2.1   自动测试	483
2.2.2   TestSuite框架	485
2.2.3   测试套件	488
2.2.4   测试框架的源代码	489
2.3   调试技术	493
2.3.1   用于代码跟踪的宏	494
2.3.2   跟踪文件	494
2.3.3   发现内存泄漏	495
2.4   小结	499
2.5   练习	500
第二部分   标准C++库
第3章   深入理解字符串	504
3.1   字符串的内部是什么	504
3.2   创建并初始化C++字符串	505
3.3   对字符串进行操作	508
3.3.1   追加、插入和连接字符串	508
3.3.2   替换字符串中的字符	509
3.3.3   使用非成员重载运算符连接	512
3.4   字符串的查找	513
3.4.1   反向查找	516
3.4.2   查找一组字符第1次或最后一次出现的位置	517
3.4.3   从字符串中删除字符	519
3.4.4   字符串的比较	520
3.4.5   字符串和字符的特性	523
3.5   字符串的应用	527
3.6   小结	531
3.7   练习	531
第4章   输入输出流	534
4.1   为什么引入输入输出流	534
4.2   救助输入输出流	537
4.2.1   插入符和提取符	537
4.2.2   通常用法	540
4.2.3   按行输入	541
4.3   处理流错误	542
4.4   文件输入输出流	544
4.4.1   一个文件处理的例子	544
4.4.2   打开模式	546
4.5   输入输出流缓冲	546
4.6   在输入输出流中定位	548
4.7   字符串输入输出流	550
4.7.1   输入字符串流	551
4.7.2   输出字符串流	552
4.8   输出流的格式化	555
4.8.1   格式化标志	555
4.8.2   格式化域	556
4.8.3   宽度、填充和精度设置	557
4.8.4   一个完整的例子	557
4.9   操纵算子	560
4.9.1   带参数的操纵算子	560
4.9.2   创建操纵算子	562
4.9.3   效用算子	563
4.10   输入输出流程序举例	565
4.10.1   维护类库的源代码	565
4.10.2   检测编译器错误	568
4.10.3   一个简单的数据记录器	570
4.11   国际化	573
4.11.1   宽字符流	574
4.11.2   区域性字符流	575
4.12   小结	577
4.13   练习	577
第5章   深入理解模板	580
5.1   模板参数	580
5.1.1   无类型模板参数	580
5.1.2   默认模板参数	582
5.1.3   模板类型的模板参数	583
5.1.4   typename关键字	587
5.1.5   以template关键字作为提示	588
5.1.6   成员模板	589
5.2   有关函数模板的几个问题	591
5.2.1   函数模板参数的类型推断	591
5.2.2   函数模板重载	594
5.2.3   以一个已生成的函数模板地址作为参数	595
5.2.4   将函数应用到STL序列容器中	598
5.2.5   函数模板的半有序	600
5.3   模板特化	601
5.3.1   显式特化	601
5.3.2   半特化	602
5.3.3   一个实例	604
5.3.4   防止模板代码膨胀	606
5.4   名称查找问题	609
5.4.1   模板中的名称	609
5.4.2   模板和友元	613
5.5   模板编程中的习语	617
5.5.1   特征	617
5.5.2   策略	621
5.5.3   奇特的递归模板模式	623
5.6   模板元编程	624
5.6.1   编译时编程	625
5.6.2   表达式模板	631
5.7   模板编译模型	636
5.7.1   包含模型	636
5.7.2   显式实例化	637
5.7.3   分离模型	638
5.8   小结	639
5.9   练习	640
第6章   通用算法	642
6.1   概述	642
6.1.1   判定函数	644
6.1.2   流迭代器	646
6.1.3   算法复杂性	647
6.2   函数对象	648
6.2.1   函数对象的分类	649
6.2.2   自动创建函数对象	649
6.2.3   可调整的函数对象	652
6.2.4   更多的函数对象例子	653
6.2.5   函数指针适配器	658
6.2.6   编写自己的函数对象适配器	662
6.3   STL算法目录	665
6.3.1   实例创建的支持工具	666
6.3.2   填充和生成	669
6.3.3   计数	670
6.3.4   操作序列	671
6.3.5   查找和替换	674
6.3.6   比较范围	679
6.3.7   删除元素	681
6.3.8   对已排序的序列进行排序和运算	684
6.3.9   堆运算	691
6.3.10   对某一范围内的所有元素进行运算	691
6.3.11   数值算法	697
6.3.12   通用实用程序	699
6.4   创建自己的STL风格算法	700
6.5   小结	701
6.6   练习	702
第7章   通用容器	706
7.1   容器和迭代器	706
7.2   概述	707
7.2.1   字符串容器	711
7.2.2   从STL容器继承	712
7.3   更多迭代器	714
7.3.1   可逆容器中的迭代器	715
7.3.2   迭代器的种类	716
7.3.3   预定义迭代器	717
7.4   基本序列容器：vector、list和deque	721
7.4.1   基本序列容器的操作	721
7.4.2   向量	723
7.4.3   双端队列	728
7.4.4   序列容器间的转换	730
7.4.5   被检查的随机访问	731
7.4.6   链表	732
7.4.7   交换序列	736
7.5   集合	737
7.6   堆栈	743
7.7   队列	745
7.8   优先队列	748
7.9   持有二进制位	755
7.9.1   bitset<n>	756
7.9.2    vector<bool>	758
7.10   关联式容器	760
7.10.1   用于关联式容器的发生器和填充器	763
7.10.2   不可思议的映像	765
7.10.3   多重映像和重复的关键字	766
7.10.4   多重集合	768
7.11   将STL容器联合使用	771
7.12   清除容器的指针	773
7.13   创建自己的容器	774
7.14   对STL的扩充	776
7.15   非STL容器	777
7.16   小结	781
7.17   练习	781
第三部分   专      题
第8章   运行时类型识别	785
8.1   运行时类型转换	785
8.2   typeid 操作符	789
8.2.1   类型转换到中间层次类型	790
8.2.2   void型指针	791
8.2.3   运用带模板的RTTI	792
8.3   多重继承	793
8.4   合理使用RTTI	793
8.5   RTTI的机制和开销	797
8.6   小结	797
8.7   练习	798
第9章   多重继承	800
9.1   概论	800
9.2   接口继承	801
9.3   实现继承	803
9.4   重复子对象	807
9.5   虚基类	810
9.6   名字查找问题	817
9.7   避免使用多重继承	819
9.8   扩充一个接口	820
9.9   小结	823
9.10   练习	823
第10章   设计模式	825
10.1   模式的概念	825
10.2   模式分类	826
10.3   简化习语	827
10.3.1   信使	827
10.3.2   收集参数	828
10.4   单件	829
10.5   命令：选择操作	833
10.6   消除对象耦合	836
10.6.1   代理模式：作为其他对象的前端	837
10.6.2   状态模式：改变对象的行为	838
10.7   适配器模式	840
10.8   模板方法模式	841
10.9   策略模式：运行时选择算法	842
10.10   职责链模式：尝试采用一系列
策略模式	843
10.11   工厂模式：封装对象的创建	845
10.11.1   多态工厂	847
10.11.2   抽象工厂	849
10.11.3   虚构造函数	851
10.12   构建器模式：创建复杂对象	855
10.13   观察者模式	860
10.13.1   “内部类”方法	862
10.13.2   观察者模式举例	864
10.14   多重派遣	867
10.15   小结	873
10.16   练习	873
第11章   并发	875
11.1   动机	875
11.2   C++中的并发	876
11.3   定义任务	878
11.4   使用线程	879
11.4.1   创建有响应的用户界面	880
11.4.2   使用执行器简化工作	882
11.4.3   让步	884
11.4.4   休眠	885
11.4.5   优先权	886
11.5   共享有限资源	887
11.5.1   保证对象的存在	887
11.5.2   不恰当地访问资源	890
11.5.3   访问控制	892
11.5.4   使用保护简化编码	893
11.5.5   线程本地存储	896
11.6   终止任务	897
11.6.1   防止输入/输出流冲突	897
11.6.2   举例观赏植物园	898
11.6.3   阻塞时终止	901
11.6.4   中断	902
11.7   线程间协作	906
11.7.1   等待和信号	906
11.7.2   生产者-消费者关系	909
11.7.3   用队列解决线程处理的问题	912
11.7.4   广播	916
11.8   死锁	921
11.9   小结	925
11.10   练习	926
附      录
附录A   推荐读物
附录B   其他
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++编程思想（两卷合订本）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>征服C指针
第0章 　本书的目标与结构——引言　　1
0.1 　本书的目标　　1
0.2 　目标读者和内容结构　　3
第1章 　从基础开始——预备知识和复习　　7
1.1 　C是什么样的语言　　7
1.1.1 　比喻　　7
1.1.2 　C的发展历程　　8
1.1.3 　不完备和不统一的语法　　9
1.1.4 　ANSI C　　10
1.1.5 　C的宝典——K&R　　11
1.1.6 　C的理念　　12
1.1.7 　C的主体　　14
1.1.8 　C是只能使用标量的语言　　15
1.2 　关于指针　　16
1.2.1 　恶名昭著的指针究竟是什么　　16
1.2.2 　和指针的第一次亲密接触　　17
1.2.3 　指针和地址之间的微妙关系　　23
1.2.4 　指针运算　　26
1.2.5 　什么是空指针　　27
1.2.6 　实践——swap函数　　31
1.3 　关于数组　　34
1.3.1 　运用数组　　34
1.3.2 　数组和指针的微妙关系　　37
1.3.3 　下标运算符[]和数组是没有关系的　　39
1.3.4 　为什么存在奇怪的指针运算　　42
1.3.5 　不要滥用指针运算　　43
1.3.6 　试图将数组作为函数的参数进行传递　　45
1.3.7 　声明函数形参的方法　　48
第2章 　做个实验见分晓——C是怎么使用内存的　　51
2.1 　虚拟地址　　51
2.2 　C的内存的使用方法　　56
2.2.1 　C的变量的种类　　56
2.2.2 　输出地址　　58
2.3 　函数和字符串常量　　61
2.3.1 　只读内存区域　　61
2.3.2 　指向函数的指针　　62
2.4 　静态变量　　64
2.4.1 　什么是静态变量　　64
2.4.2 　分割编译和连接　　64
2.5 　自动变量（栈）　　66
2.5.1 　内存区域的“重复使用”　　66
2.5.2 　函数调用究竟发生了什么　　66
2.5.3 　可变长参数　　73
2.5.4 　递归调用　　80
2.6 　利用malloc()来进行动态内存分配（堆）　　84
2.6.1 　malloc()的基础　　84
2.6.2 　malloc()是“系统调用”吗　　88
2.6.3 　malloc()中发生了什么　　89
2.6.4 　free()之后，对应的内存区域会怎样　　91
2.6.5 　碎片化　　93
2.6.6 　malloc()以外的动态内存分配函数　　94
2.7 　内存布局对齐　　98
2.8 　字节排序　　101
2.9 　关于开发语言的标准和实现——对不起，前面的内容都是忽悠的　　102
第3章 　揭秘C的语法——它到底是怎么回事　　105
3.1 　解读C的声明　　105
3.1.1 　用英语来阅读　　105
3.1.2 　解读C的声明　　106
3.1.3 　类型名　　109
3.2 　C的数据类型的模型　　111
3.2.1 　基本类型和派生类型　　111
3.2.2 　指针类型派生　　112
3.2.3 　数组类型派生　　113
3.2.4 　什么是指向数组的指针　　114
3.2.5 　C语言中不存在多维数组！　　116
3.2.6 　函数类型派生　　117
3.2.7 　计算类型的大小　　119
3.2.8 　基本类型　　121
3.2.9 　结构体和共用体　　122
3.2.10 　不完全类型　　123
3.3 　表达式　　125
3.3.1 　表达式和数据类型　　125
3.3.2 　“左值”是什么——变量的两张面孔　　129
3.3.3 　将数组解读成指针　　130
3.3.4 　数组和指针相关的运算符　　132
3.3.5 　多维数组　　133
3.4 　解读C的声明（续）　　137
3.4.1 　const修饰符　　137
3.4.2 　如何使用const？可以使用到什么程度？　　139
3.4.3 　typedef　　141
3.5 　其他　　143
3.5.1 　函数的形参的声明　　143
3.5.2 　关于空的下标运算符[]　　146
3.5.3 　字符串常量　　148
3.5.4 　关于指向函数的指针引起的混乱　　151
3.5.5 　强制类型转换　　152
3.5.6 　练习——挑战那些复杂的声明　　153
3.6 　应该记住：数组和指针是不同的事物　　157
3.6.1 　为什么会引起混乱　　157
3.6.2 　表达式之中　　158
3.6.3 　声明　　160
第4章 　数组和指针的常用方法　　161
4.1 　基本的使用方法　　161
4.1.1 　以函数返回值之外的方式来返回值　　161
4.1.2 　将数组作为函数的参数传递　　162
4.1.3 　可变长数组　　163
4.2 　组合使用　　166
4.2.1 　可变长数组的数组　　166
4.2.2 　可变长数组的可变长数组　　172
4.2.3 　命令行参数　　174
4.2.4 　通过参数返回指针　　177
4.2.5 　将多维数组作为函数的参数传递　　181
4.2.6 　数组的可变长数组　　182
4.2.7 　纠结于“可变”之前，不妨考虑使用结构体　　183
4.3 　违反标准的技巧　　187
4.3.1 　可变长结构体　　187
4.3.2 　从1开始的数组　　189
第5章 　数据结构——真正的指针的使用方法　　193
5.1 　案例学习1：计算单词的出现频率　　193
5.1.1 　案例的需求　　193
5.1.2 　设计　　195
5.1.3 　数组版　　200
5.1.4 　链表版　　203
5.1.5 　追加检索功能　　211
5.1.6 　其他的数据结构　　214
5.2 　案例学习2：绘图工具的数据结构　　218
5.2.1 　案例的需求　　218
5.2.2 　实现各种图形的数据模型　　219
5.2.3 　Shape型　　221
5.2.4 　讨论——还有别的方法吗　　223
5.2.5 　图形的组合　　228
5.2.6 　继承和多态之道　　233
5.2.7 　对指针的恐惧　　236
5.2.8 　说到底，指针究竟是什么　　237
第6章 　其他——拾遗　　239
6.1 　陷阱　　239
6.1.1 　关于strncpy()　　239
6.1.2 　如果在早期的C中使用float类型的参数　　240
6.1.3 　printf()和scanf()　　242
6.1.4 　原型声明的光和影　　243
6.2 　惯用句法　　245
6.2.1 　结构体声明　　245
6.2.2 　自引用型结构体　　246
6.2.3 　结构体的相互引用　　247
6.2.4 　结构体的嵌套　　248
6.2.5 　共用体　　249
6.2.6 　数组的初始化　　250
6.2.7 　char数组的初始化　　250
6.2.8 　指向char的指针的数组的初始化　　251
6.2.9 　结构体的初始化　　252
6.2.10 　共用体的初始化　　252
6.2.11 　全局变量的声明　　253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>征服C指针
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer中文版
第1章　快速入门　1.1  编写简单的C++程序　1.2  初窥输入/输出　　1.2.1  标准输入与输出对象　　1.2.2  一个使用IO库的程序　1.3  关于注释　1.4  控制结构　　1.4.1　while语句　　1.4.2  for语句　　1.4.3  if语句　　1.4.4  读入未知数目的输入　1.5  类的简介　　1.5.1  Sales_item类　　1.5.2  初窥成员函数　1.6  C++程序　小结　术语    第一部分  基本语言第2章　变量和基本类型第3章　标准库类型第4章　数组和指针第5章　表达式第6章　语句第7章　函数第8章　标准IO库    第二部分  容器和算法第9章　顺序容器第10章　关联容器第11章　泛型算法    第三部分  类和数据抽象第12章　类第13章　复制控制第14章　重载操作符与转换    第四部分  面向对象编程与泛型编程第16章　模板与泛型编程    第五部分  高级主题第17章　用于大型程序的工具第18章　特殊工具与技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ Primer中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反穀
前言
導論一個破碎敘事：我所不知道的
第一章掌握用火技術、栽培植物、馴化動物以及……我們自己
第二章地景塑造：農莊的綜合體
第三章人畜共通疾病：流行病學的典型風暴
第四章早期國家的農業生態
第五章人口控制：束縛以及戰爭
第六章 早期國家的脆弱性：因分解而崩潰
第七章 野蠻人的黃金時代
注釋
參考書目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反穀
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面包坊
汤种面包的由来
面团基本制作流程
面团分割滚圆
一 甜面包
二 调理面包
三 吐司面包
四 健康高纤面包
五 传统各国面包
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面包坊
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大家看的C语言书
第一部分　C语言初步
第1章　初识C语言
第2章　从何处入手
第3章　代码注释
第4章　输出
第5章　变量
第6章　字符串
第7章　#include和#define
第8章　输入
第9章　C怎么做数学运算
第二部分　操作空间
第10章　表达式还能用来做什么
第11章　关系运算符
第12章　逻辑运算符
第13章　更高级的运算符
第三部分　保持控制
第14章　循环
第15章　其他循环
第16章　终止循环
第17章　测试多个值
第18章　输入和输出
第19章　更多有关字符串的内容
第20章　更高级的数学函数
第四部分　C程序和大量数据
第21章　C语言如何处理列表
第22章　搜索数据
第23章　排序
第24章　我的名字叫指针
第25章　数组和指针有什么不同
第26章　有效管理内存空间
第27章　结构体
第五部分　用函数组织程序
第28章　把数据存到硬盘上
第29章　另一种保存文件的方式
第30章　用函数来组织程序
第31章　在函数间共享数据
第32章　让函数更完美
附录A　你可以飞得更高
附录B　玩C语言写的21点游戏
附录C　ASCII表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大家看的C语言书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金融衍生品建模
前言第1章　互换与固定收益工具　1.1　欧洲美元（利率）期货　1.2　短期国债与长期债券　　1.2.1　利用短期国债期货避险　　1.2.2　期货多头避险：对182天短期国债进行合成期货避险　1.3　在Matlab中计算短期国债价格与收益率　1.4　对债券头寸进行套期保值　　1.4.1　利用短期国债看涨期权对91天短期国债期货进行套期保值　　1.4.2　空头套期保值：管理到期日缺口　　1.4.3　到期日缺口和持有成本模型　　1.4.4　使用欧元看跌期权管理到期日缺口　　1.4.5　空头套期保值：对变动利率贷款进行套期保值　1.5　债券与互换久期、修正久期，以及每基点美元价值（DV01）　1.6　利率期限结构　1.7　自举分析模型　1.8　在Matlab中进行自举分析　1.9　在Excel中进行自举分析　1.10　在Matlab中计算互换价格的一般方法　1.11　在Matlab中利用期限结构分析为互换定价　1.12　利用c++程序进行互换定价　1.13　在Matlab中为百慕大互换进行定价　尾注第2章　copula函数第3章　住房抵押贷款证券第4章　债务抵押债券第5章　信用衍生品第6章　天气衍生品第7章　能源与电力衍生品第8章　电力衍生品的定价：理论和Matlab实现第9章　商业房地产资产抵押证券附录A　Matlab中的利率树建模附录B　第7章的代码参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>金融衍生品建模
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领导力21法则
前言
作者序言
第一章 盖子法则
第二章 影响力法则
第三章 过程法则
第四章 导航法则
第五章 哈顿法则
第六章 根基法则
第七章 敬佩法则
第八章 直觉法则
第九章 磁力法则
第十章 亲和力法则
第十一章 核心圈法则
第十二章 授权法则
第十三章 增殖法则
第十四章 接纳法则
第十五章 致胜法则
第十六章 动能法则
第十七章 优先次序法则
第十八章 “舍”“得”法则
第十九章 时机法则
第二十章 爆炸性倍增法则
第二十一章 传承法则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领导力21法则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>常微分方程
原书的序
第一章 引论
§1．一阶微分方程式
§2．一些初等的求积方法
§3．存在和唯一性定理的叙述
§4．化一般微分方程组到标准方程组的知识
§5．复值微分方程
§6．关于线性微分方程的一些知识
第二章 常系数线性方程
§7．常系数线性齐次方程(单根情形)
§8．常系数线性齐次方程(重根情形)
§9．稳定多项式
§10．常系数线性非齐次方程
§11．消去法
§12．复数振幅法
§13．电路
§14、标准的常系数线性齐次方程组
§15．自治的微分方程组及其相空间
§16．常系数线性齐次方程组的相平面
第三章 变系数线性方程
§17．标准线性方程组
§18．n阶线性方程
§19．周期系数的标准线性齐次方程组
第四章 存在性定理
§20．一阶方程式存在和唯一性定理的证明
§21．标准方程组存在和唯一性定理的证明
§22．不可延拓的解
§23．解对初值和参数的连续依赖性
§24．解对初始值和参数的可微性
§25．首次积分
第五章 稳定性
§26．李雅普诺夫定理
§27．离心调速器(维什涅格拉德斯基的研究)
§28．极限环
§29．电子管振荡器
§30．二阶自治方程组的平衡位置
§31．周期解的稳定性
附录I 若干分析问题
§32．欧氏空间的拓扑性质
§33．隐函数存在定理
附录II 线性代数
§34．最小零化多项式
§35．矩阵函数
§36．矩阵的若尔当型
名词索引
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>常微分方程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>博格长赢投资之道
引言  永无止境的知足第一部分  赢家的博弈    第1章  我赢头，你输尾：成本太多，价值不足  第2章  乌龟赢，还是兔子赢：投机太多，投资不足  第3章  土鸡能否变成金凤凰：复杂性太多，简单性不足第二部分  重新打造共同基金业  第4章  “皇帝的新衣”还要穿多久：计算太多，信任不足  第5章  CE0多少钱方可知足：商业行为太多，职业操守不足  第6章  谁说基金生来就是要死亡的：推销太多。管理不足  第7章  做“超级公司”，做正确的事：管理者太多，领导者不足第三部分  华尔街的良心  第8章  快跑的未必能赢：物质太多。奉献不足  第9章  用过去改变未来：21世纪价值观太多，18世纪价值观不足  第10章  追逐人生中的真兔子：“成功”太多。品行不足结束语  什么是知足附录  我挖掘的那些钻石后记  为什么我要努力去奋斗致谢译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>博格长赢投资之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构、算法与应用
译者序
前言
第一部分 预备知识
第1章 C++程序设计
第2章 程序性能
第二部分 数据结构
第3章 数据描述
第4章 数组和矩阵
第5章 堆栈
……
第三部分 算法设计方法
第13章 贪婪算法
第14章 分而治之算法
第15章 动态规划
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构、算法与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中层领导力
第一章 中层领导者的7个误区
误区一 职位误区：不居高位，无法领导 / 4
误区二 目的地误区：身居高层之后再学习怎样领导 / 8
误区三 影响力误区：身居高位，人们自然服从 / 10
误区四 经验不足误区：身居高位我就能掌控一切 / 12
误区五 自由误区：成为领导后我就无拘无束 / 14
误区六 潜力误区：身不在高层就无法发挥潜力 / 17
误区七 破罐子破摔误区：做不成领导者就不必领导 / 19
第二章 中层领导者普遍面临的挑战
挑战一 压力挑战：困于中层带来的压力 / 24
挑战二 挫败感挑战：上司平庸无能 / 32
挑战三 多重角色挑战：只有一人，却身兼数职 / 41
挑战四 自尊心挑战：埋没于中层 / 47
挑战五 成就感挑战：领导者更喜欢前线，而不是中层 / 54
挑战六 愿景挑战：如果制定愿景没你的份儿，那就很难真心拥护 / 62
挑战七 影响力挑战：超越职位影响他人困难重重 / 70
第三章 领导力三原则：1. 向上领导的原则
原则一：出色地领导自己 / 81
原则二：为上司减负 / 91
原则三：心甘情愿做别人不愿意做的事 / 100
原则四：领导——做的要比管理的更多 / 108
原则五：为人际关系投资 / 115
原则六：每次占用上司的时间之前做好准备 / 122
原则七：何时进何时退 / 129
原则八：成为公司骨干 / 137
原则九：不断进步 / 142
第四章 领导力三原则：2. 横向领导的原则
原则一：理解、练习并完成领导力圆环 / 151
原则二：赞美比竞争更重要 / 158
原则三：成为朋友 / 164
原则四：避免办公室政治 / 170
原则五：扩大人脉圈 / 177
原则六：让闪光创意脱颖而出 / 184
原则七：不要假装完美无缺 / 191
第五章 领导力三原则：3. 向下领导的原则
原则一：慢慢穿过走廊 / 199
原则二：将每个人视为“满分” / 205
原则三：培养每个团队成员 / 212
原则四：发挥下属的优势 / 221
原则五：以身作则 / 226
原则六：传递愿景 / 231
原则七：根据结果进行奖励 / 236
第六章 全方位领导者的价值
价值一：领导者团队比单打独斗更有效 / 244
价值二：公司的每一层都需要领导者 / 248
价值三：成功领导是更上一层楼的前提 / 253
价值四：优秀的中层领导能够提升高层领导的水平 / 257
价值五：全方位领导者具备每个企业都需要的才能 / 262
给高层领导的话：为全方位领导者创造一个大显身手的环境 / 272
全方位领导者练习册
第一章 中层领导者的7 个误区 / 282
第二章 中层领导者普遍面临的挑战 / 289
第三章 向上领导的原则 / 292
第四章 横向领导的原则 / 298
第五章 向下领导的原则 / 302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中层领导力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>后殖民理性批判
前言
第一章 哲学
第二章 文学
第三章 历史
第四章 文化
附录 解构开始工作
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>后殖民理性批判
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>天才时代
第一部分  绪论    1
01 观察宇宙 3
02 人类历史纪元 8
第二部分  战争时期    25
03 战争的起源 27
04 普法尔茨领地的丧失 44
05 雇佣军上尉 54
06 1629 年颁布《归还敕令》 65
07 瑞典巅峰 74
08 从华伦斯坦到布莱萨赫 85
09 签订《威斯特伐利亚和约》 95
10 在欧洲的废墟中 110
11 海上冲突 113
第三部分  观念的积累    121
12 通信员 123
13 知识捷径 149
14 迪伊博士和魔法艺术 175
15 玫瑰十字会恐慌 196
第四部分  从魔法到科学    223
16 从魔法到方法 225
17 科学的诞生 250
18 战争与科学 288
第五部分  社会秩序    297
19 社会与政治 299
20 语言与信仰 328
第六部分  结论    347
21 它是神话吗 ? 349
注 释 357
参考文献 369
致 谢 373
译后记 375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>天才时代
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
出版者的话
专家指导委员会
译者序
前言
第1章 基本概念
1.1 综述：系统性命周期
1.2 算法描述
1.3 数据抽象
1.4 算法的性能分析
1.5 性能测量
1.6 参考文献和文献选读
第2章 数组与结构
2.1 ADT数组
2.2 结构与共用体
2.3 ADT多项式
2.4 ADT稀疏矩阵
2.5 多维数组的存储表示
2.6 ADT字符串
2.7 参考文献和文献选读
2.8 附加习题
第3章 栈与队列
3.1 ADT栈
3.2 ADT队列
3.3 迷宫问题
3.4 表达式求值
3.5 多栈和多队列
3.6 参考文献
3.7 附加习题
第4章 链表
4.1 指针
4.2 单向链表
4.3 动态链栈与动态链队
4.4 多项式
4.5 链表的其他操作
4.6 等价关系
4.7 稀疏矩阵
4.8 双向链表
4.9 参考文献和文献选读
4.10 附加习题
第5章 树
5.1 概述
5.2 二叉树
5.3 二叉树的遍历
5.4 二叉树的其他操作
5.5 线索二叉树
5.6 堆
5.7 二叉查找树
5.8 选择树
5.9 森林
5.10 集合表示
5.11 二叉树计数
5.12 参考文献和文献选读
5.13 附加习题
第6章 图
6.1 ADT图
6.2 图的基本操作
6.3 最小代价生成树
6.4 最短路径与传递闭包
6.5 活动网络
6.6 参考文献和文献选读
6.7 附加习题
第7章 排序
第8章 散列
第9章 堆结构
第10章 查找结构
附录 ANSI C和K&RC
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C从入门到精通
第1篇  基 础 知 识
第1章  Linux系统概述	3
视频讲解：12分钟
1.1  Linux的起源与发展	4
1.1.1  GNU项目的前前后后	4
1.1.2  Linux的诞生	4
1.1.3  Linux的现状	5
1.2  Linux的内核与版本	5
1.2.1  Linux内核的介绍	5
1.2.2  Linux对硬件平台的支持	6
1.2.3  常见Linux的发行版本	6
1.3  Linux系统的安装	6
1.3.1  Linux系统安装的硬件要求	7
1.3.2  图形化安装Linux	7
1.3.3  第一次启动Linux系统	12
1.4  小结	13
第2章  C语言基础	15
视频讲解：34分钟
2.1  C语言概述	16
2.2  数据类型	16
2.2.1  基本类型	17
2.2.2  构造类型	19
2.2.3  指针类型	20
2.2.4  空类型	22
2.3  运算符和表达式	22
2.3.1  运算符	22
2.3.2  表达式	24
2.4  函数	24
2.5  程序语句	26
2.5.1  控制语句	27
2.5.2  函数调用语句	28
2.5.3  表达式语句	28
2.5.4  空语句	28
2.5.5  复合语句	28
2.6  预处理命令	29
2.6.1  宏定义	29
2.6.2  文件包含	30
2.7  小结	30
2.8  实践与练习	30
第3章  内存管理	31
视频讲解：9分钟
3.1  内存分类	32
3.1.1  动态内存	32
3.1.2  静态内存	32
3.1.3  动态内存与静态内存的区别	33
3.2  内存管理的基本操作	33
3.2.1  分配内存	33
3.2.2  释放内存	36
3.3  链表	36
3.4  小结	38
3.5  实践与练习	38
第4章  基本编辑器VIM和Emacs	39
视频讲解：12分钟
4.1  初识VIM	40
4.1.1  VIM的进入与退出	40
4.1.2  VIM基本模式	40
4.2  VIM的基本操作	41
4.2.1  VIM的命令行模式操作	41
4.2.2  VIM的编辑模式操作	43
4.2.3  VIM的底行模式操作	43
4.3  初识Emacs	44
4.4  Emacs的基本操作	44
4.4.1  启动Emacs	44
4.4.2  基本操作	45
4.5  小结	46
第5章  GCC编译器	47
视频讲解：26分钟
5.1  初识GCC编译器	48
5.1.1  第一次编译	48
5.1.2  GCC选项概述	48
5.1.3  警告	49
5.1.4  GCC调试	50
5.1.5  代码优化	52
5.2  GCC编译的基本流程	54
5.2.1  C预处理	54
5.2.2  编译	54
5.2.3  汇编	54
5.2.4  链接	54
5.3  其他编译工具简介	55
5.3.1  C++编译器G++	55
5.3.2  EGCS	55
5.3.3  F2C和P2C	55
5.4  小结	55
第6章  GDB调试工具	57
视频讲解：40分钟
6.1  初识GDB调试器	58
6.1.1  GDB调试器概述	58
6.1.2  用GDB调试简单程序	58
6.2  GDB调试器的基本功能与常用命令	60
6.2.1  启动调试程序功能及其命令	61
6.2.2  使用断点功能及其命令	62
6.2.3  检查数据的功能及其命令	64
6.2.4  使用观察窗口功能及其命令	67
6.2.5  检查栈信息功能及其命令	67
6.2.6  检查源代码功能及其命令	68
6.2.7  改变程序的运行功能及其命令	70
6.3  多线程程序调试	71
6.4  Linux平台上的其他调试工具	71
6.5  小结	72
第2篇  核 心 技 术
第7章  进程控制	75
视频讲解：57分钟
7.1  进程概述	76
7.1.1  进程的定义	76
7.1.2  进程的相关信息	77
7.2  进程的基本操作	78
7.2.1  进程创建	78
7.2.2  进程等待	84
7.2.3  进程结束	88
7.3  多个进程间的关系	89
7.3.1  进程组	89
7.3.2  时间片的分配	90
7.4  线程	92
7.4.1  线程概述	92
7.4.2  线程的属性	92
7.5  进程的特殊操作	94
7.5.1  获取进程标识	94
7.5.2  设置进程标识	98
7.6  小结	99
7.7  实践与练习	99
第8章  进程间通信	101
视频讲解：41分钟
8.1  进程间通信概述	102
8.1.1  进程间通信的工作原理	102
8.1.2  进程间通信的主要分类	102
8.2  管道与命名管道	102
8.2.1  管道基本定义	103
8.2.2  管道创建和管道关闭	103
8.2.3  pipe()函数实现管道通信	103
8.2.4  命名管道基本定义	106
8.2.5  在Shell中创建命名管道	106
8.2.6  mkfifo()函数创建命名管道	107
8.3  共享内存	109
8.3.1  SYSV子系统的基本知识	109
8.3.2  共享内存相关操作	110
8.3.3  共享内存实现进程间通信	113
8.4  信号量	115
8.4.1  信号量的工作原理	115
8.4.2  信号量的相关操作	116
8.4.3  信号量实现进程间通信	118
8.5  消息队列	120
8.5.1  消息队列的相关操作	121
8.5.2  消息队列实现进程间通信	123
8.6  小结	125
8.7  实践与练习	125
第9章  文件操作	127
视频讲解：37分钟
9.1  文件初探	128
9.1.1  文件与文件系统的概念	128
9.1.2  文件的属性	128
9.1.3  文件的相关信息	129
9.2  文件的相关操作	130
9.2.1  修改文件属性	131
9.2.2  复制文件描述符	134
9.2.3  获取文件信息	135
9.2.4  文件的其他操作	136
9.3  特殊文件的操作	137
9.3.1  目录文件的操作	137
9.3.2  链接文件的操作	141
9.3.3  设备文件	143
9.4  小结	144
9.5  实践与练习	144
第10章  文件的输入/输出操作	145
视频讲解：30分钟
10.1  文件I/O操作概述	146
10.1.1  文件描述符简介	146
10.1.2  数据流概述	146
10.2  基于文件描述符的I/O操作	147
10.2.1  文件的打开与关闭	147
10.2.2  文件的读写操作	149
10.2.3  文件的定位	150
10.3  基于数据流的I/O操作	152
10.3.1  文件的打开与关闭	153
10.3.2  字符输入/输出	154
10.3.3  字符串输入/输出	156
10.3.4  数据块输入/输出	157
10.3.5  格式化输入/输出	158
10.3.6  操作读写位置的函数	159
10.3.7  C标准库的I/O缓冲区	162
10.4  小结	163
10.5  实践与练习	164
第11章  信号及信号处理	165
视频讲解：23分钟
11.1  信号概述	166
11.1.1  在终端中查看常见的信号	166
11.1.2  信号处理	166
11.2  产生信号	167
11.2.1  kill()函数	167
11.2.2  raise()函数	168
11.2.3  alarm()函数	168
11.3  捕捉信号	168
11.3.1  signal()函数	169
11.3.2  sigaction()函数	171
11.4  信号的阻塞	172
11.4.1  sigprocmask()函数	173
11.4.2  sigsuspend()函数	173
11.4.3  sigpending()函数	173
11.5  信号处理的安全问题	175
11.6  小结	176
11.7  实践与练习	176
第12章  网络编程	177
视频讲解：30分钟
12.1  网络编程的基本原理	178
12.1.1  计算机网络	178
12.1.2  TCP/IP协议	179
12.1.3  IP地址简介	179
12.1.4  套接字编程原理	182
12.2  TCP套接字编程	187
12.3  UDP套接字编程	190
12.3.1  数据传输系统调用	191
12.3.2  基于UDP协议的C/S机制的网络
通信的工作原理	192
12.3.3  基于UDP的简单网络通信实例	193
12.4  原始套接字编程	195
12.4.1  原始套接字定义	196
12.4.2  原始套接字系统调用	196
12.4.3  原始套接字的发送与接收	197
12.4.4  报文处理	197
12.5  小结	200
12.6  实践与练习	200
第13章  make编译基础	201
视频讲解：1小时54分钟
13.1  通过实例认识make	202
13.1.1  Makefile的导入	202
13.1.2  make是如何工作的	206
13.1.3  Makefile中使用变量	207
13.1.4  让make自动推导	208
13.1.5  清空目标文件的规则	209
13.2  make概述	209
13.2.1  Makefile中有什么	209
13.2.2  Makefile的文件名	210
13.2.3  包含其他Makefile文件	210
13.2.4  变量MAKEFILES	212
13.2.5  变量MAKEFILE_LIST	213
13.2.6  其他特殊变量	213
13.2.7  Makefile文件的重建	213
13.2.8  重载另外一个Makefile	215
13.2.9  make如何解析Makefile文件	215
13.2.10  总结	216
13.3  Makefile基本规则	217
13.3.1  规则举例	217
13.3.2  规则语法	218
13.3.3  依赖的类型	219
13.3.4  文件名使用通配符	219
13.3.5  目录搜寻	221
13.3.6  Makefile伪目标	226
13.3.7  强制目标（没有命令或依赖的规则）	229
13.3.8  空目标文件	229
13.3.9  Makefile的特殊目标	230
13.3.10  多目标	231
13.3.11  多规则目标	232
13.3.12  静态模式	233
13.3.13  双冒号规则	235
13.3.14  自动产生依赖	236
13.3.15  书写命令	238
13.4  变量的基本操作	242
13.4.1  变量的基础	243
13.4.2  变量中的变量	243
13.4.3  变量高级用法	245
13.4.4  追加变量值	247
13.4.5  override指示符	248
13.4.6  多行变量	248
13.4.7  环境变量	249
13.4.8  目标变量	249
13.4.9  模式变量	250
13.5  条件判断	250
13.5.1  示例	250
13.5.2  语法	251
13.6  基本函数的使用	253
13.6.1  函数的调用语法	253
13.6.2  字符串处理函数	254
13.6.3  文件名操作函数	257
13.6.4  foreach()函数	259
13.6.5  if()函数	260
13.6.6  call()函数	260
13.6.7  origin()函数	261
13.6.8  shell()函数	262
13.6.9  控制make的函数	262
13.7  make的运行	263
13.7.1  make的退出码	263
13.7.2  指定Makefile	263
13.7.3  指定目标	263
13.7.4  检查规则	265
13.7.5  make的参数	265
13.8  隐含规则	267
13.8.1  使用隐含规则	268
13.8.2  隐含规则一览	269
13.8.3  隐含规则使用的变量	270
13.8.4  隐含规则链	271
13.8.5  模式规则	272
13.8.6  后缀规则	275
13.8.7  隐含规则搜索算法	276
13.9  make工具与函数库	277
13.9.1  函数库文件的成员	277
13.9.2  函数库成员的隐含规则	278
13.9.3  函数库文件的后缀规则	278
13.9.4  注意事项	278
13.10  小结	278
13.11  实践与练习	279
第14章  Linux系统下的C语言与
数据库	281
视频讲解：12分钟
14.1  MySQL数据库简介	282
14.2  安装和连接MySQL数据库	282
14.2.1  安装MySQL数据库	282

14.2.2  启动和关闭MySQL	283
14.3  连接操作MySQL	285
14.3.1  MySQL常用数据库操作函数	285
14.3.2  连接MySQL数据	287
14.3.3  查询表记录	288
14.3.4  插入表记录	289
14.3.5  修改表记录	290
14.3.6  删除表记录	290
14.4  Oracle数据库简介	291
14.5  Oracle数据库的安装	292
14.5.1  软硬件要求	292
14.5.2  安装Oracle 11g数据库	295
14.5.3  创建监听和数据库	296
14.6  连接Oracle数据库	300
14.7  小结	302
14.8  实践与练习	302
第15章  集成开发环境	303
视频讲解：13分钟
15.1  Eclipse与CDT简介	304
15.2  安装和配置Eclipse	305
15.2.1  安装Eclipse	305
15.2.2  配置Eclipse的CDT	307
15.3  使用Eclipse开发C代码	308
15.3.1  编写运行Hello World	308
15.3.2  CDT的相关功能	310
15.3.3  调试C/C++的项目	310
15.4  小结	311

第3篇  高 级 应 用
第16章  界面开发基础	315
视频讲解：23分钟
16.1  Linux常用桌面环境	316
16.1.1  面板介绍	316
16.1.2  桌面图标介绍	317
16.1.3  桌面背景	318
16.2  glib库介绍	319
16.2.1  类型定义	319
16.2.2  glib的宏	319
16.2.3  内存管理	320
16.2.4  字符串处理	321
16.2.5  数据结构	323
16.3  GObject对象介绍	325
16.4  图形引擎Cairo介绍	326
16.5  多媒体库介绍	328
16.5.1  元件和插件	328
16.5.2  衬垫	329
16.5.3  数据、缓冲区和事件	329
16.5.4  缓冲区的分配	330
16.5.5  MIME类型和属性	330
16.6  小结	330
16.7  实践与练习	330
第17章  界面布局	331
视频讲解：34分钟
17.1  窗体	332
17.1.1  初始化	332
17.1.2  建立窗口	332
17.1.3  结束应用程序	334
17.1.4  回调函数	334
17.1.5  其他窗体函数	336
17.2  组装盒构件	337
17.2.1  组装盒的原理	337
17.2.2  盒的细节	338
17.2.3  组装盒程序	339
17.2.4  用表组装	343
17.2.5  表组装程序	345
17.3  容器	347
17.3.1  事件盒	347
17.3.2  对齐构件	347
17.3.3  固定容器	348
17.3.4  布局容器	349
17.3.5  框架	350
17.3.6  分栏窗口构件	352
17.3.7  视角	353
17.3.8  滚动窗口	353
17.3.9  按钮盒	355
17.3.10  工具栏	357
17.3.11  笔记本	362
17.4  小结	366
17.5  实践与练习	366
第18章  界面构件开发	367
视频讲解：1小时4分钟
18.1  基本界面构件	368
18.1.1  按钮构件	368
18.1.2  调整对象	372
18.1.3  范围构件	374
18.1.4  标签	381
18.1.5  箭头	384
18.1.6  工具提示对象	386
18.1.7  进度条	386
18.1.8  对话框	390
18.1.9  标尺	391
18.2  杂项构件	394
18.2.1  状态栏	394
18.2.2  文本输入构件	396
18.2.3  微调按钮	398
18.2.4  组合框	404
18.2.5  日历	406
18.2.6  颜色选择	414
18.2.7  文件选择	415
18.3  RC文件	416
18.4  小结	417
18.5  实践与练习	417
第19章  Glade设计程序界面	419
视频讲解：23分钟
19.1  Glade简介	420
19.2  构造图形界面	421
19.2.1  添加窗体	421
19.2.2  添加容器	427
19.2.3  添加构件	433
19.2.4  设置构件属性	436
19.2.5  添加事件和回调	437
19.3  C语言代码联编	438
19.3.1  GtkBuilder代码连接基础	439
19.3.2  GtkBuilder代码连接实例	441
19.4  小结	443
19.5  实践与练习	443



第4篇  项 目 实 战
第20章  MP3音乐播放器	447
视频讲解：13分钟
20.1  GStreamer简介	448
20.2  界面设计	449
20.3  代码设计	451
20.3.1  建立工程文件	451
20.3.2  主程序设计	452
20.3.3  生成playbin对象	453
20.3.4  打开文件	457
20.3.5  播放MP3	458
20.3.6  暂停播放	459
20.3.7  停止播放	459
20.3.8  界面更新	460
20.3.9  播放控制	461
20.4  小结	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码整洁之道:程序员的职业素养
必读引言1
第1章 专业主义 7
1.1 清楚你要什么 8
1.2 担当责任 8
1.3 首先，不行损害之事 10
1.3.1 不要破坏软件功能 10
1.3.2 不要破坏结构 12
1.4 职业道德 13
1.4.1 了解你的领域 14
1.4.2 坚持学习 16
1.4.3 练习 16
1.4.4 合作 17
1.4.5 辅导 17
1.4.6 了解业务领域 17
1.4.7 与雇主／客户保持一致 18
1.4.8 谦逊 18
1.5 参考文献 18
第2章 说“不” 19
2.1 对抗角色 21
2.2 高风险时刻 24
2.3 要有团队精神 25
2.3.1 试试看 26
2.3.2 消极对抗 28
2.4 说“是”的成本 30
2.5 如何写出好代码 35
第3章 说“是” 37
3.1 承诺用语 39
3.1.1 识别“缺乏承诺”的征兆 40
3.1.2 真正的承诺听起来是怎样的 40
3.1.3 总结 43
3.2 学习如何说“是” 43
3.2.1 “试试”的另一面 43
3.2.2 坚守原则 44
3.3 结论 46
第4章 编码 47
4.1 做好准备 48
4.1.1 凌晨3点写出的代码 49
4.1.2 焦虑时写下的代码 50
4.2 流态区 51
4.2.1 音乐 52
4.2.2 中断 53
4.3 阻塞 53
4.4 调试 55
4.5 保持节奏 57
4.5.1 知道何时应该离开一会 58
4.5.2 开车回家路上 58
4.5.3 洗澡 58
4.6 进度延迟 58
4.6.1 期望 59
4.6.2 盲目冲刺 59
4.6.3 加班加点 60
4.6.4 交付失误 60
4.6.5 定义“完成” 61
4.7 帮助 61
4.7.1 帮助他人 61
4.7.2 接受他人的帮助 62
4.7.3 辅导 62
4.8 参考文献 63
第5章 测试驱动开发 65
5.1 此事已有定论 66
5.2 TDD的三项法则 67
5.3 TDD的优势 68
5.3.1 确定性 68
5.3.2 缺陷注入率 68
5.3.3 勇气 69
5.3.4 文档 69
5.3.5 设计 70
5.3.6 专业人士的选择 70
5.4 TDD的局限 70
5.5 参考文献 71
第6章 练习 73
6.1 引子 73
6.1.110的22次方 74
6.1.2 转变 75
6.2 编程柔道场 76
6.2.1 卡塔 77
6.2.2 瓦萨 78
6.2.3 自由练习 78
6.3 自身经验的拓展 79
6.3.1 开源 79
6.3.2 关于练习的职业道德 79
6.4 结论 80
6.5 参考文献 80
第7章 验收测试 81
7.1 需求的沟通 81
7.1.1 过早精细化 83
7.1.2 迟来的模糊性 83
7.2 验收测试 85
7.2.1 “完成”的定义 85
7.2.2 沟通 88
7.2.3 自动化 88
7.2.4 额外工作 89
7.2.5 验收测试什么时候写，由谁来写 90
7.2.6 开发人员的角色 90
7.2.7 测试的协商与被动推进 91
7.2.8 验收测试和单元测试 93
7.2.9 图形界面及其他复杂因素 93
7.2.10 持续集成 94
7.3 结论 95
第8章 测试策略 97
8.1 QA应该找不到任何错误 98
8.1.1 QA也是团队的一部分 98
8.1.2 需求规约定义者 98
8.1.3 特性描述者 98
8.2 自动化测试金字塔 98
8.2.1 单元测试 99
8.2.2 组件测试 100
8.2.3 集成测试 100
8.2.4 系统测试 101
8.2.5 人工探索式测试 102
8.3 结论 102
8.4 参考文献 102
第9章 时间管理 103
9.1 会议 104
9.1.1 拒绝 104
9.1.2 离席 105
9.1.3 确定议程与目标 105
9.1.4 立会 106
9.1.5 迭代计划会议 106
9.1.6 迭代回顾和DEMO展示 107
9.1.7 争论／反对 107
9.2 注意力点数 108
9.2.1 睡眠 108
9.2.2 咖啡因 108
9.2.3 恢复 109
9.2.4 肌肉注意力 109
9.2.5 输入与输出 109
9.3 时间拆分和番茄工作法 110
9.4 要避免的行为 110
9.5 死胡同 111
9.6 泥潭 111
9.7 结论 112
第10章 预估 113
10.1 什么是预估 115
10.1.1 承诺 115
10.1.2 预估 115
10.1.3 暗示性承诺 117
10.2 PERT 118
10.3 预估任务 120
10.4 大数定律 122
10.5 结论 123
10.6 参考文献 123
第11章 压力 125
11.1 避免压力 127
11.1.1 承诺 127
11.1.2 保持整洁 127
11.1.3 危机中的纪律 128
11.2 应对压力 128
11.2.1 不要惊慌失措 128
11.2.2 沟通 129
11.2.3 依靠你的纪律原则 129
11.2.4 寻求帮助 129
11.3 结论 129
第12章 协作 131
12.1 程序员与人 133
12.1.1 程序员与雇主 133
12.1.2 程序员与程序员 135
12.2 小脑 137
12.3 结论 138
第13章 团队与项目 139
13.1 只是简单混合吗 139
13.1.1 有凝聚力的团队 140
13.1.2 如何管理有凝聚力的团队 141
13.1.3 项目承包人的困境 142
13.2 结论 142
13.3 参考文献 143
第14章 辅导、学徒期与技艺 145
14.1 失败的学位教育 145
14.2 辅导 146
14.2.1 DIGI—COMPI，我的第一台计算机 146
14.2.2 高中时代的ECP—18148
14.2.3 非常规辅导 150
14.2.4 艰难的锤炼 150
14.3 学徒期 151
14.3.1 软件学徒期 152
14.3.2 现实情况 154
14.4 技艺 154
14.5 结论 155
附录 工具 157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码整洁之道:程序员的职业素养
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>占有性个人主义的政治理论
第一章 导论
第一节 自由民主理论的根源1
第二节 解释的问题4
第二章 霍布斯：市场的政治义务
第一节 哲学与政治理论9
第二节 人的本性与自然状态18
一、从社会中抽象出来18
二、自然状态19
三、从生理运动到社会运动30
第三节 社会模型49
一、模型的用途49
二、习惯社会或身份社会51
三、简单市场社会53
四、占有性市场社会
五、霍布斯与占有性模型………………………………………………62
六、自然状态的不足……………………………………………………69
第四节 政治义务……………………………………………………………71
一、从动机到义务………………………………………………………71
二、道德义务还是审慎义务？…………………………………………73
三、对平等的设定………………………………………………………75
四、道德、科学和市场…………………………………………………79
五、从事实中推定出义务………………………………………………82
第五节 霍布斯政治理论的洞察力和局限性………………………88
一、推导的历史前提……………………………………………………88
二、自我持续的主权者…………………………………………………91
三、主权与市场社会的叠合……………………………………………96
四、对一些反对理由的反思…………………………………………101
第三章 平等派：选举权与自由
第一节 选举权问题……………………………………………………109
第二节 选举权的类型…………………………………………………114
第三节 记载………………………………………………………………120
一、大事记………………………………………………………………120
二、普特尼及之后……………………………………………………123
三、在普特尼之前……………………………………………………133
四、小结…………………………………………………………………140
第四节 理论意蕴…………………………………………………………141
一、对人身的财产权…………………………………………………141
二、权利推导和选举权排除的理由…………………………………148
三、平等派和独立派的个人主义……………………………………153
四、平等派个人主义的局限和发展方向…………………………159
第四章 哈林顿：机会国家
第一节 未予检验的含糊………………………………………………165
第二节 均势与士绅……………………………………………………167
第三节 资产阶级社会…………………………………………………180
第四节 平等的共和国和平等的土地法……………………………188
第五节 自我取消的均势原理………………………………………195
第六节 哈林顿的地位…………………………………………………197
第五章 洛克：关于据有的政治理论
第一节 解释问题…………………………………………………………201
第二节 财产权理论……………………………………………………205
一、洛克的目标…………………………………………………………205
二、最初的有限权利…………………………………………………207
三、被逾越的限制……………………………………………………211
四、洛克的成就…………………………………………………………230
第三节 自然权利和理性能力的阶级差别………………………231
一、洛克对17 世纪英格兰的差别的预设…………………………231
二、权利差别和理性能力差别的一般化…………………………239
第四节 含糊不清的自然状态………………………………………247
第五节 含糊不清的政治社会………………………………………256
第六节 对未解决问题的反思………………………………………260
一、合股理论…………………………………………………………261
二、多数人统治v. 财产权利…………………………………………261
三、个人同意和多数人同意的等同…………………………………262
四、个人主义v. 集体主义……………………………………………264
五、洛克的立宪主义…………………………………………………266
第六章 占有性个人主义与自由主义民主
第一节 17 世纪的基础…………………………………………………272
第二节 20 世纪的困境…………………………………………………280
附录 1648 年左右英格兰的社会阶级和选举权人类别
类别四 雇工和领取施舍者……………………………………………289
一、雇工…………………………………………………………………289
二、领取施舍者和乞丐………………………………………………294
小结：雇工和领取施舍者……………………………………………297
类别一、二和三……………………………………………………………297
类别一 自由保有人和公司自由人…………………………………297
类别二 不属于类别一的济贫税纳税户主………………………298
类别三 不属于类别四的非济贫税纳税人………………………300
把对1688 年的估算换算成对1648 年的估算……………………301
注释……………………………………………………………………………305
引用的作品及其版本
一、17 世纪作品……………………………………………………………321
哈林顿……………………………………………………………………321
霍布斯……………………………………………………………………321
平等派著作………………………………………………………………322
洛克………………………………………………………………………323
二、现代作品………………………………………………………………324
索引……………………………………………………………………………325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>占有性个人主义的政治理论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C基础教程
第1章  启程  1.1  预备知识  1.2  历史背景  1.3  内容简介  1.4  小结第2章  对C的扩展  2.1  最简单的Objective-C程序  2.2  解构Hello Objective-C程序    2.2.1  #import    2.2.2  NSLog()和@“字符串”  2.3  布尔类型    2.3.1  BOOL强大的实用功能    2.3.2  比较  2.4  小结第3章  面向对象编程基础知识  3.1  间接    3.1.1  变量与间接    3.1.2  使用文件名的间接  3.2  在面向对象的编程中使用间接    3.2.1  过程式编程    3.2.2  实现面向对象编程  3.3  学习有关的术语  3.4  Objective-C中的OOP    3.4.1  @interface部分    3.4.2  @implementation部分    3.4.3  实例化对象    3.4.4  扩展Shapes-Object  3.5  小结第4章  继承  4.1  为何使用继承  4.2  继承语法  4.3  继承的工作机制    4.3.1  方法调度    4.3.2  实例变量  4.4  重写方法  4.5  小结第5章  复合  5.1  什么是复合    5.1.1  Car程序    5.1.2  自定义NSLog()  5.2  存取方法    5.2.1  设置发动机的属性    5.2.2  设置轮胎的属性    5.2.3  跟踪汽车的变化  5.3  扩展CarParts程序  5.4  复合还是继承  5.5  小结第6章  源文件组织  6.1  拆分接口和实现部分  6.2  拆分Car程序  6.3  使用跨文件依赖关系    6.3.1  重新编译须知    6.3.2  让汽车开动    6.3.3  导入和继承  6.4  小结第7章  深入了解Xcode  7.1  改变公司名称  7.2  使用编辑器的技巧与诀窍  7.3  在Xcode的帮助下编写代码    7.3.1  首行缩进    7.3.2  代码自动完成    7.3.3  括号匹配    7.3.4  批量编辑    7.3.5  代码导航    7.3.6  emacs不是Mac程序    7.3.7  任意搜索    7.3.8  芝麻开门    7.3.9  书签    7.3.10  集中注意力    7.3.11  开启导航条  7.4  获取信息    7.4.1  研究助手    7.4.2  文档管理程序  7.5  调试    7.5.1  暴力调试    7.5.2  Xcode的调试器    7.5.3  精巧的调试符号    7.5.4  开始调试    7.5.5  检查程序  7.5  备忘表  7.6  小结第8章  Foundation Kit快速教程  8.1  一些有用的数据类型    8.1.1  范围的作用    8.1.2  几何数据类型  8.2  字符串    8.2.1  创建字符串    8.2.2  类方法    8.2.3  关于大小    8.2.4  比较的策略    8.2.5  不区分大小写的比较    8.2.6  字符串内是否还包含别的字符串  8.3  可变性  8.4  集合家族    8.4.1  NSArray    8.4.2  可变数组    8.4.3  枚举“王国”    8.4.4  快速枚举    8.4.5  NSDictionary    8.4.6  使用，但不要扩展  8.5  各种数值    8.5.1  NSNumber    8.5.2  NSValue    8.5.3  NSNull  8.6  示例：查找文件  8.7  小结第9章  内存管理  9.1  对象生命周期    9.1.1  引用计数    9.1.2  对象所有权    9.1.3  访问方法中的保留和释放  9.2  自动释放    9.2.1  所有对象全部入池    9.2.2  自动释放池的销毁时间    9.2.3  自动释放池的工作过程  9.3  Cocoa内存管理规则    9.3.1  临时对象    9.3.2  拥有对象    9.3.3  垃圾回收  9.4  小结第10章  对象初始化  10.1  分配对象  10.2  初始化对象    10.2.1  编写初始化方法    10.2.2  初始化时做什么  10.3  便利初始化函数  10.4  更多部件改进    10.4.1  Tire类的初始化    10.4.2  更新main()函数    10.4.3  清理Car类  10.5  支持垃圾回收风格的Car类清理  10.6  指定初始化函数    10.6.1  子类化问题    10.6.2  改进Tire类的初始化函数    10.6.3  添加AllWeatherRadial类的初始化函数  10.7  初始化函数规则  10.8  小结第11章  特性  11.1  修改特性值    11.1.1  简化接口    11.1.2  简化实现    11.1.3  点表达式的妙用  11.2  特性扩展    11.2.1  名称的使用    11.2.2  只读特性    11.2.3  特性不是万能的  11.3  小结第12章  类别  12.1  创建类别    12.1.1  声明类别    12.1.2  实现类别    12.1.3  类别的局限性    12.1.4  类别的作用  12.2  利用类别分散实现  12.3  使用类别创建前向引用  12.4  非正式协议和委托类别    12.4.1  ITunesFinder项目    12.4.2  委托和类别    12.4.3  响应选择器    12.4.4  选择器的其他应用  12.5  小结第13章  协议  13.1  正式协议    13.1.1  声明协议    13.1.2  采用协议    13.1.3  实现协议  13.2  复制    13.2.1  复制Engine    13.2.2  复制Tire    13.2.3  复制Car    13.2.4  协议和数据类型  13.3  Objective-C 2.0的新特性  13.4  小结第14章  AppKit简介  14.1  构建项目  14.2  构建AppController @interface  14.3  Interface Builder  14.4  布局用户界面  14.5  连接    14.5.1  连接输出口    14.5.2  连接操作  14.6  AppController实现  14.7  小结第15章  文件加载与保存  15.1  属性列表    15.1.1  NSDate    15.1.2  NSData    15.1.3  写入和读取属性列表  15.2  编码对象  15.3  小结第16章  键/值编码  16.1  入门项目  16.2  KVC简介  16.3  路径  16.4  整体操作    16.4.1  中途小憩    16.4.2  流畅地运算  16.5  批处理  16.6  nil仍然可用  16.7  处理未定义的键  16.8  小结第17章  NSPredicate  17.1  创建谓词  17.2  燃料过滤器  17.3  格式说明符  17.4  运算符    17.4.1  比较和逻辑运算符    17.4.2  数组运算符  17.5  SELF足够了  17.6  字符串运算符  17.7  LIKE运算符  17.8  小结附录  从其他语言转向Objective-C
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>公司财务原理
作者介绍
译者序
前言
第一部分内容的相关网址
第一部分 价值
第1章　财务与财务经理
第2章　现值、企业目标与公司治理
第3章 如何计算现值
第4章 债券与普通股的价值
第5章 与其他投资准则相比，为什么净现值法则能导出较优的投资决策
第6章 利用净现值法则进行投资决策
第二部分内容的相关网址
第二部分 风险
第7章 风险、收益与资本机会成本概论
第8章 风险与收益
第9章 资本预算与风险
第三部分内容的相关网址
第三部分 资本预算的实务问题
第10章 项目并不是黑箱
第11章 战略与资本投资决策
.　　第12章 代理问题、经理人薪酬与业绩评估
第四部分内容的相关网址
第四部分 融资决策与市场有效性
第13章 公司融资与市场有效性的六点启示
第14章 公司融资概况
第15章 公司如何发行证券
第五部分内容的相关网址
第五部分 股利政策与资本结构
第16章 股利政策
第17章 负债政策重要吗
第18章 公司负债该多少
第19章 融资与价值评估
第六部分内容的相关网址
第六部分 期权
第20章 期权的基本知识
第21章 期权的价值评估
第22章 实物期权
第七部分内容的相关网址
第七部分 负债融资
第23章 政府债券的价值评估
第24章 信用风险
第25章 多种多样的债券
第26章 租赁
第八部分内容的相关网址
第八部分 风险管理
第27章 风险管理
第28章 国际风险管理
第九部分内容的相关网址
第九部分 财务计划与营运资本管理
第29章 财务分析与财务计划
第30章 营运资本管理
第31章 短期融资计划
第十部分内容的相关网址
第十部分 兼并、公司控制与公司管理
第32章 兼并
第33章 公司重组
第34章 世界各国的公司治理与公司控制
第十一部分内容的相关网址
第十一部分 总结
第35章 总结：财务理论的已知与未知
附录a 现值表
附录b 练习题答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>公司财务原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>卡尔霍恩文集（上下）
目录
导读: 通向罗马之路
卡尔霍恩文集（上）
=====
论政府
美国的宪法和政府
附录：
1798年弗吉利亚决议案
1798年肯塔基决议案
詹姆斯·麦迪逊就弗吉利亚决议案提交的报告
卡尔霍恩文集（下）
=====
否决权（1842年2月28日）
关于奴隶制问题决议案的演说（1847年2月19日）
在查尔斯顿公民集会上的演说（1847年3月9日）
俄勒冈议案演说（1848年6月27日）
关于接纳加利福尼亚为成员州问题的演说，兼及联邦的普遍状态（1850年3月4日）
关于外事委员会决议案的演说（1811年12月12日）
关税议案演说（1816年4月4日）
解释与抗议（1828年12月19日）
希尔堡演说:各州与联邦政府的关系问题（1831年7月26日）
关于废奴请愿书的演说（1837年2月6日）
致约翰·鲍斯科特及诸友人的公开信（1837年11月3日）
附录：
美国内战及其历史地位 （阿克顿）
论新帝国 （亚当斯）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>卡尔霍恩文集（上下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>灯光师圣经（插图第4版）
前　言
第一章　　片场基础知识
第二章　　前期制作计划
第三章　　基本钨丝灯库
第四章　　灯架与灯光预置
第五章　　照明的目标和方法
第六章　　光的控制
第七章　　电工的布景操作规程
第八章　　HMI灯库
第九章　　荧光灯
第十章　　LED灯
第十一章　照明控制
第十二章　电　学
第十三章　配电与调光设备
第十四章　电的使用
第十五章　电气预置
第十六章　电　源
第十七章　特殊环境与实践
第十八章　特种照明器材
附　录
重要词汇
出版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>灯光师圣经（插图第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>不朽的钢琴家
序　言
图片目录
从头说起：J．S．巴赫、J．C．巴赫、C．P．E．巴赫
要像油在流：莫扎特
三度、六度和八度：克莱门蒂
侧坐和旅行演出：杜赛克、克拉默、沃尔弗尔、施戴贝尔特
弦弹断，手抬高：贝多芬
过渡时期：车尔尼、韦伯
从爱尔兰到波希米亚：菲尔德、胡梅尔、卡尔克布雷纳、莫谢莱斯
浪漫主义以及浪漫主义的规矩
肺结核、浪漫派、诗人：肖邦
雷鸣、闪电、蛊惑、性感：李斯特
老琶音、沙龙音乐家和对美国的渗入：塔尔贝格、梅耶、赫尔茨
其他沙龙音乐家和八度“革命”：普莱耶尔、德赖萧克
两个敏感的钢琴家：阿尔坎、亨泽尔特
第一个美国人：戈特沙尔克
德高望重的钢琴家：门德尔松、哈雷、克拉拉‧舒曼
暴君和理性主义者：彪罗、戈达尔
神父的孩子们：赖内克、陶西格、门特、奥赫、里维-金
来自东方的霹雳：安东‧鲁宾斯坦、尼古拉‧鲁宾斯坦
法国式的干净、精确和典雅：圣-桑、普朗泰、普尼奥、里斯勒
李斯特的门生和莱谢蒂茨基的门生继承大业：莱谢蒂茨基、舒尔霍夫
大天使降临人间：帕德雷夫斯基
小巨人以及李斯特制造的其他巨人：达尔伯特、罗森塔尔、绍尔、约瑟菲、格里夫、弗里德海姆
莱谢蒂茨基的门徒：加布里洛维奇、弗里德曼、莫伊谢耶维奇
肖邦巧匠、佛陀和其他人：帕赫曼、戈多夫斯基、格兰杰
女士们：卡雷尼奥、艾西波夫、蔡斯勒
键盘旁的作曲家们：阿尔贝尼斯
键盘旁的浮士德博士：布索尼
完美有加：霍夫曼
清教徒：拉赫玛尼诺夫
当时的几个头牌明星：鲍尔、列维涅、科尔托、萨马罗夫
新的哲学，新的风格：普罗科菲耶夫、兰多芙斯卡
再造了贝多芬的人：施纳贝尔
浪漫主义仍在燃烧：霍洛维茨、鲁宾斯坦
二十世纪诸多学派：阿劳、吉泽金、塞尔金
解冻之后：吉利尔斯、李希特、阿什肯纳齐、贝尔曼
时髦的巴赫：古尔德
两个受到顶礼膜拜的偶像：布伦德尔、波利尼
美国制造：克莱本、博利特、古铁雷斯、佩拉希亚
人名对照
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>不朽的钢琴家
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>应用密码学：协议、算法与C源程序（原书第2版）
出版者的话
译者序
Whitfield Diffie序
前言
第1章　基础知识1
1.1　专业术语1
1.1.1　发送者和接收者1
1.1.2　消息和加密1
1.1.3　鉴别、完整性和抗抵赖1
1.1.4　算法和密钥2
1.1.5　对称算法3
1.1.6　公开密钥算法3
1.1.7　密码分析4
1.1.8　算法的安全性5
1.1.9　过去的术语6
1.2　隐写术7
1.3　代替密码和换位密码7
1.3.1　代替密码7
1.3.2　换位密码8
1.3.3　转轮机9
1.3.4　进一步的读物9
1.4　简单异或9
1.5　一次一密乱码本11
1.6　计算机算法12
1.7　大数13
第一部分　密码协议
第2章　协议结构模块16
2.1　协议概述16
2.1.1　协议的目的16
2.1.2　协议中的角色17
2.1.3　仲裁协议17
2.1.4　裁决协议19
2.1.5　自动执行协议20
2.1.6　对协议的攻击20
2.2　使用对称密码系统通信20
2.3　单向函数21
2.4　单向散列函数22
2.5　使用公开密钥密码系统通信23
2.5.1　混合密码系统24
2.5.2　Merkle的难题25
2.6　数字签名25
2.6.1　使用对称密码系统和仲裁者对文件签名26
2.6.2　数字签名树27
2.6.3　使用公开密钥密码系统对文件签名27
2.6.4　文件签名和时间标记27
2.6.5　使用公开密钥密码系统和单向散列函数对文件签名28
2.6.6　算法和术语28
2.6.7　多重签名28
2.6.8　抗抵赖和数字签名29
2.6.9　数字签名的应用29
2.7　带加密的数字签名30
2.7.1　重新发送消息作为收据30
2.7.2　阻止重新发送攻击31
2.7.3　对公开密钥密码系统的攻击31
2.8　随机和伪随机序列的产生32
2.8.1　伪随机序列32
2.8.2　密码学意义上安全的伪随机序列33
2.8.3　真正的随机序列33
第3章　基本协议34
3.1　密钥交换34
3.1.1　对称密码系统的密钥交换34
3.1.2　公开密钥密码系统的密钥交换34
3.1.3　中间人攻击34
3.1.4　连锁协议35
3.1.5　使用数字签名的密钥交换36
3.1.6　密钥和消息传输36
3.1.7　密钥和消息广播37
3.2　鉴别37
3.2.1　使用单向函数鉴别37
3.2.2　字典式攻击和salt37
3.2.3　SKEY38
3.2.4　使用公开密钥密码系统鉴别38
3.2.5　使用联锁协议互相鉴别39
3.2.6　SKID40
3.2.7　消息鉴别40
3.3　鉴别和密钥交换40
3.3.1　Wide-Mouth Frog协议41
3.3.2　Yahalom协议41
3.3.3　Needham-Schroeder协议41
3.3.4　Otway-Rees协议42
3.3.5　Kerberos协议43
3.3.6　Neuman-Stubblebine协议43
3.3.7　DASS协议44
3.3.8　Denning-Sacco协议45
3.3.9　Woo-Lam协议45
3.3.10　其他协议46
3.3.11　学术上的教训46
3.4　鉴别和密钥交换协议的形式化分析46
3.5　多密钥公开密钥密码系统48
3.6　秘密分割49
3.7　秘密共享50
3.7.1　有骗子的秘密共享51
3.7.2　没有Trent的秘密共享51
3.7.3　不暴露共享的秘密共享51
3.7.4　可验证的秘密共享51
3.7.5　带预防的秘密共享52
3.7.6　带除名的秘密共享52
3.8　数据库的密码保护52
第4章　中级协议53
4.1　时间标记服务53
4.1.1　仲裁解决方法53
4.1.2　改进的仲裁解决方法53
4.1.3　链接协议54
4.1.4　分布式协议54
4.1.5　进一步的工作55
4.2　阈下信道55
4.2.1　阈下信道的应用56
4.2.2　杜绝阈下的签名56
4.3　不可抵赖的数字签名57
4.4　指定的确认者签名58
4.5　代理签名58
4.6　团体签名59
4.7　失败终止数字签名60
4.8　加密数据计算60
4.9　位承诺60
4.9.1　使用对称密码系统的位承诺61
4.9.2　使用单向函数的位承诺61
4.9.3　使用伪随机序列发生器的位承诺62
4.9.4　模糊点62
4.10　公平的硬币抛掷62
4.10.1　使用单向函数的抛币协议63
4.10.2　使用公开密钥密码系统的抛币协议64
4.10.3　抛币入井协议64
4.10.4　使用抛币产生密钥65
4.11　智力扑克65
4.11.1　三方智力扑克65
4.11.2　对扑克协议的攻击66
4.11.3　匿名密钥分配66
4.12　单向累加器67
4.13　秘密的全或无泄露68
4.14　密钥托管68
第5章　高级协议71
5.1　零知识证明71
5.1.1　基本的零知识协议71
5.1.2　图同构73
5.1.3　汉密尔顿圈73
5.1.4　并行零知识证明74
5.1.5　非交互式零知识证明75
5.1.6　一般性75
5.2　身份的零知识证明76
5.2.1　国际象棋特级大师问题77
5.2.2　黑手党骗局77
5.2.3　恐怖分子骗局77
5.2.4　建议的解决方法77
5.2.5　多重身份骗局78
5.2.6　出租护照78
5.2.7　成员资格证明78
5.3　盲签名79
5.3.1　完全盲签名79
5.3.2　盲签名协议79
5.3.3　专利81
5.4　基于身份的公开密钥密码系统81
5.5　不经意传输81
5.6　不经意签名83
5.7　同时签约83
5.7.1　带有仲裁者的签约83
5.7.2　无需仲裁者的同时签约：面对面83
5.7.3　无需仲裁者的同时签约：非面对面84
5.7.4　无需仲裁者的同时签约：使用密码系统85
5.8　数字证明邮件86
5.9　秘密的同时交换87
第6章　深奥的协议89
6.1　保密选举89
6.1.1　简单投票协议189
6.1.2　简单投票协议289
6.1.3　使用盲签名投票90
6.1.4　带有两个中央机构的投票90
6.1.5　带有单个中央机构的投票91
6.1.6　改进的带有单个中央机构的投票91
6.1.7　无需中央制表机构的投票92
6.1.8　其他投票方案95
6.2　保密的多方计算95
6.2.1　协议195
6.2.2　协议296
6.2.3　协议396
6.2.4　协议497
6.2.5　无条件多方安全协议97
6.2.6　保密电路计算97
6.3　匿名消息广播98
6.4　数字现金99
6.4.1　协议1100
6.4.2　协议2100
6.4.3　协议3101
6.4.4　协议4101
6.4.5　数字现金和高明的犯罪103
6.4.6　实用化的数字现金104
6.4.7　其他数字现金协议104
6.4.8　匿名信用卡105
第二部分　密码技术
第7章　密钥长度108
7.1　对称密钥长度108
7.1.1　穷举攻击所需时间和金钱估计109
7.1.2　软件破译机110
7.1.3　神经网络111
7.1.4　病毒111
7.1.5　中国式抽彩法111
7.1.6　生物工程技术112
7.1.7　热力学的局限性113
7.2　公开密钥长度113
7.2.1　DNA计算法117
7.2.2　量子计算法117
7.3　对称密钥和公开密钥长度的比较118
7.4　对单向散列函数的生日攻击118
7.5　密钥应该多长119
7.6　小结120
第8章　密钥管理121
8.1　产生密钥121
8.1.1　减少的密钥空间121
8.1.2　弱密钥选择122
8.1.3　随机密钥123
8.1.4　通行短语124
8.1.5　X9.17密钥产生125
8.1.6　DoD密钥产生125
8.2　非线性密钥空间125
8.3　传输密钥126
8.4　验证密钥127
8.4.1　密钥传输中的错误检测128
8.4.2　解密过程中的错误检测128
8.5　使用密钥128
8.6　更新密钥129
8.7　存储密钥129
8.8　备份密钥130
8.9　泄露密钥131
8.10　密钥有效期131
8.11　销毁密钥132
8.12　公开密钥的密钥管理133
8.12.1　公开密钥证书133
8.12.2　分布式密钥管理134
第9章　算法类型和模式135
9.1　电子密码本模式135
9.2　分组重放136
9.3　密码分组链接模式138
9.3.1　初始化向量138
9.3.2　填充139
9.3.3　错误扩散140
9.3.4　安全问题140
9.4　序列密码算法140
9.5　自同步序列密码141
9.6　密码反馈模式142
9.6.1　初始化向量143
9.6.2　错误扩散143
9.7　同步序列密码144
9.8　输出反馈模式145
9.8.1　初始化向量145
9.8.2　错误扩散145
9.8.3　安全问题146
9.8.4　OFB模式中的序列密码146
9.9　计数器模式146
9.10　其他分组密码模式147
9.10.1　分组链接模式147
9.10.2　扩散密码分组链接模式147
9.10.3　带校验和的密码分组链接147
9.10.4　带非线性函数的输出反馈147
9.10.5　其他模式148
9.11　选择密码模式148
9.12　交错149
9.13　分组密码与序列密码150
第10章　使用算法151
10.1　选择算法151
10.2　公开密钥密码系统与对称密码系统152
10.3　通信信道加密153
10.3.1　链链加密153
10.3.2　端端加密154
10.3.3　两者的结合155
10.4　用于存储的加密数据156
10.4.1　非关联密钥156
10.4.2　驱动器级与文件级加密156
10.4.3　提供加密驱动器的随机存取157
10.5　硬件加密与软件加密158
10.5.1　硬件158
10.5.2　软件159
10.6　压缩、编码及加密159
10.7　检测加密159
10.8　密文中隐藏密文160
10.9　销毁信息161
第三部分　密码算法
第11章　数学背景164
11.1　信息论164
11.1.1　熵和不确定性164
11.1.2　语言信息率164
11.1.3　密码系统的安全性165
11.1.4　唯一解距离165
11.1.5　信息论的运用166
11.1.6　混乱和扩散166
11.2　复杂性理论167
11.2.1　算法的复杂性167
11.2.2　问题的复杂性168
11.2.3　NP完全问题170
11.3　数论170
11.3.1　模运算170
11.3.2　素数172
11.3.3　最大公因子172
11.3.4　求模逆元173
11.3.5　求系数175
11.3.6　费尔马小定理175
11.3.7　欧拉φ函数175
11.3.8　中国剩余定理175
11.3.9　二次剩余176
11.3.10　勒让德符号177
11.3.11　雅可比符号177
11.3.12　Blum整数 179
11.3.13　生成元179
11.3.14　伽罗瓦域中的计算180
11.4　因子分解181
11.5　素数的产生182
11.5.1　Solovag-Strassen183
11.5.2　Lehmann183
11.5.3　Rabin-Miller184
11.5.4　实际考虑184
11.5.5　强素数185
11.6　有限域上的离散对数185
第12章　数据加密标准187
12.1　背景187
12.1.1　标准的开发187
12.1.2　标准的采用188
12.1.3　DES设备的鉴定和认证189
12.1.4　1987年的标准189
12.1.5　1993年的标准190
12.2　DES的描述190
12.2.1　算法概要191
12.2.2　初始置换192
12.2.3　密钥置换192
12.2.4　扩展置换193
12.2.5　S盒代替193
12.2.6　P盒置换195
12.2.7　末置换196
12.2.8　DES解密196
12.2.9　DES的工作模式196
12.2.10　DES的硬件和软件实现196
12.3　DES的安全性198
12.3.1　弱密钥199
12.3.2　补密钥200
12.3.3　代数结构201
12.3.4　密钥的长度201
12.3.5　迭代的次数202
12.3.6　S盒的设计202
12.3.7　其他结论203
12.4　差分及线性分析203
12.4.1　差分密码分析203
12.4.2　相关密钥密码分析206
12.4.3　线性密码分析206
12.4.4　未来的方向208
12.5　实际设计准则208
12.6　DES的各种变型209
12.6.1　多重DES209
12.6.2　使用独立子密钥的DES209
12.6.3　DESX209
12.6.4　CRYPT(3)209
12.6.5　GDES210
12.6.6　更换S盒的DES210
12.6.7　RDES211
12.6.8　snDES211
12.6.9　使用相关密钥S盒的DES213
12.7　DES现今的安全性213
第13章　其他分组密码算法215
13.1　Lucifer算法215
13.2　Madryga算法215
13.2.1　Madryga的描述216
13.2.2　Madryga的密码分析217
13.3　NewDES算法217
13.4　FEAL算法218
13.4.1　FEAL的描述218
13.4.2　FEAL的密码分析220
13.4.3　专利222
13.5　REDOC算法222
13.5.1　REDOC Ⅲ222
13.5.2　专利和许可证223
13.6　LOKI算法223
13.6.1　LOKI91223
13.6.2　LOKI91的描述223
13.6.3　LOKI91的密码分析224
13.6.4　专利和许可证225
13.7　Khufu和Khafre算法225
13.7.1　Khufu225
13.7.2　Khafre226
13.7.3　专利226
13.8　RC2算法226
13.9　IDEA算法227
13.9.1　IDEA227
13.9.2　IDEA的描述228
13.9.3　IDEA的速度229
13.9.4　IDEA的密码分析230
13.9.5　IDEA的操作方式和变型231
13.9.6　敬告使用者231
13.9.7　专利和许可证232
13.10　MMB算法232
13.11　CA-1.1算法233
13.12　Skipjack算法234
第14章　其他分组密码算法（续）236
14.1　GOST算法236
14.1.1　GOST的描述236
14.1.2　GOST的密码分析237
14.2　CAST算法238
14.3　Blowfish算法239
14.3.1　Blowfish的描述239
14.3.2　Blowfish的安全性241
14.4　SAFER算法241
14.4.1　SAFER K-64的描述241
14.4.2　SAFER K-128242
14.4.3　SAFER K-64的安全性243
14.5　3-Way算法243
14.6　Crab算法243
14.7　SXAL8/MBAL算法245
14.8　RC5算法245
14.9　其他分组密码算法246
14.10　分组密码设计理论246
14.10.1　Feistel网络247
14.10.2　简单关系247
14.10.3　群结构248
14.10.4　弱密钥248
14.10.5　强的抗差分攻击和线性攻击248
14.10.6　S盒的设计248
14.10.7　设计分组密码250
14.11　使用单向散列函数250
14.11.1　Karn250
14.11.2　Luby-Rackoff251
14.11.3　消息摘要密码251
14.11.4　基于单向散列函数的密码安全性252
14.12　分组密码算法的选择252
第15章　组合分组密码254
15.1　双重加密254
15.2　三重加密255
15.2.1　用两个密钥进行三重加密255
15.2.2　用三个密钥进行三重加密256
15.2.3　用最小密钥进行三重加密256
15.2.4　三重加密模式256
15.2.5　三重加密的变型257
15.3　加倍分组长度258
15.4　其他多重加密方案259
15.4.1　双重OFB/计数器259
15.4.2　ECB+OFB259
15.4.3　xDESi260
15.4.4　五重加密261
15.5　缩短CDMF密钥261
15.6　白化261
15.7　级联多重加密算法261
15.8　组合多重分组算法262
第16章　伪随机序列发生器和序列密码263
16.1　线性同余发生器263
16.2　线性反馈移位寄存器265
16.3　序列密码的设计与分析270
16.3.1　线性复杂性271
16.3.2　相关免疫性271
16.3.3　其他攻击272
16.4　使用LFSR的序列密码272
16.4.1　Geffe发生器272
16.4.2　推广的Geffe发生器273
16.4.3　Jennings发生器273
16.4.4　Beth-Piper停走式发生器274
16.4.5　交错停走式发生器274
16.4.6　双侧停走式发生器275
16.4.7　门限发生器275
16.4.8　自采样发生器276
16.4.9　多倍速率内积式发生器276
16.4.10　求和式发生器276
16.4.11　DNRSG277
16.4.12　Gollmann级联277
16.4.13　收缩式发生器277
16.4.14　自收缩式发生器277
16.5　A5算法278
16.6　Hughes XPD/KPD算法278
16.7　Nanoteq算法278
16.8　Rambutan算法279
16.9　附加式发生器279
16.9.1　Fish发生器279
16.9.2　Pike发生器280
16.9.3　Mush发生器280
16.10　Gifford算法280
16.11　M算法281
16.12　PKZIP算法281
第17章　其他序列密码和真随机序列发生器283
17.1　RC4算法283
17.2　SEAL算法284
17.2.1　伪随机函数族284
17.2.2　SEAL的描述284
17.2.3　SEAL的安全性285
17.2.4　专利和许可证285
17.3　WAKE算法285
17.4　带进位的反馈移位寄存器286
17.5　使用FCSR的序列密码293
17.5.1　级联发生器293
17.5.2　FCSR组合发生器293
17.5.3　LFSR/FCSR加法/奇偶级联294
17.5.4　交错停走式发生器294
17.5.5　收缩式发生器295
17.6　非线性反馈移位寄存器295
17.7　其他序列密码296
17.7.1　Pless发生器296
17.7.2　蜂窝式自动发生器296
17.7.3　1/p发生器296
17.7.4　crypt(1)297
17.7.5　其他方案297
17.8　序列密码设计的系统理论方法297
17.9　序列密码设计的复杂性理论方法298
17.9.1　Shamir伪随机数发生器298
17.9.2　Blum-Micali发生器298
17.9.3　RSA298
17.9.4　Blum、Blum和Shub298
17.10　序列密码设计的其他方法299
17.10.1　Rip van Winkle密码299
17.10.2　Diffie随机序列密码300
17.10.3　Maurer随机序列密码300
17.11　级联多个序列密码300
17.12　选择序列密码300
17.13　从单个伪随机序列发生器产生多个序列301
17.14　真随机序列发生器302
17.14.1　RAND表302
17.14.2　使用随机噪声303
17.14.3　使用计算机时钟303
17.14.4　测量键盘反应时间304
17.14.5　偏差和相关性304
17.14.6　提取随机性305
第18章　单向散列函数307
18.1　背景307
18.1.1　单向散列函数的长度308
18.1.2　单向散列函数综述308
18.2　Snefru算法308
18.3　N-Hash算法309
18.4　MD4算法311
18.5　MD5算法312
18.5.1　MD5的描述312
18.5.2　MD5的安全性315
18.6　MD2算法315
18.7　安全散列算法316
18.7.1　SHA的描述316
18.7.2　SHA的安全性318
18.8　RIPE-MD算法319
18.9　HAVAL算法319
18.10　其他单向散列函数319
18.11　使用对称分组算法的单向散列函数320
18.11.1　散列长度等于分组长度的方案320
18.11.2　改进的Davies-Meyer322
18.11.3　Preneel-Bosselaers-Govaerts-Vandewalle322
18.11.4　Quisquater-Girault322
18.11.5　LOKI双分组323
18.11.6　并行Davies-Meyer323
18.11.7　串联和并联Davies-Meyer323
18.11.8　MDC-2和MDC-4324
18.11.9　AR散列函数325
18.11.10　GOST散列函数325
18.11.11　其他方案326
18.12　使用公开密钥算法326
18.13　选择单向散列函数326
18.14　消息鉴别码326
18.14.1　CBC-MAC327
18.14.2　消息鉴别算法327
18.14.3　双向MAC327
18.14.4　Jueneman方法327
18.14.5　RIPE-MAC328
18.14.6　IBC-Hash328
18.14.7　单向散列函数MAC328
18.14.8　序列密码MAC329
第19章　公开密钥算法330
19.1　背景330
19.2　背包算法331
19.2.1　超递增背包331
19.2.2　由私人密钥产生公开密钥332
19.2.3　加密332
19.2.4　解密332
19.2.5　实际的实现方案333
19.2.6　背包的安全性333
19.2.7　背包变型333
19.2.8　专利333
19.3　RSA算法334
19.3.1　RSA的硬件实现335
19.3.2　RSA的速度336
19.3.3　软件加速336
19.3.4　RSA的安全性337
19.3.5　对RSA的选择密文攻击337
19.3.6　对RSA的公共模数攻击338
19.3.7　对RSA的低加密指数攻击338
19.3.8　对RSA的低解密指数攻击339
19.3.9　经验339
19.3.10　对RSA的加密和签名攻击339
19.3.11　标准339
19.3.12　专利340
19.4　Pohlig-Hellman算法340
19.5　Rabin算法340
19.6　ElGamal算法341
19.6.1　ElGamal签名342
19.6.2　ElGamal加密342
19.6.3　速度343
19.6.4　专利343
19.7　McEliece算法343
19.8　椭圆曲线密码系统344
19.9　LUC算法345
19.10　有限自动机公开密钥密码系统345
第20章　公开密钥数字签名算法347
20.1　数字签名算法347
20.1.1　对通告的反应347
20.1.2　DSA的描述349
20.1.3　快速预计算350
20.1.4　DSA的素数产生351
20.1.5　使用DSA的ElGamal加密351
20.1.6　使用DSA的RSA加密352
20.1.7　DSA的安全性352
20.1.8　攻击k353
20.1.9　公共模数的危险353
20.1.10　DSA中的阈下信道353
20.1.11　专利354
20.2　DSA的变型354
20.3　GOST数字签名算法355
20.4　离散对数签名方案356
20.5　Ong-Schnorr-Shamir签名方案357
20.6　ESIGN签名方案358
20.6.1　ESIGN的安全性358
20.6.2　专利359
20.7　细胞自动机359
20.8　其他公开密钥算法359
第21章　鉴别方案361
21.1　Feige-Fiat-Shamir算法361
21.1.1　简化的Feige-Fiat-Shamir身份鉴别方案361
21.1.2　Feige-Fiat-Shamir身份鉴别方案362
21.1.3　例子362
21.1.4　加强方案363
21.1.5　Fiat-Shamir签名方案363
21.1.6　改进的Fiat-Shamir签名方案364
21.1.7　其他加强方案364
21.1.8　Ohta-Okamoto身份鉴别方案364
21.1.9　专利364
21.2　Guillou-Quisquater算法364
21.2.1　Guillou-Quisquater身份鉴别方案365
21.2.2　Guillou-Quisquater数字签名方案365
21.2.3　多重签名365
21.3　Schnorr算法366
21.3.1　鉴别协议366
21.3.2　数字签名协议366
21.3.3　专利367
21.4　将身份鉴别方案转为数字签名方案367
第22章　密钥交换算法368
22.1　Diffie-Hellman算法368
22.1.1　三方或多方Diffie-Hellman368
22.1.2　扩展Diffie-Hellman369
22.1.3　Hughes369
22.1.4　不用交换密钥的密钥交换369
22.1.5　专利369
22.2　站间协议369
22.3　Shamir的三次传递协议370
22.4　COMSET协议371
22.5　加密密钥交换371
22.5.1　基本EKE协议371
22.5.2　用RSA实现EKE372
22.5.3　用ElGamal实现EKE372
22.5.4　用Diffie-Hellman实现EKE372
22.5.5　加强的EKE372
22.5.6　扩充的EKE373
22.5.7　EKE的应用373
22.6　加强的密钥协商374
22.7　会议密钥分发和秘密广播374
22.7.1　会议密钥分发375
22.7.2　Tatebayashi-Matsuzaki-Newman376
第23章　协议的专用算法377
23.1　多重密钥的公开密钥密码系统377
23.2　秘密共享算法377
23.2.1　LaGrange插值多项式方案377
23.2.2　矢量方案378
23.2.3　Asmuth-Bloom378
23.2.4　Kamin-Greene-Hellman379
23.2.5　高级门限方案379
23.2.6　有骗子情况下的秘密共享379
23.3　阈下信道380
23.3.1　Ong-Schnorr-Shamir380
23.3.2　ElGamal381
23.3.3　ESIGN381
23.3.4　DSA382
23.3.5　挫败DSA阈下信道383
23.3.6　其他方案384
23.4　不可抵赖的数字签名384
23.5　指定的确认者签名386
23.6　用加密数据计算387
23.7　公平的硬币抛掷387
23.7.1　利用平方根的硬币抛掷387
23.7.2　利用模p指数运算的硬币抛掷388
23.7.3　利用Blum整数的硬币抛掷389
23.8　单向累加器389
23.9　秘密的全或无泄露389
23.10　公正和故障保险密码系统391
23.10.1　公正的Diffie-Hellman391
23.10.2　故障保险的Diffie-Hellman392
23.11　知识的零知识证明392
23.11.1　离散对数的零知识证明392
23.11.2　破译RSA能力的零知识证明393
23.11.3　n是一个Blum整数的零知识证明393
23.12　盲签名394
23.13　不经意传输394
23.14　保密的多方计算394
23.15　概率加密396
23.16　量子密码学397
第四部分　真实世界
第24章　实现方案实例402
24.1　IBM秘密密钥管理协议402
24.2　MITRENET403
24.3　ISDN403
24.3.1　密钥403
24.3.2　呼叫404
24.4　STU-Ⅲ404
24.5　Kerberos405
24.5.1　Kerberos模型405
24.5.2　Kerberos工作原理406
24.5.3　凭证406
24.5.4　Kerberos第5版消息407
24.5.5　最初票据的获取407
24.5.6　服务器票据的获取407
24.5.7　服务请求408
24.5.8　Kerberos第4版408
24.5.9　Kerberos的安全性408
24.5.10　许可证409
24.6　KryptoKnight409
24.7　SESAME409
24.8　IBM通用密码体系410
24.9　ISO鉴别框架411
24.9.1　证书411
24.9.2　鉴别协议412
24.10　保密性增强邮件413
24.10.1　PEM的有关文件413
24.10.2　证书413
24.10.3　PEM的消息414
24.10.4　PEM的安全性416
24.10.5　TIS/PEM416
24.10.6　RIPEM417
24.11　消息安全协议417
24.12　Pretty Good Privacy417
24.13　智能卡419
24.14　公开密钥密码学标准420
24.15　通用电子支付系统421
24.16　Clipper422
24.17　Capstone424
24.18　AT&T 3600型电话保密设备424
第25章　政治426
25.1　国家安全局426
25.2　国家计算机安全中心427
25.3　国家标准技术所428
25.4　RSA数据安全有限公司430
25.5　公开密钥合作商430
25.6　国际密码研究协会432
25.7　RACE完整性基本评估432
25.8　对欧洲的有条件访问432
25.9　ISO/IEC 9979433
25.10　专业人员、公民自由和工业组织433
25.10.1　电子秘密信息中心433
25.10.2　电子战线基金会433
25.10.3　计算机协会434
25.10.4　电气和电子工程师学会434
25.10.5　软件出版商协会434
25.11　sci.crypt434
25.12　Cypherpunks434
25.13　专利434
25.14　美国出口法规435
25.15　其他国家的密码进出口439
25.16　合法性问题440
附录A　源代码441
参考文献484
Matt Blaze跋544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>应用密码学：协议、算法与C源程序（原书第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>逻辑的力量
章节目录
第1章 基本概念
1.1　有效性和可靠性
1.2　形式和反例
1.3　一些“著名”形式 .
1.4 强度和可信度
第2章 识别论证
2.1 论证和非论证
2.2 良构论证
附录：论证图
第3章 逻辑和语言
3.1 逻辑、意义和情感力
3.2 定义
3.3 用定义评价论证
第4章 非形式谬误
4.1 包含不相干前提的谬误
4.2 包含歧义的谬误 .
4.3 包含不当假设的谬误
第5章　词项逻辑：直接推理
5.1 直言陈述的标准形式
5.2　传统对当方阵
5.3 进一步的直接推理
第6章　词项逻辑：三段论
6.1 标准形式、式和格
6.2 文恩图与直言陈述
6.3 现代对当方阵
6.4 现代对当方阵
6.5 省略式
6.6 连锁与消除项补集
6.7 评价三段论的规则
第7章 命题逻辑：真值表
7.1 日常论证的符号化
7.2 真值表
7.3 用真值表评价论证
7.4　简化真值表
7.5 重言式、矛盾式、协调式和逻辑等值式
第8章 命题逻辑：证明
8.1 蕴涵推理规则
8.2 五个等值规则
8.3 五个更多的等值规则
8.4 条件句证明
8.5 归谬律
8.6 定理证明 .
第9章 归纳
9.1 归纳和演绎：比较与分类 .
9.2 诉诸权威论证和枚举归纳
9.3 密尔法和科学推理
9.4 诉诸类比的论证
部分练习题解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>逻辑的力量
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分析心理学与梦的诠释
译序一、心理治疗实务的原则二、心理治疗的目的三、心理治疗与世界观四、当今的心理治疗五、心理治疗的基本问题六、宣泄的心理治疗价值七、解析梦的实用性八、心理学中有关梦的普遍观点九、梦的本质一○、关于情结的一般理论一一、关于类型的一般描写一二、精神分裂德汉名词对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分析心理学与梦的诠释
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哲学导论
序言
哲学的历史
导论
第一部分	世界与彼岸
第1章	实在
第2章	宗教
第3章	知识
第二部分	认识你自己
第4章	真理与相对主义
第5章	心灵与身体
第6章	自我
第7章	自由
第三部分	善与权利
第8章	伦理学
第9章	正义
术语表
出版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哲学导论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C安全编码标准
关于作者
前言
第1章 本标准使用说明系统质量
自动生成的代码
顺应性
第2章 预处理器（PRE）
建议和规则
风险评估汇总
相关规则和建议
PRE00-C.用内联函数或静态函数代替与函数相似的宏
PRE01-C.在宏参数名两边加上括号
PRE02-C.宏替换列表应该加上括号
PRE03-C.应该使用typedef定义编码类型
PRE04-C.不要复用标准头文件名
PRE05-C.理解连接标记或执行字符串化时的宏替换
PRE06-C.把头文件放在包含防护条件中
PRE07-C.避免使用连续的问号
PRE08-C.保证头文件名惟一
PRE09-C.不要用不安全的函数替换安全函数
PRE10-C.在一个do-while循环中包装多条语句的宏
PRE30-C.不要通过连接创建统一字符名称
PRE31-C.不要在不安全宏的参数中包含赋值、增值、减值、volatile访问或函数调用
第3章 声明和初始化（DCL）
建议和规则
风险评估汇总
DCL00-C. 用const限定不可修改的对象
DCL01-C.不要在子作用域中复用变量名
DCL02-C.使用视觉区别明显的标识符
DCL03-C.使用静态断言测试常量表达式的值
DCL04-C.不要在一个声明中声明超过1个的变量
DCL05-C.使用typedef声明提高代码的可读性
DCL06-C.使用有意义的符号常量表示程序逻辑中的字面值
DCL07-C.在函数声明器中包含适当的类型信息
DCL08-C.在常量定义中对关系进行正确的编码
DCL09-C.把返回errno错误代码的函数的返回类型声明为errno_t
DCL10-C.维护变参函数的编写者和调用者之间的契约
DCL11-C.理解与变参函数相关联的类型问题
DCL12-C.使用不透明类型实现抽象数据类型
DCL13-C.把不会被函数修改的值指针参数声明为const
DCL14　不要对跨翻译单元的全局变量的初始化顺序作出假设
DCL15-C.把不需要外部链接的对象声明为static
DCL30-C.声明具有正确存储持久期的对象
DCL31-C.在使用标识符之前声明它们
DCL32-C.保证相互可见的标识符是惟一的
DCL33-C.保证函数实参中具有限制性限定的源指针和目标指针不引用重叠的对象
DCL34-C.对无法缓存的数据使用volatile
DCL35-C.不要使用与函数定义不匹配的类型转换函数
DCL36-C.不要声明具有冲突链接属性的标识符
第4章 表达式（EXP）
建议和规则
风险评估汇总
相关的规则和建议
EXP00-C.使用括号保证操作的优先级
EXP01-C.不要用指针的长度确定它所指向类型的长度
EXP02-C.注意逻辑AND和OR操作符的短路行为
EXP03-C.不要认为结构的长度等于它的各个成员的长度之和
EXP04-C.不要在结构之间执行逐字节的比较
EXP05-C.不要转换掉const限定
EXP06-C. sizeof操作符的操作数不应该包含副作用
EXP07-C.不要在表达式中对常量的值作出假设而削弱常量的优点
EXP08-C.确保正确地使用指针运算
EXP09-C.使用sizeof确定类型或变量的长度
EXP10-C.不要依赖子表达式的求值顺序或副作用的发生顺序
EXP11-C.不要把期待一种类型的操作符应用于一种不兼容的类型
EXP12-C.不要忽略函数的返回值
EXP30-C.不要依赖序列点之间的求值顺序
EXP31-C.避免断言的副作用
EXP32-C.不要转换掉volatile限定..
EXP33-C.不要引用未初始化的内存
EXP34-C.保证不对null指针进行解引用
EXP35-C.不要在后续的序列点之后访问或修改一个函数的调用结果中的数组
EXP36-C.不要把指针转换为对齐要求更严格的指针类型
EXP37-C.调用函数时使用API所指定的参数
EXP38-C.不要在位段成员或非法类型上调用offsetof()
第5章 整数（INT）
建议和规则
风险评估汇总
相关的规则和建议
INT00-C.理解编译器所使用的数据模型
INT01-C.使用rsize_t或size_t类型表示所有表示对象长度的整数值
INT02-C.理解整数转换规则
INT03-C.使用安全的整数库
INT04-C.对来自不信任来源的整数值实行限制
INT05-C.如果输入函数无法处理所有可能出现的错误就不要用它们转换字符数据
INT06-C.使用strtol()或相关函数把字符串标记转换为整数
INT07-C.只使用显式的有符号或无符号char类型表示数值
INT08-C.验证所有的整数值位于范围内
INT09-C.保证枚举常量映射到惟一数值
INT10-C.使用%操作符时不要假设余数总是正的
INT11-C.把指针转换为整数或者把整数转换为指针时需要小心
INT12-C.当普通的整数位段用于表达式时，不要对它的类型作出假设
INT13-C.只对无符号操作数使用位操作符
INT14-C.避免在同一个数据上执行位操作和算术运算
INT15-C.在程序员定义的整数类型的格式化I/O中使用intmax_t或uintmax_t
INT30-C.保证无符号整数运算不产生回绕
INT31-C.保证整型转换不会丢失或错误解释数据
INT32-C.保证有符号整数运算不会产生溢出
INT33-C.保证除法和求模运算不会导致除零错误
INT34-C.移位的数量不能是负数或大于操作数的位数
INT35-C.把整型表达式比较或赋值为一种较大类型之前用这种较大类型对它进行求值
第6章 浮点数（FCP）
建议和规则
风险评估汇总
相关规则和建议
FLP00-C.理解浮点数的限制
FLP01-C.在重新排列浮点表达式时需要注意
FLP02-C.需要精确计算时避免使用浮点数
FLP03-C.检测和处理浮点错误
FLP30-C.不要使用浮点数作为循环计数器
FLP31-C.不要用复数调用期望接受实数的函数
FLP32-C.防止或检测数学函数中的定义域错误和值域错误
FLP33-C.执行浮点运算时把整数转换为浮点数
FLP34-C.保证浮点转换位于新类型的范围之内
第7章 数组（ARR）
建议和规则
风险评估汇总
相关规则和建议
ARR00-C.理解数组的工作方式
ARR01-C.获取数组的长度时不要对指针应用sizeof操作符
ARR02-C.显式地指定数组的边界，即使它已经由初始化值列表隐式地指定
ARR30-C.保证数组索引位于合法的范围之内
ARR31-C.在所有源文件中使用一致的数组记法
ARR32-C.保证变长数组的长度参数位于合法范围之内
ARR33-C.保证复制的目标具有足够的存储空间
ARR34-C.保证表达式中的数组类型是兼容的
ARR35-C.不允许循环迭代到数组尾部之后
ARR36-C.不要对两个并不指向同一个数组的指针进行相减或比较
ARR37-C.不要把一个指向非数组对象的指针加上或减去一个整数
ARR38-C.如果结果值并不引用合法的数组元素，不要把指针加上或减去一个整数
第8章 字符和字符串（STR）
建议和规则
风险评估汇总
相关规则和建议
STR00-C.使用适合的类型表示字符
STR01-C.采纳和实现一致的字符串管理计划
STR02-C.对传递给复杂子系统的字符串数据进行净化
STR03-C.不要意外地截断null结尾的字节字符串
STR04-C.使用普通char类型表示基本字符集中的字符
STR05-C.引用字符串常量时使用const指针
STR06-C.不要以为strtok()会使解析的字符串不被修改
STR07-C.使用TR 24731修正现在的字符串操纵代码
STR08-C.使用托管字符串开发新的字符串操纵代码
STR30-C.不要试图修改字符串常量
STR31-C.保证字符串的存储具有足够的空间容纳字符数据和null结尾符
STR32-C.根据需要将字符串用null结尾
STR33-C.正确地判断宽字符串的长度
STR34-C.在转换为更大的整型长度时把字符转换为无符号类型
STR35-C.不要把未检查边界来源的数据复制到固定长度的数组
STR36-C.不要指定用字符串常量初始化的字符数组的边界
STR37-C.字符处理函数的参数必须能够用unsigned char表示
第9章 内存管理（MEM）
建议和规则
风险评估汇总
相关规则和建议
MEM00-C.在同一个模块、同一个抽象层中分配和释放内存
MEM01-C.在free()之后立即在指针中存储一个新值
MEM02-C.把内存分配函数的调用结果立即转换为指向被分配类型的指针
MEM03-C.及时清除存储在可复用资源中的敏感信息
MEM04-C.不要执行零长度的分配
MEM05-C.避免大型的堆栈分配
MEM06-C.保证敏感数据不会被写入到磁盘
MEM07-C.保证calloc()的参数相乘后可以用size_t表示
MEM08-C.只把realloc()用于改变动态分配数组的大小
MEM09-C.不要假设内存分配函数会对内存进行初始化
MEM10-C.定义和使用指针验证函数
MEM30-C.不要访问已经被释放的内存
MEM31-C.动态分配的内存只应释放一次
MEM32-C.检测和处理内存分配错误
MEM33-C.使用正确的语法表示灵活数组成员
MEM34-C.只释放动态分配的内存
MEM35-C.为对象分配足够的内存
第10章 输入/输出（FLO）
建议和规则
风险评估汇总
相关规则和建议
FIO00-C.在创建格式字符串时应该小心
FIO01-C.调用通过文件名标识文件的函数时必须小心
FIO02-C.对来自不信任来源的路径名进行标准化
FIO03-C.不要对fopen()和文件的创建作出假设
FIO04-C.检测和处理输入和输出错误
FIO05-C.使用多个文件属性标识文件
FIO06-C.创建具有正确访问权限的文件
FIO07-C.用fseek()代替rewind()
FIO08-C.在打开的文件上调用remove()时应该小心
FIO09-C.跨系统传输二进制数据时应该小心
FIO10-C.使用rename()函数时应该小心
FIO11-C.指定fopen()的mode参数时应该小心
FIO12-C.使用setvbuf()代替setbuf()
FIO13-C.不要压回多于1个的字符
FIO14-C.理解文件流的文本模式和二进制模式的区别
FIO15-C.保证文件操作在安全目录中执行
FIO16-C.通过创建jail限制对文件的访问
FIO30-C.排除格式字符串中的用户输入
FIO31-C.不要打开已经被打开的文件
FIO32-C.不要在专用于文件的设备上执行操作
FIO33-C.检测和处理导致未定义行为的输入输出错误
FIO34-C.使用int捕捉字符I/O函数的返回值
FIO35-C.当sizeof(int) == sizeof(char)时使用feof()和ferror()检测文件尾和文件错误
FIO36-C.不要假设fgets()会读取换行符
FIO37-C.不要假设被读取的是字符数据
FIO38-C.不要使用FILE对象的拷贝进行输入和输出
FIO39-C.不要在没有干预刷新或定位调用的情况下在一个流中交替地执行输入和输出
FIO40-C.在fgets()失败时重置字符串
FIO41-C.调用getc()或putc()时不要使用具有副作用的流参数
FIO42-C.保证当文件不再需要时及时将它们关闭
FIO43-C.不要在共享目录中创建临时文件
FIO44-C.只在fsetpos()中使用fgetpos()所返回的值
第11章 环境（ENV）
建议和规则
风险评估汇总
相关规则和建议
ENV00-C.不要存储指向getenv()返回的字符串的指针
ENV01-C.不要对环境变量的长度作出假设
ENV02-C.注意具有相同有效名称的多个环境变量
ENV03-C. 调用外部程序时对环境进行净化
ENV04-C.如果不需要命令处理器就不要调用system()
ENV30-C.不要修改getenv()所返回的字符串
ENV31-C.在可能无效化环境指针的操作之后不能再依赖它
ENV32-C.所有的atexit处理函数都不能以除了正常返回之外的其他任何方式终止
第12章 信号（SIG）
建议和规则
风险评估汇总
相关规则和建议
SIG00-C.屏蔽由不可中断的信号处理函数所处理的信号
SIG01-C.理解与信号处理函数的持久性有关的平台特定的细节
SIG02-C.避免使用信号实现常规的功能
SIG30-C.只在信号处理函数中调用异步安全的函数
SIG31-C.不要访问和修改信号处理函数中的共享对象
SIG32-C.不要在信号处理函数中调用longjmp()
SIG33-C.不要递归地调用raise()函数
SIG34-C.不要在不可中断的信号处理函数内部调用signal()
第13章 错误处理（ERR）
建议和规则
风险评估汇总
相关规则和建议
ERR00-C.采用和实现一致的、全面的错误处理策略
ERR01-C.使用ferror()而不是errno检查FILE流错误
ERR02-C.避免带内错误指示符
ERR03-C.调用TR24731-1所定义的函数时使用运行时约束处理函数
ERR04-C.选择一种适当的终止策略
ERR05-C.独立于应用程序的代码应该在不提示错误处理的情况下提供错误检测
ERR06-C.理解assert()和abort()的终止行为
ERR30-C.调用设置errno的库函数之前把errno设置为0，并且在函数返回一个提示失败的值之后检查errno
ERR31-C.不要重定义errno
ERR32-C.不要依赖errno的不确定值
第14章 其他（MSC）
建议和规则
风险评估总结
MSC00-C.在高警告级别进行干净的编译
MSC01-C.实现逻辑完整性
MSC02-C.避免因为省略所导致的错误
MSC03-C.避免因为多余所导致的错误
MSC04-C.用一种可读的风格一致地使用注释
MSC05-C.不要直接维护time_t类型的值
MSC06-C.处理敏感数据时注意编译器的优化
MSC07-C.检测和删除死代码
MSC08-C.库函数应该对形参进行验证
MSC09-C.字符编码：使用ASCII的子集以保证安全
MSC10-C.字符编码：UTF　8相关的问题
MSC11-C.使用断言进行诊断测试
MSC12-C.检测和删除没有效果的代码
MSC13-C.检测和删除未使用的值
MSC14-C.不要引入不必要的平台依赖性
MSC15-C.不要依赖未定义的行为
MSC30-C.不要使用rand()函数产生伪随机数
MSC31-C.保证返回值与适当的类型进行比较
附录 POSIX（POS）
建议和规则
风险评估汇总
相关的规则和建议
POS00-C.避免多线程的竞争条件
POS01-C.检查链接是否存在
POS02-C.遵循最小特权原则
POS30-C.正确地使用readlink()函数
POS31-C.不要解锁或销毁另一个线程的mutex
POS32-C.在多线程环境中使用位段时包含一个mutex
POS33-C.不要使用vfork()
POS34-C.不要用一个指向自动变量的指针为参数调用putenv()
POS35-C.避免检查符号链接是否存在时的竞争条件
POS36-C.在撤消特权时注意正确的撤消顺序
POS37-C.保证特权的撤消是成功的
词汇表
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C安全编码标准
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中华帝国的法律
序
第一篇 中国法律初论
第一章 中国法的基本概念
第一节 中国法的范围和意义
第二节 法律、宗教和经济
第三节 古代中国的法律起源理论
第四节 中国最早的法典
第五节 儒家与法家
第六节 儒家的礼法观
第七节 法家与法律
第八节 法家的胜利与法律儒家化
第九节 作为礼之范例的帝国法典
第十节 法律中的孝、忠及人道主义
第十一节 法律与宇宙和谐
第十二节 概要与结论
第二章 清帝国的法典及其编纂史
第一节 文献介绍
第二节 清化法典的历史和结构
第三节 律和例
第四节 注释与翻译
第三章 刑事制度
第一节 五刑
第二节 监禁与罚金
第三节 笞刑与杖刑
第四节 徒刑
第五节 流刑
第六节 军流刑
第七节 死刑
第八节 附设刑
第九节 刑制总评
第十节 犯罪的种类
第四章 司法制度
第一节 上诉制度
第二节 刑部
第三节 死刑案件
第四节 死刑复审
第五章 《刑案汇览》
第一节 成书背景及编辑目的
第二节 案例来源
第三节 案例选择中的几个问题
第六章 从《刑案汇览》看中国的社会与政府
第一节 清代中国的犯罪
第二节 犯罪者的人员构成
第三节 司法程序
第四节 社会控制
第五节 家庭
第二篇 清帝国案例评析
一 名例律类
二 吏律类
三 户律类
四 礼律类
五 兵律类
六 刑律类
七 工律类
第三篇 清帝国法律的司法解释
附录
参考书目
词汇表
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中华帝国的法律
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>我是C罗
引言
童年——足球梦开始的地方
豪门处子秀——曼彻斯特的首赛季
代表祖国——为梦想而战的04欧洲杯
逆境中的成长——属于蓝衣军团的赛季
我们又回来了——幸运的第三个赛季？
德国世界杯——星冉冉升起
王者之战——终获冠军
继续迎接挑战——吾将上下而求索
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>我是C罗
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计语言
出版者的话
专家指导委员会前言
第1章 导言
第2章 类型、运算符与表达式
第3章 控制流
第4章 函数与程序结构
第5章 指针与数组
第6章 结构
第7章 输入与输出
第8章 UNIX系统接口
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>抗衰老饮食
第1章　抗衰老计划 / 001
挑战流行的信条 / 002
两面出击 / 003
第2章　我们所处时代的衰老疾病 / 005
疾病的“西化” / 006
20 年法则 / 007
饮食的区别 / 008
第3章　探讨心脏 / 010
胡编乱造的高昂代价 / 011
饮食与心脏 / 013
第4章　血液中的营养与心脏病 / 017
导致心脏病发作的因素 / 018
血脂形态 / 019
高密度载脂蛋白：好的胆固醇 / 020
甘油三酯 / 020
高水平甘油三酯 / 低水平高密度载脂蛋白：致命组合 / 021
载脂蛋白（A） / 023
同型半胱氨酸：隐藏的心脏危害 / 024
第5章　我们为何衰老：胰岛素的联系 / 029
心脏病和糖尿病 / 030
胰岛素和衰老的联系 / 033
如此甜美的酸味 / 035
老龄化快车道 / 037
糖如何导致我们衰老 / 038
高血压 / 041
脱氢表雄酮的干扰 / 041
处理胰岛素和血糖的困境 / 042
第6章　我们为何衰老：自由基理论 / 044
衰老的自由基理论 / 045
理解自由基 / 046
自由基损伤 / 047
自由基的其他来源 / 049
反击 / 049
打破链条：抗氧化剂救援 / 050
抗氧化酶和生命营养物 / 051
食物和补充物 / 053
第7章　为何不能进行卡路里限制 / 054
实验室里的老鼠和猴子 / 055
饥饿的人类 / 056
没有饥饿的节食 / 057
第8章　抗氧化物是“重要的”营养素 / 059
最好的抗氧化剂 / 061
行动与互动 / 061
预防心脏病 / 062
保护大脑 / 065
预防癌症 / 066
用抗氧化剂挽救视力 / 069
免疫和抗氧化剂 / 069
选择抗氧化剂 / 070
第9章　抗氧化酶 / 073
超氧化物歧化酶、过氧化氢酶和谷胱甘肽 / 073
提高酶水平 / 075
氨基酸 / 075
矿物质和维生素 / 078
辅酶 Q10 / 078
褪黑激素：幕后的抗氧化褪黑素 / 080
第10章　为何需要类胡萝卜素 / 083
类胡萝卜素 / 084
胡萝卜素 / 085
番茄红素 / 090
叶黄素和玉米黄质 / 092
阿特金斯医生的胡萝卜素处方 / 093
第11章　生物类黄酮的好处 / 095
绿茶：一杯茶中的抗氧化剂 / 096
受益的心脏 / 097
茶的其他好处 / 097
槲皮素 / 098
大蒜 / 100
寡聚原花青素：强劲的抗氧化剂 / 101
葡萄酒怎么样 / 102
银杏 / 102
多吃蔬菜！保持平衡 / 103
第12章　逆转降低的激素水平 / 105
激素的作用 / 106
激素使用注意事项 / 106
激素乐团 / 108
脱氢表雄酮：激素的母体 / 109
脱氢表雄酮和心脏病 / 110
脱氢表雄酮增强免疫力 / 111
癌症和脱氢表雄酮 / 111
脱氢表雄酮强壮骨骼 / 112
服用脱氢表雄酮 / 112
与皮质醇的联系 / 113
脱氢表雄酮剂量 / 114
孕烯醇酮：激素祖母 / 115
第13章　永葆青春之激素 / 118
雄烯二酮和天然雄性激素 / 119
关于雄性激素 / 120
女性雄性激素 / 123
黄体酮建造骨骼 / 127
生长激素 / 128
生长激素缺乏综合征 / 129
生长激素治疗方法 / 130
不利因素 / 131
如何提高类胰岛素生长因子 -1 水平 / 132
如何花钱 / 133
脱氢表雄酮和生长激素 / 133
褪黑激素和睡眠的重要性 / 134
刺激生长激素：甲状腺功能、氨基酸 / 135
喜德镇和生长激素 / 136
提升生长激素 / 137
饮食和生长激素 / 137
第14章　好脂肪和真正的坏脂肪 / 138
饱和点 / 139
好脂肪 / 141
必需脂肪酸的作用 / 142
ω-3 族脂肪酸和心脏 / 143
必需脂肪酸预防癌症 / 145
必需脂肪酸的其他好处 / 145
替代药物 / 146
ω-6 族脂肪酸和 γ- 亚油酸 / 146
怎样获益于脂肪酸 / 147
在饮食中添加必需脂肪酸 / 148
地中海饮食 / 149
最坏的反式脂肪酸 / 150
第15章　提高你的免疫力 / 153
有益于提高免疫力的饮食 / 154
免疫与癌症 / 155
有益于增强免疫力的生命营养物 / 156
植物免疫增强剂 / 161
谷氨酸：免疫系统的动力 / 163
胸腺支持 / 163
第16章　给身体解毒 / 165
减少与有毒物质的接触 / 166
你是在毒害自己吗 / 167
帮助肝脏 / 170
排铅和其他重金属 / 172
螯合排毒的关键 / 173
螯合试剂绕过搭桥手术 / 175
汞的解毒 / 176
汞和心脏 / 178
第17章　锻炼 / 179
为健康的心脏进行锻炼 / 179
锻炼的好处 / 180
更大的画面 / 181
做出抉择 / 182
健美操与力量训练 / 183
走出更好的健康 / 183
伸展真相 / 186
做的多得到的少 / 186
从现在开始 / 187
启动锻炼计划 / 188
第18章　提高大脑活力 / 189
为什么要保护大脑 / 190
如何帮助大脑 / 192
大脑的食物，大脑的锻炼 / 192
大脑的生命营养物 / 193
银杏 / 194
磷脂酰丝氨酸 / 195
胆碱 / 197
二十二碳六烯酸（DHA） / 197
乙酰左旋肉碱 / 198
孕烯醇酮 / 199
B 族维生素 / 199
“智能药物”和同样的承诺 / 202
第19章　创建抗衰老饮食 / 204
抗衰老饮食计划 / 207
消除已有的破坏 / 207
理解糖类食物 / 208
使血糖不稳定的糖类 / 209
脂肪的事实 / 210
选择安全食物 / 211
多从膳食中获取 / 212
变化是健康的调味品 / 213
避免食物过敏 / 213
评估过去的饮食 / 214
第20章　抗衰老饮食的基础知识 / 215
目标：稳定的血糖 / 216
抗衰老饮食的成分 / 217
饮料 / 223
我应该吃多少 / 224
第21章　抗衰老的饮食生活 / 226
理想的糖类水平 / 227
平衡糖类 / 228
喜人的水果 / 231
清点类胡萝卜素 / 234
水果和蔬菜的价值 / 238
全谷物的故事 / 239
建议菜单 / 241
菜单和食谱 / 241
菜 单 / 243
食 谱 / 249
第22章　抗衰老的生命营养物计划 / 263
基本的生命营养物 / 264
生命营养物解决方法 / 266
心血管健康 / 267
高胆固醇 / 268
高血压 / 269
血糖失衡 / 270
超重和肥胖 / 272
脑营养 / 273
更年期综合征 / 273
预防和治疗骨质疏松症 / 275
前列腺保护 / 276
第23章　总结 / 277
与医生合作 / 277
改变健康的世界 / 278
最后的话 / 279
附录：常见食物的升糖指数 / 281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>抗衰老饮食
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
前　言
第一部分　语法篇
第1章　从C继承而来的/2
建议0：不要让main函数返回void/2
建议1：区分0的4种面孔/5
建议2：避免那些由运算符引发的混乱/8
建议3：对表达式计算顺序不要想当然/9
建议4：小心宏#define使用中的陷阱/12
建议5：不要忘记指针变量的初始化/14
建议6：明晰逗号分隔表达式的奇怪之处/15
建议7：时刻提防内存溢出/16
建议8：拒绝晦涩难懂的函数指针/19
建议9：防止重复包含头文件/19
建议10：优化结构体中元素的布局/21
建议11：将强制转型减到最少/23
建议12：优先使用前缀操作符/26
建议13：掌握变量定义的位置与时机/28
建议14：小心typedef使用中的陷阱/30
建议15：尽量不要使用可变参数/32
建议16：慎用goto/36
建议17：提防隐式转换带来的麻烦/38
建议18：正确区分void与void*/42
第2章　从C到C++，需要做出一些改变/45
建议19：明白在C++中如何使用C /45
建议20：使用memcpy()系列函数时要足够小心/48
建议21：尽量用new/delete代替malloc/free/49
建议22：灵活地使用不同风格的注释/52
建议23：尽量使用C++标准的iostream/55
建议24：尽量采用C++风格的强制转型/58
建议25：尽量用const、enum、inline替换#define/59
建议26：用引用代替指针/62
第3章　说一说“内存管理”的那点事儿/66
建议27：区分内存分配的方式/67
建议28：new/delete与new[]/delete[]必须配对使用/69
建议29：区分new的三种形态/71
建议30：new内存失败后的正确处理/75
建议31：了解new_handler的所作所为/78
建议32：借助工具监测内存泄漏问题/81
建议33：小心翼翼地重载operator new/ operator delete /84
建议34：用智能指针管理通过new创建的对象/88
建议35：使用内存池技术提高内存申请效率与性能/91
第4章　重中之重的类/95
建议36：明晰class与struct之间的区别/95
建议37：了解C++悄悄做的那些事/99
建议38：首选初始化列表实现类成员的初始化/101
建议39：明智地拒绝对象的复制操作/105
建议40：小心，自定义拷贝函数/107
建议41：谨防因构造函数抛出异常而引发的问题/110
建议42：多态基类的析构函数应该为虚/113
建议43：绝不让构造函数为虚/116
建议44：避免在构造/析构函数中调用虚函数/117
建议45：默认参数在构造函数中给你带来的喜与悲/120
建议46：区分Overloading、Overriding及Hiding之间的差异/122
建议47：重载operator=的标准三步走/126
建议48：运算符重载，是成员函数还是友元函数/131
建议49：有些运算符应该成对实现/134
建议50：特殊的自增自减运算符重载/136
建议51：不要重载operator&&、operator||以及operator，/137
建议52：合理地使用inline函数来提高效率/139
建议53：慎用私有继承/141
建议54：抵制MI的糖衣炮弹/144
建议55：提防对象切片/147
建议56：在正确的场合使用恰当的特性/150
建议57：将数据成员声明为private/154
建议58：明晰对象构造与析构的顺序/156
建议59：明了如何在主调函数启动前调用函数/158
第5章　用好模板，向着GP开进/161
建议60：审慎地在动、静多态之间选择/161
建议61：将模板的声明和定义放置在同一个头文件里/164
建议62：用模板替代参数化的宏函数/168
建议63：区分函数模板与模板函数、类模板与模板类/169
建议64：区分继承与模板/171
第6章　让神秘的异常处理不再神秘/176
建议65：使用exception来处理错误/176
建议66：传值throw异常，传引用catch异常/179
建议67：用“throw;”来重新抛出异常/183
建议68：了解异常捕获与函数参数传递之间的差异/185
建议69：熟悉异常处理的代价/189
建议70：尽量保证异常安全/192
第7章　用好STL这个大轮子/198
建议71：尽量熟悉C++标准库/198
建议72：熟悉STL中的有关术语/201
建议73：删除指针的容器时避免资源泄漏/204
建议74：选择合适的STL容器/206
建议75：不要在STL容器中存储auto_ptr对象/209
建议76：熟悉删除STL容器中元素的惯用法/210
建议77：小心迭代器的失效/213
建议78：尽量使用vector和string代替动态分配数组/214
建议79：掌握vector和string与C语言API的通信方式/216
建议80：多用算法调用，少用手写循环/217
第二部分　编码习惯和规范篇
第8章　让程序正确执行/222
建议81：避免无意中的内部数据裸露/222
建议82：积极使用const为函数保驾护航/224
建议83：不要返回局部变量的引用/228
建议84：切忌过度使用传引用代替传对象/230
建议85：了解指针参数传递内存中的玄机/231
建议86：不要将函数参数作为工作变量 /233
建议87：躲过0值比较的层层陷阱/234
建议88：不要用reinterpret_cast去迷惑编译器/236
建议89：避免对动态对象指针使用static_cast/237
建议90：尽量少应用多态性数组/238
建议91：不要强制去除变量的const属性/240
第9章　提高代码的可读性/242
建议92：尽量使代码版面整洁优雅/243
建议93：给函数和变量起一个“能说话”的名字/246
建议94：合理地添加注释/248
建议95：为源代码设置一定的目录结构/251
建议96：用有意义的标识代替Magic Numbers/252
建议97：避免使用“聪明的技巧”/253
建议98：运算符重载时坚持其通用的含义/254
建议99：避免嵌套过深与函数过长/255
建议100：养成好习惯，从现在做起/256
第10章　让代码运行得再快些/258
建议101：用移位实现乘除法运算/258
建议102：优化循环，提高效率/259
建议103：改造switch语句/260
建议104：精简函数参数 /261
建议105：谨慎使用内嵌汇编/262
建议106：努力减少内存碎片/263
建议107：正确地使用内联函数/263
建议108：用初始化取代赋值/264
建议109：尽可能地减少临时对象/266
建议110：最后再去优化代码/267
第11章　零碎但重要的其他建议/269
建议111：采用相对路径包含头文件/269
建议112：让条件编译为开发出力/270
建议113：使用.inl文件让代码整洁可读/272
建议114：使用断言来发现软件问题/274
建议115：优先选择编译和链接错误/275
建议116：不放过任何一条编译器警告/277
建议117：尽量减少文件之间的编译依赖 /278
建议118：不要在头文件中使用using/280
建议119：划分全局名空间避免名污染/282
第三部分　程序架构和思想篇
第12章　面向对象的类设计/286
建议120：坚持“以行为为中心”的类设计/286
建议121：用心做好类设计/287
建议122：以指针代替嵌入对象或引用/289
建议123：努力将接口最小化且功能完善/291
建议124：让类的数据隐藏起来/292
建议125：不要让成员函数破坏类的封装性/294
建议126：理解“virtual + 访问限定符”的深层含义/295
建议127：谨慎恰当地使用友元机制/297
建议128：控制对象的创建方式/299
建议129：控制实例化对象的个数/301
建议130：区分继承与组合/303
建议131：不要将对象的继承关系扩展至对象容器/307
建议132：杜绝不良继承/308
建议133：将RAII作为一种习惯/310
建议134：学习使用设计模式/311
建议135：在接口继承和实现继承中做谨慎选择/314
建议136：遵循类设计的五项基本原则/315
第13章　返璞归真的程序设计/318
建议137：用表驱动取代冗长的逻辑选择/318
建议138：为应用设定特性集/324
建议139：编码之前需三思/324
建议140：重构代码/326
建议141：透过表面的语法挖掘背后的语义/328
建议142：在未来时态下开发C++程序/330
建议143：根据你的目的决定造不造轮子/331
建议144：谨慎在OO与GP之间选择/331
建议145：让内存管理理念与时俱进/332
建议146：从大师的代码中学习编程思想与技艺/334
建议147：遵循自然而然的C++风格/335
建议148：了解C++语言的设计目标与原则/335
建议149：明确选择C++的理由/338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>伊雍：自性现象学研究
序 言
第一章 自 我
第二章 阴 影
第三章 会合：阿尼玛与阿尼姆斯
第四章 自 性
第五章 基督：自性的象征
第六章 双鱼座之符号
第七章 诺查丹玛斯的预言
第八章 鱼的历史意义
第九章 双鱼象征的矛盾性
第十章 炼金术中的鱼
第十一章 炼金术对鱼的解释
第十二章 基督教炼金术象征的心理学背景
第十三章 诺斯替教中的自性象征
第十四章 自性的结构和动力
第十五章 结 论
译名对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>伊雍：自性现象学研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C基础教程
目 　 　录
第1章 　启程　　1
1.1 　预备知识　　1
1.2 　历史　　1
1.3 　内容简介　　2
1.4 　准备工作　　3
1.5 　小结　　5
第2章 　对C的扩展　　6
2.1 　最简单的Objective-C程序　　6
2.2 　解构Hello Objective-C程序　　10
2.2.1 　#import语句　　10
2.2.2 　框架　　11
2.2.3 　NSLog()和@"字符串"　　11
2.3 　布尔类型　　14
2.4 　小结　　18
第3章 　面向对象编程的基础知识　　19
3.1 　间接　　19
3.1.1 　变量与间接　　20
3.1.2 　使用文件名的间接　　22
3.2 　在面向对象编程中使用间接　　28
3.2.1 　过程式编程　　28
3.2.2 　实现面向对象编程　　34
3.3 　有关术语　　37
3.4 　Objective-C语言中的OOP　　38
3.4.1 　@interface部分　　38
3.4.2 　@implementation部分　　41
3.4.3 　实例化对象　　43
3.4.4 　扩展Shapes-Object程序　　45
3.5 　小结　　47
第4章 　继承　　48
4.1 　为何使用继承　　48
4.2 　继承的语法格式　　51
4.3 　继承的工作机制　　53
4.3.1 　方法调度　　54
4.3.2 　实例变量　　55
4.4 　重写方法　　57
4.5 　小结　　59
第5章 　复合　　61
5.1 　什么是复合　　61
5.2 　自定义NSLog()　　62
5.3 　存取方法　　65
5.3.1 　设置engine属性的存取方法　　66
5.3.2 　设置tires属性的存取方法　　67
5.3.3 　Car类代码的其他变化　　68
5.4 　扩展CarParts程序　　69
5.5 　复合还是继承　　70
5.6 　小结　　71
第6章 　源文件组织　　72
6.1 　拆分接口和实现　　72
6.2 　拆分Car程序　　75
6.3 　使用跨文件依赖关系　　77
6.3.1 　重新编译须知　　78
6.3.2 　让汽车跑一会儿　　79
6.3.3 　导入和继承　　81
6.4 　小结　　82
第7章 　深入了解Xcode　　84
7.1 　窗口布局一览　　84
7.2 　改变公司名称　　85
7.3 　使用编辑器的技巧　　86
7.4 　在Xcode的帮助下编写代码　　87
7.4.1 　首行缩进（美观排版）　　88
7.4.2 　代码自动完成　　88
7.4.3 　括号配对　　90
7.4.4 　批量编辑　　91
7.4.5 　代码导航　　94
7.4.6 　集中精力　　96
7.4.7 　使用导航条　　97
7.4.8 　获取信息　　98
7.5 　调试　　101
7.5.1 　暴力测试　　101
7.5.2 　Xcode的调试器　　101
7.5.3 　精巧的调试符号　　101
7.5.4 　开始调试　　101
7.5.5 　检查程序　　104
7.6 　备忘表　　105
7.7 　小结　　106
第8章 　Foundation Kit介绍　　107
8.1 　稳固的Foundation　　107
8.2 　使用项目样本代码　　107
8.3 　一些有用的数据类型　　108
8.3.1 　范围　　108
8.3.2 　几何数据类型　　109
8.4 　字符串　　109
8.4.1 　创建字符串　　110
8.4.2 　类方法　　110
8.4.3 　关于大小　　111
8.4.4 　字符串比较　　111
8.4.5 　不区分大小写的比较　　112
8.4.6 　字符串内是否还包含别的字符串　　113
8.4.7 　可变性　　114
8.5 　集合大家族　　115
8.5.1 　NSArray　　115
8.5.2 　可变数组　　119
8.5.3 　枚举　　120
8.5.4 　快速枚举　　121
8.5.5 　NSDictionary　　122
8.5.6 　请不要乱来　　124
8.6 　其他数值　　124
8.6.1 　NSNumber　　124
8.6.2 　NSValue　　125
8.6.3 　NSNull　　126
8.7 　示例：查找文件　　126
8.8 　小结　　130
第9章 　内存管理　　131
9.1 　对象生命周期　　131
9.1.1 　引用计数　　132
9.1.2 　对象所有权　　134
9.1.3 　访问方法中的保留和释放　　134
9.1.4 　自动释放　　136
9.1.5 　所有对象放入池中　　136
9.1.6 　自动释放池的销毁时间　　137
9.1.7 　自动释放池的工作流程　　138
9.2 　Cocoa的内存管理规则　　140
9.2.1 　临时对象　　141
9.2.2 　拥有对象　　141
9.2.3 　垃圾回收　　143
9.2.4 　自动引用计数　　144
9.3 　异常　　154
9.3.1 　与异常有关的关键字　　155
9.3.2 　捕捉不同类型的异常　　156
9.3.3 　抛出异常　　156
9.3.4 　异常也需要内存管理　　157
9.3.5 　异常和自动释放池　　158
9.4 　小结　　159
第10章 　对象初始化　　160
10.1 　分配对象　　160
10.1.1 　初始化对象　　160
10.1.2 　编写初始化方法　　161
10.1.3 　初始化时要做些什么　　162
10.2 　便利初始化函数　　163
10.3 　更多部件改进　　164
10.3.1 　Tire类的初始化　　165
10.3.2 　更新main()函数　　166
10.3.3 　清理Car类　　168
10.4 　Car类的内存清理（垃圾回收方式和ARC方式）　　171
10.5 　指定初始化函数　　172
10.5.1 　子类化问题　　173
10.5.2 　Tire类的初始化函数改进 后的版本　　175
10.5.3 　添加AllWeatherRadial类 的初始化函数　　175
10.6 　初始化函数规则　　176
10.7 　小结　　176
第11章 　属性　　177
11.1 　使用属性值　　177
11.1.1 　简化接口代码　　178
11.1.2 　简化实现代码　　179
11.1.3 　点表达式的妙用　　182
11.2 　属性扩展　　183
11.2.1 　名称的使用　　186
11.2.2 　只读属性　　188
11.2.3 　自己动手有时更好　　189
11.2.4 　特性不是万能的　　189
11.3 　小结　　189
第12章 　类别　　191
12.1 　创建类别　　191
12.1.1 　开始创建类别　　192
12.1.2 　@interface部分　　193
12.1.3 　@implementation部分　　194
12.1.4 　类别的缺陷　　195
12.1.5 　类别的优势　　196
12.1.6 　类扩展　　196
12.2 　利用类别分散实现代码　　197
12.3 　通过类别创建前向引用　　200
12.4 　非正式协议和委托类别　　201
12.4.1 　ITunesFinder项目　　202
12.4.2 　委托和类别　　204
12.4.3 　响应选择器　　205
12.4.4 　选择器的其他应用　　206
12.5 　小结　　206
第13章 　协议　　207
13.1 　正式协议　　207
13.1.1 　声明协议　　207
13.1.2 　采用协议　　208
13.1.3 　实现协议　　209
13.2 　复制　　209
13.2.1 　复制Engine　　210
13.2.2 　复制Tire　　211
13.2.3 　复制Car　　212
13.2.4 　协议和数据类型　　215
13.3 　Objective-C 2.0的新特性　　215
13.4 　委托方法　　216
13.5 　小结　　218
第14章 　代码块和并发性　　219
14.1 　代码块　　219
14.1.1 　代码块和函数指针　　219
14.1.2 　Objective-C变量　　223
14.2 　并发性　　224
14.2.1 　同步　　224
14.2.2 　队列也要内存管理　　227
14.2.3 　操作队列　　229
14.3 　小结　　231
第15章 　AppKit简介　　232
15.1 　构建项目　　232
15.2 　创建委托文件的@interface部分　　234
15.3 　Interface Builder　　235
15.4 　设计用户界面　　236
15.5 　创建连接　　239
15.5.1 　连接输出口（IBOutlet）　　239
15.5.2 　连接操作（IBAction）　　240
15.6 　应用程序委托的实现　　242
15.7 　小结　　244
第16章 　UIKit简介　　245
16.1 　视图控制器　　249
16.2 　小结　　263
第17章 　文件加载与保存　　264
17.1 　属性列表　　264
17.1.1 　NSDate　　264
17.1.2 　NSData　　265
17.1.3 　写入和读取属性列表　　266
17.1.4 　修改对象类型　　267
17.2 　编码对象　　268
17.3 　小结　　273
第18章 　键/值编码　　274
18.1 　入门项目　　274
18.2 　KVC简介　　276
18.3 　键路径　　277
18.4 　整体操作　　278
18.4.1 　休息一下　　279
18.4.2 　快速运算　　282
18.5 　批处理　　284
18.6 　nil仍然可用　　285
18.7 　处理未定义的键　　286
18.8 　小结　　287
第19章 　使用静态分析器　　288
19.1 　静态工作　　288
19.1.1 　开始分析　　288
19.1.2 　协助分析器　　292
19.1.3 　了解更多　　293
19.2 　小结　　295
第20章 　NSPredicate　　296
20.1 　创建谓词　　296
20.2 　计算谓词　　297
20.3 　数组过滤器　　298
20.4 　格式说明符　　299
20.5 　运算符　　300
20.5.1 　比较和逻辑运算符　　300
20.5.2 　数组运算符　　301
20.6 　有SELF就足够了　　302
20.7 　字符串运算符　　304
20.8 　LIKE运算符　　304
20.9 　结语　　305
附录 　从其他语言转向Objective-C　　306
索引　　314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++嵌入式系统编程
前言
第一章 引言
什么是嵌入式系统
各种实现间的差异
C：最基本的必需品
关于硬件的一些说明
第二章 你的第一个嵌入式程序
Hello，World！
闪烁程序
无限循环的作用
第三章 编译、链接和定址
创建过程
编译
链接
定址
创建闪烁程序
第四章 下载和调试
在ROM中的时候
远程调试器
仿真器
模拟器和其他工具

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++嵌入式系统编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全球文化工业
第一章 引言：理论坐标
启蒙辩证法
全球文化工业
第二章 方法：本体论、运动、绘图
引言
研究方法
再论研究方法
各章介绍
第三章 足球传记：事件的品牌化
纯红
激情与时尚：杂志
1996年欧洲杯
媒介场
权利商
公有物品和公有权利：欧洲模式
第四章 观念艺术／媒介艺术／生活艺术
观念艺术
媒介艺术
生活艺术
第五章 媒介的物化：灵活性与动画
引言
泛灵论、机械行为和动画
性格和叙事
类型与玩具
弄假成真
游戏的标准
第六章 物的媒介化：媒介物之中
引言
斯沃琪
耐克
大众产品和物的媒介化
第七章 流动：流通的实践与属性
引言
小礼物
时间的压力
断裂与差异的流动
流通的属性
流动的逻辑与实践
第八章 巴西文化工业：图像、市场、展示
引言
巴西文化工业的三个历史阶段
全球微观结构：《猜火车》
全球微观结构：《超级无敌掌门狗》
人物传记：对行业的热爱
“路径，路径，路径，路径，路径，路径，路径”：食人主义
第九章 结论：虚拟对象与社会想象
引言
从表征到物
文化物自身
游戏：本体论和拟仿
作为装饰性表面的对象
商标：结构配对与社会想象
表面想象
全球文化工业
致谢
中英文人名对照
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全球文化工业
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#高效编程
第1章 C#语言习惯	1
条目1 使用属性而不是可访问的数据成员	1
条目2 用运行时常量（readonly）而不是编译期常量（const）	7
条目3 推荐使用is或as操作符而不是强制类型转换	11
条目4 使用Conditional特性而不是#if条件编译	19
条目5 为类型提供ToString（）方法	26
条目6 理解几个等同性判断之间的关系	33
条目7 理解GetHashCode（）的陷阱	41
条目8 推荐使用查询语法而不是循环	47
条目9 避免在API中使用转换操作符	51
条目10 使用可选参数减少方法重载的数量	55
条目11 理解短小方法的优势	59
第2章 .NET资源管理	63
条目12 推荐使用成员初始化器而不是赋值语句	67
条目13 正确地初始化静态成员变量	70
条目14 尽量减少重复的初始化逻辑	72
条目15 使用using和try/finally清理资源	79
条目16 避免创建非必要的对象	85
条目17 实现标准的销毁模式	89
条目18 区分值类型和引用类型	94
条目19 保证0为值类型的有效状态	99
条目20 保证值类型的常量性和原子性	103
第3章 使用C#表达设计	111
条目21 限制类型的可见性	112
条目22 通过定义并实现接口替代继承	115
条目23 理解接口方法和虚方法的区别	123
条目24 用委托实现回调	127
条目25 用事件模式实现通知	130
条目26 避免返回对内部类对象的引用	137
条目27 让类型支持序列化	140
条目28 提供粗粒度的因特网服务API	148
条目29 支持泛型协变和逆变	152
第4章 使用框架	158
条目30 使用覆写而不是事件处理函数	158
条目31 使用IComparable〈T〉和IComparer〈T〉实现顺序关系	161
条目32 避免使用ICloneable接口	168
条目33 仅用new修饰符处理基类更新	171
条目34 避免重载基类中定义的方法	175
条目35 PLINQ如何实现并行算法	179
条目36 理解PLINQ在I/O密集场景中的应用	189
条目37 注意并行算法中的异常	193
第5章 C#中的动态编程	199
条目38 理解动态类型的优劣	199
条目39 使用动态类型表达泛型类型参数的运行时类型	207
条目40 将接受匿名类型的参数声明为dynamic	210
条目41 用DynamicObject或IDynamicMetaObjectProvider实现数据驱动的动态类型	213
条目42 如何使用表达式API	223
条目43 使用表达式将延迟绑定转换为预先绑定	229
条目44 尽量减少在公有API中使用动态对象	234
第6章 杂  项	240
条目45 尽量减少装箱和拆箱	240
条目46 为应用程序创建专门的异常类	243
条目47 使用强异常安全保证	248
条目48 尽量使用安全的代码	257
条目49 实现与CLS兼容的程序集	260
条目50 实现小尺寸、高内聚的程序集	265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#高效编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET入门经典
第1章 初识ASP.NET
第2章 剖析ASP.NET页
第3章 表单和HTML服务器控件
第4章 使用C#存储变量数据
第5章 XML语言介绍
第6章 控制结构和过程式编程
第7章 事件驱动编程技术和回送
第8章 对象概述
第9章 静态粝员和类关系
第10章 ASP.NET中的对象
第11章 对象和结构化数据
第12章 从数据源中读取
第13章 操纵数据源
第14章 ASP.NET服务器控件
……
附录A 公用的系统名称空间
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C算法(第一卷:基础、数据结构、排序和搜索)(第三版)
第一部分　基础知识
第1章 导

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C算法(第一卷:基础、数据结构、排序和搜索)(第三版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>魔鬼家书
作者序　／　1
书信　／　5
私酷鬼致祝酒辞前言　／　150
私酷鬼致祝酒辞　／　153
后记　／　176
译后记　／　190
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>魔鬼家书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第1章数据结构概论11.1数据结构的概念11.1.1数据结构举例11.1.2数据与数据结构21.1.3数据结构的分类31.1.4数据结构课程的内容41.2数据结构的抽象形式61.2.1数据类型61.2.2数据抽象与抽象数据类型71.3作为ADT的C++类91.3.1面向对象的概念91.3.2C++中的类101.3.3C++中的对象121.3.4C++的输入输出131.3.5C++中的函数141.3.6动态存储分配171.3.7C++中的继承181.3.8多态性191.3.9C++的模板231.4算法定义241.5算法性能分析与度量261.5.1算法的性能标准261.5.2算法的后期测试261.5.3算法的事前估计271.5.4算法的渐进分析321.5.5最坏、最好和平均情况36习题37第2章线性表432.1线性表432.1.1线性表的概念432.1.2线性表的类定义442.2顺序表452.2.1顺序表的定义和特点452.2.2顺序表的类定义及其操作452.2.3顺序表的性能分析502.2.4顺序表的应用522.3单链表522.3.1单链表的概念532.3.2单链表的类定义542.3.3单链表中的插入与删除562.3.4带附加头结点的单链表592.3.5单链表的模板类602.4线性链表的其他变形662.4.1循环链表662.4.2双向链表692.5单链表的应用：多项式及其运算732.5.1多项式的表示742.5.2多项式的类定义752.5.3多项式的加法772.5.4多项式的乘法792.6静态链表80习题83第3章栈和队列883.1栈883.1.1栈的定义883.1.2顺序栈893.1.3链式栈923.1.4栈的应用之一——括号匹配943.1.5栈的应用之二——表达式的计算953.2栈与递归1013.2.1递归的概念1013.2.2递归过程与递归工作栈1053.2.3用回溯法求解迷宫问题1093.3队列1143.3.1队列的概念1143.3.2循环队列1143.3.3链式队列1183.3.4队列应用举例：打印二项展开式(a+b)i的系数1203.3.5队列应用举例：电路布线1213.4优先级队列1243.4.1优先级队列的概念1243.4.2优先级队列的存储表示和实现1253.5双端队列1263.5.1双端队列的概念1263.5.2双端队列的数组表示1283.5.3双端队列的链表表示129习题131第4章数组、串与广义表1354.1多维数组的概念与存储1354.1.1多维数组的概念1354.1.2多维数组的存储表示1364.2特殊矩阵1384.2.1对称矩阵的压缩存储1384.2.2三对角线/多对角线矩阵的压缩存储1404.3稀疏矩阵1414.3.1稀疏矩阵及其三元组数组表示1414.3.2稀疏矩阵的转置1454.3.3稀疏矩阵的相加和相乘1474.3.4矩阵的正交链表表示1524.4字符串1534.4.1字符串的概念1534.4.2C++有关字符串的库函数1544.4.3字符串的实现1564.4.4字符串的自定义类1584.4.5字符串操作的实现1594.4.6字符串的模式匹配1614.4.7字符串的存储方法1674.5广义表1694.5.1广义表的定义与性质1694.5.2广义表的表示1704.5.3广义表存储结构的实现1704.5.4广义表的递归算法1744.5.5三元多项式的表示181习题183第5章树1865.1树的基本概念1865.1.1树的定义和术语1865.1.2树的抽象数据类型1885.2二叉树1895.2.1二叉树的定义1895.2.2二叉树的性质1905.2.3二叉树的抽象数据类型1915.3二叉树的存储表示1925.3.1二叉树的数组存储表示1925.3.2二叉树的链表存储表示1935.4二叉树遍历及其应用1985.4.1二叉树遍历的递归算法1985.4.2二叉树遍历的应用2005.4.3二叉树遍历的非递归算法2035.4.4二叉树的计数2075.5线索二叉树2105.5.1线索2105.5.2中序线索二叉树的建立和遍历2115.5.3中序线索二叉树的插入与删除2165.5.4前序与后序的线索化二叉树2185.6树与森林2205.6.1树的存储表示2205.6.2森林与二叉树的转换2255.6.3树与二叉树的转换2275.7树与森林的遍历及其应用2275.7.1树与森林的深度优先遍历2275.7.2树和森林的广度优先遍历2305.7.3树遍历算法的应用2315.7.4其他基于遍历序列的几种存储表示2325.8堆2355.8.1最小堆和最大堆2355.8.2堆的建立2365.8.3堆的插入与删除2385.9Huffman树及其应用2405.9.1路径长度2405.9.2Huffman树2415.9.3Huffman树的应用：最优判定树2435.9.4Huffman树的应用：Huffman编码244习题246第6章集合与字典2516.1集合及其表示2516.1.1集合的基本概念2516.1.2用位向量实现集合抽象数据类型2526.1.3用有序链表实现集合的抽象数据类型2576.2并查集与等价类2626.2.1并查集的定义及其实现2626.2.2并查集的应用：等价类划分2676.3字典2686.3.1字典的概念2696.3.2字典的线性表描述2706.4跳表2736.4.1跳表的概念2736.4.2跳表的类定义2746.4.3跳表的搜索、插入和删除2766.5散列2796.5.1散列表与散列方法2796.5.2散列函数2806.5.3处理冲突的闭散列方法2826.5.4处理冲突的开散列方法2916.5.5散列表分析293习题294第7章搜索结构2977.1静态搜索结构2987.1.1静态搜索表2987.1.2顺序搜索3007.1.3基于有序顺序表的顺序搜索和折半搜索3027.1.4基于有序顺序表的其他搜索方法3077.2二叉搜索树3087.2.1二叉搜索树的概念3097.2.2二叉搜索树上的搜索3107.2.3二叉搜索树的插入3117.2.4二叉搜索树的删除3137.2.5二叉搜索树的性能分析3147.2.6最优二叉搜索树3177.3AVL树3207.3.1AVL树的概念3217.3.2平衡化旋转3217.3.3AVL树的插入3267.3.4AVL树的删除3297.3.5AVL树的性能分析3337.4伸展树3347.5红黑树3377.5.1红黑树的概念和性质3377.5.2红黑树的搜索3387.5.3红黑树的插入3387.5.4红黑树的删除339习题342第8章图3468.1图的基本概念3468.1.1与图有关的若干概念3468.1.2图的抽象数据类型3488.2图的存储结构3498.2.1图的邻接矩阵表示3508.2.2图的邻接表表示3558.2.3图的邻接多重表表示3618.3图的遍历3638.3.1深度优先搜索3648.3.2广度优先搜索3658.3.3连通分量3668.3.4重连通分量3688.4最小生成树3708.4.1Kruskal算法3718.4.2Prim算法3738.5最短路径3758.5.1非负权值的单源最短路径3768.5.2任意权值的单源最短路径3798.5.3所有顶点之间的最短路径3818.6用顶点表示活动的网络（AOV网络）3838.7用边表示活动的网络（AOE网络）388习题392第9章排序3979.1排序的概念及其算法性能分析3979.1.1排序的概念3979.1.2排序算法的性能评估3989.1.3排序表的类定义4009.2插入排序4019.2.1直接插入排序4019.2.2折半插入排序4039.2.3希尔排序4049.3快速排序4059.3.1快速排序的过程4069.3.2快速排序的性能分析4079.3.3快速排序的改进算法4099.3.4三路划分的快速排序算法4129.4选择排序4139.4.1直接选择排序4139.4.2锦标赛排序4149.4.3堆排序4199.5归并排序4229.5.1归并4229.5.2归并排序算法4239.6基于链表的排序算法4259.6.1链表插入排序4259.6.2链表归并排序4279.6.3链表排序结果的重排4289.7分配排序4319.7.1桶式排序4319.7.2基数排序4329.7.3MSD基数排序4339.7.4LSD基数排序4359.8内部排序算法的分析4379.8.1排序方法的下界4379.8.2各种内部排序方法的比较439习题440第10章文件、外部排序与搜索44410.1主存储器和外存储器44410.1.1磁带44410.1.2磁盘存储器44610.1.3缓冲区与缓冲池44810.2文件组织44910.2.1文件的概念44910.2.2文件的存储结构45010.3外排序45910.3.1外排序的基本过程45910.3.2k路平衡归并与败者树46110.3.3初始归并段的生成（run generation）46610.3.4并行操作的缓冲区处理47010.3.5最佳归并树47310.4多级索引结构47510.4.1静态的ISAM方法47510.4.2动态的m路搜索树47610.4.3B树47810.4.4B树的插入48010.4.5B树的删除48210.4.6B+树48610.4.7VSAM48910.5可扩充散列49010.5.1二叉Trie树49010.5.2将二叉Trie树转换为目录表49110.5.3目录表扩充与收缩49310.5.4性能分析49410.6Trie树49410.6.1Trie树的定义49410.6.2Trie树的搜索49510.6.3在Trie树上的插入和删除496习题497附录A程序索引500附录B词汇索引504参考文献512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序性能优化
第1 章 　CPU 与编译器概论
1.1 　高速路与人行道　　002
1.2 　编译器是如何运作的　　003
编译后的汇编语言程序　　004
添加优化选项后的结果　　007
1.3 　CPU 是如何运作的　　008
指令集架构与微架构　　008
如何执行指令　　009
指令流水线　　011
高速缓存　　012
深入探讨高速缓存　　013
缓存块的替换算法　　015
超标量指令执行　　015
第1 章 　是不是偏离了主题　　017
第2 章 　执行成本
2.1 　两程序的执行成本 020
2.2 　计·测·谋　　020
书中的探讨　　020
2.3 　防止基准测试程序被优化　　023
防止操作“归并”　　023
防止变量在初始化时被优化　　024
防止重复单一指令被优化　　025
本书中的基准测试程序　　026
2.4 　验证——哪一步操作导致执行速度缓慢　　029
2.5　基础加法与赋值运算　　031
单一的赋值操作（寄存器间的传送）　　032
单一的赋值操作（数据相互关联的情况）　　032
常量赋值　　033
变量间的加法运算　　033
变量与常量相加　　034
2.6 　耗时的乘法运算　　036
变量间的乘法运算　　037
变量与常量相乘　　037
2.7 　更为耗时的除法运算　　040
变量的除法（寄存器间的计算）　　040
除数为2、4 的除法运算　　042
除数不是2 的乘方的除法运算　　042
无符号整数除法运算　　042
除数为2 的乘方时除法运算使用低成本移位指令　　043
2.8 　内存读取 　045
小数组的读取（小范围内的内存操作）　　045
大数组的读取（ 大范围内的内存操作）　　047
与台式机的CPU进行比较　　049
2.9 　造成执行时间差别的判断语句　　051
无else节点的if 语句　　051
带else节点的if 语句　　053
2.10 　32/64 位环境中不同的函数调用　　053
2.11 　实验总结　　055
若想被爱则先爱　　055
第3 章 　寻找性能瓶颈
3.1　使用gprof 命令进行分析　　058
gprof的使用方法　　058
3.2 　哪个环节在消耗时间　　058
获取库函数的评测信息　　060
耗时的函数　　062
显示库函数的调用次数　　063
3.3 　函数的调用关系　　063
3.4 　进行数据分析的原理　　066
3.5 　其他性能分析器　　067
培养高水平人才的教育系统　　068
第4 章　　达人方法论
4.1 　达人的关注点　　072
硬件篇　　072
编译器/ 中间件篇　　074
算法篇　　075
4.2 　【硬件篇】数组和缓存的有效利用　　076
矩阵的乘法运算 　076
调整数组操作的顺序 　077
展开循环的方式 　078
矩阵的分块 　079
4.3 　【库函数篇】缓慢函数的迂回战术 　080
strcmp 函数为何缓慢 　080
优化的陷阱 　081
4.4 　【硬件篇】 使用SIMD 进行字符串对比　　083
4.5 　【库函数篇】对比各种输入输出方法　　085
行输入函数的对比　　085
输出方法　　089
管道输入输出的特殊案例　　091
管道输入输出与文件输入输出　　092
4.6 　【 算法篇】二分法查找与平衡二叉树　　092
海量数据的分类　　093
真要做到如此地步？　　097
第5 章 　进一步研究编译器
5.1 　不同级别的优化选项　　100
GCC 的优化选项　　100
“零优化”对调试有效　　100
以不出现未定义行为为前提的2 级以上优化选项　　101
5.2 　优化·寄存器·外部变量　　102
5.3 　删除公共子表达式为程序瘦身　　104
5.4 　指针与复杂运算简化　　105
5.5 　将用户函数进行内联展开　　106
和别人拉开差距！　　108
第6 章 　给办公系统的一些启示
6.1 　排序与字符串操作　　112
6.2 　小数点数的计算与字符串/ 数字的换算　　112
块数据输入输出和字段分割　　113
统计带小数部分的数　　113
整数转换成字符串　　115
性能优化的效果　　116
6.3 　半角字符转换为全角字符　　117
判定字符的字节数　　118
ASCII字符与半角片假名字符的判定　　119
ASCII字符转换为全角字符　　123
半角字符转换为全角字符　　124
性能优化的效果　　127
判定字符字节数的其他方法　　127
有关UTF-8　　130
6.4 　探索具有某种数据特性的数组　　132
数据的特性　　133
二分法查找与线性查找相结合　　135
性能优化的效果　　138
后记　　139
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通C#（第6版）
目　录

第一部分　C#与.NET平台
第1章　.NET之道	2
1.1 　初识.NET平台　　2
1.2 　.NET平台构造块（CLR、CTS和CLS）简介　　3
1.2.1 　基础类库的作用　　3
1.2.2 　C#的优点　　4
1.2.3 　托管代码与非托管代码　　5
1.3 　其他支持.NET的编程语言　　5
1.4 　.NET程序集概览　　7
1.4.1 　CIL的作用　　8
1.4.2 　.NET类型元数据的作用　　10
1.4.3 　程序集清单的作用　　11
1.5 　CTS　　12
1.5.1 　CTS类类型　　12
1.5.2 　CTS接口类型　　12
1.5.3 　CTS结构类型　　13
1.5.4 　CTS枚举类型　　13
1.5.5 　CTS委托类型　　13
1.5.6 　CTS类型成员　　14
1.5.7 　内建的CTS数据类型　　14
1.6 　CLS　　15
1.7 　CLR　　16
1.8 　程序集/命名空间/类型的区别　　17
1.8.1 　Microsoft根命名空间的作用　　20
1.8.2 　以编程方式访问命名空间　　20
1.8.3 　引用外部程序集　　21
1.9 　使用ildasm.exe探索程序集　　22
1.9.1 　查看CIL代码　　23
1.9.2 　查看类型元数据　　23
1.9.3 　查看程序集元数据（即清单）　　24
1.10 　.NET的平台无关性　　24
1.11 　Windows 8应用程序简介　　25
1.11.1 　构建Windows 8应用程序　　26
1.11.2 　.NET在Windows 8中的作用　　27
1.12 　小结　　28
第2章　构建C#应用程序　　29
2.1 　.NET Framework 4.5 SDK的作用　　29
2.2 　用csc.exe构建C#应用程序　　30
2.2.1 　指定输入输出目标　　31
2.2.2 　引用外部程序集　　32
2.2.3 　引用多个外部程序集　　33
2.2.4 　编译多个源文件　　33
2.2.5 　使用C#响应文件　　34
2.3 　使用Notepad++构建.NET应用程序　　35
2.4 　使用SharpDevelop构建.NET应用程序　　36
2.5 　使用Visual C# Express构建.NET应用程序　　38
2.6 　使用Visual Studio构建.NET应用程序　　39
2.6.1 　Visual Studio的独特功能　　39
2.6.2 　使用New Project对话框指向.NET Framework　　40
2.6.3 　解决方案资源管理器　　40
2.6.4 　Class View工具　　42
2.6.5 　Object Browser工具　　43
2.6.6 　集成对代码重构的支持　　43
2.6.7 　代码扩展和围绕技术　　45
2.6.8 　可视化Class Designer　　47
2.6.9 　集成的.NET Framework 4.5 SDK文档系统　　50
2.7 　小结　　51
第二部分　C#核心编程结构
第3章　C#核心编程结构Ⅰ　　54
3.1 　一个简单的C#程序　　54
3.1.1 　Main()方法的其他形式　　55
3.1.2 　指定应用程序错误代码　　56
3.1.3 　处理命令行参数　　57
3.1.4 　使用Visual Studio指定命令行参数　　59
3.2 　有趣的题外话：System.Environment类的其他成员　　59
3.3 　System.Console类　　61
3.3.1 　使用Console类进行基本的输入和输出　　61
3.3.2 　格式化控制台输出　　62
3.3.3 　格式化数值数据　　63
3.3.4 　在控制台应用程序外格式化数值数据　　64
3.4 　系统数据类型和相应的C#关键字　　64
3.4.1 　变量声明和初始化　　65
3.4.2 　内建数据类型与new操作符　　67
3.4.3 　数据类型类的层次结构　　67
3.4.4 　数值数据类型的成员　　69
3.4.5 　System.Boolean的成员　　69
3.4.6 　System.Char的成员　　69
3.4.7 　从字符串数据中解析数值　　70
3.4.8 　System.DateTime和System.TimeSpan　　70
3.4.9 　System.Numerics.dll程序集　　71
3.5 　使用字符串数据　　72
3.5.1 　基本的字符串操作　　73
3.5.2 　字符串拼接　　73
3.5.3 　转义字符　　74
3.5.4 　定义逐字字符串　　75
3.5.5 　字符串和相等性　　75
3.5.6 　字符串是不可变的　　76
3.5.7 　System.Text.StringBuilder类型　　77
3.6 　窄化和宽化数据类型转换　　78
3.6.1 　checked关键字　　80
3.6.2 　设定项目级别的溢出检测　　81
3.6.3 　unchecked关键字　　82
3.7 　隐式类型本地变量　　82
3.7.1 　隐式类型变量的限制　　84
3.7.2 　隐式类型数据是强类型数据　　84
3.7.3 　隐式类型本地变量的用途　　85
3.8 　C#迭代结构　　86
3.8.1 　for循环　　86
3.8.2 　foreach循环　　87
3.8.3 　while和do/while循环结构　　87
3.9 　条件结构和关系/相等操作符　　88
3.9.1 　if/else语句　　88
3.9.2 　关系/相等操作符　　88
3.9.3 　逻辑操作符　　89
3.9.4 　switch语句　　89
3.10 　小结　　91
第4章　C#核心编程结构Ⅱ　　92
4.1 　方法和参数修饰符　　92
4.1.1 　默认的参数传递行为　　93
4.1.2 　out修饰符　　94
4.1.3 　ref修饰符　　95
4.1.4 　params修饰符　　96
4.1.5 　定义可选参数　　97
4.1.6 　使用命名参数调用方法　　98
4.1.7 　成员重载　　99
4.2 　C#数组　　101
4.2.1 　C#数组初始化语法　　102
4.2.2 　隐式类型本地数组　　103
4.2.3 　定义object数组　　103
4.2.4 　使用多维数组　　104
4.2.5 　数组作为参数（和返回值）　　105
4.2.6 　System.Array基类　　106
4.3 　枚举类型　　107
4.3.1 　控制枚举的底层存储　　108
4.3.2 　声明枚举变量　　109
4.3.3 　System.Enum类型　　110
4.3.4 　动态获取枚举的名称/值对　　110
4.4 　结构类型　　112
4.5 　值类型和引用类型　　115
4.5.1 　值类型、引用类型和赋值操作符　　116
4.5.2 　包含引用类型的值类型　　117
4.5.3 　按值传递引用类型　　119
4.5.4 　按引用传递引用类型　　120
4.5.5 　值类型和引用类型：最后的细节　　121
4.6 　C#可空类型　　122
4.6.1 　使用可空类型　　123
4.6.2 　??操作符　　124
4.7 　小结　　124
第三部分　C#面向对象编程
第5章　封装　　126
5.1 　C#类类型　　126
5.2 　构造函数　　129
5.2.1 　默认构造函数的作用　　129
5.2.2 　定义自定义的构造函数　　130
5.2.3 　再谈默认构造函数　　131
5.3 　this关键字的作用　　132
5.3.1 　使用this进行串联构造函数调用　　133
5.3.2 　观察构造函数流程　　135
5.3.3 　再谈可选参数　　137
5.4 　static关键字　　138
5.4.1 　定义静态数据　　138
5.4.2 　定义静态方法　　140
5.4.3 　定义静态构造函数　　141
5.4.4 　定义静态类　　143
5.5 　定义OOP的支柱　　144
5.5.1 　封装的作用　　144
5.5.2 　继承的作用　　144
5.5.3 　多态的作用　　146
5.6 　C#访问修饰符　　147
5.6.1 　默认的访问修饰符　　148
5.6.2 　访问修饰符和嵌套类型　　148
5.7 　第一个支柱：C#的封装服务　　149
5.7.1 　使用传统的访问方法和修改方法执行封装　　149
5.7.2 　使用.NET属性进行封装　　151
5.7.3 　使用类的属性　　154
5.7.4 　只读和只写属性　　155
5.7.5 　静态属性　　156
5.8 　自动属性　　156
5.8.1 　与自动属性交互　　158
5.8.2 　关于自动属性和默认值　　158
5.9 　对象初始化语法　　160
5.9.1 　使用初始化语法调用自定义构造函数　　161
5.9.2 　初始化内部类型　　162
5.10 　常量数据　　163
5.10.1 　只读字段　　164
5.10.2 　静态只读字段　　165
5.11 　分部类型　　165
5.12 　小结　　167
第6章　继承和多态　　168
6.1 　继承的基本机制　　168
6.1.1 　指定既有类的父类　　169
6.1.2 　多个基类　　170
6.1.3 　sealed关键字　　171
6.2 　回顾Visual Studio类关系图　　172
6.3 　OOP的第二个支柱：继承　　173
6.3.1 　使用base关键字控制基类的创建　　174
6.3.2 　家族的秘密：protected关键字　　176
6.3.3 　增加密封类　　177
6.4 　包含/委托编程　　178
6.5 　OOP的第三个支柱：C#的多态支持　　180
6.5.1 　virtual和override关键字　　181
6.5.2 　使用Visual Studio IDE重写虚方法　　183
6.5.3 　密封虚成员　　184
6.5.4 　抽象类　　184
6.5.5 　构建多态接口　　186
6.5.6 　成员投影　　189
6.6 　基类/派生类的转换规则　　191
6.6.1 　C#的as关键字　　192
6.6.2 　C#的is关键字　　193
6.7 　超级父类：System.Object　　193
6.7.1 　重写System.Object.ToString()　　196
6.7.2 　重写System.Object.Equals()　　196
6.7.3 　重写System.Object.GetHashCode()　　197
6.7.4 　测试修改后的Person类　　198
6.7.5 　System.Object的静态成员　　199
6.8 　小结　　199
第7章　结构化异常处理　　200
7.1 　错误、bug与异常　　200
7.2 　.NET异常处理的作用　　201
7.2.1 　.NET异常处理的四要素　　202
7.2.2 　System.Exception基类　　202
7.3 　最简单的例子　　203
7.3.1 　引发普通的异常　　205
7.3.2 　捕获异常　　206
7.4 　配置异常的状态　　207
7.4.1 　TargetSite属性　　207
7.4.2 　StackTrace属性　　208
7.4.3 　HelpLink属性　　208
7.4.4 　Data属性　　209
7.5 　系统级异常　　211
7.6 　应用程序级异常　　211
7.6.1 　构建自定义异常，第一部分　　212
7.6.2 　构建自定义异常，第二部分　　213
7.6.3 　构建自定义异常，第三部分　　214
7.7 　处理多个异常　　215
7.7.1 　通用的catch语句　　217
7.7.2 　再次引发异常　　218
7.7.3 　内部异常　　218
7.7.4 　finally块　　219
7.8 　谁在引发什么异常　　220
7.9 　未处理异常的后果　　220
7.10 　使用Visual Studio调试未处理的异常　　221
7.11 　小结　　222
第8章　接口　　223
8.1 　接口类型　　223
8.2 　定义自定义接口　　226
8.3 　实现接口　　227
8.4 　在对象级别调用接口成员　　229
8.4.1 　获取接口引用：as关键字　　230
8.4.2 　获取接口引用：is关键字　　230
8.5 　接口作为参数　　231
8.6 　接口作为返回值　　233
8.7 　接口类型数组　　233
8.8 　使用Visual Studio实现接口　　234
8.9 　显式接口实现　　235
8.10 　设计接口层次结构　　238
8.11 　构建可枚举类型（IEnumerable和IEnumerator）　　241
8.11.1 　用yield关键字构建迭代器方法　　243
8.11.2 　构建命名迭代器　　244
8.12 　构建可克隆的对象（ICloneable）　　245
8.13 　构建可比较的对象（IComparable）　　249
8.13.1 　指定多个排序顺序　　252
8.13.2 　自定义属性、自定义排序类型　　253
8.14 　小结　　253
第四部分　高级C#编程结构
第9章　集合与泛型　　256
9.1 　集合类的动机　　256
9.1.1 　System.Collections命名空间　　257
9.1.2 　System.Collections.Specialized命名空间　　259
9.2 　非泛型集合的问题　　260
9.2.1 　性能问题　　260
9.2.2 　类型安全问题　　263
9.2.3 　初识泛型集合　　265
9.3 　泛型类型参数的作用　　266
9.3.1 　为泛型类/结构指定类型参数　　267
9.3.2 　为泛型成员指定类型参数　　268
9.3.3 　为泛型接口指定类型参数　　269
9.4 　System.Collections.Generic命名空间　　270
9.4.1 　集合初始化语法　　271
9.4.2 　使用List<T>类　　272
9.4.3 　使用Stack<T>类　　273
9.4.4 　使用Queue<T>类　　274
9.4.5 　使用SortedSet<T>类　　275
9.5 　System.Collections.ObjectModel命名空间　　277
9.6 　创建自定义泛型方法　　279
9.7 　创建自定义泛型结构和类　　282
9.8 　类型参数的约束　　284
9.8.1 　使用where关键字的示例　　284
9.8.2 　操作符约束的不足　　285
9.9 　小结　　286
第10章　委托、事件和Lambda表达式　　287
10.1 　.NET委托类型　　287
10.1.1 　在C#中定义委托类型　　288
10.1.2 　System.MulticastDelegate与System.Delegate基类　　290
10.2 　最简单的委托示例　　291
10.3 　使用委托发送对象状态通知　　293
10.3.1 　支持多路广播　　296
10.3.2 　从委托的调用列表中移除成员　　297
10.3.3 　方法组转换语法　　298
10.4 　泛型委托　　300
10.5 　C#事件　　303
10.5.1 　event关键字　　304
10.5.2 　揭开事件的神秘面纱　　305
10.5.3 　监听传入的事件　　306
10.5.4 　使用Visual Studio简化事件注册　　307
10.5.5 　创建自定义的事件参数　　308
10.5.6 　泛型EventHandler<T>委托　　309
10.6 　C#匿名方法　　310
10.7 　Lambda表达式　　313
10.7.1 　剖析Lambda表达式　　315
10.7.2 　使用多个语句处理参数　　316
10.7.3 　含有多个（或零个）参数的Lambda表达式　　317
10.7.4 　使用Lambda表达式重新编写CarEvents示例　　318
10.8 　小结　　319
第11章　高级C#语言特性　　320
11.1 　索引器方法　　320
11.1.1 　使用字符串值索引对象　　322
11.1.2 　重载索引器方法　　323
11.1.3 　多维的索引器　　323
11.1.4 　在接口类型上定义索引器　　324
11.2 　操作符重载　　325
11.2.1 　重载二元操作符　　325
11.2.2 　+=与-=操作符　　327
11.2.3 　重载一元操作符　　328
11.2.4 　重载相等操作符　　329
11.2.5 　重载比较操作符　　329
11.2.6 　操作符重载的最后思考　　330
11.3 　自定义类型转换　　331
11.3.1 　回顾：数值转换　　331
11.3.2 　回顾：相关的类类型间的转换　　331
11.3.3 　创建自定义转换例程　　332
11.3.4 　Square类型的其他显式转换　　334
11.3.5 　定义隐式转换例程　　335
11.4 　扩展方法　　336
11.4.1 　定义扩展方法　　336
11.4.2 　在实例层次上调用扩展方法　　337
11.4.3 　导入扩展方法　　338
11.4.4 　扩展方法的智能感知　　339
11.4.5 　扩展实现了指定接口的类型　　339
11.5 　匿名类型　　340
11.5.1 　定义匿名类型　　341
11.5.2 　匿名类型的内部表示方式　　342
11.5.3 　方法ToString()和GetHashCode()的实现　　343
11.5.4 　匿名类型的相等语义　　344
11.5.5 　包含匿名类型的匿名类型　　345
11.6 　指针类型　　346
11.6.1 　unsafe关键字　　347
11.6.2 　*和&操作符　　348
11.6.3 　不安全（与安全）交换功能　　349
11.6.4 　通过指针访问字段　　350
11.6.5 　stackalloc关键字　　350
11.6.6 　使用fixed关键字固定类型　　351
11.6.7 　sizeof关键字　　352
11.7 　小结　　352
第12章　LINQ to Object　　353
12.1 　LINQ特有的编程结构　　353
12.1.1 　隐式类型本地变量　　354
12.1.2 　对象和集合初始化语法　　354
12.1.3 　Lambda表达式　　355
12.1.4 　扩展方法　　355
12.1.5 　匿名类型　　356
12.2 　LINQ的作用　　356
12.2.1 　LINQ表达式是强类型的　　357
12.2.2 　核心LINQ程序集　　357
12.3 　将LINQ查询应用于原始数组　　358
12.3.1 　再一次，不使用LINQ　　359
12.3.2 　反射LINQ结果集　　360
12.3.3 　LINQ和隐式类型本地变量　　361
12.3.4 　LINQ和扩展方法　　362
12.3.5 　延迟执行的作用　　363
12.3.6 　立即执行的作用　　364
12.4 　返回LINQ查询的结果　　365
12.5 　将LINQ查询应用到集合对象　　367
12.5.1 　访问包含的子对象　　367
12.5.2 　将LINQ查询应用于非泛型集合　　368
12.5.3 　使用OfType<T>()筛选数据　　369
12.6 　C# LINQ查询操作符　　369
12.6.1 　基本的选择语法　　371
12.6.2 　获取数据子集　　371
12.6.3 　投影新数据类型　　372
12.6.4 　使用Enumerable获取总数　　373
12.6.5 　反转结果集　　373
12.6.6 　对表达式进行排序　　374
12.6.7 　维恩图工具　　374
12.6.8 　移除重复　　375
12.6.9 　LINQ聚合操作　　376
12.7 　LINQ查询语句的内部表示　　376
12.7.1 　用查询操作符建立查询表达式（复习）　　377
12.7.2 　使用Enumerable类型和Lambda表达式来建立查询表达式　　377
12.7.3 　使用Enumerable类型和匿名方法来建立查询表达式　　379
12.7.4 　用Enumerable类型和原始委托建立查询表达式　　379
12.8 　小结　　380
第13章　对象的生命周期　　381
13.1 　类、对象和引用　　381
13.2 　对象生命周期的基础　　382
13.2.1 　CIL的new指令　　383
13.2.2 　将对象引用设置为空　　384
13.3 　应用程序根的作用　　385
13.4 　对象的代　　386
13.5 　.NET 1.0 至.NET 3.5的并发垃圾回收　　387
13.6 　.NET 4.0及后续版本　　387
13.7 　System.GC类型　　388
13.8 　构建可终结对象　　391
13.8.1 　重写System.Object.Finalize()　　392
13.8.2 　终结过程的细节　　393
13.9 　构建可处置对象　　394
13.10 　构建可终结类型和可处置类型　　397
13.11 　延迟对象实例化　　400
13.12 　小结　　403
第五部分　用.NET程序集编程
第14章　.NET程序集入门　　406
14.1 　定义自定义命名空间　　406
14.1.1 　使用完全限定名解决命名冲突　　408
14.1.2 　使用别名解决命名冲突　　409
14.1.3 　创建嵌套的命名空间　　410
14.1.4 　Visual Studio 的默认命名空间　　411
14.2 　.NET程序集的作用　　412
14.2.1 　程序集促进代码重用　　412
14.2.2 　程序集确定类型边界　　412
14.2.3 　程序集是可版本化的单元　　412
14.2.4 　程序集是自描述的　　413
14.2.5 　程序集是可配置的　　413
14.3 　.NET程序集的格式　　413
14.3.1 　Windows文件首部　　413
14.3.2 　CLR文件首部　　414
14.3.3 　CIL代码、类型元数据和程序集清单　　415
14.3.4 　可选的程序集资源　　415
14.4 　构建和使用自定义类库　　416
14.4.1 　清单　　418
14.4.2 　CIL　　421
14.4.3 　类型元数据　　421
14.4.4 　构建C#客户端应用程序　　422
14.4.5 　构建Visual Basic客户端应用程序　　424
14.4.6 　实现跨语言继承　　425
14.5 　私有程序集　　425
14.5.1 　私有程序集的标识　　426
14.5.2 　探测过程　　426
14.5.3 　配置私有程序集　　427
14.5.4 　App.Config文件　　428
14.6 　共享程序集　　430
14.6.1 　全局程序集缓存　　430
14.6.2 　强名称　　431
14.6.3 　在命令行生成强名称　　432
14.6.4 　使用Visual Studio为程序集赋予强名称　　434
14.6.5 　在GAC中安装强名称的程序集　　436
14.7 　使用共享程序集　　437
14.8 　配置共享程序集　　439
14.8.1 　冻结当前的共享程序集　　439
14.8.2 　构建共享程序集2.0.0.0版本　　440
14.8.3 　动态重定向到共享程序集的特定版本　　441
14.9 　发行者策略程序集　　443
14.10 　<codeBase>元素　　444
14.11 　System.Configuration命名空间　　446
14.12 　配置文件架构文档　　447
14.13 　小结　　448
第15章　类型反射、晚期绑定和基于特性的编程　　449
15.1 　类型元数据的必要性　　449
15.1.1 　查看（部分）EngineState枚举的元数据　　450
15.1.2 　查看（部分）Car类型的元数据　　451
15.1.3 　研究TypeRef　　452
15.1.4 　记录定义的程序集　　452
15.1.5 　记录引用的程序集　　453
15.1.6 　记录字符串字面量　　453
15.2 　反射　　454
15.2.1 　System.Type类　　454
15.2.2 　使用System.Object.GetType()得到Type引用　　455
15.2.3 　使用typeof()得到Type引用　　455
15.2.4 　使用System.Type.GetType()得到Type引用　　455
15.3 　构建自定义的元数据查看器　　456
15.3.1 　反射方法　　456
15.3.2 　反射字段和属性　　457
15.3.3 　反射实现的接口　　457
15.3.4 　显示其他信息　　458
15.3.5 　实现Main()　　458
15.3.6 　反射泛型类型　　460
15.3.7 　反射方法参数和返回值　　460
15.4 　动态加载程序集　　461
15.5 　反射共享程序集　　464
15.6 　晚期绑定　　465
15.6.1 　System.Activator类　　466
15.6.2 　调用没有参数的方法　　467
15.6.3 　调用有参数的方法　　468
15.7 　.NET特性的作用　　469
15.7.1 　特性的使用者　　470
15.7.2 　在C#中使用特性　　470
15.7.3 　C#特性简化符号　　471
15.7.4 　为特性指定构造参数　　472
15.7.5 　Obsolete特性　　472
15.8 　构建自定义特性　　473
15.8.1 　应用自定义特性　　473
15.8.2 　命名属性语法　　474
15.8.3 　限制特性使用　　474
15.9 　程序集级别特性　　475
15.10 　使用早期绑定反射特性　　477
15.11 　使用晚期绑定反射特性　　478
15.12 　反射、晚期绑定和自定义特性的使用背景　　479
15.13 　构建可扩展的应用程序　　480
15.13.1 　构建CommonSnappable-Types.dll　　480
15.13.2 　构建C#插件　　481
15.13.3 　构建Visual Basic插件　　482
15.13.4 　构建可扩展的Windows Forms应用程序　　482
15.14 　小结　　485
第16章　动态类型和动态语言运行时　　486
16.1 　dynamic关键字的作用　　486
16.1.1 　调用动态声明的数据的成员　　488
16.1.2 　Microsoft.CSharp.dll程序集的作用　　489
16.1.3 　dynamic关键字的作用域　　490
16.1.4 　dynamic关键字的限制　　491
16.1.5 　dynamic关键字的实际用途　　491
16.2 　DLR的作用　　492
16.2.1 　表达式树的作用　　492
16.2.2 　System.Dynamic命名空间的作用　　493
16.2.3 　表达式树的动态运行时查找　　493
16.3 　使用动态类型简化后期绑定调用　　494
16.4 　使用动态数据简化COM互操作　　497
16.4.1 　主互操作程序集的作用　　498
16.4.2 　嵌入互操作元数据　　499
16.4.3 　普通COM互操作的难点　　500
16.5 　使用C# 动态数据进行COM互操作　　500
16.6 　不使用C# 动态数据进行COM互操作　　504
16.7 　小结　　505
第17章　进程、应用程序域和对象上下文　　506
17.1 　Windows进程的作用　　506
17.2 　.NET平台下与进程进行交互　　508
17.2.1 　列举运行中的进程　　510
17.2.2 　特定的进程　　511
17.2.3 　进程的线程集合　　511
17.2.4 　进程中的模块集合　　513
17.2.5 　以编程方式启动或结束进程　　514
17.2.6 　使用ProcessStartInfo类控制进程的启动　　515
17.3 　.NET应用程序域　　516
17.4 　与默认应用程序域进行交互　　518
17.4.1 　枚举加载的程序集　　519
17.4.2 　接收程序集加载通知　　520
17.5 　创建新的应用程序域　　521
17.5.1 　在自定义应用程序域中加载程序集　　522
17.5.2 　以编程方式卸载应用程序域　　523
17.6 　对象上下文边界　　525
17.6.1 　上下文灵活和上下文绑定类型　　525
17.6.2 　定义上下文绑定对象　　526
17.6.3 　研究对象的上下文　　526
17.7 　进程、应用程序域和上下文小结　　528
17.8 　小结　　528
第18章　CIL和动态程序集的作用　　529
18.1 　学习CIL语法的原因　　529
18.2 　CIL指令、特性和操作码　　530
18.2.1 　CIL指令的作用　　530
18.2.2 　CIL特性的作用　　530
18.2.3 　CIL操作码的作用　　531
18.2.4 　区别CIL操作码和CIL助记符　　531
18.3 　入栈和出栈：CIL基于栈的本质　　532
18.4 　正反向工程　　533
18.4.1 　CIL代码标签的作用　　536
18.4.2 　与CIL交互：修改*.il文件　　536
18.4.3 　使用ilasm.exe编译CIL代码　　537
18.4.4 　peverify.exe的作用　　538
18.5 　CIL指令和特性　　539
18.5.1 　在CIL中指定外部引用程序集　　539
18.5.2 　在CIL中定义当前程序集　　539
18.5.3 　在CIL中定义命名空间　　540
18.5.4 　在CIL中定义类类型　　540
18.5.5 　在CIL中定义和实现接口　　541
18.5.6 　在CIL中定义结构　　542
18.5.7 　在CIL中定义枚举　　542
18.5.8 　在CIL中定义泛型　　543
18.5.9 　编译CILTypes.il文件　　543
18.6 　.NET基础类库、C#和CIL数据类型的映射　　544
18.7 　在CIL中定义类型成员　　544
18.7.1 　在CIL中定义数据字段　　545
18.7.2 　在CIL中定义类型的构造函数　　545
18.7.3 　在CIL中定义属性　　546
18.7.4 　定义成员参数　　546
18.8 　剖析CIL操作码　　547
18.8.1 　.maxstack指令　　548
18.8.2 　在CIL中声明本地变量　　549
18.8.3 　在CIL中映射参数到本地变量　　550
18.8.4 　this隐式引用　　550
18.8.5 　在CIL中使用循环结构　　551
18.9 　使用CIL构建.NET程序集　　551
18.9.1 　构建CILCars.dll　　551
18.9.2 　构建CILCarClient.exe　　554
18.10 　动态程序集　　555
18.10.1 　System.Reflection.Emit命名空间　　556
18.10.2 　System.Reflection.Emit.ILGenerator的作用　　557
18.10.3 　产生动态的程序集　　557
18.10.4 　产生程序集和模块集　　559
18.10.5 　ModuleBuilder类型的作用　　560
18.10.6 　产生HelloClass类型和字符串成员变量　　561
18.10.7 　产生构造函数　　561
18.10.8 　产生SayHello()方法　　562
18.10.9 　使用动态产生的程序集　　563
18.11 　小结　　564
第六部分　.NET基础类库
第19章　多线程、并行和异步编程　　566
19.1 　进程、应用程序域、上下文及线程之间的关系　　566
19.1.1 　并发问题　　567
19.1.2 　线程同步的作用　　568
19.2 　.NET委托的简短回顾　　568
19.3 　委托的异步性　　570
19.3.1 　BeginInvoke()和EndInvoke()方法　　570
19.3.2 　System.IAsyncResult接口　　570
19.4 　异步调用方法　　571
19.4.1 　同步调用线程　　572
19.4.2 　AsyncCallback委托的作用　　573
19.4.3 　AsyncResult类的作用　　575
19.4.4 　传递和接收自定义状态数据　　575
19.5 　System.Threading命名空间　　576
19.6 　System.Threading.Thread类　　577
19.6.1 　获得当前执行线程的统计信息　　578
19.6.2 　Name属性　　579
19.6.3 　Priority属性　　579
19.7 　手工创建次线程　　580
19.7.1 　使用ThreadStart委托　　580
19.7.2 　使用ParameterizedThreadStart委托　　582
19.7.3 　AutoResetEvent类　　583
19.7.4 　前台线程和后台线程　　584
19.8 　并发问题　　585
19.8.1 　使用C#的lock关键字进行同步　　588
19.8.2 　使用System.Threading.Monitor类型进行同步　　589
19.8.3 　使用System.Threading.Interlocked类型进行同步　　590
19.8.4 　使用[Synchronization]特性进行同步　　591
19.9 　使用TimerCallback编程　　592
19.10 　CLR线程池　　593
19.11 　使用任务并行库进行并行编程　　595
19.11.1 　任务并行库API　　595
19.11.2 　Parallel类的作用　　596
19.11.3 　使用Parallel类的数据并行　　596
19.11.4 　在次线程中访问UI元素　　598
19.11.5 　Task类　　599
19.11.6 　处理取消请求　　599
19.11.7 　使用并行类的任务并行　　601
19.12 　并行LINQ查询（PLINQ）　　603
19.12.1 　使用PLINQ查询　　604
19.12.2 　取消PLINQ查询　　604
19.13 　.NET 4.5下的异步调用　　605
19.13.1 　C# async和await关键字初探　　606
19.13.2 　异步方法的命名约定　　607
19.13.3 　返回void的异步方法　　609
19.13.4 　具有多个await的异步方法　　609
19.13.5 　用async/await改进AddWithThreads示例　　610
19.14 　小结　　611
第20章　文件输入输出和对象序列化　　612
20.1 　研究System.IO命名空间　　612
20.2 　Directory(Info)和File(Info)类型　　613
20.3 　使用DirectoryInfo类型　　614
20.3.1 　使用DirectoryInfo类型枚举出文件　　616
20.3.2 　使用DirectoryInfo类型创建子目录　　616
20.4 　使用Directory类型　　617
20.5 　使用DriveInfo类类型　　618
20.6 　使用FileInfo类　　619
20.6.1 　FileInfo.Create()方法　　620
20.6.2 　FileInfo.Open()方法　　621
20.6.3 　FileInfo.OpenRead()和FileInfo.OpenWrite()方法　　622
20.6.4 　FileInfo.OpenText()方法　　622
20.6.5 　FileInfo.CreateText()和FileInfo.AppendText()方法　　623
20.7 　使用File类型　　623
20.8 　Stream抽象类　　625
20.9 　使用StreamWriter和StreamReader类型　　627
20.9.1 　写文本文件　　628
20.9.2 　读文本文件　　628
20.9.3 　直接创建StreamWriter/StreamReader类型　　629
20.10 　使用StringWriter和StringReader类型　　630
20.11 　使用BinaryWriter和BinaryReader　　631
20.12 　以编程方式“观察”文件　　632
20.13 　对象序列化　　634
20.14 　为序列化配置对象　　637
20.14.1 　定义可序列化的类型　　637
20.14.2 　公共字段、私有字段和公共属性　　638
20.15 　选择序列化格式化程序　　638
20.15.1 　IFormatter和IRemoting-Formatting接口　　639
20.15.2 　在格式化程序中的类型保真　　640
20.16 　使用BinaryFormatter序列化对象　　641
20.17 　使用SoapFormatter序列化对象　　642
20.18 　使用XmlSerializer序列化对象　　643
20.19 　序列化对象集合　　645
20.20 　自定义Soap/Binary序列化过程　　647
20.20.1 　深入了解对象序列化　　647
20.20.2 　使用ISerializable自定义序列化　　648
20.20.3 　使用特性定制序列化　　650
20.21 　小结　　651
第21章　ADO.NET之一：连接层　　653
21.1 　ADO.NET的宏观定义　　653
21.2 　ADO.NET数据提供程序　　655
21.2.1 　微软提供的ADO.NET数据提供程序　　656
21.2.2 　关于System.Data.Oracle-Client.dll　　657
21.2.3 　选择第三方的数据提供程序　　657
21.3 　其他的ADO.NET命名空间　　658
21.4 　System.Data命名空间的类型　　658
21.4.1 　IDbConnection接口的作用　　659
21.4.2 　IDbTransaction接口的作用　　659
21.4.3 　IDbCommand接口的作用　　660
21.4.4 　IDbDataParameter和IDataParameter接口的作用　　660
21.4.5 　IDbDataAdapter和IDataAdapter接口的作用　　661
21.4.6 　IDataReader和IDataRecord接口的作用　　661
21.5 　使用接口的抽象数据提供程序　　662
21.6 　创建AutoLot数据库　　665
21.6.1 　创建Inventory表　　665
21.6.2 　为Inventory表添加测试记录　　667
21.6.3 　编写GetPetName()存储过程　　668
21.6.4 　创建Customers和Orders表　　669
21.6.5 　可视化创建表关系　　671
21.7 　ADO.NET数据提供程序工厂模型　　672
21.7.1 　完整的数据提供程序工厂的例子　　673
21.7.2 　数据提供程序工厂模型的潜在缺陷　　675
21.7.3 　<connectionStrings>元素　　676
21.8 　ADO.NET的连接层　　677
21.8.1 　使用连接对象　　678
21.8.2 　使用ConnectionStringBuilder对象　　679
21.8.3 　使用命令对象　　680
21.9 　使用数据读取器　　681
21.10 　构建可重用的数据访问库　　683
21.10.1 　增加连接逻辑　　684
21.10.2 　增加插入逻辑　　685
21.10.3 　增加删除逻辑　　686
21.10.4 　增加更新逻辑　　686
21.10.5 　增加选择逻辑　　687
21.10.6 　使用参数化的命令对象　　688
21.10.7 　执行存储过程　　690
21.11 　创建控制台UI前端　　691
21.11.1 　实现Main()方法　　691
21.11.2 　实现ShowInstructions()方法　　693
21.11.3 　实现ListInventory()方法　　693
21.11.4 　实现DeleteCar()方法　　694
21.11.5 　实现InsertNewCar()方法　　694
21.11.6 　实现UpdateCarPetName()方法　　695
21.11.7 　实现LookUpPetName()　　696
21.12 　数据库事务　　697
21.12.1 　ADO.NET事务对象的主要成员　　697
21.12.2 　为AutoLot数据库添加CreditRisks表　　698
21.12.3 　为InventoryDAL添加事物方法　　699
21.12.4 　测试数据库事务　　700
21.13 　小结　　701
第22章　ADO.NET之二：断开连接层　　702
22.1 　ADO.NET断开连接层　　702
22.2 　DataSet的作用　　703
22.2.1 　DataSet的主要属性　　704
22.2.2 　DataSet的主要方法　　704
22.2.3 　构建DataSet　　705
22.3 　使用DataColumn　　705
22.3.1 　构建DataColumn　　706
22.3.2 　启用自增列　　707
22.3.3 　把DataColumn对象加入DataTable　　707
22.4 　使用DataRow　　707
22.4.1 　RowState属性　　709
22.4.2 　DataRowVersion属性　　710
22.5 　使用DataTable　　710
22.5.1 　将DataTable插入到DataSet中　　711
22.5.2 　获取DataSet中的数据　　712
22.5.3 　使用DataTableReader对象处理DataTable　　713
22.5.4 　序列化DataTable/DataSet对象为XML　　714
22.5.5 　以二进制格式序列化Data-Table/DataSet对象　　715
22.6 　将DataTable对象绑定到用户界面　　716
22.6.1 　从泛型List<T>合成DataTable　　717
22.6.2 　从DataTable中删除行　　719
22.6.3 　根据筛选条件选择行　　720
22.6.4 　在DataTable中更新行　　722
22.6.5 　使用DataView类型　　723
22.7 　使用数据适配器　　724
22.7.1 　一个简单的数据适配器示例　　725
22.7.2 　映射数据库名称为友好名称　　726
22.8 　向AutoLotDAL.dll添加断开连接功能　　727
22.8.1 　定义初始类类型　　727
22.8.2 　使用SqlCommandBuilder来配置数据适配器　　728
22.8.3 　实现GetAllInventory()　　729
22.8.4 　实现UpdateInventory()　　729
22.8.5 　设置版本号　　729
22.8.6 　测试非连接的功能　　730
22.9 　多表DataSet对象和数据关系　　731
22.9.1 　建立数据适配器　　732
22.9.2 　建立表间关系　　733
22.9.3 　更新Database表　　733
22.9.4 　在关联表中切换　　734
22.10 　Windows Forms数据库设计器工具　　736
22.10.1 　可视化设计DataGridView　　736
22.10.2 　生成的App.config文件　　740
22.10.3 　强类型的DataSet　　740
22.10.4 　强类型的DataTable　　741
22.10.5 　强类型的DataRow　　742
22.10.6 　强类型的数据适配器　　743
22.10.7 　完成Windows Forms应用程序　　744
22.11 　将强类型的数据库代码隔离到类库中　　744
22.11.1 　查看生成的代码　　746
22.11.2 　用生成的代码选择数据　　747
22.11.3 　用生成的代码插入数据　　748
22.11.4 　用生成的代码删除数据　　748
22.11.5 　用生成的代码调用存储过程　　749
22.12 　LINQ to DataSet　　750
22.12.1 　DataSet Extensions库的作用　　751
22.12.2 　获取与LINQ兼容的DataTable　　752
22.12.3 　DataRowExtensions.Field-<T>()扩展方法的作用　　753
22.12.4 　从LINQ查询中生成新的DataTable　　754
22.13 　小结　　754
第23章　ADO.NET之三：Entity Framework　　756
23.1 　Entity Framework的作用　　756
23.1.1 　实体的作用　　758
23.1.2 　Entity Framework的基础知识　　760
23.2 　创建和分析EDM　　764
23.3 　对概念模型进行编程　　774
23.4 　AutoLotDAL 4.0版，加入实体　　779
23.4.1 　导航属性的作用　　780
23.4.2 　在LINQ to Entity查询中使用导航属性　　781
23.4.3 　调用存储过程　　782
23.5 　将数据实体绑定到Windows Forms GUI　　783
23.6 　展望.NET数据访问API的未来　　786
23.7 　小结　　787
第24章　LINQ to XML简介　　788
24.1 　两个XML API的故事　　788
24.1.1 　更优秀的DOM——LINQ to XML　　789
24.1.2 　更优秀的LINQ to XML——VB字面量语法　　790
24.2 　System.Xml.Linq命名空间的成员　　791
24.2.1 　LINQ to XML的轴方法　　793
24.2.2 　奇妙的XName和XNamespace　　794
24.3 　使用XElement和XDocument　　795
24.3.1 　从数组和容器中生成文档　　797
24.3.2 　加载和解析XML内容　　798
24.4 　在内存中操作XML文档　　798
24.4.1 　构建LINQ to XML应用程序的UI　　799
24.4.2 　引入Inventory.xml文件　　799
24.4.3 　定义LINQ to XML辅助类　　800
24.4.4 　将UI组装到辅助类　　801
24.5 　小结　　802
第25章　WCF　　803
25.1 　各种分布式计算API　　803
25.1.1 　DCOM的作用　　804
25.1.2 　COM+/企业服务的作用　　804
25.1.3 　MSMQ的作用　　805
25.1.4 　.NET Remoting的作用　　805
25.1.5 　XML Web服务的作用　　806
25.2 　WCF的作用　　807
25.2.1 　WCF特性概览　　807
25.2.2 　SOA概览　　808
25.2.3 　WCF概要　　809
25.3 　WCF核心程序集　　809
25.4 　Visual Studio WCF项目模板　　810
25.5 　WCF应用程序的基本构成　　811
25.6 　WCF的ABC　　812
25.6.1 　WCF契约　　813
25.6.2 　WCF绑定　　814
25.6.3 　WCF地址　　816
25.7 　构建WCF服务　　816
25.7.1 　[ServiceContract]特性　　818
25.7.2 　[OperationContract]特性　　819
25.7.3 　作为操作契约的服务类型　　819
25.8 　承载WCF服务　　820
25.8.1 　在App.config文件中创建
ABC　　820
25.8.2 　针对ServiceHost类型进行编程　　821
25.8.3 　指定库地址　　821
25.8.4 　ServiceHost类型的功能　　823
25.8.5 　<system.serviceModel>元素的细节　　824
25.8.6 　启用元数据交换　　825
25.9 　构建WCF客户端应用程序　　827
25.9.1 　使用svcutil.exe生成代理代码　　827
25.9.2 　使用Visual Studio生成代理代码　　828
25.9.3 　配置基于TCP的绑定　　830
25.10 　简化配置设置　　831
25.10.1 　使用默认终结点　　831
25.10.2 　使用多重绑定公开单独的WCF服务　　832
25.10.3 　修改WCF绑定的设置　　833
25.10.4 　使用默认的MEX行为配置　　835
25.10.5 　刷新客户端代理和选择绑定　　836
25.11 　使用WCF服务库项目模板　　837
25.11.1 　构建简单的Math服务　　837
25.11.2 　使用WcfTestClient.exe测试WCF服务　　838
25.11.3 　使用SvcConfigEditor.exe修改配置文件　　839
25.12 　以Windows服务承载WCF服务　　840
25.12.1 　在代码中指定ABC　　841
25.12.2 　启用MEX　　843
25.12.3 　创建Windows服务安装程序　　843
25.12.4 　安装Windows服务　　845
25.13 　从客户端异步调用服务　　845
25.14 　定义WCF数据契约　　847
25.14.1 　使用Web相关的WCF服务项目模板　　848
25.14.2 　实现服务契约　　849
25.14.3 　*.svc文件的作用　　851
25.14.4 　更新web.config文件　　851
25.14.5 　测试服务　　851
25.15 　小结　　852
第26章　Windows Workflow Foundation简介　　853
26.1 　定义业务流程　　853
26.2 　构建简单的工作流　　854
26.3 　Workflow运行时　　857
26.3.1 　使用WorkflowInvoker承载工作流　　857
26.3.2 　使用WorkflowApplication承载工作流　　860
26.3.3 　第一个工作流示例回顾　　861
26.4 　检查Workflow中的活动　　861
26.4.1 　控制流活动　　861
26.4.2 　流程图活动　　862
26.4.3 　消息传递活动　　862
26.4.4 　状态机活动　　863
26.4.5 　运行时活动与基元活动　　863
26.4.6 　事务活动　　863
26.4.7 　集合活动和错误处理活动　　864
26.5 　构建流程图工作流　　864
26.5.1 　在流程图中连接活动　　865
26.5.2 　使用InvokeMethod活动　　866
26.5.3 　定义工作流变量　　867
26.5.4 　使用FlowDecision活动　　868
26.5.5 　使用TerminateWorkflow活动　　868
26.5.6 　构建“true”条件　　869
26.5.7 　使用ForEach<T>活动　　870
26.5.8 　完成应用程序　　872
26.5.9 　我们做了什么　　873
26.6 　在专门的DLL中构建Squence工作流　　874
26.6.1 　定义初始化项目　　874
26.6.2 　引入程序集和命名空间　　876
26.6.3 　定义工作流参数　　877
26.6.4 　定义工作流变量　　877
26.6.5 　使用Assign活动　　878
26.6.6 　使用If和Switch活动　　879
26.6.7 　构建自定义代码活动　　882
26.7 　使用工作流库　　884
26.8 　小结　　886
第七部分　WPF
第27章　WPF和XAML　　888
27.1 　WPF背后的动机　　888
27.1.1 　统一多种不同的API　　889
27.1.2 　通过XAML将关注点分离　　889
27.1.3 　提供优化的呈现模型　　890
27.1.4 　简化复杂的UI编程　　890
27.2 　各种形式的WPF应用程序　　891
27.2.1 　传统的桌面应用程序　　891
27.2.2 　基于导航的WPF应用程序　　892
27.2.3 　XBAP应用程序　　893
27.2.4 　WPF/Silverlight关系　　894
27.3 　WPF程序集　　894
27.3.1 　Application类的作用　　896
27.3.2 　Window类的作用　　897
27.4 　创建不使用XAML的WPF应用程序　　900
27.4.1 　创建强类型的Window类　　902
27.4.2 　创建简单的用户界面　　902
27.4.3 　与应用程序级别的数据交互　　904
27.4.4 　处理Window对象的关闭　　905
27.4.5 　拦截鼠标事件　　906
27.4.6 　拦截键盘事件　　907
27.5 　仅使用XAML构建WPF应用程序　　908
27.5.1 　用XAML定义窗体对象　　909
27.5.2 　用XAML定义应用对象　　910
27.5.3 　通过msbuild.exe处理XAML文件　　911
27.6 　将标记转换为.NET程序集　　913
27.6.1 　将窗口XAML标记映射到C#代码　　913
27.6.2 　BAML的作用　　914
27.6.3 　将应用程序XAML标记映射到C#代码　　915
27.6.4 　XAML到程序集的过程摘要　　916
27.7 　WPF XAML语法　　916
27.7.1 　Kaxaml　　917
27.7.2 　XAML XML命名空间和XAML关键字　　918
27.7.3 　控制类和成员变量的可见性　　920
27.7.4 　XAML元素、XAML特性和类型转换器　　920
27.7.5 　XAML属性元素语法　　921
27.7.6 　XAML附加属性　　922
27.7.7 　XAML标记扩展　　923
27.8 　使用代码隐藏文件构建WPF应用程序　　924
27.8.1 　为MainWindow类添加代码文件　　925
27.8.2 　为MyApp类添加代码文件　　925
27.8.3 　用msbuild.exe处理代码文件　　926
27.9 　使用Visual Studio构建WPF应用程序　　927
27.9.1 　WPF项目模板　　927
27.9.2 　工具箱和XAML设计器/编辑器　　928
27.9.3 　使用Properties窗口设置属性　　929
27.9.4 　使用Properties窗口处理事件　　930
27.9.5 　在XAML编辑器中处理事件　　931
27.9.6 　Document Outline窗口　　932
27.9.7 　查看自动生成的代码文件　　933
27.10 　使用Visual Studio构建自定义XAML编辑器　　933
27.10.1 　设计窗口的GUI　　934
27.10.2 　实现Loaded事件　　935
27.10.3 　实现按钮的Click事件　　936
27.10.4 　实现Closed事件　　937
27.10.5 　测试应用程序　　937
27.10.6 　探索WPF 文档　　938
27.11 　小结　　939
第28章　使用WPF控件编程　　941
28.1 　WPF核心控件概述　　941
28.1.1 　WPF Ink控件　　942
28.1.2 　WPF Document控件　　942
28.1.3 　WPF公共对话框　　942
28.1.4 　文档中的细节　　943
28.2 　Visual Studio WPF设计器　　944
28.2.1 　在Visual Studio中使用WPF控件　　944
28.2.2 　使用Document Outline编辑器　　945
28.3 　使用面板控制内容布局　　946
28.3.1 　在Canvas面板中放置内容　　948
28.3.2 　在WrapPanel面板中放置内容　　949
28.3.3 　在StackPanel面板中放置内容　　951
28.3.4 　在Grid面板中放置内容　　952
28.3.5 　在DockPanel面板中放置内容　　954
28.3.6 　启用Panel类型的滚动功能　　955
28.3.7 　使用Visual Studio设计器配置Panel　　956
28.4 　使用嵌套面板构建窗口框架　　959
28.4.1 　构建菜单系统　　960
28.4.2 　构建工具条　　962
28.4.3 　构建状态条　　963
28.4.4 　完成UI设计　　963
28.4.5 　实现MouseEnter/MouseLeave事件处理程序　　964
28.4.6 　实现拼写检查逻辑　　964
28.5 　WPF命令　　965
28.5.1 　内置的命令对象　　965
28.5.2 　将命令连接到Command属性　　966
28.5.3 　将命令连接到任意行为　　967
28.5.4 　使用Open和Save命令　　968
28.6 　深入了解WPF API和控件　　970
28.7 　构建Ink API选项卡　　972
28.7.1 　设计工具条　　973
28.7.2 　RadioButton控件　　975
28.7.3 　处理Ink API选项卡的事件　　977
28.7.4 　InkCanvas控件　　977
28.7.5 　ComboBox控件　　980
28.7.6 　保存、加载和清除InkCanvas数据　　981
28.8 　Documents API　　982
28.8.1 　块元素和内联元素　　982
28.8.2 　文档布局管理器　　982
28.9 　构建Documents选项卡　　983
28.9.1 　使用代码填充FlowDocument　　984
28.9.2 　启用批注和便签　　985
28.9.3 　保存和加载流文档　　986
28.10 　WPF数据绑定模型　　987
28.10.1 　构建Data Binding选项卡　　988
28.10.2 　使用Visual Studio建立数据绑定　　988
28.10.3 　DataContext属性　　990
28.10.4 　使用IValueConverter进行数据转换　　991
28.10.5 　在代码中建立数据绑定　　992
28.10.6 　构建DataGrid选项卡　　992
28.11 　小结　　994
第29章　WPF图形呈现服务　　995
29.1 　理解WPF的图形呈现服务　　995
29.2 　使用形状呈现图形数据　　996
29.2.1 　在画布中添加矩形、椭圆形和线条　　998
29.2.2 　在画布中移除矩形、圆形和线条　　1001
29.2.3 　折线和多边形　　1002
29.2.4 　路径　　1002
29.3 　WPF画刷和画笔　　1005
29.3.1 　使用Visual Studio配置画刷　　1006
29.3.2 　在代码中配置画刷　　1008
29.3.3 　配置画笔　　1009
29.4 　图形变换　　1009
29.4.1 　变换概览　　1010
29.4.2 　变换Canvas数据　　1011
29.5 　使用Visual Studio变换编辑器　　1012
29.5.1 　构建初始布局　　1012
29.5.2 　在设计时应用变换　　1014
29.5.3 　在代码中变换画布　　1015
29.6 　使用绘图和几何图形呈现图形数据　　1015
29.6.1 　使用几何图形构建DrawingBrush　　1017
29.6.2 　用DrawingBrush进行绘画　　1017
29.6.3 　在DrawingImage中使用绘图类型　　1018
29.7 　Expression Design的作用　　1019
29.7.1 　将示例设计文件导出为XAML　　1019
29.7.2 　将图像数据导入WPF对象　　1021
29.7.3 　与熊共舞　　1022
29.8 　使用可视化层呈现图形数据　　1022
29.9 　小结　　1028
第30章　WPF资源、动画和样式　　1029
30.1 　理解WPF资源系统　　1029
30.2 　使用对象（逻辑）资源　　1034
30.2.1 　Resources属性的作用　　1034
30.2.2 　定义窗口级别的资源　　1035
30.2.3 　{StaticResource}标记扩展　　1037
30.2.4 　{DynamicResource}标记扩展　　1037
30.2.5 　应用程序级别的资源　　1038
30.2.6 　定义合并的资源字典　　1039
30.2.7 　定义只含资源的程序集　　1041
30.3 　理解WPF动画服务　　1042
30.3.1 　动画类型的作用　　1043
30.3.2 　To、From和By属性　　1043
30.3.3 　Timeline基类的作用　　1044
30.3.4 　用C#代码创建动画　　1044
30.3.5 　控制动画的速度　　1045
30.3.6 　动画的反转和循环　　1046
30.4 　用XAML创建动画　　1047
30.4.1 　演示图板的作用　　1047
30.4.2 　事件触发器的作用　　1048
30.4.3 　使用不连续的关键帧创建动画　　1048
30.5 　WPF样式的作用　　1049
30.5.1 　定义并使用样式　　1050
30.5.2 　重写样式设置　　1050
30.5.3 　使用TargetType自动应用样式　　1051
30.5.4 　继承已有的样式　　1052
30.5.5 　未命名样式的作用　　1052
30.5.6 　使用触发器定义样式　　1053
30.5.7 　使用多个触发器定义样式　　1053
30.5.8 　动画样式　　1054
30.5.9 　以编程方式设置样式　　1054
30.6 　小结　　1056
第31章　依赖属性、路由事件和模板　　1057
31.1 　依赖属性的作用　　1057
31.1.1 　已知的依赖属性　　1059
31.1.2 　CLR属性包装器的重要说明　　1061
31.2 　构建自定义依赖属性　　1061
31.2.1 　添加数据验证例程　　1065
31.2.2 　响应属性的改变　　1065
31.3 　路由事件　　1066
31.3.1 　路由冒泡事件的作用　　1067
31.3.2 　继续或中止冒泡　　1068
31.3.3 　路由隧道事件的作用　　1068
31.4 　逻辑树、可视树和默认模板　　1070
31.4.1 　以编程方式查看逻辑树　　1070
31.4.2 　以编程方式查看可视树　　1072
31.4.3 　以编程方式查看控件的默认模板　　1073
31.5 　使用触发器框架构建自定义控件模板　　1075
31.5.1 　模板资源　　1076
31.5.2 　使用触发器添加可视提示　　1078
31.5.3 　{TemplateBinding}标记扩展的作用　　1079
31.5.4 　ContentPresenter的作用　　1080
31.5.5 　融合模板和样式　　1081
31.6 　小结　　1082
第八部分　ASP.NET Web Form
第32章 　ASP.NET Web Form 　　1084
32.1 　HTTP的作用　　1084
32.1.1 　HTTP请求/响应循环　　1084
32.1.2 　HTTP是无状态协议　　1085
32.2 　Web应用程序和Web服务器　　1085
32.2.1 　IIS虚拟目录的作用　　1085
32.2.2 　ASP.NET Development Web Server　　1086
32.3 　HTML的作用　　1087
32.3.1 　HTML文档结构　　1087
32.3.2 　HTML表单的作用　　1088
32.3.3 　Visual Studio HTML设计器工具　　1088
32.3.4 　构建HTML表单　　1090
32.4 　客户端脚本的作用　　1091
32.5 　回发到Web服务器　　1093
32.6 　ASP.NET API概览　　1094
32.6.1 　ASP.NET 2.0及其后续版本的主要特性　　1095
32.6.2 　ASP.NET 3.5（和.NET 3.5 SP1）的主要特性　　1096
32.6.3 　ASP.NET 4.0和4.5的主要特性　　1096
32.7 　构建单个文件的ASP.NET网页　　1097
32.7.1 　引用AutoLotDAL.dll　　1098
32.7.2 　设计UI　　1098
32.7.3 　添加数据访问逻辑　　1099
32.7.4 　ASP.NET指令的作用　　1101
32.7.5 　脚本块　　1102
32.7.6 　ASP.NET控件声明　　1103
32.8 　使用代码文件构建ASP.NET Web页面　　1104
32.8.1 　引用AutoLotDAL.dll程序集　　1106
32.8.2 　更新代码文件　　1107
32.8.3 　调试并跟踪ASP.NET页面　　1107
32.9 　ASP.NET Web Site和ASP.NET Web Application　　1108
32.10 　ASP.NET网站目录结构　　1110
32.10.1 　引用程序集　　1110
32.10.2 　App_Code文件夹的作用　　1111
32.11 　页面类型的继承链　　1111
32.12 　与传入的HTTP请求交互　　1113
32.12.1 　获得浏览器统计数据　　1113
32.12.2 　访问传入的表单数据　　1114
32.12.3 　IsPostBack属性　　1115
32.13 　与输出HTTP响应交互　　1115
32.13.1 　提交HTML内容　　1116
32.13.2 　重定向用户　　1116
32.14 　ASP.NET网页的生命周期　　1117
32.14.1 　AutoEventWireUp特性的作用　　1118
32.14.2 　Error事件　　1118
32.15 　web.config文件的作用　　1120
32.16 　小结　　1121
第33章 　ASP.NET Web控件、母版页和主题　　1122
33.1 　Web控件的本质　　1122
33.1.1 　服务器端事件处理　　1123
33.1.2 　AutoPostBack属性　　1123
33.2 　Control和WebControl基类　　1124
33.2.1 　枚举所包含的控件　　1125
33.2.2 　动态添加和删除控件　　1127
33.2.3 　与动态创建的控件交互　　1128
33.2.4 　WebControl基类的功能　　1128
33.3 　ASP.NET Web控件的类别　　1129
33.3.1 　关于System.Web.UI.HtmlControls的简短说明　　1131
33.3.2 　Web控件的文档　　1132
33.4 　构建ASP.NET汽车网站　　1132
33.4.1 　使用ASP.NET母版页工作　　1133
33.4.2 　定义默认的内容页面　　1138
33.4.3 　设计Inventory内容页面　　1140
33.4.4 　设计Build-a-Car内容页面　　1143
33.5 　验证控件的作用　　1146
33.5.1 　开启客户端JavaScript验证支持　　1147
33.5.2 　RequiredFieldValidator　　1148
33.5.3 　RegularExpressionValidator　　1148
33.5.4 　RangeValidator　　1148
33.5.5 　CompareValidator　　1149
33.5.6 　创建ValidationSummary　　1150
33.5.7 　定义验证分组　　1151
33.6 　使用主题　　1152
33.6.1 　*.skin文件　　1153
33.6.2 　应用网站级别的主题　　1155
33.6.3 　在页面级别应用主题　　1155
33.6.4 　SkinID属性　　1155
33.6.5 　以编程方式分配主题　　1156
33.7 　小结　　1157
第34章　ASP.NET状态管理技术　　1158
34.1 　状态问题　　1158
34.2 　ASP.NET状态管理技术　　1160
34.3 　ASP.NET视图状态的作用　　1160
34.3.1 　演示视图状态　　1161
34.3.2 　添加自定义视图状态数据　　1162
34.4 　Global.asax文件的作用　　1163
34.4.1 　全局最后异常事件处理程序　　1164
34.4.2 　HttpApplication基类　　1165
34.5 　应用程序状态与会话状态的差别　　1165
34.5.1 　维护应用程序级的状态数据　　1166
34.5.2 　修改应用程序数据　　1168
34.5.3 　处理Web应用程序的关闭　　1169
34.6 　使用应用程序缓存　　1169
34.6.1 　使用数据缓存　　1170
34.6.2 　修改*.aspx文件　　1172
34.7 　维护会话数据　　1174
34.8 　cookie　　1177
34.8.1 　创建cookie　　1177
34.8.2 　读取传入的cookie数据　　1178
34.9 　<sessionState>元素的作用　　1179
34.9.1 　在ASP.NET会话状态服务器中保存会话数据　　1179
34.9.2 　把会话数据保存在专门的数据库中　　1180
34.10 　ASP.NET用户配置API　　1181
34.10.1 　ASPNETDB.mdf数据库　　1181
34.10.2 　在web.config中定义用户配置　　1182
34.10.3 　以编程方式访问用户配置数据　　1183
34.10.4 　分组用户配置数据并且持久化自定义对象　　1185
34.11 　小结　　1186
索引　　1187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通C#（第6版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>理性、浪漫主义和基督教
导言
C.S路易斯简介
C.S.路易斯的研究现状
本书的思路与结构
第一章 C.S.路易斯的生平、著作、思想渊源和核心
生平
主要著作
思想渊源
C.S.路易斯思想的“三大柱石”
第二章 客观的道德律
道德律——上帝存在的一个证明
客观的道德律
第三章 对天国的渴望
“我的体验就是我的证明”
普遍存在而又普遍遭到误解的渴望
渴望与荣耀的关联
其他人对渴望的论述
第四章 “纯粹的”基督教
基督徒的信念
基督徒的行为
第五章 神迹
“大神迹”——道成肉身
“旧创造的神迹”
“新创造的神迹”
第六章 苦难
历史回顾
C.S.路易斯的苦难观
第七章 祷告
祷告的性质
祷告的必要性
祷告的有效性
祷告与上帝的意志、宇宙的进程
时间、永恒与自由
祷告的应允与拒绝
第八章 爱
需求之爱、给予之爱、欣赏之爱
对自然和国家的爱
情爱、友爱、爱情
仁爱
与柏拉图、奥古斯丁、蒂利希观点的比较
第九章 C.S.路易斯的洞察力
“内圈”
民主
谦卑
基督徒的灵性生活
结语：笔者眼中的C.S.路易斯
C.S.路易斯其人
C.S.路易斯著作的吸引力
C.S.路易斯的思想对当今时代的意义
参考文献
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>理性、浪漫主义和基督教
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Exceptional C++（中文版）
1泛型程序设计与C++标准库
条款1：迭代器难度系数
条款2：大小写不敏感的字符串——之一
条款3：大小写不敏感的字符串——之二
条款4：可重用性最高的泛型容器——之一
条款5：可重用性最高的泛型容器——之二
条款6：临时对象
条款7：标准库的使用（或者，再论临时对象）
2异常安全性相关的问题与技术
条款8：编写异常安全的代码——之一
条款9：编写异常安全的代码——之二
条款10：编写异常安全的代码——之三
条款11：编写异常安全的代码——之四
条款12：编写异常安全的代码——之五
条款13：编写异常安全的代码——之六
条款14：编写异常安全的代码——之七
条款15：编写异常安全的代码——之八
条款16：编写异常安全的代码——之九
条款17：编写异常安全的代码——之十
条款18：代码的复杂性——之一
条款19：代码的复杂性——之二
3类的设计与继承
条款20：类的编写技巧
条款21：虚函数的重载
条款22：类之间的关系——之一
条款23：类之间的关系——之二
条款24：继承的使用和滥用
条款25：面向对象程序设计
4编译器防火墙和Pimpl惯用法
条款26：将编译期依赖性降到最低——之一
条款27：将编译期依赖性降到最低——之二
条款28：将编译期依赖性降到最低——之三
条款29：编译防火墙
条款30：FastPimpl惯用法
5名字查找、名字空间和接口规则
条款31：名字查找与接口规则——之一
条款32：名字查找与接口规则——之二
条款33：名字查找和接口规则——之三
条款34：名字查找与接口规则——之四
6内存管理
条款35：内存管理——之一
条款36：内存管理——之二
条款37：AUTO_PTR
7误区、陷阱以及错误的惯用法
条款38：对象标识
条款39：自动转换
条款40：对象的生存期——之一
条款41：对象的生存期——之二
8其他主题
条款42：变量的初始化
条款43：正确使用const
条款44：类型转换
条款45：BOOL
条款46：转调函数
条款47：控制流程
后记
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Exceptional C++（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通C语言
第一周课程
第1天课程 C语言初步
第2天课程 C语言程序的组成部分
第3天课程 存储信息：变量和常量
第4天课程 语句、表达式和运算符
……
第二周课程
第8天课程 使用数值数组
第9天课程 指针
第10天课程 字符和字符串
第11天课程 结构、共用体和TypeDef
……
第三周课程
第15天课程 有关指针的高级主题
第16天课程 使用磁盘文件
第17天课程 操纵字符串
第18天课程 有关函数的高级主题
……
附加课程（具体内容见光盘）
附录A ASCII字符集
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重塑实在论
中文版前言
前言
1导言
第Ⅰ部分一个关于因果和信息的理论
2走向统一的因果理论
3情境理论与因果
4一个决定论模型
5一个非决定论模型
6一个概率因果模型
7高阶因果：作为原因的模态事实
8因果的普遍性
9关于信息与信息错误的理论
10回顾与展望
第Ⅱ部分在形而上学、认识论和伦理学中的应用
11概述
12作为高阶因果的目的论
13心理内容的因果理论
14心理表征的目的论语义学
15关于逻辑与数学认知的因果理论
16心智的目的论理论
17目的论的可靠论
18持存实体及其同一性
19幸福论与价值的客观性
20作为品行目的论的道德理论
21融贯的实在论是全面的实在论
附录A部分性、模态和条件句
附录B因果演算
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重塑实在论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Effective C#中文版
第1章　使用泛型
条目1：使用1.x框架API的泛型版本
条目2：恰到好处地定义约束
条目3：运行时检查泛型参数的类型并提供特定的算法
条目4：使用泛型强制编译期类型推断
条目5：确保泛型类型支持可销毁对象
条目6：使用委托定义类型参数上的方法约束
条目7：不要为基类或接口创建泛型的特殊实现
条目8：尽可能使用泛型方法，除非需要将类型参数用于实例的字段中
条目9：使用泛型元组代替out和ref参数
条目10：在实现泛型接口的同时也实现传统接口
第2章　C#中的多线程
条目11：使用线程池而不是创建线程
条目12：使用BackgroundWorker实现线程间通信
条目13：让lock()作为同步的第一选择
条目14：尽可能地减小锁对象的作用范围
条目15：避免在锁定区域内调用外部代码
条目16：理解Windows窗体和WPF中的跨线程调用
第3章　C#设计实践
条目17：为序列创建可组合的API
条目18：将遍历和操作、谓词以及函数分开
条目19：根据需要生成序列中的元素
条目20：使用函数参数降低耦合
条目21：让重载方法组尽可能清晰、最小化且完整
条目22：定义方法后再重载操作符
条目23：理解事件是如何增加对象间运行时耦合的
条目24：仅声明非虚的事件
条目25：使用异常来报告方法的调用失败
条目26：确保属性的行为与数据类似
条目27：区分继承和组合
第4章　C# 3.0语言增强
条目28：使用扩展方法增强现有接口
条目29：使用扩展方法增强现有类型
条目30：推荐使用隐式类型局部变量
条目31：使用匿名类型限制类型的作用域
条目32：为外部组件创建可组合的API
条目33：避免修改绑定变量
条目34：为匿名类型定义局部函数
条目35：不要在不同命名空间中声明同名的扩展方法
第5章　使用LINQ
条目36：理解查询表达式与方法调用之间的映射
条目37：推荐使用延迟求值查询
条目38：推荐使用lambda表达式而不是方法
条目39：避免在函数或操作中抛出异常
条目40：区分早期执行和延迟执行
条目41：避免在闭包中捕获昂贵的外部资源
条目42：区分IEnumerable和IQueryable数据源
条目43：使用Single()和First()来明确给出对查询结果的期待
条目44：推荐保存Expression[]而不是Func[]
第6章　杂项
条目45：最小化可空类型的可见范围
条目46：为部分类的构造函数、修改方法以及事件处理程序提供部分方法
条目47：仅在需要parms数组时才使用数组作为参数
条目48：避免在构造函数中调用虚方法
条目49：考虑为大型对象使用弱引用
条目50：使用隐式属性表示可变但不可序列化的数据
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Effective C#中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C 程序设计语言(第二版)
中文版序译者序序第1版

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C 程序设计语言(第二版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计疑难解析与技巧300例
第1章 初识C语言
1-1 C语言是如何成熟的
1-2 使用C语言编写程序有什么优点
1-3 C语言语句简练表现在哪些方面
1-4 如何利用C语言的弱类型特性
1-5 如何利用C语言移植性好这一特性
1-6 如何规避C语言的不足之处
1-7 C语言主要应用在哪些领域
1-8 如何理解C++是C语言的超集
1-9 C语言的开发过程包括哪些步骤
1-10 C语言中，程序、文件、函数三者有何关系
1-11 组成C语言程序的最小可执行单元及最小模块单元是什么
1-12 如何保证程序的可读性
1-13 为什么说算法是程序设计的关键
1-14 结构化程序设计包含的三种基本结构是什么
1-15 如何在TurboC 2.0中输入一个程序
1-16 选用什么方法来调试程序比较好
1-17 如何掌握优秀的编程风格
1-18 在编写输入语句时应当注意什么
1-19 多文件程序如何实现
第2章 数据类型
2-1 如何区分常量和变量
2-2 数据在内存中是如何存储的
2-3 怎样合理使用整型数据类型
2-4 怎么界定数字型变量的范围
2-5 超出int型数据取值范围的数如何进行赋值
2-6 不同进制的整型数据之间怎么样进行运算
2-7 如何正确确定实型数据的有效数字位数
2-8 C语言中允许使用的浮点数包括什么
2-9 单精度型和双精度型实型变量有什么区别
2-10 怎样区分字符常量与字符串常量
2-11 如何理解字符与整数之间的关系
2-12 数字在计算机中的表示方法和存储方法分别有哪些
2-13 为什么C语言的常量通常用符号常量替代
2-14 字符串常量后面的'/O'的含义是什么
2-15 如何规定常量的前缀和后缀
2-16 如何有效使用转义字符
2-17 怎么合理给变量取名
2-18 说明一个变量和定义一个变量有什么区别
2-19 如果程序中出现没有定义的变量会发生什么现象
2-20 变量必须初始化吗？给变量赋初值和赋值有什么区别
2-21 一个float变量赋值为3-1时，为什么printf()函数输出的值为3-0999999
2-22 如何确定变量所占内存空间
2-23 编写程序将小写字母转换为大写字母
2-24 如何避免在自动转换数据类型过程中损失数据精度
2-25 什么时候应该对数据类型进行强制转换
2-26 事先定义类型的变量经过强制转换后，它的类型会发生变化吗
第3章 运算符和表达式
3-1 如何利用运算符的优先级和结合性
3-2 运算符的结合性总是保证“自左至右”或“自右至左”吗
3-3 “5／2”和“5％2”的结果分别是什么
3-4 如何区分“，”是运算符还是分隔符
3-5 什么是左值和右值?数组名为什么不能作为左值
3-6 表达式“a=b”和“a＝＝b”相同吗
3-7 赋值运算符两边的数据类型不相同怎样处理
3-8 试用三目运算符找出三个数中的最大值
3-9 计算表达式值时需要注意什么
3-10 怎样将数学表达式转化为算术表达式
3-11 C语言中有哪些简化的运算表达式
3-12 计算逻辑表达式有什么特殊要求
3-13 如何确定条件表达式结果的数据类型
3-14 “廾”和“一”运算时需要注意什么
3-15 C语言系统如何处理表达式a+++b
3-16 如何避免表达式的二义性
3-17 在一个表达式中，有几种不同类型的变量如何处理
第4章 语句
4-1 怎么区分赋值表达式和赋值语句
4-2 如何利用空语句
4-3 举例说明复合语句的用途
4-4 复合语句与分程序有什么区别
4-5 if语句后面的括号中的表达式可以是什么类型
4-6 举例说明if语句的判断流程
4-7 if语句中else个数是否有限制
4-8 在含有多个if…else语句中，怎样判断哪个else是属于哪个if的语句
4-9 举例说明switch语句的判断流程
4-10 什么时候使用switch语句比使用if语句好
4-11 switch语句中default关键字是否必须有
4-12 在switch语句中使用break语句应该注意什么
4-13 利用三种循环体分别编写：从1加到100的程序
4-14 while语句中循环条件可以使用什么表达式
4-15 while语句和do…while语句有什么区别
4-16 for语句后面的三个表达式是否可以省略
4-17 如何判断for循环语句中循环体的循环次数
4-18 怎样将for循环转换为while循环
4-19 编写程序：使用穷举法来判断一个数是否是素数
4-20 如何避免循环结构中累加(乘、减)变量忘记置初值或置初值的位置不对的错误
4-21 空循环是不是就是无限循环
4-22 如何判定循环结束?循环提前结束如何判定
4-23 continue语句和break语句有什么区别
4-24 循环嵌套时需要注意些什么
4-25 如何利用循环嵌套输出菱形
4-26 如何使用辗除法求最大公约数和最小公倍数
4-27 怎样提高循环语句的执行效率
4-28 C语言提供了哪些转向语句?有什么特点
4-29 为什么要慎用goto语句
4-30 返回语句return在一个函数体内必须使用吗?并且只能使用一次吗
第5章 函数和存储类别
5-1 怎样定义一个函数
5-2 定义函数时比较容易犯的错误包括什么
5-3 怎么区分函数定义和函数说明
5-4 如何正确理解函数分类
5-5 如何确定是否需要函数说明
5-6 如何区分函数的简单说明和原型说明
5-7 在函数定义中如何利用关键字void
5-8 什么是空函数
5-9 什么是库函数?常用的库函数包括什么
5-10 一个有返回值的函数，调用时不使用其返回值会出现什么现象
5-11 调用一个函数有几个返回值
5-12 函数的形参和实参有什么区别
5-13 main函数的参数如何设置?其参数有什么作用
5-14 函数定义时不作任何类型说明，这种定义代表什么
5-15 C语言中函数的调用方式有哪几种
5-16 函数传值调用时对函数参数有什么要求
5-17 函数的参数传递有哪几种?有什么区别
5-18 举例说明如何嵌套调用函数
5-19 举例说明怎样使用函数的递归调用
5-20 exit()函数与return语句功能有什么不同
5-21 在C语言中如何调用库函数
5-22 C语言中标识符、语句标号、变量和函数的作用域分别是怎样规定的
5-23 变量的存储类有什么作用
5-24 变量存储在内存的什么地方
5-25 C语言中变量“寿命”有哪些种类
5-26 作用域和“寿命”有什么关系
5-27 哪些存储类变量属于全局变量?哪些存储类变量属于局部变量
5-28 举例说明auto变量是局部有效的
5-29 为什么寄存器变量不能随意使用
5-30 为什么要尽量不要过多定义静态变量
5-31 外部静态变量和内部静态变量如何区分
5-32 外部变量的定义和外部变量的说明一样吗
5-33 如何理解外部变量是实现函数之间数据通信的有效手段
5-34 各存储类变量未被编译系统赋值或赋初值时能否使用
5-35 C语言怎样规定外部函数和内部函数
第6章 数组
6-1 什么情况下需要定义数组这种数据结构
6-2 数组下标总是从O开始的吗
6-3 C语言为什么不进行数组下标有效性检查
6-4 数组下标使用小数会出现什么情况
6-5 定义数组时数组元素个数的位置上能不能出现变量
6-6 用数组名作函数参数与用数组元素作实参有什么不同之处
6-7 在给一维数组赋初值时，对数组元素个数和初始值表中的数据项的个数有何要求
6-8 举例使用循环对数组赋值和输出
6-9 什么是信号变量?它有什么功能
6-10 为什么要谨慎对待紧跟在数组后面的元素
6-11 如何使用冒泡法进行数组元素排序
6-12 举例使用比较交换法进行数组排序
6-13 使用选择法排序有什么优点
6-14 inta[2][3]＝｛｛1，2，3｝，｛4，5，6｝同｛｛1，2，3｝，｛4，5，6｝｝声明效果相同吗
6-15 在给二维数组赋初值时，对数组元素个数和初始值表中的数据项的个数有何要求
6-16 如何利用双循环遍历二维数组的各个元素
6-17 如何看待二维数组中的行地址与列地址的关系
6-18 如何利用数组输出杨辉三角
6-19 什么是字符串?一维字符数组就是字符串吗
6-20 在给字符数组赋初值时，对数组元素个数和初始值表中的数据项的个数有何要求
6-21 编写程序：输入五个地区的名称，并按字母顺序排列输出
6-22 在使用scanf()函数读入字符串时需要注意什么
6-23 怎样使用字符串输出函数puts()
6-24 字符串输入函数gets()的功能是什么
6-25 如何正确使用字符串连接函数strcat()
6-26 怎样复制字符串
6-27 如何确定字符串比较函数strcmp()的返回值
6-28 如何使用测字符串长度函数strlen()
6-29 ‘＼0’和“＼0”有什么区别
第7章 指针
7-1 如何理解指针就是一种变量
7-2 指针的类型和指针所指向的类型是一样的吗
7-3 给指针赋值或赋初值时需要注意什么
第8章 编译预处理
第9章 结构体和联合体
第10章 文件
第11章 图形图像和音频
第12章 内存管理
第13章 C语言应用技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计疑难解析与技巧300例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言参考手册(原书第5版)
第一部分 C语言
第一章 简介
第二章 词法元素
第三章 C语言预处理器
第四章 声明
第五章 类型
第六章 转换与表示
第七章 表达示
第八章 语句
第九章 函数
第二部分 C语言库
第十章 库简介
第十一章 标准语言补充
第十二章 字符处理函数
第十三章 字符串处理函数
第十四章 内存函数
第十五章 输入/输出函数
第十六章 通用函数
第十七章 数学函数
第十八章 时间和日期函数
第十九章 控制函数
第二十章 区域设置函数
第二十一章 扩展整数类型
第二十二章 浮点数环境
第二十三章 复数算术
第二十四章 宽字符与多字节函数
第三部分 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言参考手册(原书第5版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字图像处理与机器视觉
第0章  数字图像处理概述  0.1  数字图像    0.1.1  什么是数字图像    0.1.2  数字图像的显示    0.1.3  数字图像的分类    0.1.4  数字图像的实质    0.1.5  数字图像的表示    0.1.6  图像的空间和灰度级分辨率  0.2  数字图像处理与识别    0.2.1  从图像处理到图像识别    0.2.2  什么是机器视觉    0.2.3  数字图像处理和识别的应用实例  0.3  数字图像处理的预备知识    0.3.1  邻接性、连通性、区域和边界    0.3.2  距离度量的几种方法    0.3.3  基本的图像操作第1章  MATLAB图像处理编程基础第2章  Visual C++图像处理编程基础第3章  图像的点运算第4章  图像的几何变换第5章  空间域图像增强第6章  频率域图像增强第7章  彩色图像处理第8章  形态学图像处理第9章  图像分割第10章  特征提取第11章  图像识别初步第12章  人工神经网络第13章  支持向量机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字图像处理与机器视觉
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分形算法与程序设计
第1章 分形简介
第2章 分形图的递归算法
第3章 文法构图算法
第4章 迭代函数系统算法
第5章 逃逸时间算法
第6章 分形显微镜
第7章 分形演化算法
第8章 分形动画
第9章 三维空间中的分形
第10章 分形自然景物模拟算法
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分形算法与程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++深层探索
Part  I　1
00 预备知识　3
01 C/C++语言的发展简史　9
02 关于字节顺序　15
03 调用函数、栈　19
04 变量的可见范围与生存期　27
05 变量的声明和定义　33
06 编译和链接　41
07 外部变量的链接性质　45
08 静态内部变量　51
09 函数的声明和定义（上）　55
10 函数的声明和定义（下）　65
11 函数的链接性质　73

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++深层探索
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript面向对象精要
第1章　原始类型和引用类型 1
1.1　什么是类型 2
1.2　原始类型 3
1.2.1　鉴别原始类型 4
1.2.2　原始方法 6
1.3　引用类型 6
1.3.1　创建对象 6
1.3.2　对象引用解除 7
1.3.3　添加删除属性 8
1.4　内建类型实例化 8
1.4.1　字面形式 9
1.4.2　对象和数组字面形式 9
1.4.3　函数字面形式 10
1.4.4　正则表达式字面形式 11
1.5　访问属性 11
1.6　鉴别引用类型 12
1.7　鉴别数组 13
1.8　原始封装类型 14
1.9　总结 16
第2章　函数 17
2.1　声明还是表达式 18
2.2　函数就是值 19
2.3　参数 21
2.4　重载 23
2.5　对象方法 24
2.5.1　this对象 25
2.5.2　改变this 26
2.6　总结 29
第3章　理解对象 31
3.1　定义属性 32
3.2　属性探测 33
3.3　删除属性 35
3.4　属性枚举 36
3.5　属性类型 37
3.6　属性特征 38
3.6.1　通用特征 39
3.6.2　数据属性特征 40
3.6.3　访问器属性特征 41
3.6.4　定义多重属性 43
3.6.5　获取属性特征 44
3.7　禁止修改对象 45
3.7.1　禁止扩展 45
3.7.2　对象封印 45
3.7.3　对象冻结 47
3.8　总结 48
第4章　构造函数和原型对象 49
4.1　构造函数 49
4.2　原型对象 53
4.2.1　[[Prototype]]属性 54
4.2.2　在构造函数中使用原型对象 57
4.2.3　改变原型对象 60
4.2.4　内建对象的原型对象 62
4.3　总结 63
第5章　继承 65
5.1　原型对象链和Object.prototype 65
5.1.1　继承自Object.prototype的方法 66
5.1.2　修改Object.prototype 68
5.2　对象继承 69
5.3　构造函数继承 72
5.4　构造函数窃取 75
5.5　访问父类方法 77
5.6　总结 78
第6章　对象模式 79
6.1　私有成员和特权成员 80
6.1.1　模块模式 80
6.1.2　构造函数的私有成员 82
6.2　混入 84
6.3　作用域安全的构造函数 90
6.4　总结 92
索引 93
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript面向对象精要
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计教程
出版说明
译者序
前言
第1章 基本概念
第2章 C语言程序设计入门
第3章 结构化程序的开发
第4章 程序控制
第5章 函数
第6章 数组
第7章 指针
第8章 字符和字符串
第9章 格式化输入/输出
第10章 结构、联合、位运算和枚举
第11章 文件处理
第12章 数据结构
第13章 预处理程序
第14章 高级话题

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First C#（中文版）
引子
1　C#助你快速开发：10分钟(甚至更短时间)内轻松搞定可视化应用
2　都只是代码：幕后的故事
3　对象我们的方向！让代码更合理
4　类型与引用：现在是上午10：00，你知道你的数据在哪儿吗？
C#实验室1：赛狗日
5　封装：让你的隐私……属于你个人
6 　继承：对象的家庭树
7　接口与抽象类：让类信守承诺
8　枚举与集成：存储大量数据
C#实验室2：冒险游戏
9　读写文件：保存了字节数组，就留住了一切
10　异常处理：救火太老套
11　事件与委托：没有你的监视，代码自己在做什么
12　复习与预习：知识，能力，动手实践
13　控件与图片：应用的美化
14　CAPTAIN AMAZING：对象之死
15　LINQ：让数据在你的掌控之中
C#实验室3：入侵者
附录　其他
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First C#（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>圣洁
序
第一章 引言
第二章 罪
第三章 成圣
第四章 圣洁
第五章 争战
第六章 代价
第七章 长进
第八章 得救确据
第九章 摩西——一个榜样
第十章 罗得——一个警示
第十一章 一个要回想的女子——罗得的妻子
第十二章 基督最大的战利品
第十三章 风浪的主宰
第十四章 基督所建造的教会
第十五章 对有形教会的警告
第十六章 你爱我吗
第十七章 与基督无关
第十八章 永不再渴
第十九章 测不透的丰富
第二十章 时代的需要
第二十一章 基督是一切
第二十二章 先贤作品摘抄
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>圣洁
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>时空之恋3
序幕
第一章 杏仁糖果心
第二章 只是朋友
第三章 另一台时光仪
第四章 神秘箱子
第五章 保卫时光仪
第六章 《安娜•卡列尼娜》
第七章 质问
第八章 化装舞会
第九章 死亡降临
第十章 重归于好
第十一章 智慧石的秘密
第十二章 异人圈闭合
第十三章 真相
第十四章 拯救幽灵
第十五章 决战
尾声
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>时空之恋3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚人
前言与致谢
引言
第一章  “目前虽然幸福，但防备欠周……”
第二章  “粗鄙、没有脑子的英格兰学生们”
第三章  “带血牛排和浓啤酒”
第四章  “我从来没有吓到祈祷的地步”
第五章  “真正的家在别的什么地方”
第六章  “我让步”
第七章  “坚定地信仰基督”
第八章  “你们认为我是在设法编制咒语吗？”
第九章  “我对他们所有人都充满了无以言表的感激之情”
第十章  “没有人能够驳倒路易斯”
第十一章  “我们很快就学会去爱我们知道一定会失去的东西”
第十二章  “喜悦是天国的要紧事务”
后记  纳尼亚的未来
注释
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚人
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和C++安全编码
译者序
序言
前言
作译者简介
第1章 夹缝求生 1
1.1 衡量危险 3
1.1.1 损失的现状 4
1.1.2 威胁的来源 5
1.1.3 软件安全 6
1.2 安全概念 7
1.2.1 安全策略 8
1.2.2 安全缺陷 8
1.2.3 漏洞 9
1.2.4 利用 10
1.2.5 缓解措施 10
1.3 C和C++ 11
1.3.1 C和C++简史 11
1.3.2 C存在的问题 12
1.3.3 遗留代码 13
1.3.4 其他语言 13
1.4 开发平台 13
1.4.1 操作系统 13
1.4.2 编译器 15
1.5 本章小结 16
1.6 阅读材料 16
第2章 字符串 17
2.1 字符串特征 17
2.2 常见的字符串操作错误 18
2.2.1 无界字符串复制 18
2.2.2 差一错误 20
2.2.3 空结尾错误 21
2.2.4 字符串截断 21
2.2.5 与函数无关的字符串错误 21
2.3 字符串漏洞 22
2.3.1 安全缺陷 23
2.3.2 缓冲区溢出 24
2.4 进程内存组织 24
2.5 栈粉碎 27
2.6 代码注入 30
2.7 弧注入 32
2.8 缓解策略 34
2.8.1 预防 34
2.8.2 字符串流 44
2.8.3 检测和恢复 45
2.9 著名的漏洞 48
2.9.1 远程登录 49
2.9.2 Kerberos 49
2.9.3 Metamail 49
2.10 本章小结 50
2.11 阅读材料 51
第3章 指针诡计 52
3.1 数据位置 52
3.2 函数指针 53
3.3 数据指针 54
3.4 修改指令指针 54
3.5 全局偏移表 56
3.6 .dtors区 57
3.7 虚指针 58
3.8 atexit()和on_exit()函数 60
3.9 longjmp()函数 61
3.10 异常处理 62
3.10.1 结构化异常处理 62
3.10.2 系统默认异常处理 64
3.11 缓解策略 65
3.11.1 W^X 65
3.11.2 Canaries 65
3.12 本章小结 65
3.13 阅读材料 66
第4章 动态内存管理 67
4.1 动态内存管理 67
4.2 常见的动态内存管理错误 69
4.2.1 初始化 69
4.2.2 检查返回值失败 70
4.2.3 引用已释放的内存 71
4.2.4 多次释放内存 72
4.2.5 不匹配的内存管理函数 73
4.2.6 未正确区分标量和数组 73
4.2.7 对分配函数的不当使用 73
4.3 Doug Lea的内存分配器 74
4.3.1 内存管理 74
4.3.2 缓冲区溢出 76
4.3.3 双重释放漏洞 80
4.3.4 写入已释放的内存 83
4.4 RtlHeap 83
4.4.1 Win32中的内存管理 83
4.4.2 RtlHeap的数据结构 85
4.4.3 缓冲区溢出 88
4.4.4 缓冲区溢出（再回顾） 89
4.4.5 写入已释放内存 92
4.4.6 双重释放 92
4.4.7 look-aside表 95
4.5 缓解策略 95
4.5.1 空指针 95
4.5.2 一致的内存管理约定 96
4.5.3 堆完整性检测 96
4.5.4 phkmalloc 97
4.5.5 随机化 98
4.5.6 哨位页 98
4.5.7 OpenBSD 98
4.5.8 运行时分析工具 99
4.5.9 Windows XP SP2 100
4.6 著名的漏洞 101
4.6.1 CVS缓冲区溢出漏洞 102
4.6.2 微软数据访问组件（MDAC） 102
4.6.3 CVS服务器双重释放漏洞 103
4.6.4 MIT Kerberos 5中的漏洞 103
4.7 本章小结 103
4.8 阅读材料 103
第5章 整数安全 105
5.1 整数 105
5.1.1 整数表示法 106
5.1.2 整数类型 106
5.1.3 整数取值范围 108
5.2 整型转换 109
5.2.1 整型提升 109
5.2.2 整数转换级别 109
5.2.3 从无符号整型转换 111
5.2.4 从带符号整型转换 112
5.2.5 带符号或无符号字符 113
5.2.6 普通算术转换 113
5.3 整数错误情形 113
5.3.1 整数溢出 114
5.3.2 符号错误 115
5.3.3 截断错误 115
5.4 整数操作 116
5.4.1 加法 117
5.4.2 减法 119
5.4.3 乘法 120
5.4.4 除法 122
5.5 漏洞 126
5.5.1 整数溢出 126
5.5.2 符号错误 127
5.5.3 截断错误 128
5.6 非异常的整数逻辑错误 129
5.7 缓解策略 130
5.7.1 范围检查 130
5.7.2 强类型 131
5.7.3 编译器运行时检查 131
5.7.4 安全的整数操作 132
5.7.5 任意精度的算术 136
5.7.6 测试 137
5.7.7 源代码审查 137
5.8 著名的漏洞 137
5.8.1 XDR库 137
5.8.2 Windows DirectX MIDI库 138
5.8.3 bash 138
5.9 本章小结 139
5.10 阅读材料 140
第6章 格式化输出 141
6.1 变参函数 142
6.1.1 ANSI C标准参数 142
6.1.2 Unix System V Varargs 144
6.2 格式化输出函数 144
6.2.1 格式字符串 145
6.2.2 GCC 147
6.2.3 Visual C++.NET 147
6.3 对格式化输出函数的漏洞利用 148
6.3.1 缓冲区溢出 148
6.3.2 输出流 149
6.3.3 使程序崩溃 149
6.3.4 查看栈内容 150
6.3.5 查看内存内容 151
6.3.6 覆写内存 152
6.3.7 国际化 156
6.4 栈随机化 156
6.4.1 阻碍栈随机化 156
6.4.2 以双字的格式写地址 157
6.4.3 直接参数存取 158
6.5 缓解策略 160
6.5.1 静态内容的动态使用 160
6.5.2 限制字节写入 161
6.5.3 ISO/IEC TR 24731 162
6.5.4 iostream与stdio 162
6.5.5 测试 163
6.5.6 编译器检查 164
6.5.7 词法分析 164
6.5.8 静态污点分析 164
6.5.9 调整变参函数的实现 165
6.5.10 Exec Shield 166
6.5.11 FormatGuard 166
6.5.12 Libsafe 167
6.5.13 静态二进制分析 167
6.6 著名的漏洞 168
6.6.1 华盛顿大学FTP Daemon 168
6.6.2 CDE ToolTalk 168
6.7 本章小结 169
6.8 阅读材料 170
第7章 文件I/O 171
7.1 并发 171
7.1.1 竞争条件 171
7.1.2 互斥和死锁 172
7.2 检查时间和使用时间 173
7.3 作为锁的文件和文件锁定 174
7.4 文件系统利用 176
7.4.1 符号链接利用 176
7.4.2 临时文件打开利用 178
7.4.3 unlink()竞争利用 180
7.4.4 受信文件名 180
7.4.5 非唯一的临时文件名 181
7.5 缓解策略 181
7.5.1 关闭竞争窗口 182
7.5.2 消除竞争对象 184
7.5.3 控制对竞争对象的访问 187
7.5.4 竞争侦测工具 188
7.6 本章小结 189
第8章 推荐的实践 190
8.1 安全的软件开发原则 191
8.1.1 机制经济性原则 192
8.1.2 失败-保险默认原则 192
8.1.3 完全仲裁原则 192
8.1.4 开放式设计原则 192
8.1.5 特权分离原则 192
8.1.6 最小特权原则 193
8.1.7 最少公共机制原则 193
8.1.8 心理可接受性原则 194
8.2 系统质量需求工程 194
8.3 威胁建模 195
8.4 使用/误用案例 196
8.5 架构与设计 196
8.6 现成软件 198
8.6.1 现有代码中的漏洞 198
8.6.2 安全的包装器 199
8.7 编译器检查 199
8.8 输入验证 200
8.9 数据净化 201
8.9.1 黑名单 201
8.9.2 白名单 202
8.9.3 测试 203
8.10 静态分析 203
8.10.1 Fortify 203
8.10.2 Prexis 204
8.10.3 Prevent 204
8.10.4 PREfix和PREfast 205
8.11 质量保证 205
8.11.1 渗透测试 205
8.11.2 模糊测试 206
8.11.3 代码审计 206
8.11.4 开发人员准则与检查清单 206
8.11.5 独立安全审查 207
8.12 内存权限 207
8.12.1 W^X 207
8.12.2 PaX 208
8.12.3 数据执行防护 208
8.13 深层防御 209
8.14 TSP-Secure 209
8.14.1 计划和跟踪 209
8.14.2 质量管理 210
8.15 本章小结 211
8.16 阅读材料 211
参考文献 212
缩略语 223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和C++安全编码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精灵墨丘利
一、 佐西莫斯的幻象
（一） 文本
（二） 评论
1. 对解释所做的总评
2. 牺牲行为
3. 拟人化
4. 石头的象征作用
5. 水的象征作用
6. 幻象的起源
二、 作为一种精神现象的帕拉赛尔苏斯
《帕拉塞尔西卡》的序言
（一） 知识的两种起源：自然之光和启示之光
1. 魔法
2. 炼金术
3. 神秘教义
4. 原始人
（二） 《长生不老》：神秘教义的阐述
1. 伊利亚斯特
2. 阿夸斯特
3. 阿瑞斯
4. 梅露西娜
5. 作为神秘物质的王子（迈克尔 · 梅耶）
6. 通过蒸馏而导致太一或中心的产生
7. 在泉水中化合
（三） 自然转换的秘密
1. 黑暗之光
2. 人的两种本性的结合
3. 最大化的人的四位一体
4. 恢复与无意识的友好关系
（四） 杰拉德 · 多恩的评论
1. 梅露西娜与自性化过程
2. 永生者的神圣婚姻
3. 精神与自然
4. 教会的圣餐和炼金术的作品
（五） 结语
三、 精灵墨丘利
第一部分
1. 瓶子里的精灵
2. 精灵与树之间的联系
3. 使墨丘利获得解救的问题
第二部分
1. 导言
2. 作为水银和/或水的墨丘利
3. 作为火的墨丘利
4. 作为精神和灵魂的墨丘利
A. 作为空气精灵的墨丘利
B. 作为灵魂的墨丘利
C. 作为非物质的、形而上意义上的精神的墨丘利
5. 墨丘利的双重性
6. 墨丘利的统一与三位一体
7. 墨丘利与占星术和执政官教条的关系
8. 墨丘利与赫尔墨斯
9. 作为神秘物质的墨丘利
10. 小结
译名对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精灵墨丘利
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>正义的前沿
导论
第一章社会契约和三个悬而未决的正义问题
第二章残障和社会契约
第三章能力与残障
第四章互利与全球不平等
第五章超越国界的能力
第六章超越“同情与人道”
第七章道德情感与能力进路

注释
参考文献
索引
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>正义的前沿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++探秘
第一部分 C++基础
第1讲 打磨工具	2
1.1 作者推荐	2
1.1.1 Windows平台	2
1.1.2 Macintosh OS 9以及更早版本	3
1.1.3 其他平台	3
1.2 阅读文档	3
1.3 第一个程序	4
第2讲 阅读C++代码	10
2.1 注释	11
2.2 头文件	11
2.3 主程序	13
2.4 变量定义	13
2.5 语句	14
2.6 输出	15
第3讲 整数表达式	17
第4讲 字符串	23
第5讲 简单的输入	28
第6讲 错误消息	33
6.1 拼写错误	34
6.2 错误字符	34
6.3 未知操作符	35
6.4 未知名字	35
6.5 符号错误	36
6.6 从错误中获得乐趣	36
第7讲 For循环	37
7.1 有界循环	37
7.1.1 初始化	37
7.1.2 条件	38
7.1.3 后循环	39
7.1.4 for循环的工作原理	39
7.2 由你来做	39
第8讲 格式化输出	41
8.1 问题	41
8.2 字段宽度	42
8.3 填充	43
8.4 std前缀	44
8.5 对齐	44
8.6 探索格式化	44
8.7 替代语法	46
8.8 由你完成	46
第9讲 数组和向量	49
9.1 用向量代替数组	49
9.2 向量	50
9.3 迭代器	51
9.4 算法	53
9.5 成员类型	54
9.6 使用迭代器和算法	55
第10讲 自增和自减	58
10.1 自增	58
10.2 自减	59
第11讲 条件和逻辑	64
11.1 I/O和bool	64
11.2 布尔类型	65
11.3 逻辑操作符	67
11.4 旧式语法	68
11.5 比较操作符	68
第12讲 复合语句	71
12.1 语句	71
12.2 局部定义和范围	74
12.3 for循环头中的定义	76
第13讲 文件I/O简介	79
13.1 读文件	79
13.2 写文件	80
第14讲 数据结构映射	83
14.1 使用映射	83
14.2 迭代器	84
14.3 搜索映射	86
第15讲 类型同义词	88
15.1 typedef声明	88
15.2 常见的类型定义	89
第16讲 字符	91
16.1 字符类型	91
16.2 字符I/O	93
16.3 换行和移植性	94
16.4 转义字符	94
第17讲 字符分类	96
17.1 字符集	96
17.2 字符分类	98
17.3 区域设置	99
第18讲 大小写转换	103
18.1 简单的大小写	103
18.2 复杂的大小写	104
第19讲 编写函数	107
19.1 函数	107
19.2 函数调用	109
19.3 声明和定义	109
19.4 再谈单词计数	111
19.5 函数main()	113
第20讲 函数实参	115
20.1 实参传递	115
20.2 按引用传递	117
20.3 常量引用	119
20.4 const_iterator	120
20.5 输出参数	121
第21讲 使用算法	122
21.1 传递数据	122
21.2 谓词	126
21.3 其他算法	128
第22讲 重载函数名	131
第23讲 大数和小数	136
23.1 长整型和短整型	136
23.1.1 长整数	137
23.1.2 短整数	137
23.2 整数字面量	138
23.3 字节长度的整数	139
23.4 类型转换	140
23.5 整数算术	141
23.6 重载解析	142
第24讲 极大数和极小数	145
24.1 浮点数	145
24.2 浮点字面量	146
24.3 浮点特征	147
24.4 浮点I/O	148
第25讲 文档	151
25.1 Doxygen	151
25.2 结构化注释	151
25.3 文档标签	152
25.4 使用Doxygen	156
第26讲 项目1：身体质量指数	157
第二部分 自定义类型
第27讲 自定义类型	160
27.1 定义新类型	160
27.2 成员函数	161
27.3 构造函数	164
27.4 重载构造函数	166
第28讲 重载操作符	167
28.1 比较有理数	167
28.2 算术操作符	171
28.3 数学函数	173
第29讲 自定义I/O操作符	175
29.1 输入操作符	175
29.2 输出操作符	176
29.3 错误状态	177
第30讲 赋值与初始化	179
30.1 赋值操作符	179
30.2 构造函数	180
30.3 合并	181
第31讲 编写类	186
31.1 类的结构	186
31.2 成员函数	187
31.3 构造函数	189
第32讲 深入探索成员函数	193
32.1 调用默认构造函数	193
32.2 重温Project 1	196
32.3 const成员函数	199
第33讲 访问级别	203
33.1 公有与私有	203
33.2 class与struct	206
33.3 简单的旧式数据	206
33.4 公有还是私有	207
第34讲 面向对象编程介绍	212
34.1 书籍与杂志	212
34.2 分类	213
34.3 继承	215
34.4 Liskov置换原则	216
34.5 类型多态	216
第35讲 继承	218
35.1 派生类	218
35.2 析构函数	221
35.3 访问级别	224
35.4 编程风格	225
第36讲 虚函数	226
36.1 类型多态	226
36.2 虚函数	229
36.3 引用与切除	230
36.4 纯虚函数	231
36.5 虚析构函数	232
第37讲 类与类型	233
37.1 类与typedef	233
37.2 值类型	236
37.2.1 复制	236
37.2.2 赋值	236
37.2.3 比较	236
37.3 资源获取即为初始化	239
第38讲 声明与定义	241
38.1 声明与定义	241
38.2 内联函数	243
38.3 变量声明与定义	244
38.4 静态变量	246
38.5 静态数据成员	248
38.6 声明符	250
第39讲 使用多个源文件	251
39.1 多个源文件	251
39.2 声明与定义	252
39.3 #include文件	254
39.3.1 引号与括号	256
39.3.2 嵌套#include指令	256
39.3.3 包含监护	257
39.3.4 文档	258
39.4 外部变量	261
39.5 内联函数	261
39.6	“一份定义”规则	262
第40讲 函数对象	264
40.1 函数调用操作符	264
40.2 函数对象	265
40.3 复用成员函数	269
40.4 生成器函子	270
第41讲 有用的算法	272
41.1 搜索	272
41.1.1 线性搜索算法	272
41.1.2 二分搜索算法	276
41.2 比较	279
41.3 重组织数据	281
41.4 复制数据	282
41.5 删除元素	283
41.6 迭代器	284
第42讲 迭代器	285
42.1 迭代器的种类	285
42.1.1 输入迭代器	286
42.1.2 输出迭代器	286
42.1.3 前向迭代器	286
42.1.4 双向迭代器	287
42.1.5 随机访问迭代器	287
42.2 使用迭代器工作	288
42.3 const_iterator与const iterator	290
42.4 错误消息	292
42.5 专用迭代器	292
42.6 迭代器要点	294
第43讲 异常	296
43.1 异常介绍	296
43.2 捕获异常	297
43.3 抛出异常	299
43.4 程序栈	300
43.5 标准异常	304
43.6 I/O异常	304
43.7 自定义异常	306
43.8 对异常的建议	307
第44讲 更多操作符	309
44.1 条件操作符	309
44.2 短路操作符	311
44.3 逗号操作符	311
44.4 算术赋值操作符	313
44.5 自增与自减	315
第45讲 项目2：定点数	318
第三部分 泛型编程
第46讲 函数模板	324
46.1 泛型函数	324
46.2 使用函数模板	325
46.3 编写函数模板	326
46.4 模板形参	328
46.5 模板实参	329
46.6 声明与定义	331
46.7 成员函数模板	331
第47讲 类模板	333
47.1 参数化类型	333
47.2 参数化rational类	334
47.3 使用类模板	336
47.4 重载的操作符函数	338
47.5 混合类型	340
第48讲 模板特化	342
48.1 实例化与特化	342
48.2 自定义比较函数	345
48.3 特化函数模板	346
48.4 特征	347
第49讲 部分特化	349
49.1 退化的pair	349
49.2 部分特化	350
49.3 部分特化函数模板	351
49.4 值模板形参	351
第50讲 名字与名字空间	353
50.1 名字空间	353
50.2 嵌套名字空间	355
50.3 全局名字空间	358
50.4 名字空间std	358
50.5 使用名字空间	359
50.5.1 using指令	359
50.5.2 using声明	361
50.5.3 类中的using声明	363
50.6 无名名字空间	364
50.7 名字查找	365
第51讲 容器	370
51.1 容器的性质	370
51.2 技术报告1	371
51.3 成员类型	372
51.4 容器里能放什么	373
51.5 插入与清除	374
51.5.1 顺序容器的插入操作	374
51.5.2 顺序容器的清除操作	375
51.5.3 关联容器的插入操作	375
51.5.4 关联容器的清除操作	376
51.5.5 异常	377
51.6 迭代器与引用	377
51.7 顺序容器	380
51.7.1 类模板array	381
51.7.2 类模板deque	382
51.7.3 类模板list	383
51.7.4 类模板vector	384
51.8 关联容器	385
第52讲 国际字符	389
52.1 为何要“宽”	389
52.2 使用宽字符	389
52.3 宽字符串	390
52.4 宽字符的I/O操作	392
52.5 多字节字符集	393
52.6 Unicode	394
52.7 通用字符名字	396
第53讲 区域设置与分面	397
53.1 问题	397
53.2 拯救者“区域设置”	398
53.3 区域设置与I/O	399
53.4 分面	399
53.5 字符类别	402
53.6 排序规则	406
第54讲 文本I/O	410
54.1 文件模式	410
54.2 字符串流	411
54.3 文本转换	417
54.4 Boost词法转换	420
第55讲 项目3：货币类型	422
第四部分 实时编程
第56讲 指针	424
56.1 问题	424
56.2 解决方案	432
56.3 地址与指针	433
56.4 依赖图	434
第57讲 动态内存	437
57.1 分配内存	437
57.2 释放内存	438
57.3 指向为空的指针	438
57.4 实现标准容器	440
57.5 增加变量	441
57.6 特殊成员函数	448
第58讲 异常—安全	452
58.1 内存泄漏	452
58.2 异常与动态内存	454
58.3 自动删除指针	456
58.4 auto_ptr不能做的事	458
58.5 异常与构造函数	458
第59讲 旧式数组	462
59.1 C风格的数组	462
59.2 数组的限制	463
59.3 动态分配数组	464
59.4 多维数组	465
59.5 C风格的字符串	466
59.6 命令行参数	466
59.7 指针运算	468
第60讲 智能指针	470
60.1 重新审视auto_ptr	470
60.2 可复制智能指针	472
60.3 智能数组	474
60.4 Pimpl	474
60.5 迭代器	482
第61讲 位操作	483
61.1 将整数作为位的集合	483
61.2 位掩码	485
61.3 移位	486
61.4 使用无符号类型安全移位	487
61.4.1 有符号与无符号类型	488
61.4.2 无符号字面量	488
61.4.3 类型转换	489
61.5 溢出	493
61.6 位域简介	493
61.7 可移植性	494
61.8	bitset类模板	495
第62讲 枚举	498
62.1 理想的枚举	498
62.2 作为位掩码的枚举	499
62.3 模拟枚举	500
62.3.1 枚举计算机语言	500
62.3.2 对语言进行比较	501
62.3.3 赋值	502
62.3.4 字符串和语言	503
62.3.5 初始化	508
62.3.6 读写语言	508
62.3.7 使用模拟的枚举	509
62.4 重新审视项目	510
第63讲 多重继承	512
63.1 多重基类	512
63.2 虚基类	514
63.3 类Java接口	516
63.4 接口与模板	518
63.5 Mix-in	519
63.6 友元来帮忙	521
第64讲 特征萃取与策略	524
64.1 案例研究：迭代器	524
64.2 迭代器特征萃取	528
64.3 案例研究：char_traits	529
64.4 基于策略的编程	530
第65讲 名字与模板	538
65.1 限定名的问题	538
65.2 非限定名的问题	540
第66讲 重载函数	546
66.1 重载函数回顾	546
66.2 重载解析	549
66.2.1 候选函数	549
66.2.2 可行函数	551
66.2.3 最佳可行函数	551
66.3 默认实参	555
第67讲 元编程	557
67.1 编译时编程	557
67.2 模板特化	557
67.3 部分特化	559
第68讲 项目4：计算器	566
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++探秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>快学Scala
目录
序
前言
关于作者
1 基础 [A1]
1.1 Scala解释器
1.2 声明值和变量
1.3 常用类型
1.4 算术和操作符重载
1.5 调用函数和方法
1.6 apply方法
1.7 Scaladoc
练习
2 控制结构和函数 [A1]
2.1 条件表达式
2.2 语句终止
2.3 块表达式和赋值
2.4 输入和输出
2.5 循环
2.6 高级for循环和for推导式
2.7 函数
2.8 默认参数和带名参数 [L1]
2.9 变长参数 [L1]
2.10 过程
2.11 懒值 [L1]
2.12 异常
练习
3 数组相关操作 [A1]
3.1 定长数组
3.2 变长数组：数组缓冲
3.3 遍历数组和数组缓冲
3.4 数组转换
3.5 常用算法
3.6 解读Scaladoc
3.7 多维数组
3.8 与Java的互操作
练习
4 映射和元组 [A1]
4.1 构造映射
4.2 获取映射中的值
4.3 更新映射中的值
4.4 迭代映射
4.5 已排序映射
4.6 与Java的互操作
4.7 元组
4.8 拉链操作
练习
5 类 [A1]
5.1 简单类和无参方法
5.2 带getter和setter的属性
5.3 只带getter的属性
5.4 对象私有字段
5.5 Bean属性 [L1]
5.6 辅助构造器
5.7 主构造器
5.8 嵌套类 [L1]
练习
6 对象 [A1]
6.1 单例对象
6.2 伴生对象
6.3 扩展类或特质的对象
6.4 apply方法
6.5 应用程序对象
6.6 枚举
练习
7 包和引入 [A1]
7.1 包
7.2 作用域规则
7.3 串联式包语句
7.4 文件顶部标记法
7.5 包对象
7.6 包可见性
7.7 引入
7.8 任何地方都可以声明引入
7.9 重命名和隐藏方法
7.10 隐式引入
练习
8 继承 [A1]
8.1 扩展类
8.2 重写方法
8.3 类型检查和转换
8.4 受保护字段和方法
8.5 超类的构造
8.6 重写字段
8.7 匿名子类
8.8 抽象类
8.9 抽象字段
8.10 构造顺序和提前定义 [L3]
8.11 Scala继承层级
8.12 对象相等性 [L1]
练习
9 文件和正则表达式 [A1]
9.1 读取行
9.2 读取字符
9.3 读取词法单元和数字
9.4 从URL或其他源读取
9.5 读取二进制文件
9.6 写入文本文件
9.7 访问目录
9.8 序列化
9.9 进程控制 [A2]
9.10 正则表达式
9.11 正则表达式组
练习
10 特质 [L1]
10.1 为什么没有多重继承？
10.2 当作接口使用的特质
10.3 带有具体实现的特质
10.4 带有特质的对象
10.5 叠加在一起的特质
10.6 在特质中重写抽象方法
10.7 当作富接口使用的特质
10.8 特质中的具体字段
10.9 特质中的抽象字段
10.10 特质构造顺序
10.11 初始化特质中的字段
10.12 扩展类的特质
10.13 自身类型 [L2]
10.14 背后发生了什么
练习
11 操作符 [L1]
11.1 标识符
11.2 中置操作符
11.3 一元操作符
11.4 赋值操作符
11.5 优先级
11.6 结合性
11.7 apply和update方法
11.8 提取器 [L2]
11.9 带单个参数或无参数的提取器 [L2]
11.10 unapplySeq方法
练习
12 高阶函数 [L1]
12.1 作为值的函数
12.2 匿名函数
12.3 带函数参数的函数
12.4 参数（类型）推断
12.5 一些有用的高阶函数
12.6 闭包
12.7 SAM转换
12.8 柯里化
12.9 控制抽象
12.10 return表达式
练习
13 集合 [A2]
13.1 主要的集合特质
13.2 可变和不可变集合
13.3 序列
13.4 列表
13.5 可变列表
13.6 集
13.7 用于添加或去除元素的操作符
13.8 常用方法
13.9 将函数映射到集合
13.10 化简、折叠和扫描 [A3]
13.11 拉链操作
13.12 迭代器
13.13 流 [A3]
13.14 懒视图
13.15 与Java集合的互操作
13.16 线程安全的集合
13.17 并行集合
练习
14 模式匹配和样例类 [A2]
14.1 更好的switch
14.2 守卫
14.3 模式中的变量
14.4 类型模式
14.5 匹配数组、列表和元组
14.6 提取器
14.7 变量声明中的模式
14.8 for表达式中的模式
14.9 样例类
14.10 copy方法和带名参数
14.11 case语句中的中置表示法
14.12 匹配嵌套结构
14.13 样例类是邪恶的吗？
14.14 密封类
14.15 模拟枚举
14.16 Option类型
14.17 偏函数 [L2]
练习
15 注解 [A2]
15.1 什么是注解？
15.2 什么可以被注解？
15.3 注解参数
15.4 注解实现
15.5 针对Java特性的注解
15.5.1 Java修饰符
15.5.2 标记接口
15.5.3 受检异常
15.5.4 变长参数
15.5.5 JavaBeans
15.6 用于优化的注解
15.6.1 尾递归
15.6.2 跳转表的生成和内联
15.6.3 可省略方法
15.6.4 基本类型的特殊化
15.7 用于错误和警告的注解
练习
16 XML处理 [A2]
16.1 XML字面量
16.2 XML节点
16.3 元素属性
16.4 内嵌表达式
16.5 在属性中使用表达式
16.6 特殊节点类型
16.7 类XPath表达式
16.8 模式匹配
16.9 修改元素和属性
16.10 XML变换
16.11 加载和保存
16.12 命名空间
练习
17 类型参数 [L2]
17.1 泛型类
17.2 泛型函数
17.3 类型变量界定
17.4 视图界定
17.5 上下文界定
17.6 Manifest上下文界定
17.7 多重界定
17.8 类型约束 [L3]
17.9 型变
17.10 协变和逆变点
17.11 对象不能泛型
17.12 类型通配符
练习
18 高级类型 [L2]
18.1 单例类型
18.2 类型投影
18.3 路径
18.4 类型别名
18.5 结构类型
18.6 复合类型
18.7 中置类型
18.8 存在类型
18.9 Scala类型系统
18.10 自身类型
18.11 依赖注入
18.12 抽象类型 [L3]
18.13 家族多态 [L3]
18.14 高等类型 [L3]
练习
19 解析 [A3]
19.1 文法
19.2 连结解析器操作
19.3 解析器结果变换
19.4 丢弃词法单元
19.5 生成解析树
19.6 避免左递归
19.7 更多的连结符
19.8 避免回溯
19.9 记忆式解析器
19.10 解析器说到底是什么？
19.11 正则解析器
19.12 基于词法单元的解析器
19.13 错误处理
练习
20 Actor [A3]
20.1 创建和启动actor
20.2 发送消息
20.3 接收消息
20.4 向其他actor发送消息
20.5 消息通道
20.6 同步消息和Future
20.7 共享线程
20.8 actor的生命周期
20.9 将多个actor链接在一起
20.10 actor的设计
练习
21 隐式转换和隐式参数 [L3]
21.1 隐式转换
21.2 利用隐式转换丰富现有类库的功能
21.3 引入隐式转换
21.4 隐式转换规则
21.5 隐式参数
21.6 利用隐式参数进行隐式转换
21.7 上下文界定
21.8 类型证明
21.9 @implicitNotFound注解
21.10 CanBuildFrom解读
练习
22 定界延续 [L3]
22.1 捕获并执行延续
22.2 “运算当中挖个洞”
22.3 reset和shift的控制流转
22.4 reset表达式的值
22.5 reset和shift表达式的类型
22.6 CPS注解
22.7 将递归访问转化为迭代
22.8 撤销控制反转
22.9 CPS变换
22.10 转换嵌套的控制上下文
练习
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>快学Scala
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白色神话
“后殖民理论经典译丛”总序赵稀方/
前言/1
第一章白色神话/
第二章马克思主义与历史问题/
第三章萨特的挥霍/
第四章历史主义的科学批评/
第五章福柯的幻像/
第六章詹姆逊的袭击/
第七章迷失的东方主义/
第八章巴巴的矛盾心理/
第九章斯皮瓦克：去殖，解构/
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白色神话
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++ 2012入门经典
目    录
第1章  使用Visual C++编程	1
1.1  使用Visual C++学习	1
1.2  编写C++应用程序	2
1.3  学习桌面应用程序的编程	2
1.3.1  学习C++	3
1.3.2  控制台应用程序	3
1.3.3  Windows编程概念	3
1.4  集成开发环境简介	5
1.4.1  编辑器	5
1.4.2  编译器	5
1.4.3  链接器	5
1.4.4  库	6
1.5  使用IDE	6
1.5.1  工具栏选项	7
1.5.2  可停靠的工具栏	8
1.5.3  文档	8
1.5.4  项目和解决方案	8
1.5.5  设置Visual C++的选项	16
1.5.6  创建和执行Windows应用程序	17
1.6  小结	19
1.7  本章主要内容	19
第2章  数据、变量和计算	21
2.1  C++程序结构	21
2.1.1  main()函数	28
2.1.2  程序语句	28
2.1.3  空白	30
2.1.4  语句块	30
2.1.5  自动生成的控制台程序	31
2.2  定义变量	32
2.2.1  命名变量	32
2.2.2  声明变量	33
2.2.3  变量的初始值	34
2.3  基本数据类型	34
2.3.1  整型变量	35
2.3.2  字符数据类型	36
2.3.3  整型修饰符	37
2.3.4  布尔类型	38
2.3.5  浮点类型	38
2.3.6  C++中的基本类型	39
2.3.7  字面值	39
2.3.8  定义数据类型的同义词	40
2.4  基本的输入/输出操作	41
2.4.1  从键盘输入	41
2.4.2  到命令行的输出	41
2.4.3  格式化输出	42
2.4.4  转义序列	43
2.5  C++中的计算	45
2.5.1  赋值语句	45
2.5.2  算术运算	45
2.5.3  计算余数	50
2.5.4  修改变量	50
2.5.5  增量和减量运算符	51
2.5.6  计算的顺序	53
2.6  类型转换和类型强制转换	54
2.6.1  赋值语句中的类型转换	55
2.6.2  显式类型转换	56
2.6.3  老式的类型强制转换	57
2.7  AUTO关键字	57
2.8  类型的确定	58
2.9  按位运算符	58
2.9.1  按位AND运算符	58
2.9.2  按位OR运算符	60
2.9.3  按位EOR运算符	61
2.9.4  按位NOT运算符	61
2.9.5  移位运算符	61
2.10  lvalue和rvalue	63
2.11  了解存储时间和作用域	64
2.11.1  自动变量	64
2.11.2  决定变量声明的位置	66
2.11.3  全局变量	67
2.11.4  静态变量	70
2.12  具有特定值集的变量	70
2.12.1  旧枚举	70
2.12.2  类型安全的枚举	72
2.13  名称空间	74
2.13.1  声明名称空间	75
2.13.2  多个名称空间	76
2.14  小结	77
2.15  练习	77
2.16  本章主要内容	78
第3章  判断和循环	79
3.1  比较数据值	79
3.1.1  if语句	80
3.1.2  嵌套的if语句	81
3.1.3  嵌套的if-else语句	85
3.1.4  逻辑运算符和表达式	87
3.1.5  条件运算符	89
3.1.6  switch语句	91
3.1.7  无条件转移	94
3.2  重复执行语句块	95
3.2.1  循环的概念	95
3.2.2  for循环的变体	97
3.2.3  while循环	104
3.2.4  do-while循环	106
3.2.5  基于范围的循环	107
3.2.6  嵌套的循环	107
3.3  小结	110
3.4  练习	110
3.5  本章主要内容	111
第4章  数组、字符串和指针	113
4.1  处理多个相同类型的数据值	113
4.1.1  数组	113
4.1.2  声明数组	114
4.1.3  初始化数组	117
4.1.4  使用基于范围的for循环	118
4.1.5  字符数组和字符串处理	119
4.1.6  多维数组	122
4.2  间接数据访问	125
4.2.1  指针的概念	125
4.2.2  声明指针	125
4.2.3  使用指针	126
4.2.4  初始化指针	127
4.2.5  sizeof操作符	132
4.2.6  常量指针和指向常量的指针	134
4.2.7  指针和数组	136
4.3  动态内存分配	142
4.3.1  堆的别名——空闲存储器	142
4.3.2  new和delete操作符	142
4.3.3  为数组动态分配内存	143
4.3.4  多维数组的动态分配	146
4.4  使用引用	146
4.4.1  引用的概念	147
4.4.2  声明并初始化lvalue引用	147
4.4.3  在基于范围的for循环中使用
引用	148
4.4.4  rvalue引用	148
4.5  字符串的库函数	149
4.5.1  确定以空字符结尾的字符串
的长度	149
4.5.2  连接以空字符结尾的字符串	150
4.5.3  复制以空字符结尾的字符串	151
4.5.4  比较以空字符结尾的字符串	152
4.5.5  搜索以空字符结尾的字符串	152
4.6  小结	154
4.7  练习	155
4.8  本章主要内容	155
第5章  程序结构(1)	157
5.1  理解函数	157
5.1.1  需要函数的原因	158
5.1.2  函数的结构	158
5.1.3  替代的函数语法	161
5.1.4  使用函数	161
5.2  给函数传递实参	164
5.2.1  按值传递机制	165
5.2.2  给函数传递指针实参	166
5.2.3  给函数传递数组	167
5.2.4  给函数传递引用实参	171
5.2.5  使用const修饰符	173
5.2.6  rvalue引用形参	174
5.2.7  main()函数的实参	176
5.2.8  接受数量不定的函数实参	177
5.3  从函数返回值	179
5.3.1  返回指针	179
5.3.2  返回引用	182
5.3.3  函数中的静态变量	184
5.4  递归函数调用	186
5.5  小结	189
5.6  练习	189
5.7  本章主要内容	189
第6章  程序结构(2)	191
6.1  函数指针	191
6.1.1  声明函数指针	191
6.1.2  函数指针作为实参	194
6.1.3  函数指针的数组	196
6.2  初始化函数形参	196
6.3  异常	198
6.3.1  抛出异常	199
6.3.2  捕获异常	200
6.3.3  重新抛出异常	201
6.3.4  MFC中的异常处理	202
6.4  处理内存分配错误	203
6.5  函数重载	204
6.5.1  函数重载的概念	204
6.5.2  引用类型和重载选择	207
6.5.3  何时重载函数	207
6.6  函数模板	208
6.7  使用decltype操作符	210
6.8  使用函数的示例	212
6.8.1  实现计算器	212
6.8.2  从字符串中删除空格	215
6.8.3  计算表达式的值	216
6.8.4  获得项值	218
6.8.5  分析数	219
6.8.6  整合程序	221
6.8.7  扩展程序	223
6.8.8  提取子字符串	224
6.8.9  运行修改过的程序	226
6.9  小结	227
6.10  练习	227
6.11  本章主要内容	228
第7章  自定义数据类型	229
7.1  C++中的结构	229
7.1.1  结构的概念	230
7.1.2  定义结构	230
7.1.3  初始化结构	230
7.1.4  访问结构的成员	231
7.1.5  伴随结构的智能感知帮助	234
7.1.6  RECT结构	235
7.1.7  使用指针处理结构	236
7.2  数据类型、对象、类和实例	237
7.2.1  类的起源	239
7.2.2  类的操作	239
7.2.3  术语	240
7.3  理解类	240
7.3.1  定义类	240
7.3.2  声明类的对象	241
7.3.3  访问类的数据成员	241
7.3.4  类的成员函数	243
7.3.5  成员函数定义的位置	245
7.3.6  内联函数	245
7.4  类构造函数	246
7.4.1  构造函数的概念	247
7.4.2  默认的构造函数	248
7.4.3  默认的形参值	250
7.4.4  在构造函数中使用初始化列表	252
7.4.5  声明显式的构造函数	253
7.5  类的私有成员	254
7.5.1  访问私有类成员	256
7.5.2  类的友元函数	257
7.5.3  默认复制构造函数	259
7.6  this指针	260
7.7  类的const对象	263
7.7.1  类的const成员函数	263
7.7.2  类外部的成员函数定义	264
7.8  类对象的数组	265
7.9  类的静态成员	267
7.9.1  类的静态数据成员	267
7.9.2  类的静态函数成员	270
7.10  类对象的指针和引用	270
7.10.1  类对象的指针	270
7.10.2  类对象的引用	273
7.11  小结	274
7.12  练习	274
7.13  本章主要内容	275
第8章  深入理解类	277
8.1  类析构函数	277
8.1.1  析构函数的概念	277
8.1.2  默认的析构函数	278
8.1.3  析构函数与动态内存分配	280
8.2  实现复制构造函数	283
8.3  在变量之间共享内存	284
8.3.1  定义联合	285
8.3.2  匿名联合	286
8.3.3  类和结构中的联合	286
8.4  运算符重载	287
8.4.1  实现重载的运算符	287
8.4.2  实现对比较运算符的完全支持	290
8.4.3  重载赋值运算符	294
8.4.4  重载加法运算符	299
8.4.5  重载递增和递减运算符	303
8.4.6  重载函数调用操作符	304
8.5  对象复制问题	305
8.5.1  避免不必要的复制操作	305
8.5.2  应用rvalue引用形参	308
8.5.3  命名的对象是lvalue	310
8.6	默认的类成员	314
8.7  类模板	315
8.7.1  定义类模板	316
8.7.2  根据类模板创建对象	318
8.7.3  使用有多个形参的类模板	321
8.7.4  函数对象模板	323
8.8  完美转发	324
8.9  使用类	327
8.9.1  类接口的概念	327
8.9.2  定义问题	327
8.9.3  实现CBox类	328
8.10  组织程序代码	343
8.11  字符串的库类	345
8.11.1  创建字符串对象	345
8.11.2  连接字符串	346
8.11.3  访问与修改字符串	350
8.11.4  比较字符串	353
8.11.5  搜索字符串	356
8.12  小结	364
8.13  练习	364
8.14  本章主要内容	365
第9章  类继承和虚函数	367
9.1  面向对象编程的基本思想	367
9.2  类的继承	368
9.2.1  基类的概念	369
9.2.2  基类的派生类	369
9.3  继承机制下的访问控制	372
9.3.1  派生类中构造函数的操作	375
9.3.2  声明类的保护成员	378
9.3.3  继承类成员的访问级别	380
9.4  派生类中的复制构造函数	382
9.5  禁止派生类	384
9.6  友元类成员	385
9.6.1  友元类	387
9.6.2  对类友元关系的限制	387
9.7  虚函数	387
9.7.1  虚函数的概念	389
9.7.2  确保虚函数的正确执行	391
9.7.3  禁止重写函数	391
9.7.4  使用指向类对象的指针	392
9.7.5  使用引用处理虚函数	393
9.7.6  纯虚函数	395
9.7.7  抽象类	395
9.7.8  间接基类	398
9.7.9  虚析构函数	400
9.8  类类型之间的强制转换	403
9.9  嵌套类	403
9.10  小结	407
9.11  练习	407
9.12  本章主要内容	409
第10章  标准模板库	411
10.1  标准模板库的定义	411
10.1.1  容器	412
10.1.2  容器适配器	414
10.1.3   迭代器	414
10.2  智能指针	415
10.3  算法	418
10.4  STL中的函数对象	418
10.5  STL容器范围	419
10.6  序列容器	419
10.6.1  创建矢量容器	420
10.6.2  矢量容器的容量和大小	423
10.6.3  访问矢量中的元素	428
10.6.4  在矢量中插入和删除元素	428
10.6.5  在矢量中存储类对象	431
10.6.6  排序矢量元素	436
10.6.7  排序矢量中的指针	437
10.6.8  双端队列容器	442
10.6.9  使用列表容器	445
10.6.10  使用forward_list容器	454
10.6.11  使用其他序列容器	456
10.6.12  tuple< >类模板	466
10.7  关联容器	469
10.7.1  使用映射容器	469
10.7.2  使用多重映射容器	480
10.8  关于迭代器的更多内容	481
10.8.1  使用输入流迭代器	481
10.8.2  使用插入迭代器	484
10.8.3  使用输出流迭代器	485
10.9  关于函数对象的更多内容	487
10.10  关于算法的更多内容	488
10.10.1  fill()	489
10.10.2  replace()	489
10.10.3  find()	489
10.10.4  transform()	490
10.11  类型特质和静态断言	491
10.12  λ表达式	492
10.12.1  capture子句	493
10.12.2  捕获特定的变量	494
10.12.3  模板和λ表达式	494
10.12.4  包装λ表达式	498
10.13  小结	500
10.14  练习	500
10.15  本章主要内容	501
第11章  Windows编程的概念	503
11.1  Windows编程基础	503
11.1.1  窗口的元素	504
11.1.2  Windows程序与操作系统	505
11.1.3  事件驱动型程序	505
11.1.4  Windows消息	506
11.1.5  Windows API	506
11.1.6  Windows数据类型	506
11.1.7  Windows程序中的符号	507
11.2  Windows程序的结构	508
11.2.1  WinMain()函数	509
11.2.2  消息处理函数	519
11.3  MFC	524
11.3.1  MFC表示法	524
11.3.2  MFC程序的组织方式	525
11.4  小结	528
11.5  本章主要内容	528
第12章  使用MFC编写Windows程序	531
12.1  MFC的文档/视图概念	531
12.1.1  文档的概念	531
12.1.2  文档界面	532
12.1.3  视图的概念	532
12.1.4  链接文档和视图	533
12.1.5  应用程序和MFC	534
12.2  创建MFC应用程序	535
12.2.1  创建SDI应用程序	536
12.2.2  MFC Application Wizard的输出	539
12.2.3  创建MDI应用程序	548
12.3  小结	549
12.4  练习	550
12.5  本章主要内容0	550
第13章  处理菜单和工具栏	551
13.1  与Windows进行通信	551
13.1.1  了解消息映射	552
13.1.2  消息类别	554
13.1.3  处理程序中的消息	554
13.2  扩展Sketcher程序	555
13.3  菜单的元素	556
13.4  为菜单消息添加处理程序	559
13.4.1  选择处理菜单消息的类	560
13.4.2  创建菜单消息函数	560
13.4.3  编写菜单消息函数的代码	562
13.4.4  添加更新菜单消息的处理
程序	565
13.5  添加工具栏按钮	568
13.5.1  编辑工具栏按钮的属性	569
13.5.2  练习使用工具栏按钮	570
13.5.3  添加工具提示	571
13.6  小结	571
13.7  练习	571
13.8  本章主要内容	571
第14章  在窗口中绘图	573
14.1  窗口绘图的基础知识	573
14.1.1  窗口工作区	573
14.1.2  Windows图形设备界面	574
14.2  MFC的绘图机制	576
14.2.1  应用程序中的视图类	576
14.2.2  CDC类	577
14.3  实际绘制图形	585
14.4  对鼠标进行编程	587
14.4.1  鼠标发出的消息	587
14.4.2  鼠标消息处理程序	588
14.4.3  使用鼠标绘图	590
14.5  绘制草图	611
14.5.1  运行示例	612
14.5.2  捕获鼠标消息	612
14.6  小结	613
14.7  练习题	613
14.8  本章主要内容	614
第15章  改进视图	615
15.1  Sketcher应用程序的缺陷	615
15.2  改进视图	616
15.2.1  更新多个视图	616
15.2.2  滚动视图	617
15.2.3  使用MM_LOENGLISH
映射模式	622
15.3  删除和移动元素	622
15.4  实现上下文菜单	623
15.4.1  关联菜单和类	624
15.4.2  选中上下文菜单项	625
15.5  标识位于光标下的元素	626
15.5.1  练习弹出菜单	627
15.5.2  突出显示元素	627
15.5.3  实现移动和删除功能	631
15.6  处理屏蔽的元素	637
15.7  小结	639
15.8  练习	639
15.9  本章主要内容	639
第16章  使用对话框和控件	641
16.1  理解对话框	641
16.2  理解控件	642
16.3  创建对话框资源	642
16.3.1  给对话框添加控件	643
16.3.2  测试对话框	644
16.4  对话框的编程	644
16.4.1  添加对话框类	644
16.4.2  模态和非模态对话框	645
16.4.3  显示对话框	646
16.5  支持对话框控件	648
16.5.1  初始化对话框控件	648
16.5.2  处理单选按钮消息	649
16.6  完成对话框的操作	650
16.6.1  给文档添加线宽	651
16.6.2  给元素添加线宽	651
16.6.3  在视图中创建元素	653
16.6.4  练习使用对话框	654
16.7  使用微调按钮控件	655
16.7.1  添加Scale菜单项和工具栏
按钮	655
16.7.2  创建微调按钮	655
16.7.3  生成比例对话框类	656
16.7.4  显示微调按钮	659
16.8  使用缩放比例	660
16.8.1  可缩放的映射模式	660
16.8.2  设置文档的大小	661
16.8.3  设置映射模式	662
16.8.4  同时实现滚动与缩放	663
16.9  使用状态栏	665
16.9.1  给框架窗口添加状态栏	665
16.9.2  CString类	669
16.10  使用编辑框控件	669
16.10.1  创建编辑框资源	670
16.10.2  创建对话框类	671
16.10.3  添加Text菜单项	672
16.10.4  定义文本元素	672
16.10.5  实现CText类	673
16.11  小结	677
16.12  练习	678
16.13  本章主要内容	678
第17章  存储和打印文档	679
17.1  了解序列化	679
17.2  序列化文档	680
17.2.1  文档类定义中的序列化	680
17.2.2  文档类实现中的序列化	681
17.2.3  基于CObject的类的功能	683
17.2.4  序列化的工作方式	684
17.2.5  如何实现类的序列化	685
17.3  应用序列化	685
17.3.1  记录文档修改	686
17.3.2  序列化文档	687
17.3.3  序列化元素类	689
17.4  练习序列化	693
17.5  打印文档	694
17.6  实现多页打印	697
17.6.1  获取文档的总尺寸	698
17.6.2  存储打印数据	698
17.6.3  准备打印	699
17.6.4  打印后的清除	700
17.6.5  准备设备上下文	701
17.6.6  打印文档	701
17.6.7  获得文档的打印输出	705
17.7  小结	705
17.8  练习	705
17.9  本章主要内容	706
第18章  编写Windows 8应用程序	707
18.1  理解Windows 8应用程序	707
18.2	开发WINDOWS 8应用程序	708
18.3  Windows Runtime的概念	709
18.3.1  WinRT名称空间	709
18.3.2  WinRT对象	709
18.4  C++ COMPONENT EXTENSIONS
(C++/CX)	710
18.4.1  C++/CX名称空间	710
18.4.2  定义WinRT类类型	711
18.4.3  Ref类类型的变量	713
18.4.4  访问ref类对象的成员	713
18.4.5  事件处理函数	714
18.4.6	转换ref类引用的类型	714
18.5  XAML	714
18.5.1  XAML元素	715
18.5.2  XAML中的UI元素	716
18.5.3  附加属性	719
18.5.4  父元素和子元素	719
18.5.5  控件元素	719
18.5.6	布局元素	720
18.5.7  处理UI元素的事件	720
18.6  创建Windows 8应用程序	721
18.6.1  应用程序文件	721
18.6.2  定义用户界面	722
18.6.3  创建标题	724
18.6.4  添加游戏控件	726
18.6.5  创建包含纸牌的网格	727
18.6.6  实现游戏的操作	732
18.6.7  初始化MainPage对象	735
18.6.8  初始化一副纸牌	736
18.6.9  建立cardGrid的子元素	736
18.6.10  初始化游戏	738
18.6.11  洗牌	740
18.6.12  突出显示UI纸牌	741
18.6.13	处理翻牌事件	741
18.6.14  处理图形事件	743
18.6.15  确认赢家	745
18.6.16  处理游戏控件的按钮事件	746
18.7  缩放UI元素	747
18.8  平移	749
18.8.1  应用程序的启动动画	749
18.8.2  故事板动画	750
18.9  小结	752
18.10  本章主要内容	752
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++ 2012入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>聆听智者
序言/1
一月/1
二月/33
三月/63
四月/95
五月/129
六月/163
七月/195
八月/229
九月/261
十月/295
十一月/329
十二月/363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>聆听智者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>单页Web应用
第一部分　单页应用简介
第1章　第一个单页应用　3
1．1　定义、一些历史和一些关注点　4
1．1．1　一些历史　4
1．1．2　是什么导致JavaScript单页应用姗姗来迟　5
1．1．3　我们的关注点　8
1．2　构建第一个单页应用　9
1．2．1　定义目标　9
1．2．2　创建文件结构　10
1．2．3　使用Chrome开发者工具　10
1．2．4　开发HTML和CSS　11
1．2．5　添加JavaScript　12
1．2．6　使用Chrome开发者工具查看应用　17
1．3　精心编写的单页应用的用户效益　19
1．4　小结　20
第2章　温故JavaScript　22
2．1　变量作用域　24
2．2　变量提升　27
2．3　高级变量提升和执行环境对象　28
2．3．1　提升　28
2．3．2　执行环境和执行环境对象　30
2．4　作用域链　33
2．5　JavaScript对象和原型链　35
2．6　函数——更深入的窥探　43
2．6．1　函数和匿名函数　43
2．6．2　自执行匿名函数　44
2．6．3　模块模式——将私有变量引入JavaScript　46
2．6．4　闭包　51
2．7　小结　54
第二部分　单页应用客户端
第3章　开发Shell　57
3．1　深刻理解Shell　57
3．2　创建文件和名字空间　59
3．2．1　创建文件结构　59
3．2．2　编写应用的HTML文件　60
3．2．3　创建CSS根名字空间　61
3．2．4　创建JavaScript根名字空间　62
3．3　创建功能容器　64
3．3．1　选取策略　64
3．3．2　编写Shell的HTML　64
3．3．3　编写Shell的CSS　65
3．4　渲染功能容器　68
3．4．1　将HTML转换为JavaScript　68
3．4．2　在JavaScript中添加HTML模板　69
3．4．3　编写Shell的样式表　71
3．4．4　指示应用使用Shell　73
3．5　管理功能容器　74
3．5．1　编写展开或收起聊天滑块的方法　74
3．5．2　给聊天滑块添加点击事件处理程序　76
3．6　管理应用状态　80
3．6．1　理解浏览器用户所期望的行为　80
3．6．2　选取一个策略来管理历史控件　81
3．6．3　当发生历史事件时，更改锚　82
3．6．4　使用锚来驱动应用状态　83
3．7　小结　89
第4章　添加功能模块　90
4．1　功能模块策略　91
4．1．1　与第三方模块的比较　91
4．1．2　功能模块和分形MVC模式　93
4．2　创建功能模块文件　96
4．2．1　规划文件结构　96
4．2．2　填写文件　97
4．2．3　我们创建了什么　103
4．3　设计方法API　103
4．3．1　锚接口模式　104
4．3．2　Chat的配置API　105
4．3．3　Chat的初始化API　106
4．3．4　Chat的setSliderPosition API　107
4．3．5　配置和初始化的级联　107
4．4　实现功能API　109
4．4．1　样式表　110
4．4．2　修改Chat　114
4．4．3　清理Shell　120
4．4．4　详细解释执行的过程　125
4．5　添加经常使用的方法　127
4．5．1　removeSlider方法　127
4．5．2　handleResize方法　129
4．6　小结　133
第5章　构建Model　134
5．1　理解Model　135
5．1．1　我们将要构建什么　135
5．1．2　Model做什么　137
5．1．3　Model不做什么　137
5．2　创建Model和其他文件　138
5．2．1　规划文件结构　138
5．2．2　填充文件　139
5．2．3　使用统一的触摸——鼠标库　145
5．3　设计people对象　145
5．3．1　设计person对象　146
5．3．2　设计people对象的API　147
5．3．3　给people对象的API编写文档　150
5．4　构建people对象　151
5．4．1　创建伪造的人员列表　152
5．4．2　开始构建people对象　154
5．4．3　完成people对象的构建　157
5．4．4　测试people对象的API　164
5．5　在Shell中开启登入和登出的功能　166
5．5．1　设计用户登入的体验　167
5．5．2　更新Shell的JavaScript　167
5．5．3　更新Shell的样式表　169
5．5．4　使用UI测试登入和登出　170
5．6　小结　171
第6章　完成Model和Data模块　172
6．1　设计chat对象　172
6．1．1　设计方法和事件　173
6．1．2　给chat对象的API添加文档　175
6．2　构建chat对象　177
6．2．1　先创建chat对象的join方法　177
6．2．2　更新Fake以响应chat．join　179
6．2．3　测试chat．join方法　181
6．2．4　给chat对象添加消息传输功能　182
6．2．5　更新Fake，模拟消息传输功能　187
6．2．6　测试chat的消息传输功能　189
6．3　给Model添加Avatar功能　190
6．3．1　给chat对象添加Avatar功能　190
6．3．2　修改Fake来模拟头像功能　191
6．3．3　测试头像功能　192
6．3．4　测试驱动开发　193
6．4　完成Chat功能模块　195
6．4．1　更新Chat的JavaScript　196
6．4．2　更新样式表　203
6．4．3　测试Chat UI　207
6．5　创建Avatar功能模块　208
6．5．1　创建Avatar的JavaScript　209
6．5．2　创建Avatar的样式表　213
6．5．3　更新Shell和浏览文档　214
6．5．4　测试Avatar功能模块　215
6．6　数据绑定和jQuery　216
6．7　创建Data模块　217
6．8　小结　220
第三部分　单页应用服务器
第7章　Web服务器　223
7．1　服务器的作用　223
7．1．1　认证和授权　224
7．1．2　验证　224
7．1．3　数据的保存和同步　225
7．2　Node．js　225
7．2．1　为什么选择Node．js　225
7．2．2　使用Node．js创建‘Hello World’应用　226
7．2．3　安装并使用Connect　229
7．2．4　添加Connect中间件　230
7．2．5　安装并使用Express　231
7．2．6　添加Express中间件　234
7．2．7　Express的使用环境　235
7．2．8　Express的静态文件服务　236
7．3　高级路由　237
7．3．1　用户对象的CRUD路由　237
7．3．2　通用CRUD路由　243
7．3．3　把路由放到单独的Node．js模块里面　246
7．4　添加认证和授权　249
7．5　Web socket和Socket．IO　251
7．5．1　简单的Socket．IO应用程序　251
7．5．2　Socket．IO和消息服务器　254
7．5．3　使用Socket．IO更新JavaScript　255
7．6　小结　258
第8章　服务器数据库　259
8．1　数据库的作用　259
8．1．1　选择数据存储　260
8．1．2　消除数据转换　260
8．1．3　把逻辑放在需要的地方　261
8．2　MongoDB简介　262
8．2．1　面向文档的存储　262
8．2．2　动态文档结构　262
8．2．3　开始使用MongoDB　263
8．3　使用MongoDB驱动程序　264
8．3．1　准备项目文件　265
8．3．2　安装并连接MongoDB　265
8．3．3　使用MongoDB的CRUD方法　267
8．3．4　向服务器应用添加CRUD操作　270
8．4　验证客户端数据　274
8．4．1　验证对象类型　274
8．4．2　验证对象　276
8．5　创建单独的CRUD模块　283
8．5．1　组织文件结构　284
8．5．2　把CRUD移到它自己的模块里面　287
8．6　构建chat模块　292
8．6．1　开始创建chat模块　293
8．6．2　创建adduser消息处理程序　295
8．6．3　创建updatechat消息处理程序　299
8．6．4　创建disconnect消息处理程序　301
8．6．5　创建updateavatar消息处理程序　302
8．7　小结　305
第9章　单页应用发布准备　306
9．1　单页应用针对搜索引擎的优化　307
9．2　云和第三方服务　310
9．2．1　站点分析　310
9．2．2　记录客户端错误　312
9．2．3　内容分发网络　314
9．3　缓存和缓存破坏　314
9．3．1　缓存时机　315
9．3．2　Web存储　316
9．3．3　HTTP缓存　317
9．3．4　服务器缓存　320
9．3．5　数据库查询缓存　325
9．4　小结　326
附录A　JavaScript编码标准　328
附录B　测试单页应用　361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>单页Web应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领导力21法则
推荐序 / 1
致谢 / 3
引言 / 4
1. 盖子法则 / 11
领导力决定一个人的办事效力
迪克和莫里斯兄弟距离他们的美国梦只有一步之遥，但最终却未能实现。相反，一个叫雷的人却借助两兄弟创办的麦当劳获得了巨大成功。这一切只因为两兄弟不了解盖子法则。
2. 影响力法则 / 22
衡量领导力的真正尺度是影响力亚伯拉罕•林肯最初的级别是上尉，而到战争结束，他却成了一名二等兵。这是怎么回事？因为他成了影响力法则的受害者。
3. 过程法则 / 36
领导力的提升是日积月累的结果，而非一日之功
西奥多•罗斯福创造了一个世界超级大国，赢得了诺贝尔和平奖，并且当上了美国总统。然而，如果他当初不懂得过程法则的话，那么直到今天你可能都没听过他的名字。
4. 导航法则 / 50
谁都可以掌舵，唯有领导者才能设定航线
斯科特领着一队冒险家，带着一个自动防故障罗盘，到达了世界尽头——也走向了不光彩的死亡之路。如果他懂得导航法则的道理，他们原本可以活下来。
5. 增值法则 / 63
领导者为他人提升价值
在折叠式小桌上办公，自己接电话，一有空就去看望小时工，被华尔街指责为对员工太仁慈——哪一个《财富》500强的CEO会这么做呢？就是那个明白增值法则的领导者。
6. 根基法则 / 77
信任是领导力的根基所在
如果罗伯特•麦克纳马拉当初懂得根基法则，那么越南战争——以及因此而在国内发生的一系列事件——也许就会有不同的结局了。
7. 尊重法则 / 90
人们通常愿意追随比自己强的领导者
各方面的迹象都表明她成功的几率很小，但是成千上万的人都称她为自己的领袖。为什么呢？因为他们无法摆脱尊重法则的巨大影响。
8. 直觉法则 / 106
领导者善用领导直觉评估每件事情
史蒂夫•乔布斯为什么能够不断地创新苹果电脑，使之更上一个台阶呢？从直觉法则中可以找到答案。
9. 吸引力法则 / 124
你只能吸引和你相似的人
人员不足、装备落后的南部邦联军队为什么能与强大的联邦军队作如此长时间的抵抗？因为南部邦联军队有着更为优秀的将军。为什么他们有更好的将军？吸引力法则将为你揭晓谜底。
10. 亲和力法则 / 134
领导者深知，得人之前必先得其心
作为一个新领导，约翰深知，组织里最有影响的那个人可能会破坏自己的威信。那么他该怎么做呢？他采取了亲和力法则。
11. 核心圈法则 / 149
一个领导者的潜力，由最接近他的人决定
兰斯•阿姆斯特朗被誉为有史以来最伟大的自行车手。人们称赞他坚忍不拔的意志，赞扬他严酷训练的毅力，却忽略了核心圈法则。
12. 授权法则 / 164
有安全感的领导者才会授权予人
亨利•福特改革了汽车工业，被誉为美国商业界的偶像式人物。那么，是什么原因使他犯了一个重大错误，以至于他的儿子担心福特汽车公司会倒闭呢？因为他成了授权法则的受害者。
13. 镜像法则 / 178
看到别人怎么做，大家也会怎么做
E连在阿登战役中挫败了德国军队的进攻，粉碎了希特勒阻止协约国军队前进的阴谋。他们之所以能够成功，是因为他们的领导者遵从了镜像法则。
14. 接纳法则 / 192
人们先接纳领导者，然后接纳他描绘的愿景
他们通过消极反抗解放了自己的国家，虽然几千人因此牺牲了性命。是什么激励他们这么做？是接纳法则。
15. 制胜法则 / 203
领导者为他的团队找出一条制胜之路
是什么将英国从闪电战中救出？是什么打破了南非的种族隔离？又是什么使芝加哥公牛队赢得多次美国职业篮球联盟（NBA）冠军？这三个问题的答案只有一个。那就是，他们的领导者遵循了制胜法则。
16. 动势法则 / 217
动势是领导者最好的朋友
杰米•埃斯卡兰被称为美国最优秀的教师。但他的教学能力只是其中部分原因，他和加菲尔德高中的成功皆得益于动势法则。
17. 优先次序法则 / 233
领导者明白，忙碌不一定等于成效
他们叫他奇才。他对自己的重要任务烂熟于心，如果你说出一个日期和具体时间，他都能准确地告诉你他的运动员在做什么正因如此，他拿到了十次锦标赛冠军。那么，优先法则对你来说有什么用呢？
18. 舍得法则 / 245
领导者必须先“舍”后“得”
为了你的追随者，你会放弃什么？这个领导者放弃了自己的生命。为什么？因为他明白舍得法则的强大力量。
19. 时机法则 / 259
掌握时机与善用策略同样重要
无论是市长、省长、部长还是总统，各级领导都丢下了自己的责任。当一个领导者违反了时机法则，潜在的危机就会爆发——他们中却没有人认识到这个道理。
20. 爆炸性倍增法则 / 271
培养追随者，得到相加的效果； 培养领导者，得到倍增的效果
要在全球培训100多万人，有没有这个可能呢？如果你用领导者的数学，就有可能实现。秘诀就是爆炸性倍增法则。
21. 传承法则 / 284
一个领导者的长久价值由其继承者决定
人们会在你的葬礼上说些什么？今天你如何用好传承法则将决定他们明天说些什么。
结语 兴衰成败皆系于领导力 / 294
领导力21法则自测题 / 296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领导力21法则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
前言
第一部分　语言篇
第1章　基本语言要素 / 2
建议1：正确操作字符串 / 2
建议2：使用默认转型方法 / 6
建议3：区别对待强制转型与as和is / 9
建议4：TryParse比Parse好 / 12
建议5：使用int?来确保值类型也可以为null / 15
建议6：区别readonly和const的使用方法 / 16
建议7：将0值作为枚举的默认值 / 19
建议8：避免给枚举类型的元素提供显式的值 / 20
建议9：习惯重载运算符 / 22
建议10：创建对象时需要考虑是否实现比较器 / 23
建议11：区别对待==和Equals / 27
建议12：重写Equals时也要重写GetHashCode / 29
建议13：为类型输出格式化字符串 / 32
建议14：正确实现浅拷贝和深拷贝 / 36
建议15：使用dynamic来简化反射实现 / 40
第2章　集合和LINQ / 43
建议16：元素数量可变的情况下不应使用数组 / 43
建议17：多数情况下使用foreach进行循环遍历 / 45
建议18：foreach不能代替for / 51
建议19：使用更有效的对象和集合初始化 / 53
建议20：使用泛型集合代替非泛型集合 / 54
建议21：选择正确的集合 / 57
建议22：确保集合的线程安全 / 61
建议23：避免将List<T>作为自定义集合类的基类 / 64
建议24：迭代器应该是只读的 / 67
建议25：谨慎集合属性的可写操作 / 68
建议26：使用匿名类型存储LINQ查询结果 / 70
建议27：在查询中使用Lambda表达式 / 73
建议28：理解延迟求值和主动求值之间的区别 / 75
建议29：区别LINQ查询中的IEnumerable<T>和IQueryable<T> / 78
建议30：使用LINQ取代集合中的比较器和迭代器 / 80
建议31：在LINQ查询中避免不必要的迭代 / 83
第3章　泛型、委托和事件 / 86
建议32：总是优先考虑泛型 / 86
建议33：避免在泛型类型中声明静态成员 / 88
建议34：为泛型参数设定约束 / 90
建议35：使用default为泛型类型变量指定初始值 / 92
建议36：使用FCL中的委托声明 / 94
建议37：使用Lambda表达式代替方法和匿名方法 / 96
建议38：小心闭包中的陷阱 / 99
建议39：了解委托的实质 / 103
建议40：使用event关键字为委托施加保护 / 106
建议41：实现标准的事件模型 / 108
建议42：使用泛型参数兼容泛型接口的不可变性 / 109
建议43：让接口中的泛型参数支持协变 / 111
建议44：理解委托中的协变 / 112
建议45：为泛型类型参数指定逆变 / 114
第4章　资源管理和序列化 / 116
建议46：显式释放资源需继承接口IDisposable / 116
建议47：即使提供了显式释放方法，也应该在终结器中提供隐式清理 / 119
建议48：Dispose方法应允许被多次调用 / 120
建议49：在Dispose模式中应提取一个受保护的虚方法 / 121
建议50：在Dispose模式中应区别对待托管资源和非托管资源 / 123
建议51：具有可释放字段的类型或拥有本机资源的类型应该是可释放的 / 124
建议52：及时释放资源 / 125
建议53：必要时应将不再使用的对象引用赋值为null / 127
建议54：为无用字段标注不可序列化 / 131
建议55：利用定制特性减少可序列化的字段 / 136
建议56：使用继承ISerializable接口更灵活地控制序列化过程 / 137
建议57：实现ISerializable的子类型应负责父类的序列化 / 140
第5章　异常与自定义异常 / 144
建议58：用抛出异常代替返回错误代码 / 144
建议59：不要在不恰当的场合下引发异常 / 147
建议60：重新引发异常时使用Inner Exception  / 150
建议61：避免在finally内撰写无效代码 / 151
建议62：避免嵌套异常 / 157
建议63：避免“吃掉”异常 / 160
建议64：为循环增加Tester-Doer模式而不是将try-catch置于循环内 / 161
建议65：总是处理未捕获的异常 / 162
建议66：正确捕获多线程中的异常 / 166
建议67：慎用自定义异常 / 168
建议68：从System.Exception或其他常见的基本异常中派生异常 / 170
建议69：应使用finally避免资源泄漏 / 172
建议70：避免在调用栈较低的位置记录异常 / 175
第6章　异步、多线程、任务和并行 / 177
建议71：区分异步和多线程应用场景 / 177
建议72：在线程同步中使用信号量 / 180
建议73：避免锁定不恰当的同步对象 / 184
建议74：警惕线程的IsBackground / 188
建议75：警惕线程不会立即启动 / 189
建议76：警惕线程的优先级 / 191
建议77：正确停止线程 / 193
建议78：应避免线程数量过多 / 194
建议79：使用ThreadPool或BackgroundWorker代替Thread / 196
建议80：用Task代替ThreadPool / 198
建议81：使用Parallel简化同步状态下Task的使用 / 202
建议82：Parallel简化但不等同于Task默认行为 / 204
建议83：小心Parallel中的陷阱 / 205
建议84：使用PLINQ / 208
建议85：Task中的异常处理 / 209
建议86：Parallel中的异常处理 / 214
建议87：区分WPF和WinForm的线程模型 / 216
建议88：并行并不总是速度更快 / 220
建议89：在并行方法体中谨慎使用锁 / 222
第二部分　架构篇
第7章　成员设计 / 226
建议90：不要为抽象类提供公开的构造方法 / 226
建议91：可见字段应该重构为属性 / 226
建议92：谨慎将数组或集合作为属性 / 227
建议93：构造方法应初始化主要属性和字段 / 228
建议94：区别对待override和new / 229
建议95：避免在构造方法中调用虚成员 / 235
建议96：成员应优先考虑公开基类型或接口 / 236
建议97：优先考虑将基类型或接口作为参数传递 / 237
建议98：用params减少重复参数 / 237
建议99：重写时不应使用子类参数 / 238
建议100：静态方法和实例方法没有区别 / 239
建议101：使用扩展方法，向现有类型“添加”方法 / 240
第8章　类型设计 / 243
建议102：区分接口和抽象类的应用场合 / 243
建议103：区分组合和继承的应用场合 / 245
建议104：用多态代替条件语句 / 248
建议105：使用私有构造函数强化单例 / 251
建议106：为静态类添加静态构造函数 / 253
建议107：区分静态类和单例 / 255
建议108：将类型标识为sealed / 255
建议109：谨慎使用嵌套类 / 256
建议110：用类来代替enum / 257
建议111：避免双向耦合 / 260
建议112：将现实世界中的对象抽象为类，将可复用对象圈起来就是命名空间 / 262
第9章　安全性设计 / 264
建议113：声明变量前考虑最大值 / 264
建议114：MD5不再安全 / 265
建议115：通过HASH来验证文件是否被篡改 / 268
建议116：避免用非对称算法加密文件 / 269
建议117：使用SSL确保通信中的数据安全 / 273
建议118：使用SecureString保存密钥等机密字符串 / 284
建议119：不要使用自己的加密算法 / 289
建议120：为程序集指定强名称 / 289
建议121：为应用程序设定运行权限 / 291
第三部分　编码规范及习惯
第10章　命名规范 / 296
建议122：以<Company>.<Component>为命名空间命名 / 296
建议123：程序集不必与命名空间同名 / 296
建议124：考虑在命名空间中使用复数 / 297
建议125：避免用FCL的类型名称命名自己的类型 /  / 297
建议126：用名词和名词组给类型命名 / 298
建议127：用形容词组给接口命名 / 299
建议128：考虑让派生类的名字以基类名字作为后缀 / 300
建议129：泛型类型参数要以T作为前缀 / 300
建议130：以复数命名枚举类型，以单数命名枚举元素 / 301
建议131：用PascalCasing命名公开元素 / 302
建议132：考虑用类名作为属性名 / 302
建议133：用camelCasing命名私有字段和局部变量  / 303
建议134：有条件地使用前缀  / 304
建议135： 考虑使用肯定性的短语命名布尔属性 / 305
建议136：优先使用后缀表示已有类型的新版本 / 306
建议137：委托和事件类型应添加上级后缀 / 307
建议138：事件和委托变量使用动词或形容词短语命名 / 308
建议139：事件处理器命名采用组合方式 / 309
第11章　代码整洁 / 311
建议140：使用默认的访问修饰符 / 311
建议141：不知道该不该用大括号时，就用 / 312
建议142：总是提供有意义的命名 / 314
建议143：方法抽象级别应在同一层次 / 315
建议144：一个方法只做一件事 / 316
建议145：避免过长的方法和过长的类 / 317
建议146：只对外公布必要的操作 / 318
建议147：重构多个相关属性为一个类 / 319
建议148：不重复代码 / 320
建议149：使用表驱动法避免过长的if和switch分支 / 321
建议150：使用匿名方法、Lambda表达式代替方法 / 324
建议151：使用事件访问器替换公开的事件成员变量  / 325
建议152：最少，甚至是不要注释 / 326
建议153：若抛出异常，则必须要注释 / 326
第12章　规范开发行为 / 327
建议154：不要过度设计，在敏捷中体会重构的乐趣 / 327
建议155：随生产代码一起提交单元测试代码 / 336
建议156：利用特性为应用程序提供多个版本 / 342
建议157：从写第一个界面开始，就进行自动化测试  / 344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言点滴
目　录
第1章　程序猿 && 程序媛　1
1.1　装备篇　1
1.1.1　衣着　1
1.1.2　键盘和鼠标　2
1.1.3　电脑　4
1.2　程序猿和互联网　6
1.2.1　搜索引擎　6
1.2.2　通信　9
1.2.3　社交　12
1.2.4　论坛与博客　14
1.2.5　夺宝奇兵　17
1.2.6　互联网精神　19
1.3　熬夜指南　20
1.4　程序=数据结构+算法　22
1.4.1　数据结构　23
1.4.2　算法　24
1.5　内功修炼　28
1.5.1　数学　28
1.5.2　软件工程　31
第2章　编程基础知识　33
2.1　编程语言　33
2.1.1　C语言的昨天　34
2.1.2　C语言的今天　35
2.2　如何学好C语言　38
2.3　开发平台　40
2.4　开发工具　42
2.4.1　集成开发工具　42
2.4.2　文档生成工具　45
2.4.3　版本控制工具　47
2.4.4　推荐开发流程　49
2.5　编程风格　50
2.5.1　变量名　51
2.5.2　缩进和大括号匹配　52
2.5.3　函数的长度和分布　53
2.5.4　编程字体　54
2.5.5　风格和重构　55
第3章　数据类型　58
3.1　原码、反码和补码的解释　58
3.2　整型数的溢出　62
3.3　溢出深入分析　64
3.3.1　溢出的定义　64
3.3.2　溢出的边界　65
3.3.3　溢出的危害　66
3.3.4　避免溢出的方法　66
3.4　无符号数　67
3.5　int和char的关系　70
3.5.1　char就是short short　70
3.5.2　char的符号　71
3.6　浮点数的有效位　72
3.7　判断两个浮点数相等　75
3.8　常量与常量后缀　76
3.9　sizeof运算符　77
3.9.1　sizeof返回值　77
3.9.2　sizeof的用处　77
3.9.3　sizeof(指针)和sizeof(数组)的区别　78
3.10　本章小结　79
第4章　表达式和运算符　81
4.1　自增(减)运算符　81
4.2　左值和右值　83
4.3　布尔值　84
4.4　数据类型转换　85
4.5　写表达式的注意事项　88
4.5.1　用括号来确定运算优先级　88
4.5.2　避免运算顺序问题　89
4.6　有趣的模运算%　90
4.6.1　模运算的基本知识和用法　90
4.6.2　模运算和哈希(Hash)结构　91
4.7　位运算　94
4.8　本章小结　96
第5章　输入输出　97
5.1　流　97
5.2　stdin、stdout、stderr　99
5.3　单个字符输入输出　100
5.3.1　字符输入输出函数　101
5.3.2　getch函数　103
5.4　字符串输入输出　104
5.5　格式化输入输出　105
5.5.1　scanf函数的基本知识　105
5.5.2　scanf函数的输入特点　107
5.5.3　scanf函数处理字符、数字和字符串　109
5.5.4　scanf函数注意事项　111
5.5.5　scanf函数总结　114
5.5.6　格式化输出printf函数　116
5.5.7　选择合适的格式控制符　117
5.6　输入规则全真七子　118
5.7　字符串的安全输入方法　119
5.8　本章小结　121
第6章　控制结构　122
6.1　控制结构常见错误　122
6.2　语句块　124
6.3　for循环　125
6.4　结构化编程及goto语句　127
6.5　假死现象　129
6.6　本章小结　130
第7章　函数、模块和宏定义　132
7.1　预处理指令　132
7.1.1　文件包含　132
7.1.2　条件编译　133
7.1.3　宏替换　134
7.2　main函数　135
7.3　命令行解析　138
7.4　static和const　139
7.5　编译和链接　142
7.6　声明和定义　144
7.7　头文件　145
7.8　头文件的重复包含　147
7.9　多文件项目　150
7.10　C和C++语言混合项目　152
7.11　本章小结　154
第8章　库函数　155
8.1　数学相关　156
8.2　字符串相关　156
8.3　字符和数字相互转换　159
8.4　时间函数　160
8.5　随机数探讨　162
8.6　系统相关函数　165
8.7　库函数使用建议　166
8.8　本章小结　167
第9章　数组　169
9.1　数组的基本知识　169
9.2　数组初始化和数组之间赋值　170
9.3　数组与函数　171
9.4　数组越界　172
9.5　debug和release的区别　173
9.6　二维数组　174
9.6.1　二维数组的定义和初始化　175
9.6.2　二维数组的访问　176
9.7　本章小结　177
第10章　指针　178
10.1　指针的基本知识和定义　179
10.2　指针类型和指针指向的类型　181
10.3　指针定义中常见的错误　183
10.3.1　野指针　183
10.3.2　指针赋值原则　184
10.4　void和NULL　185
10.4.1　void　185
10.4.2　NULL　187
10.5　指针和数组的关系初探　188
10.6　指针与数组关系的再探　192
10.6.1　四个概念的联系　193
10.6.2　指针型指针和指针数组　195
10.6.3　数组指针和二维数组　198
10.7　C语言的内存映像　200
10.8　动态内存分配　202
10.8.1　典型用法　202
10.8.2　malloc函数和calloc函数　203
10.8.3　realloc函数　204
10.8.4　内存释放free　206
10.8.5　内存操作函数　208
10.8.6　内存使用的效率建议　209
10.9　动态数组　210
10.9.1　动态一维数组　210
10.9.2　动态二维数组　211
10.10　字符串　212
10.11　函数和指针　215
10.11.1　用指针类型作为函数形参　215
10.11.2　函数返回指针类型　217
10.12　函数指针　219
10.12.1　函数指针基本知识　219
10.12.2　回调函数　220
10.12.3　函数指针作用的深度思考　222
10.13　复杂声明　227
10.13.1　复杂声明分析　227
10.13.2　返回函数指针的函数　230
10.13.3　复杂声明定义　232
10.13.4　复杂声明用于强制类型转换　233
10.14　本章小结　234
第11章　结构体　236
11.1　自定义数据类型　236
11.2　定义一个结构体变量的三种方法　237
11.3　结构体中的“洞”　239
11.4　结构体的赋值和比较　240
11.5　结构体的读写　242
11.6　函数与结构体　243
11.7　枚举　244
11.8　本章小结　245
第12章　文件　247
12.1　文件基础知识　247
12.1.1　文件指针的解释　247
12.1.2　路径名　248
12.1.3　r+和w+的区别　249
12.2　同时读写　249
12.3　断行标志符　251
12.4　文本格式和二进制格式　254
12.5　文件末尾与feof函数　256
12.5.1　feof函数的基本知识　256
12.5.2　正确使用feof函数　260
12.6　文件读写的错误处理　261
12.7　本章小结　262
第13章　Bug，错误及调试　264
13.1　Bug、错误(error)及异常(exception)　265
13.1.1　三个概念的区别　265
13.1.2　Debug和错误处理　266
13.2　Bug以及Debug　267
13.2.1　Bug的分类　267
13.2.2　bug的避免及发现　269
13.2.3　常见的Debug的工具和方法　274
13.2.4　程序员和bug　276
13.3　C语言中的错误处理机制　278
13.3.1　错误的检测　278
13.3.2　错误的处理方法　280
13.4　面向对象语言中的异常处理机制　281
13.4.1　返回值返回错误的缺点　281
13.4.2　异常处理简介　283
13.4.3　异常处理一般策略　285
13.5　本章小结　287
第14章　进阶之路　289
14.1　程序的效率　289
14.2　C语言的使用原则　291
14.3　加深对C语言的理解　292
14.4　C，C++以及C#(java)　294
14.5　我们现在在哪里？　296
14.6　计算机领域的继续学习　298
参考文献　301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言点滴
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用TCP/IP进行网际互连第二卷
第1章  引言与概述  1.1  TCP/IP协议  1.2  了解细节的必要性  1.3  协议问交互作用的复杂性  1.4  本书采用的方法  1.5  研究代码的重要性  1.6  Xinu操作系统  1.7  本书其余部分的组织  1.8  小结  深入研究第2章  操作系统中的TCP/IP软件结构  2.1  引言  2.2  进程的概念  2.3  进程的优先级  2.4  进程的同步通信  2.5  进程间通信    2.5.1  端口    2.5.2  消息传送  2.6  设备驱动程序和输入、输出程序  2.7  网络的输入和中断  2.8  向高层协议传递分组  2.9  IP协议与传输协议之间的数据报传递    2.9.1  将传人的数据报发送给TCP    2.9.2  将传人的数据报发送给UDP  2.10  向应用程序的传递操作  2.11  输出时的信息流  2.12  从TCP经过IP到网络输出  2.13  UDP输出处理  2.14  小结  深入研究  习题第3章  网络接口层  3.1  引言  3.2  网络接口抽象模型    3.2.1  接口数据结构  3.3  以太网的基本定义    3.3.1  应用中的统计数据  3.4  接口的逻辑状态  3.5  本地主机接口  3.6  缓冲区管理    3.6.1  大缓冲区方案    3.6.2  链表方案(mbuf)    3.6.3  方案举例    3.6.4  有关缓冲区的其他议题  3.7  传人分组的多路分解  3.8  小结  深入研究  习题第4章  地址的发现及绑定(ARP)  4.1  引言  4.2  ARP软件在理论上的结构  4.3  ARP设计方案举例  4.4  ARP高速缓存的数据结构  4.5  ARP输出处理    4.5.1  搜索ARP高速缓存    4.5.2  ARF请求分组的广播    4.5.3  输出过程  4.6  ARP输入处理    4.6.1  向表中增加已转换的表项    4.6.2  发送等待发送的分组    4.6.3  ARP输入过程  4.7  ARP高速缓存的管理    4.7.1  高速缓存表项的分配    4.7.2  高速缓存的定期维护管理    4.7.3  释放队列中的分组  4.8  ARP初始化  4.9  ARP参数配置  4.10  小结  深入研究  习题第5章  IP：软件的总体结构  5.1  引言  ……第6章  IP：选路表和选路算法第7章  IP：分片与重组第8章  IP：差错出理(ICMP)第9章  IP：组播处理(IGMP)第10章  UDP：用户数据报第11章  TCP：数据结构和输入处理第12章  TCP：有限状态机的实现第13章  TCP：输出处理第14章  定时器管理第15章  流量控制和自适应重发第16章  紧急数据处理和推功能第17章  套接层的接口第18章  RIP：主动路由传播和被动获取第19章  OSPF：使用SPF算法的路由传播第20章  SNMP：MIB变量、表示形式和绑定第21章  SNMP：客户与服务器第22章  SNMP：表格访问函数第23章  实现的回顾附录1  过程调用交叉参考表附录2  程序代码中使用到的C数据结构交叉参考表附录3  程序代码中使用到的Xinu函数和常量参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用TCP/IP进行网际互连第二卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>嵌入式系统的微模块化程序设计
第1部分 状态图
第1章 量子编程的快速浏览
第2章 状态图速成
第3章 标准状态机实现
第4章 实现行为继承
第5章 状态模式
第6章 继承状态模型
第2部分 量子框架
第7章 量子框架介绍
第8章 量子框架的设计
第9章 量子框架的实现
第10章 量子框架应用实例
第11章 结束语
附录A C+――用C作面向对象编程
附录B 表示法指南
附录C CD-ROM
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>嵌入式系统的微模块化程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>加勒比没那么远
1.墨西哥
第一章，致我们呼啸而过的青春
第二章，一面湖水
2.古巴
第三章，色色
第四章，长路漫漫
第五章，物物交换
第六章，惠
第七章，那些加勒比的强盗们

3.危地马拉
第八章，穿越国境线
第九章，金毛狮王
第十章，江湖
第十一章，险途莫近
4.哥斯达黎加
第十二章，阿里巴巴
第十三章，苏
第十四章,人猿泰山
第十五章，凤求凰
第十六章，雨林
5.巴拿马
第十七章，到不了的地方叫远方
第十八章，盗亦有道
第十九章，从前有只卢比兔
第二十章，同在异乡为异客
第二十一章，温柔乡
6.哥伦比亚
第二十二章，只爱陌生人
第二十三章，孤岛
第二十四章，棒棒糖
第二十五章，放纵抑或放逐 I
第二十六章，放纵抑或放逐 II
第二十七章，背手张望
7.厄瓜多尔
第二十八章，遇见
第二十九章，遇见说再见
8.附
附I  ，中南美洲诸国签证实录
附II ，中南美洲诸国交通实录
附III，中南美洲诸国吃、住、行、购费用实录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>加勒比没那么远
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学C语言
写给未来的程序员
前言
第一篇　C语言基础
第1章　踏上征程前的思想动员
第2章　跟我写HellocWorld
第3章　分解HellocWorld——最简单C程序的组成
第4章　如何存储和获取数据——变量及数据类型
第5章　用屏幕和键盘交互——简单的输出和输入
第6章　程序的基本构成——运算符和表达式
第7章　程序的最小独立单元——语句
第8章　条件判断——分支结构
第9章　一遍又一遍——循环结构
第二篇　一窥C语言门庭
第10章　写程序就是写函数——函数入门
第11章　同一类型多个元素的集合——简单数组
第12章　C语言难点——指针初探
第13章　字符串及字符串操作
第14章　结构体、共用体、枚举和
第15章　如何节省内存——位运算
第三篇　C语言进阶
第16章　存储不仅仅局限于内存——文件
第17章　灵活却难以理解——指针进阶
第18章　更深入的理解——函数进阶
第19章　生存期、作用域与可见域
第20章　编译及预处理
第21章　数据结构
第四篇　C语言程序设计实例
第22章　C语言程序课程设计：游戏
附录　ASCII编码表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>两种文化
导言
从历史的观点看“两种文化”
斯诺的生平
“两种文化”思想的发展
反应和争论
变化着的学科版图
专业化
变化中的世界与“两种文化”
里德演讲，1959年
两种文化
作为天然卢德派的知识分子
科学革命
富国和穷国
再看两种文化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>两种文化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>LINUX系统编程
序
前言
第一章 介绍与基本概念
系统编程
API与ABI
标准
Linux编程的概念
向系统编程迈进
第二章 文件I／O
打开文件
以read()进行读取操作
以write()进行写入操作
同步化I／O
关闭文件
使用lseek()查找文件位置
针对特定位置的读取与写入
截短文件
多任务式I／O
内核内部
结束语
第三章 缓冲式I／O
用户缓冲式I／O
标准I／O
打开文件
经文件描述符打开流
关闭流
从流中读取
使用缓冲式I／O的简单程序
查找一个流
刷新一个流
错误与EOF
取得相应的文件描述符
控制与缓冲机制
线程安全
标准I／O的缺陷
结束语
第四章 高级文件I／O
分散一聚集I／O
事件轮询接口
将文件映射至内存
对一般文件I／0的用法提供建议
同步化、同步及异步操作
I／O调度程序与I／O性能
结束语
第五章 进程管理
进程ID
运行一个新进程
终止一个进程
等待已终止的子进程
用户与组
会话与进程组
守护进程
结束语
第六章 高级进程管理
进程的调度
让出处理器
进程优先级
实时系统
资源限制
第七章 文件和目录管理
文件与其元数据
目录
链接
文件的复制以及移动
设备节点
带外通信
第八章 内存管理
进程地址空间
分配动态内存
管理数据段
匿名内存映射
高级内存分配
调试内存分配
基于堆栈的分配
选择内存分配机制
操作内存
锁定内存
投机取巧的分配策略
第九章 信号
信号的概念
基本的信号管理
发送一个信号
可重人性
信号集
阻挡信号
高级信号管理
以payload送出信号
结束语
第十章 时间
时间的数据结构
POSIX时钟
取得当前时间
设定当前时间
操作时间
调整系统时钟
休眠与等待
定时器
附录GCC对C语言的扩展
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>LINUX系统编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南
第0章  导读	1
0.1  关于本书	1
0.2  读者对象	1
0.3  本书的术语与风格	2
0.4  本书的结构	3
0.5  如何阅读本书	5
第1章  Boost程序库总论	7
1.1  关于Boost	7
1.1.1  什么是Boost	7
1.1.2  安装Boost	8
1.1.3  使用Boost	8
1.2  关于STLport	9
1.2.1  什么是STLport	9
1.2.2  安装STLport	10
1.2.3  编译STLport	10
1.2.4  使用STLport	10
1.3  开发环境简介	11
1.4  开发环境搭建	12
1.4.1  UNIX开发环境	12
1.4.2  Windows开发环境	13
1.4.3  高级议题	14
1.5  总结	16
第2章  时间与日期	17
2.1  timer库概述	17
2.2  timer	18
2.2.1  用法	18
2.2.2  类摘要	19
2.2.3  使用建议	20
2.3  progress_timer	20
2.3.1  用法	20
2.3.2  类摘要	21
2.3.3  扩展计时精度	22
2.4  progress_display	24
2.4.1  类摘要	24
2.4.2  用法	25
2.4.3  注意事项	26
2.5  date_time库概述	27
2.5.1  编译date_time库	28
2.5.2  date_time库的基本概念	29
2.6  处理日期	29
2.6.1  日期	30
2.6.2  创建日期对象	30
2.6.3  访问日期	32
2.6.4  日期的输出	33
2.6.5  与tm结构的转换	34
2.6.6  日期长度	34
2.6.7  日期运算	35
2.6.8  日期区间	37
2.6.9  日期区间运算	38
2.6.10  日期迭代器	40
2.6.11  其他功能	41
2.6.12  综合运用	41
2.7  处理时间	44
2.7.1  时间长度	44
2.7.2  操作时间长度	45
2.7.3  时间长度的精确度	47
2.7.4  时间点	48
2.7.5  创建时间点对象	49
2.7.6  操作时间点对象	50
2.7.7  与tm、time_t等结构
的转换	51
2.7.8  时间区间	51
2.7.9  时间迭代器	52
2.7.10  综合运用	52
2.8  date_time库的高级议题	56
2.8.1  编译配置宏	56
2.8.2  格式化时间	56
2.8.3  本地时间	57
2.8.4  序列化	59
2.9  总结	59
第3章  内存管理	61
3.1  smart_ptr库概述	61
3.1.1  RAII机制	61
3.1.2  智能指针	62
3.2  scoped_ptr	63
3.2.1  类摘要	63
3.2.2  操作函数	64
3.2.3  用法	65
3.2.4  与auto_ptr的区别	66
3.2.5  与unique_ptr的区别	67
3.3  scoped_array	69
3.3.1  类摘要	69
3.3.2  用法	69
3.3.3  与unique_ptr的区别	70
3.3.4  使用建议	71
3.4  shared_ptr	72
3.4.1  类摘要	72
3.4.2  操作函数	73
3.4.3  用法	75
3.4.4  工厂函数	76
3.4.5  应用于标准容器	77
3.4.6  应用于桥接模式	79
3.4.7  应用于工厂模式	80
3.4.8  定制删除器	81
3.4.9  高级议题	83
3.5  shared_array	84
3.5.1  类摘要	84
3.5.2  用法	84
3.6  weak_ptr	85
3.6.1  类摘要	85
3.6.2  用法	86
3.6.3  获得this的shared_ptr	87
3.6.4  打破循环引用	88
3.7  intrusive_ptr	89
3.8  pool库概述	89
3.9  pool	90
3.9.1  类摘要	90
3.9.2  操作函数	91
3.9.3  用法	91
3.10  object_pool	92
3.10.1  类摘要	92
3.10.2  操作函数	93
3.10.3  用法	93
3.10.4  使用更多的构造参数	94
3.11  singleton_pool	95
3.11.1  类摘要	96
3.11.2  用法	96
3.12  pool_alloc	97
3.13  总结	98
第4章  实用工具	101
4.1  noncopyable	101
4.1.1  原理	102
4.1.2  用法	102
4.1.3  原理	103
4.2  typeof	104
4.2.1  动机	104
4.2.2  用法	106
4.2.3  向typeof库注册自定义类	107
4.2.4  使用建议	108
4.3  optional	108
4.3.1 “无意义”的值	108
4.3.2  类摘要	109
4.3.3  操作函数	109
4.3.4  用法	110
4.3.5  工厂函数	111
4.3.6  高级议题	112
4.4  assign	113
4.4.1  使用操作符+=向容器
增加元素	113
4.4.2  使用操作符()向容器
增加元素	114
4.4.3  初始化容器元素	115
4.4.4  减少重复输入	117
4.4.5  搭配非标准容器工作	118
4.4.6  高级用法	120
4.5  swap	121
4.5.1  原理	121
4.5.2  交换数组	122
4.5.3  特化std::swap	122
4.5.4  特化ADL可找到的swap	123
4.5.5  使用建议	124
4.6  singleton	124
4.6.1  boost.pool的单件实现	125
4.6.2  boost.serialzation的
单件实现	127
4.7  tribool	129
4.7.1  类摘要	129
4.7.2  用法	130
4.7.3  为第三态更名	131
4.7.4  输入/输出	132
4.7.5  与optional<bool>的区别	132
4.8  operators	133
4.8.1  基本运算概念	134
4.8.2  算术操作符的用法	135
4.8.3  基类链	137
4.8.4  复合运算概念	138
4.8.5  相等与等价	140
4.8.6  解引用操作符	141
4.8.7  下标操作符	142
4.8.8  高级议题	143
4.9  exception	144
4.9.1  标准库中的异常	145
4.9.2  类摘要	146
4.9.3  向异常传递信息	147
4.9.4  更进一步的用法	148
4.9.5  包装标准异常	150
4.9.6  使用函数抛出异常	151
4.9.7  获得更多的调试信息	152
4.9.8  高级议题	153
4.10  uuid	155
4.10.1  类摘要	155
4.10.2  用法	156
4.10.3  生成器	158
4.10.4  增强的uuid类	160
4.10.5  与字符串的转换	161
4.10.6  SHA1摘要算法	162
4.11  config	163
4.11.1  BOOST_STRINGIZE	163
4.11.2  BOOST_STATIC_
CONSTANT	164
4.11.3  其他工具	165
4.12  utility	165
4.12.1  BOOST_BINARY	165
4.12.2  BOOST_CURRENT_
FUNCTION	166
4.13  总结	167
第5章  字符串与文本处理	171
5.1  lexical_cast	171
5.1.1  用法	172
5.1.2  异常bad_lexical_cast	173
5.1.3  对转换对象的要求	174
5.1.4  应用于自己的类	174
5.2  format	175
5.2.1  简单的例子	176
5.2.2  输入操作符%	177
5.2.3  类摘要	179
5.2.4  格式化语法	180
5.2.5  format的性能	181
5.2.6  高级用法	181
5.3  string_algo	182
5.3.1  简单的例子	183
5.3.2  string_algo概述	184
5.3.3  大小写转换	185
5.3.4  判断式（算法）	185
5.3.5  判断式（函数对象）	187
5.3.6  分类	188
5.3.7  修剪	189
5.3.8  查找	190
5.3.9  替换与删除	191
5.3.10  分割	193
5.3.11  合并	195
5.3.12  查找（分割）迭代器	196
5.4  tokenizer	197
5.4.1  类摘要	197
5.4.2  用法	198
5.4.3  分词函数对象	199
5.4.4  char_separator	199
5.4.5  escaped_list_separator	201
5.4.6  offset_separator	201
5.4.7  tokenizer库的缺陷	202
5.5  xpressive	204
5.5.1  两种使用方式	204
5.5.2  正则表达式语法简介	205
5.5.3  类摘要	206
5.5.4  匹配	208
5.5.5  查找	211
5.5.6  替换	212
5.5.7  迭代	213
5.5.8  分词	215
5.5.9  与regex的区别	216
5.5.10  高级议题	217
5.6  总结	219
第6章  正确性与测试	221
6.1  assert	221
6.1.1  基本用法	221
6.1.2  禁用断言	222
6.1.3  扩展用法	223
6.1.4  BOOST_ASSERT_MSG	224
6.1.5  BOOST_VERIFY	225
6.2  static_assert	225
6.2.1  定义	226
6.2.2  用法	226
6.2.3  使用建议	228
6.3  test	228
6.3.1  编译test库	228
6.3.2  最小化的测试套件	229
6.3.3  单元测试框架简介	231
6.3.4  测试断言	231
6.3.5  测试用例与套件	232
6.3.6  测试实例	234
6.3.7  测试夹具	235
6.3.8  测试日志	237
6.3.9  运行参数	238
6.3.10  函数执行监视器	239
6.3.11  程序执行监视器	242
6.3.12  高级议题	242
6.4  总结	245
第7章  容器与数据结构	247
7.1  array	247
7.1.1  类摘要	248
7.1.2  操作函数	248
7.1.3  用法	249
7.1.4  能力限制	250
7.1.5  初始化	251
7.1.6  零长度的数组	251
7.1.7  与C++11标准的区别	252
7.1.8  实现ref_array	252
7.1.9  ref_array的用法	254
7.2  dynamic_bitset	254
7.2.1  类摘要	255
7.2.2  创建与赋值	256
7.2.3  容器操作	257
7.2.4  位运算与比较运算	258
7.2.5  访问元素	259
7.2.6  类型转换	260
7.2.7  集合操作	261
7.2.8  综合运用	261
7.3  unordered	263
7.3.1  散列集合简介	263
7.3.2  散列集合的用法	265
7.3.3  散列映射简介	267
7.3.4  散列映射的用法	269
7.3.5  高级议题	271
7.4  bimap	272
7.4.1  类摘要	273
7.4.2  基本用法	273
7.4.3  值的集合类型	275
7.4.4  集合类型的用法	276
7.4.5  使用标签类型	277
7.4.6  使用assign库	279
7.4.7  查找与替换	279
7.4.8  投射	281
7.4.9  高级议题	282
7.5  circular_buffer	283
7.5.1  类摘要	283
7.5.2  用法	284
7.5.3  环形缓冲区	285
7.5.4  空间优化型缓冲区	286
7.6  tuple	287
7.6.1  最简单的tuple:pair	287
7.6.2  类摘要	288
7.6.3  创建与赋值	288
7.6.4  访问元素	290
7.6.5  比较操作	291
7.6.6  输入输出	292
7.6.7  连结变量	293
7.6.8  应用于assign库	293
7.6.9  应用于exception库	294
7.6.10  内部结构	294
7.6.11  使用访问者模式	295
7.6.12  高级议题	297
7.7  any	299
7.7.1  类摘要	299
7.7.2  访问元素	300
7.7.3  用法	301
7.7.4  简化的操作函数	302
7.7.5  保存指针	303
7.7.6  输出	304
7.7.7  应用于容器	306
7.8  variant	306
7.8.1  类摘要	307
7.8.2  访问元素	308
7.8.3  用法	308
7.8.4  访问器	309
7.8.5  与any的区别	312
7.8.6  高级议题	312
7.9  multi_array	314
7.9.1  类摘要	314
7.9.2  用法	316
7.9.3  多维数组生成器	318
7.9.4  改变形状和大小	319
7.9.5  创建子视图	320
7.9.6  适配普通数组	322
7.9.7  高级议题	323
7.10  property_tree	326
7.10.1  类摘要	327
7.10.2  读取配置信息	328
7.10.3  写入配置信息	330
7.10.4  更多用法	331
7.10.5  XML数据格式	332
7.10.6  其他数据格式	333
7.10.7  高级议题	335
7.11  总结	336
第8章  算法	339
8.1  foreach	339
8.1.1  用法	340
8.1.2  详细解说	341
8.1.3  更优雅的名字	342
8.1.4  支持的序列类型	343
8.1.5  一个小问题	344
8.2  minmax	345
8.2.1  用法	345
8.2.2  使用tuples::tie	346
8.3  minmax_element	347
8.3.1  用法	347
8.3.2  其他函数的用法	348
8.4  总结	349
第9章  数学与数字	351
9.1  integer	351
9.1.1  integer_traits	351
9.1.2  标准整数类型	353
9.1.3  整数类型模板类	355
9.2  rational	358
9.2.1  类摘要	358
9.2.2  创建与赋值	359
9.2.3  算术运算与比较运算	360
9.2.4  类型转换	360
9.2.5  输入输出	361
9.2.6  分子与分母	361
9.2.7  与数学函数配合工作	361
9.2.8  异常	361
9.2.9  rational的精度	362
9.2.10  实现无限精度的
整数类型	362
9.2.11  最大公约数和最小
公倍数	367
9.3  crc	367
9.3.1  类摘要	368
9.3.2  预定义的实现类	368
9.3.3  计算CRC	369
9.3.4  CRC函数	370
9.3.5  自定义CRC函数	371
9.4  random	371
9.4.1  伪随机数发生器	372
9.4.2  伪随机数发生器的构造	373
9.4.3  伪随机数发生器的拷贝	374
9.4.4  随机数分布器	375
9.4.5  随机数分布器类摘要	376
9.4.6  随机数分布器用法	379
9.4.7  变量发生器	379
9.4.8  产生随机数据块	381
9.4.9  真随机数发生器	382
9.4.10  实现真随机数发生器	383
9.5  总结	384
第10章  操作系统相关	387
10.1  io_state_savers	387
10.1.1  类摘要	388
10.1.2  用法	388
10.1.3  简化new_progress_timer	390
10.2  system	390
10.2.1  编译system库	391
10.2.2  错误值枚举	391
10.2.3  错误类别	392
10.2.4  错误代码	393
10.2.5  错误异常	395
10.3  cpu_timer	396
10.3.1  编译cpu_timer库	396
10.3.2  时间类型	397
10.3.3  cpu_timer	398
10.3.4  auto_cpu_timer	400
10.3.5  定制输出格式	401
10.4  filesystem	402
10.4.1  编译filesystem库	402
10.4.2  类摘要	403
10.4.3  路径表示	405
10.4.4  可移植的文件名	406
10.4.5  路径处理	407
10.4.6  异常	409
10.4.7  文件状态	410
10.4.8  文件属性	412
10.4.9  文件操作	413
10.4.10  迭代目录	414
10.4.11  实例1：实现查找
文件功能	417
10.4.12  实例2：实现模糊查找
文件功能	418
10.4.13  实例3：实现拷贝
目录功能	420
10.4.14  文件流操作	422
10.5  program_options	422
10.5.1  编译program_options库	423
10.5.2  概述	424
10.5.3  选项值	426
10.5.4  选项描述器	427
10.5.5  选项描述器的用法	428
10.5.6  分析器	430
10.5.7  存储器	432
10.5.8  使用位置选项值	432
10.5.9  分析环境变量	434
10.5.10  分组选项信息	435
10.5.11  高级用法	437
10.6  总结	440
第11章  函数与回调	443
11.1  result_of	443
11.1.1  原理	444
11.1.2  用法	444
11.2  ref	446
11.2.1  类摘要	447
11.2.2  基本用法	447
11.2.3  工厂函数	448
11.2.4  操作包装	449
11.2.5  综合应用	450
11.2.6  为ref增加函数调用功能	451
11.3  bind	453
11.3.1  工作原理	453
11.3.2  绑定普通函数	454
11.3.3  绑定成员函数	455
11.3.4  绑定成员变量	457
11.3.5  绑定函数对象	457
11.3.6  使用ref库	458
11.3.7  高级议题	459
11.4  function	461
11.4.1  类摘要	462
11.4.2  function的声明	462
11.4.3  操作函数	463
11.4.4  比较操作	464
11.4.5  用法	464
11.4.6  使用ref库	465
11.4.7  用于回调	467
11.4.8  与typeof的区别	469
11.5  signals2	469
11.5.1  类摘要	470
11.5.2  操作函数	471
11.5.3  插槽的连接与调用	472
11.5.4  信号的返回值	474
11.5.5  合并器	474
11.5.6  管理信号的连接	476
11.5.7  更灵活的管理信号连接	477
11.5.8  自动连接管理	480
11.5.9  应用于观察者模式	482
11.5.10  高级议题	485
11.6  总结	489
第12章  并发编程	491
12.1  thread	491
12.1.1  编译thread库	492
12.1.2  时间功能	493
12.1.3  互斥量	493
12.1.4  线程对象	496
12.1.5  创建线程	497
12.1.6  操作线程	499
12.1.7  中断线程	500
12.1.8  线程组	504
12.1.9  条件变量	505
12.1.10  共享互斥量	508
12.1.11  future	510
12.1.12  高级议题	513
12.2  asio	518
12.2.1  概述	519
12.2.2  定时器	520
12.2.3  定时器用法	521
12.2.4  网络通信简述	524
12.2.5  IP地址和端点	525
12.2.6  同步socket处理	526
12.2.7  异步socket处理	528
12.2.8  查询网络地址	532
12.2.9  高级议题	533
12.3  总结	537
第13章  编程语言支持	539
13.1  python库概述	539
13.1.1  Python语言简介	540
13.1.2  安装Python环境	541
13.1.3  编译python库	541
13.1.4  使用python库	542
13.2  嵌入Python	543
13.2.1  初始化解释器	543
13.2.2  封装Python对象	544
13.2.3  执行Python语句	546
13.2.4  异常处理	547
13.3  扩展Python	548
13.3.1  最简单的例子	549
13.3.2  导出函数	551
13.3.3  导出重载函数	552
13.3.4  导出类	554
13.3.5  导出类的更多细节	556
13.3.6  高级议题	558
13.4  总结	560
第14章  其他Boost组件	563
14.1  算法	563
14.2  字符串和文本处理	564
14.3  容器与数据结构	565
14.4  迭代器	566
14.5  函数对象与高级编程	566
14.6  泛型编程	568
14.7  模板元编程	569
14.8  预处理元编程	569
14.9  并发编程	570
14.10  数学与数字	570
14.11  TR1实现	571
14.12  输入输出	571
14.13  杂项	572
14.14  总结	574
第15章  Boost与设计模式	575
15.1  创建型模式	575
15.2  结构型模式	577
15.3  行为模式	580
15.4  其他模式	583
15.5  总结	584
第16章  结束语	587
16.1  未臻完美的Boost	587
16.2  让Boost工作得更好	588
16.3  工夫在诗外	590
附录A  推荐书目	593
附录B  C++标准简述	595
附录C  STL简述	597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>狂人C
第1篇 理解程序设计	1
第1章 基础知识	2
1.1 什么是编程	3
1.2 怎样用C语言编程	7
1.3 printf()函数初步	13
1.4 C语言的“字母”和“单词”	14
第2章 数据类型	23
2.1 什么是数据类型	24
2.2 让程序记住计算结果——变量	31
2.3 int类型——总结与补充	35
2.4 对数据类型的进一步讨论	39
2.5 莫名其妙的“整型”	45
2.6 浮点类型	51
2.7 数据类型与算法	57
2.8 算法的特性	61
第3章 运算符、表达式及语句	66
3.1 C的“动词”及“动词”的“宾语”	67
3.2 表达式——C语言的“词组”	67
3.3 谁是谁的谁	71
3.4 右值的类型转换	74
3.5 语句的概念	81
3.6 例题	84
3.7 算法和数据结构初窥	88
3.8 在程序运行时提供数据	90
第4章 选择语句	95
4.1 关系运算	96
4.2 if语句	97
4.3 判等运算	104
4.4 表达复杂的条件	106
4.5 if-else语句	107
4.6 鸡肋——_Bool类型(C99)	109
4.6 鸡肋——_B4.7判断三角形种类	111
4.8 显得很有学问的运算符	117
4.9 大师如是说goto	118
4.10 给程序更多选项——switch语句	119
4.11 程序开发的过程	124
第5章 从循环到穷举	130
5.1 造句：当……就……	131
5.2 do-while语句	138
5.3 for语句	140
5.4 不规则的循环及对循环的修整	150
5.5 循环的嵌套与穷举法	151
第2篇 结构化程序设计与简单的数据结构	161
第6章 最复杂的运算符——“()”	162
6.1 什么是函数	163
6.2 步骤1：函数的声明	163
6.3 步骤2：函数的定义	165
6.4 步骤3：函数的调用	167
6.5 程序的执行过程	168
6.6 例题——为什么使用函数	170
6.7 使用函数小结	171
6.8 函数与结构化程序设计	174
6.9 变量的作用域	181
6.10 递归	182
6.11 对局部变量的进一步修饰	190
6.12 使用库函数	193
6.13 inline关键字(C99)	195
第7章 作为类型说明符和运算符的“[]”	199
7.1 使用数组	200
7.2 深入理解数组	202
7.3 熟练应用一维数组	205
7.4 数组名做实参	209
7.5 多维数组	216
第8章 结构体、共用体与位运算	228
8.1 结构体	229
8.2 C语言中复数类型的历史和现状	237
8.3 共用体union	240
8.4 位运算	242
8.5 “小的变量”——位段	251
第9章 指针	258
9.1 指针是什么	259
9.2 指向数据对象的指针	260
9.3 指针的应用与误用	266
9.4 指针与一维数组	270
9.5 指针的应用(二)	279
9.6 高维数组名	281
9.7 变量长度数组——VLA(C99)	287
9.8 数组类型的字面量(C99)	291
9.9 指针与结构体	292
9.10 指针与函数	294
9.11 指向虚无的指针	298
9.12 参数不确定的函数	299
第10章 字符串、字符数组及指向字符的指针	306
10.1 字符串文字量	307
10.2 字符串的输入与存储	309
10.3 例题	310
10.4 形参说明符“[]”里的修饰符(C99)	316
10.5 常用的字符串函数	317
10.6 main()的参数	320
10.7 体现代码优美的数据类型——枚举类型	323
第3篇 复杂的数据结构、算法及其他话题	328
第11章 复杂的数据类型与算法	329
11.1 2 2 2 2 = 0	330
11.2 复杂数据类型的构造和解读	331
11.3 递归、穷举、回溯、排列	344
11.4 更自由地使用内存	356
11.5 typedef	364
第12章 程序的输入与输出	369
12.1 面向文件的输入与输出	370
12.2 文卷、流、“FILE”及“FILE *”	380
12.3 二进制文卷的读写	384
12.4 定位问题	388
12.5 制作素数表	389
第13章 程序组织与编译预处理	394
13.1 简介	395
13.2 文件包含	396
13.3 Tic-Tac-Toe游戏	397
13.4 重新开始	409
13.5 宏定义与宏替换	416
13.6 使用外部变量	423
13.7 走棋	427
13.8 预处理命令的其他话题	439
第14章 标准库简介	446
14.1 使用标准库的一些常识	447
14.2 对语言的补充	449
14.3 stdio.h	452
14.4 通用函数：stdlib.h	454
14.5 inttypes.h(C99)	460
14.6 string.h	462
14.7 数值计算	462
14.8 错误处理：errno.h	466
14.9 断言与调试：assert.h	468
14.10 非本地跳转setjmp.h	468
14.11 信号处理signal.h	470
14.12 time.h	471
14.13 国际化问题	475
附录	477
附录A C语言的关键字	478
附录B C语言的数据类型	479
附录C ASCII表	480
附录D C语言运算符	481
参考文献	482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>狂人C
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言解析教程(原书第4版)
出版者的话
专家指导委员会
译者序
前言
第1章 编写ASNI C程序
第2章 词法元素、运算符和C系统
第3章 控制流
第4章 函数和结构化编程
第5章 安符处理
第6章 基本数据类型
第7章 枚举类型和typedef
第8章 函数、指针和存储类型
第9章 数组和指针
……
附录A 标准库
附录B 预处理器
……
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言解析教程(原书第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>后殖民主义与世界格局
导言：蒙太奇式的简述
１　属下阶层的知识
２　来自下层与上层的历史与权力
３　空间与土地
４　混杂
５　后殖民女权主义
６　从后殖民的角度解读全球化
７　翻译与转化
索　引
英文原文
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>后殖民主义与世界格局
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言大全
第一部分 C语言基础
第1章 C语言概述
第2章 C表达式
……
第二部分 C99标准
第11章 C99
第三部分 C标准库
第12章 链接、库和头部
第13章 I/O函数
……
第四部分 算法和应用
第21章 排序和查找
第22章 队列、堆栈、链表和树
……
第五部分 C语言软件开发
第26章 构造Windows 2000框架
……
第六部分 C解释程序
第29章 C解释程序
……

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法之美
第1 章 从数据到算法 .................................................................. 1
1.1 数据与数据结构 ..................................................................................... 1
1.1.1 数据及其类型 ................................................................................................. 1
1.1.2 数据结构简介 ................................................................................................. 3
1.2 算法 ......................................................................................................... 5
1.2.1 算法的概念 ..................................................................................................... 5
1.2.2 算法的分析 ..................................................................................................... 8
1.2.3 算法的设计 ................................................................................................... 12
1.3 C++中的STL ........................................................................................ 18
1.3.1 STL 简介 ...................................................................................................... 19
1.3.2 STL 构成 ...................................................................................................... 20
1.3.3 STL 的不同版本 ........................................................................................... 22
本章参考文献 ................................................................................................ 23
第2 章 指针与数组——也谈中国古代兵制 ................................ 24
2.1 指针 ....................................................................................................... 24
2.1.1 内存与地址 ................................................................................................... 24
2.1.2 指针的语法 ................................................................................................... 27
2.1.3 使用指针变量 ............................................................................................... 29
2.1.4 函数与参数传递 ........................................................................................... 31
2.2 数组 ....................................................................................................... 36
2.2.1 结构型数据类型 ........................................................................................... 37
2.2.2 数组定义与初始化 ....................................................................................... 37
2.2.3 数组与指针 ................................................................................................... 41
2.2.4 数组的抽象数据类型 ................................................................................... 45
2.3 数组应用举例 ....................................................................................... 48
2.3.1 Z 字形编排问题 ........................................................................................... 48
2.3.2 大整数乘法问题 ........................................................................................... 51
2.3.3 九宫格问题 ................................................................................................... 52
2.4 动态内存管理 ....................................................................................... 53
2.4.1 关键词new 和delete .................................................................................... 53
2.4.2 避免内存错误 ............................................................................................... 56
本章参考文献 ................................................................................................ 61
第3 章 字符串与模式匹配——梦里寻她千百度 ......................... 62
3.1 基本概念与定义 ................................................................................... 62
3.1.1 C++中的字符串 ............................................................................................ 62
3.1.2 字符串抽象数据类型 ................................................................................... 65
3.2 文本的精确匹配 ................................................................................... 66
3.2.1 BF 算法 ......................................................................................................... 66
3.2.2 MP 算法 ........................................................................................................ 67
3.2.3 KMP 算法 ..................................................................................................... 72
3.2.4 BM 算法 ....................................................................................................... 75
3.2.5 BMH 算法 ..................................................................................................... 81
3.3 文本的模糊匹配 ................................................................................... 83
3.3.1 全局编辑距离 ............................................................................................... 83
3.3.2 局部最佳对准 ............................................................................................... 86
3.3.3 N 元距离模型 ............................................................................................... 87
3.3.4 语音编码模型 ............................................................................................... 88
本章参考文献 ................................................................................................ 89
第4 章 链表——老鹰捉小鸡 ..................................................... 91
4.1 链表的概念 ........................................................................................... 91
4.2 单向链表 ............................................................................................... 92
4.2.1 单向链表的结构 ........................................................................................... 92
4.2.2 单向链表的操作算法 ................................................................................... 94
4.2.3 有序链表的合并算法 ................................................................................. 101
4.3 单向循环链表 ..................................................................................... 102
4.3.1 单向循环链表的结构 ................................................................................. 102
4.3.2 单向循环链表的实现 ................................................................................. 103
4.3.3 约瑟夫环的问题 ......................................................................................... 107
4.3.4 魔术师发牌问题 ......................................................................................... 108
4.3.5 拉丁方阵的问题 ......................................................................................... 109
4.4 双向循环链表 ...................................................................................... 110
4.4.1 双向循环链表的结构 ................................................................................. 110
4.4.2 双向循环链表的实现 .................................................................................. 111
4.4.3 维吉尼亚加密法问题 ................................................................................. 115
4.5 游标类的设计与实现 .......................................................................... 117
4.5.1 游标类的结构 ............................................................................................. 117
4.5.2 游标类的实现 ............................................................................................. 118
4.6 STL 与链表 ......................................................................................... 122
4.6.1 STL 中链表类的接口 ................................................................................. 122
4.6.2 遍历 ............................................................................................................. 124
4.6.3 元素的插入与删除 ..................................................................................... 125
本章参考文献 .............................................................................................. 126
第5 章 先进先出与后进先出——简单而深刻 .......................... 127
5.1 摞盘子的策略 ..................................................................................... 127
5.1.1 栈的结构 ..................................................................................................... 127
5.1.2 栈的操作及实现 ......................................................................................... 129
5.1.3 括号匹配问题 ............................................................................................. 132
5.1.4 停车场模拟问题 ......................................................................................... 133
5.2 排队的智慧 ......................................................................................... 136
5.2.1 队列的结构 ................................................................................................. 136
5.2.2 队列的操作及实现 ..................................................................................... 138
5.2.3 舞伴问题 ..................................................................................................... 142
5.2.4 杨辉三角问题 ............................................................................................. 143
5.2.5 游程编码问题 ............................................................................................. 145
5.3 优先级队列——兼谈页面置换算法 .................................................. 146
5.3.1 优先级队列的结构 ..................................................................................... 146
5.3.2 优先级队列的实现 ..................................................................................... 149
5.4 STL 中的栈与队列 ............................................................................. 150
5.4.1 STL 中的stack ........................................................................................... 151
5.4.2 STL 中的queue .......................................................................................... 153
5.4.3 STL 中的priority_queue ............................................................................ 155
本章参考文献 .............................................................................................. 158
第6 章 递归——老和尚讲故事 ................................................ 159
6.1 递归的概念 ......................................................................................... 159
6.1.1 定义 ............................................................................................................ 159
6.1.2 应用递归的原则 ......................................................................................... 162
6.1.3 递归和非递归的转化 ................................................................................. 168
6.2 分治法 ................................................................................................. 170
6.2.1 分治法简述 ................................................................................................. 171
6.2.2 汉诺塔问题 ................................................................................................. 172
6.2.3 传染病问题 ................................................................................................. 174
6.3 回溯法 ................................................................................................. 176
6.3.1 回溯法简述 ................................................................................................. 176
6.3.2 迷宫问题 ..................................................................................................... 176
6.3.3 八皇后问题 ................................................................................................. 180
本章参考文献 .............................................................................................. 183
第7 章 树——从红楼梦说起 ................................................... 184
7.1 认识树这种结构 ................................................................................. 184
7.1.1 基本定义 ..................................................................................................... 184
7.1.2 一些术语 ..................................................................................................... 186
7.1.3 树的抽象 ..................................................................................................... 187
7.2 花开二枝分外香——二叉树及相关算法 .......................................... 188
7.2.1 二叉树的定义 ............................................................................................. 188
7.2.2 二叉树的性质 ............................................................................................. 190
7.2.3 二叉树的实现 ............................................................................................. 191
7.2.4 二叉树的遍历算法 ..................................................................................... 196
7.2.5 二叉树线索化算法 ..................................................................................... 200
7.3 合抱之木，生于毫末——从树到森林 .............................................. 203
7.3.1 树的存储表示 ............................................................................................. 203
7.3.2 树的实现 ..................................................................................................... 206
7.3.3 树与森林的遍历算法 ................................................................................. 209
7.3.4 森林与二叉树的转换 .................................................................................. 211
7.4 哈夫曼树——最优二叉树编码算法 .................................................. 213
7.4.1 哈夫曼编码 ................................................................................................. 213
7.4.2 构造哈夫曼树 ............................................................................................. 215
7.4.3 哈夫曼编码的实现 ..................................................................................... 216
7.5 堆 ......................................................................................................... 220
7.5.1 堆的概念 ..................................................................................................... 220
7.5.2 堆的建立 ..................................................................................................... 221
7.5.3 堆的操作 ..................................................................................................... 223
7.6 基于STL 实现树结构 ........................................................................ 224
7.6.1 STL 中的vector .......................................................................................... 224
7.6.2 STL 中的map ............................................................................................. 228
本章参考文献 .............................................................................................. 230
第8 章 图——始于哥尼斯堡的七桥问题 .................................. 231
8.1 图的基本概念 ..................................................................................... 231
8.1.1 图的定义 ..................................................................................................... 231
8.1.2 图的术语 ..................................................................................................... 232
8.1.3 图的运算 ..................................................................................................... 236
8.1.4 图的抽象数据类型 ..................................................................................... 237
8.2 图的存储与表示 ................................................................................. 239
8.2.1 图的邻接矩阵表示 ..................................................................................... 239
8.2.2 图的邻接表表示 ......................................................................................... 241
8.2.3 两种表示法的比较 ..................................................................................... 243
8.3 图的遍历 ............................................................................................. 244
8.3.1 欧拉路径与欧拉回路 ................................................................................. 244
8.3.2 哈密尔顿路径与哈密尔顿回路 ................................................................. 248
8.3.3 广度优先遍历算法 ..................................................................................... 252
8.3.4 深度优先遍历算法 ..................................................................................... 254
8.4 最短路径问题 ..................................................................................... 258
8.4.1 固定起点最短路径问题 ............................................................................. 258
8.4.2 非固定起点最短路径问题 ......................................................................... 264
8.4.3 最短路径的动态规划解法 ......................................................................... 266
8.5 最小生成树 ......................................................................................... 273
8.5.1 最小生成树的定义 ..................................................................................... 273
8.5.2 克鲁斯卡尔算法 ......................................................................................... 275
8.5.3 普里姆算法 ................................................................................................. 279
本章参考文献 .............................................................................................. 283
第9 章 树形搜索结构——做一名出色的园艺师 ....................... 284
9.1 二叉搜索树 ......................................................................................... 284
9.1.1 二叉搜索树的概念 ..................................................................................... 284
9.1.2 二叉搜索树的操作 ..................................................................................... 285
9.1.3 二叉搜索树的实现 ..................................................................................... 288
9.1.4 二叉搜索树的分析 ..................................................................................... 291
9.2 自平衡的二叉搜索树——AVL 树 .................................................... 294
9.2.1 AVL 树的概念 ............................................................................................ 294
9.2.2 AVL 树的旋转 ............................................................................................ 295
9.2.3 AVL 树的实现 ............................................................................................ 299
9.3 树中亦有“红与黑” ......................................................................... 303
9.3.1 红黑树的概念 ............................................................................................. 303
9.3.2 红黑树的操作 ............................................................................................. 306
9.3.3 红黑树的实现 ............................................................................................. 314
9.4 基于Trie 树的单词检索 ..................................................................... 314
9.4.1 Trie 树的概念 ............................................................................................. 315
9.4.2 Trie 树的表示 ............................................................................................. 316
9.4.3 Trie 树的实现 ............................................................................................. 317
本章参考文献 .............................................................................................. 320
第10 章 集合与字典——再言搜索之话题 ............................... 321
10.1 集合论基础 ....................................................................................... 321
10.1.1 集合的概念 ............................................................................................... 321
10.1.2 集合的运算 ............................................................................................... 323
10.2 集合的实现 ....................................................................................... 325
10.2.1 位向量集合 ............................................................................................... 325
10.2.2 单链表集合 ............................................................................................... 330
10.3 字典 ................................................................................................... 337
10.3.1 字典的概念 ............................................................................................... 338
10.3.2 搜索运算 ................................................................................................... 342
10.4 散列 ................................................................................................... 346
10.4.1 散列的概念 ............................................................................................... 347
10.4.2 散列函数 ................................................................................................... 348
10.4.3 字符串散列 ............................................................................................... 351
10.4.4 处理散列冲突 ........................................................................................... 353
10.5 拼写检查问题 ................................................................................... 358
10.6 不相交集 ........................................................................................... 363
10.6.1 不相交集的概念 ....................................................................................... 363
10.6.2 不相交集的实现 ....................................................................................... 366
10.6.3 犯罪团伙的问题 ....................................................................................... 369
10.6.4 路径压缩的实现 ....................................................................................... 370
10.7 STL 中的set ...................................................................................... 371
本章参考文献 .............................................................................................. 374
第11 章 排序——有序让世界更美好 ....................................... 375
11.1 排序问题概述 ................................................................................... 375
11.1.1 基本概念和定义 ....................................................................................... 375
11.1.2 排序算法的分类 ....................................................................................... 376
11.1.3 排序算法的分析 ....................................................................................... 377
11.2 插入排序 ........................................................................................... 378
11.2.1 直接插入排序 ........................................................................................... 378
11.2.2 二分插入排序 ........................................................................................... 380
11.2.3 希尔排序 ................................................................................................... 382
11.3 选择排序 ........................................................................................... 384
11.3.1 直接选择排序 ........................................................................................... 384
11.3.2 堆排序 ....................................................................................................... 386
11.4 交换排序 ........................................................................................... 390
11.4.1 冒泡排序 ................................................................................................... 390
11.4.2 鸡尾酒排序 ............................................................................................... 392
11.4.3 快速排序 ................................................................................................... 395
11.5 归并排序 ........................................................................................... 399
11.6 计数排序 ........................................................................................... 403
本章参考文献 .............................................................................................. 407
附录 经典求职面试题目 .......................................................... 408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C形包围
序　从蓝天俯冲下来的“炮手”/程亚文
第一章 C形包围
2030： 中国面临被肢解的命运——美国世界帝国战略与中国的危机
中国已被“C”字形战略包围
当前国际政治和军事大势： 一个帝王和三大战
美国对中国的暗算
为什么中国不能摆脱下一场战争的劫难？
中国正面临第三次被瓜分的危机
未来十年惨不忍睹： 中国尚未意识到危机的逼近
第二章 窥破玄机
金融危机背后的战略玄机
金融风暴对美国军事和世界的影响
美国有一种“世界大战”幻觉
中、俄： 美“帝”霸权的两大门槛
第三章 冷观“反恐”
丧钟为谁而鸣： 冷观美国反恐战争
论伊拉克战争之持久战
血的四年： 伊拉克战争的证明
短期内美国不敢打伊朗
即将打破苏军纪录： 美国还将在阿富汗挺多久？
2009年： 世界军事主舞台不在中东而在中
第四章 中亚逐鹿
俄格冲突背后的美国大战略
俄格之战暴露出俄军信息化水平不高
2008： 美国全球封堵俄罗斯
2009： 俄罗斯对美国发起战略反攻
俄罗斯军改将震动苏式军事体系国家
俄罗斯加速军事改革的八大启示
第五章 东亚战鼓
日本和F22：猛兽和“猛禽”的致命结合
从大战略看日本的“右转”
日本才是真正的韬光养晦
石原们： “你”为了“谁”而赴死？
牛与狼： 一语说尽千年中日关系的实质
中日隔着琉球，哪有东海争端？
反导： 美国为日本套上的新绞索
第六章 空军上校眼里的中国空军
猎杀“猛禽”： 回击列克星敦研究所关于中国的战争狂想
回望歼八： 中国发展新战机的前车之鉴
中国下一代隐身战斗机应该以什么性能为主？
大飞机： 中国大张旗鼓讨论，日本悄无声息问世
航空工业是现代强国的发动机
8000里外拦截战争： 未来新型中国空军遐想
第七章 空军上校眼里的中国陆军
观摩中国陆军演习
中国新军事变革的突破口在陆军
第八章 空军上校眼里的中国海军
向中国海军编队敬礼
中国新航海时代的序幕
像集群坦克一样冲锋： 中国海军应在领海内展示力量
疾进南沙，经略未来
维护海外利益，需建一流海军
第九章 国策·军策： 中国国家战略定位
中国国家战略定位与军事变革
未来中国国家安全环境判断及相关对策
三重危机是中国发展转型的战略机遇
御敌于国门之外： 2008特大雪灾的战争警示
国防意识是国家发展的强大精神动力
公正是国家强大的起点
附录　反对“军八股”——兼论军事论文的写作
后记甘为中华做鹰犬
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C形包围
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货及其他衍生产品
推荐序一
推荐序二
译者序
前言
作者简介
译者简介
第1章 导言
1.1 交易所市场
1.2 场外市场
1.3 远期合约
1.4 期货合约
1.5 期权合约
1.6 交易员的种类
1.7 对冲者
1.8 投机者
1.9 套利者
1.10 危害
小结
推荐阅读
练习题
作业题
第2章 期货市场的运作机制
2.1 背景知识
2.2 期货合约的规定
2.3 期货价格收敛到即期价格的特性
2.4 保证金的运作
2.5 场外市场
2.6 市场报价
2.7 交割
2.8 交易员类型和交易指令类型
2.9 制度
2.10 会计和税收
2.11 远期与期货合约比较
小结
推荐阅读
练习题
作业题
第3章 利用期货的对冲策略
3.1 基本原理
3.2 拥护与反对对冲的观点
3.3 基差风险
3.4 交叉对冲
3.5 股指期货
3.6 向前滚动对冲
小结
推荐阅读
练习题
作业题
附录3 A资本资产定价模型
第4章 利率
4.1 利率的种类
4.2 利率的计量
4.3 零息利率
4.4 债券定价
4.5 国库券零息利率的确定
4.6 远期利率
4.7 远期利率合约
4.8 久期
4.9 曲率
4.10 利率期限结构理论
……
第5章 远期和期货价格的确定
第6章 利率期货
第7章 互换
第8章 证券化与2007年信用危机
第9章 期权市场机制
第10章 股票期权的性质
第11章 期权交易策略
第12章 二叉树
第13章 维纳过程和伊藤引理
第14章 布莱克-斯科尔斯-默顿模型
第15章 雇员股票期权
第16章 股指期权与货币期权
第17章 期货期权
第18章 希腊值
第19章 波动率微笑
第20章 基本数值方法
第21章 风险价值度
第22章 估计波动率和相关系数
第23章 信用风险
第24章 信用衍生产品
第25章 特种期权
第26章 再论模型和数值算法
第27章 鞅与测度
第28章 利率衍生产品：标准市场模型
第29章 曲率、时间与quanto调整
第30章 利率衍生产品：短期利率模型
第31章 利率衍生产品：hjm与lmm模型
第32章 再谈互换
第33章 能源与商品衍生产品
第34章 实物期权
第35章 重大金融损失与借鉴
附录a derivagem软件
附录b 世界上的主要期权期货交易所
附录c x≤0时n（x）的取值
附录d x≥0时n（x）的取值
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>期权、期货及其他衍生产品
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第1章 绪论
第2章 数组
第3章 链表
第4章 栈和队列
第5章 递归（RECURVE）
第6章 树与森林
第7章 集合与搜索
第8章 图
第9章 排序
第10章 索引结构与散列
附录 实习要求与实习报告
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Windows Sockets网络开发
第1篇  网络开发基础篇  第1章  准备开发环境  第2章  TCP/IP简介  第3章  Windows Sockets基础第2篇  Visual C++网络模式开发篇  第4章  阻塞模式开发  第5章  非阻塞模式开发  第6章  Select模型开发  第7章  WSAAsyncSelect模型开发  第8章  WSAEventSelect模型开发  第9章  重叠I/O模型开发  第10章  完成端口模型开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Windows Sockets网络开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计题解与上机指导
第一部分  《C程序设计》（第二版）习题与参考解答
1 C语言概述
2 程序的灵魂――算法
3 数据类型、运算符与表达式
4 最简单的C程序设计――顺序程序设计
5 选择结构程序设计
6 循环控制
7 数组
8 函数
9 预处理命令
10 指针
11 结构体与共用体
12 位运算
13 文件
第二部分  C语言上机指南
14 Turbo C的上机过程
15 Borland C++使用简介
第三部分 上机实验安排
16 实验指导
17 实验内容
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计题解与上机指导
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用C语言编程
第一部分 基础
第一章 什么是 C？
编程原理
C语言简史
C如何工作
如何学习C
第二章 编程基础
程序从概念到运行
编写一个真正的程序
使用命令行编译器编程
使用集成开发环境（IDE）编程
获取UNIX帮助
获取集成开发环境帮助
集成开发环境菜单
编程练习
第三章 风格
基础编码练习
编码盲从
缩进与编码格式
清晰
简明
小结
第四章 基本定义与表达式
程序要素
程序的基本结构
简单表达式
变量和存储
变量定义
整型
赋值语句
printf函数
浮点型
浮点数与整数的除法运算
字符
答案
编程练习
第五章 数组、修饰符与读取数字
数组
串
读取串
多维数组
读取数字
变量初始化
整型
浮点型
常量说明
十六进制与八进制常量
快捷运算符
副作用
++x或 x++
更多的副作用问题
答案
编程练习
第六章 条件和控制语句
if语句
else语句
怎样避免误用strcmp函数
循环语句
while语句
break语句
continue语句
随处赋值的副作用
答案
编程练习
第七章 程序设计过程
设置
程序规范
代码设计
原型
Makefile
测试
调试
维护
修改
代码分析
注释程序
使用调试器
用文本编辑器测览
增加注释
编程练习
第二部分 简单程序设计
第八章 更多的控制语旬
for语句
SwitCh语句
switch，break和 continue
答案
编程练习
第九章 变量作用域和函数
作用域和类
函数
无参数的函数
结构化程序设计
违归
答案
编程练习
第十章 C预处理器
＃define语句
条件编译
包含文件
带参数的宏
高级特征
小结
答案
编程练习
第十一章 位运算
位运算符
与运算符（＆）
按位或（＼）
按住异或（＾）
非运算符（～）
左移与右移运算符（＜＜，＞＞）
设置、清除和检测位
位图图形
答案
编程练习
第十二章 高级类型
结构
联合
typedef
枚举类型
强制类型转换
位字段或紧缩结构
结构数组

小结
编程练习
第十三章 简单指针
函数自变量指针
常量指针
指针和数组
如何不使用指针
用指针分隔字符串
指针和结构
命令行参数
编程练习
答案
第十四章 文件输入／输出
转换程序
二进制和ASCll码文件
行尾难题
二进制I/O
缓冲问题
非缓冲 I/O
设计文件格式
答案
编程练习
第十五章 调试和优化
调试
交互调试器
调试一个二分查找程序
实时运行错误
公开声明调试方法
优化
答案
编程练习
第十六章 浮点数
浮点数格式
浮点数加法／减法
乘法
除法
上溢和下溢
舍入误差
精度
舍入误差最小化
判定精度
精度和速度
幂级数
编程练习
第三部分 高级编程观念
第十七章 高级指针
指针和结构
free函数
链表
结构指针运算符
顺序链表
双向链表
树
树的打印
程序的剩余部分
象棋程序中用到的数据结构
答案
编程练习
第十八章 模块化编程
模块
公用和专用
extern修饰符
头文件
模块体
使用无限数组的程序
用于多文件的Makefile
使用无限数组
把一项任务分成模块
模块划分实例：文本编辑器
编译器
电子表格
模块设计准则
编程练习
第十九章 旧式编译器
K＆R风格的函数
库的发展
遗漏的特性
Free／Malloc的发展
lint
答案
第二十章 移植问题
模块化
字大小
字节顺序问题
对齐问题
NULL指针问题
文件名问题
文件类型
小结
答案
第二十一章 c内的“角落”
do／while
goto
？：指令
运算符
不稳定限定词
答案
第二十二章 组合到一起
需求
规范说明
代码设计
编码
功能描述
扩展
测试
修改
最后的警告
程序文件
编程练习
第二十三章 程序设计格言
概述
设计
定义
SWitCh语句
预处理器
风格
编译
最后的注解
答案
第四部分 其他语言特性
附录一 ASCll表
附录二 范围和参数传递转换
附录三 运算符优先规则
附录四 使用幂级数计算正弦函数的程序
词汇表

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用C语言编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux环境下C编程指南
第1章　c语言基础和linux系统概述
第2章　vim与emacs编辑器
第3章　gcc编译器
第4章　调试工具gdb
第5章　使用make
第6章　进程控制
第7章　文件操作
第8章　输入输出——基于流的操作
第9章　内存管理
第10章　信号及信号处理
第11章　进程间通信
第12章　网络编程
第13章　底层终端编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux环境下C编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言详解
第0章 计算机科学的职业之路
引言
0.1 为什么选择计算机科学领域
0.1.1 将计算机科学作为专业的理由
0.1.2 计算机科学家的特质
0.2 大学经历：可选的计算机学科和专业
0.2.1 计算机科学
0.2.2 计算机工程
0.2.3 信息系统
0.2.4 信息技术
0.2.5 软件工程
0.2.6 交叉学科
0.3 就业机会
0.3.1 美国和全世界的需求
0.3.2 非代表性群体的需求
0.3.3 新职业持续出现
第1章 计算机与程序设计概述
1.1 电子计算机的过去和现在
1.2 计算机硬件
1.2.1 存储器
1.2.2 中央处理器
1.2.3 输入/输出设备
1.2.4 计算机网络
1.3 计算机软件
1.3.1 操作系统
1.3.2 应用软件
1.3.3 计算机语言
1.3.4 执行程序
1.4 软件开发方法
1.4.1 软件开发方法
1.4.2 注意：失败是编程过程的一部分
1.5 应用软件开发方法
实例研究英里到公里的转换
复习
快速测试
快速测试答案
复习题
第2章 C概述
2.1 C语言要素
2.1.1 预处理指令
2.1.2 预处理指令的语法展示
2.1.3 main函数
2.1.4 保留字
2.1.5 标准标识符
2.1.6 用户定义的标识符
2.1.7 大写字母和小写字母
2.1.8 程序风格之选择标识符名称
2.2 变量声明和数据类型
2.2.1 变量声明
2.2.2 数据类型
2.3 可执行语句
2.3.1 内存中的程序
2.3.2 赋值语句
2.3.3 输入/输出操作和函数
2.3.4 printf函数
2.3.5 scanf函数
2.3.6 return语句
2.4 C程序的一般形式
2.4.1 程序风格之程序中的空格
2.4.2 程序的注释
2.4.3 程序风格之使用注释
2.5 算术表达式
2.5.1 运算符/和%
2.5.2 表达式的数据类型
2.5.3 混合类型赋值语句
2.5.4 强制类型转换
2.5.5 具有多个运算符的表达式
2.5.6 用C语言编写数学公式
实例研究超市硬币处理机
2.6 在程序输出中格式化数值
2.6.1 格式化int型值
2.6.2 格式化double型值
2.6.3 程序风格之消除前导空白
2.7 交互模式、批处理模式和数据文件
2.7.1 输入重定向
2.7.2 程序风格之回显与提示符
2.7.3 输出重定向
2.7.4 程序控制的输入和输出文件
2.8 常见编程错误
2.8.1 语法错误
2.8.2 运行时错误
2.8.3 未检测到的错误
2.8.4 逻辑错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第3章 函数的自顶向下设计
3.1 利用已有信息编程
实例研究求圆的面积和周长
实例研究计算一批垫圈的重量
3.2 库函数
3.2.1 预定义函数和代码复用
3.2.2 使用灰色区分新结构
3.2.3 C库函数
3.2.4 本节目标
3.3 自顶向下设计和结构图
实例研究画简单的图形
3.4 无参函数
3.4.1 函数原型
3.4.2 函数定义
3.4.3 程序中函数的位置
3.4.4 程序风格之在含有函数的程序中使用注释
3.4.5 函数子程序和主函数的执行顺序
3.4.6 使用函数子程序的优点
3.4.7 显示用户指令
3.5 带输入参数的函数
3.5.1 带输入参数的void函数
3.5.2 带输入参数和单一结果的函数
3.5.3 程序风格之函数接口注释
3.5.4 带多个参数的函数
3.5.5 参数表一致性
3.5.6 函数数据区
3.5.7 使用驱动测试函数
3.6 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第4章 选择结构：if语句和switch语句
4.1 控制结构
4.2 条件
4.2.1 关系运算符和判等运算符
4.2.2 逻辑运算符
4.2.3 运算符优先级
4.2.4 短路求值
4.2.5 用C语言表示条件
4.2.6 比较字符
4.2.7 逻辑赋值
4.2.8 条件取反
4.3 if语句
4.3.1 有两个选项的if语句
4.3.2 只有一个选项的if语句
4.3.3 比较一个选项的if语句和两个选项的if语句4.3.4 程序风格之if语句的格式
4.4 具有复合语句的if语句
4.4.1 程序风格之编写具有复合语句的if语句
4.4.2 跟踪if语句
4.5 算法中的决策步骤
实例研究水费问题
4.5.1 程序风格之在函数中使用一致的名称
4.5.2 程序风格之内聚函数
4.5.3 程序风格之使用常量宏来增强可读性和易维护性
4.6 解决更多问题
4.6.1 结构图中的数据流信息
4.6.2 使用函数子程序修改程序
实例研究具有节约需求的水费问题
4.7 嵌套if语句和多选项决策
4.7.1 比较嵌套if和if序列
4.7.2 嵌套if的多选项决策形式
4.7.3 多选项决策中条件的顺序
4.7.4 程序风格之确认变量的值
4.7.5 具有多个变量的嵌套if语句
4.8 switch语句
4.9 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第5章 重复和循环语句
5.1 程序中的重复
5.2 计数循环和while语句
5.3 在循环中计算和或者乘积
5.3.1 程序风格之编写通用循环
5.3.2 计算一列数的乘积
5.3.3 复合赋值运算符
5.4 for语句
5.4.1 程序风格之格式化for语句
5.4.2 自增和自减运算符
5.4.3 步长非1的自增和自减
5.4.4 显示值构成的表格
5.5 条件循环
5.6 循环设计
5.6.1 标记控制循环
5.6.2 使用for语句实现标记循环
5.6.3 文件结束控制循环
5.6.4 错误数据上的无限循环
5.7 嵌套循环
5.8 do-while语句和标志控制循环
5.9 问题求解示例
实例研究太阳能加热房的采暖面积
5.10 如何调试和测试程序
5.10.1 使用调试器程序
5.10.2 不使用调试器进行调试
5.10.3 循环次数差1的错误
5.10.4 测试
5.11 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第6章 模块化编程
6.1 带简单输出参数的函数
6.2 带输入输出参数函数的多次调用
6.3 名字的作用域
6.4 输出形参作为实参变量
6.5 由多个函数构成的程序
实例研究简分数的算术运算
6.6 程序系统的调试与测试
6.7 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第7章 简单数据类型
7.1 数值类型的表示与转换
7.1.1 数值类型的差异
7.1.2 数值的不精确性
7.1.3 数据类型的自动转换
7.1.4 数据类型的显式转换
7.2 字符类型的表示与转换
7.3 枚举类型
7.4 迭代近似
实例研究求根的二分方法
7.5 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第8章 数组
8.1 声明和引用数组
8.2 数组下标
8.3 使用循环顺序存取
8.3.1 使用数组进行统计计算
8.3.2 程序风格之使用循环控制变量作为数组下标
8.4 将数组元素作为函数参数使用
8.5 数组参数
8.5.1 形参数组
8.5.2 和形参数组对应的实参
8.5.3 数组作为输入参数
8.5.4 返回数组结果
8.5.5 部分填充数组
8.5.6 栈
8.6 数组搜索和排序
8.6.1 数组搜索
8.6.2 数组排序
8.7 多维数组
8.7.1 多维数组的初始化
8.7.2 多维数组
8.8 数组处理示例
实例研究医院收入汇总
8.9 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第9章 字符串
9.1 字符串基础
9.1.1 声明并初始化字符串变量
9.1.2 字符串数组
9.1.3 使用printf和scanf进行输入/输出
9.2 字符串库函数：赋值和子串
9.2.1 字符串赋值
9.2.2 子串
9.3 较长的字符串：拼接和整行输入
9.3.1 拼接
9.3.2 字符和字符串的区别
9.3.3 扫描一个完整的行
9.4 字符串比较
9.5 指针数组
9.6 字符操作
9.6.1 字符输入/输出
9.6.2 字符分析和转换
9.7 字符串到数值和数值到字符串的转换.2 90
9.8 字符串处理示例
实例研究文本编辑器
9.9 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第10章 递归
10.1 递归的本质
10.2 跟踪递归函数
10.2.1 带返回值的递归函数的跟踪
10.2.2 void类型递归函数的跟踪
10.2.3 参数与局部变量栈
10.2.4 C中参数栈的实现
10.2.5 何时、如何跟踪递归函数
10.3 递归数学函数
10.4 带数组和字符串参数的递归函数
实例研究找出字符串中的大写字母
实例研究递归选择排序
10.5 用递归解决问题
实例研究集合运算
10.6 递归的经典实例研究：汉诺塔
10.7 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第11章 结构与联合类型
11.1 用户自定义结构类型
11.1.1 结构类型定义
11.1.2 操作结构化数据对象的单个成员
11.1.3 运算符优先级回顾
11.1.4 操作结构整体
11.1.5 程序风格之类型命名约定
11.2 结构类型数据作为输入/输出参数
11.3 返回值为结构类型的函数
11.4 用结构类型解决问题
实例研究 用于复数的用户自定义类型
11.5 并行数组和结构的数组
11.5.1 并行数组
11.5.2 结构数组的声明
实例研究 通用计量转换
11.6 联合类型(可选)
11.7 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第12章 文本文件和二进制文件的处理
12.1 输入/输出文件：回顾与进一步研究
12.1.1 键盘和屏幕作为文本流
12.1.2 换行与EOF
12.1.3 转义序列
12.1.4 用printf实现格式化输出
12.1.5 文件指针变量
12.1.6 获取文件指针参数的函数
12.1.7 关闭文件
12.2 二进制文件
12.3 数据库查询
实例研究数据库查询
12.4 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第13章 大型程序设计
13.1 使用抽象处理复杂问题
13.1.1 过程抽象
13.1.2 数据抽象
13.1.3 信息隐藏
13.1.4 可复用代码
13.2 个人库：头文件
13.2.1 头文件
13.2.2 头文件设计的忠告
13.3 个人库：实现文件
13.4 存储类型
13.4.1 全局变量
13.4.2 static和register存储类型
13.5 库中包含函数的修改
13.6 条件编译
13.7 函数main的参数
13.8 定义带参数的宏
13.8.1 在宏体中使用括号
13.8.2 在两行以上扩展宏
13.9 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第14章 动态数据结构
14.1 指针
14.1.1 作为函数参数的指针
14.1.2 表示数组和字符串的指针
14.1.3 指向结构的指针
14.1.4 指针使用的小结
14.2 动态内存分配
14.2.1 访问动态分配的结构成员
14.2.2 使用calloc动态分配数组
14.2.3 返回堆单元
14.3 链表
14.3.1 带指针成员的结构
14.3.2 连接结点
14.3.3 链表的优点
14.4 链表运算符
14.4.1 遍历链表
14.4.2 获得输入表
14.4.3 在表中查询目标
14.4.4 避免跟踪NULL指针
14.5 用链表表示栈
14.6 用链表表示队列
14.7 有序表
实例研究维护一个整数有序表
14.8 二叉树
14.8.1 二叉查找树
14.8.2 搜索二叉查找树
14.8.3 建立二叉查找树
14.8.4 显示二叉查找树
14.9 常见编程错误
复习
快速测试
快速测试答案
复习题
程序设计项目
第15章 使用进程和线程的多进程
15.1 多任务
15.1.1 线性程序设计和并行程序设计
15.1.2 分时多任务
15.1.3 抢占式多任务
15.1.4 时间片和并行
15.1.5 并发程序设计
15.2 进程
15.2.1 进程创建
15.2.2 进程等待
15.2.3 从进程中执行另一个程序
15.3 进程间通信和管道
15.3.1 管道
15.3.2 管道的用法
15.3.3 使用标准输入的进程间通信
15.3.4 父进程和子进程间通信举例
15.4 线程
15.4.1 线程的创建
15.4.2 线程的同步
15.4.3 互斥锁
15.4.4 死锁
15.5 线程举例
实例研究生产者/消费者模型
15.6 常见编程错误
复习
C语言结构的复习
快速测试
快速测试答案
复习题
程序设计项目
第16章 关于C++
16.1 C++控制结构、输入/输出以及函数
16.1.1 使用名字空间std
16.1.2 C++标准输入/输出
16.1.3 引用参数
16.1.4 输出格式化
16.2 C++对面向对象编程的支持
16.2.1 头文件complexh
16.2.2 类名和构造函数
16.2.3 成员函数和运算符
16.2.4 实现文件complex.cpp
16.2.5 数据成员
16.2.6 输入/输出运算符重载
复习
快速测试
快速测试答案
复习题
程序设计项目
附录A 关于指针的更多信息
附录B ANSIC标准库
附录C C运算符
附录D 字符集
附录E ANSIC保留字
附录F ANSIC结构参照表
词汇表
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WPF 编程宝典
第Ⅰ部分 基础知识
第1章 WPF概述	3
1.1 Windows图形演化	3
1.1.1 DirectX：新的图形引擎	4
1.1.2 硬件加速与WPF	4
1.2 WPF：高级API	4
1.3 分辨率无关性	5
1.3.1 WPF单位	6
1.3.2 系统DPI	7
1.3.3 位图和矢量图形	9
1.4 WPF体系结构	10
1.5 WPF 4.5	13
1.5.1 WPF工具包	14
1.5.2 Visual Studio 2012	14
1.6 小结	16
第2章 XAML	17
2.1 理解XAML	17
2.1.1 WPF之前的图形用户界面	17
2.1.2 XAML变体	19
2.1.3 XAML编译	19
2.2 XAML基础	20
2.2.1 XAML名称空间	21
2.2.2 代码隐藏类	22
2.3 XAML中的属性和事件	24
2.3.1 简单属性与类型转换器	25
2.3.2 复杂属性	26
2.3.3 标记扩展	28
2.3.4 附加属性	29
2.3.5 嵌套元素	30
2.3.6 特殊字符与空白	32
2.3.7 事件	34
2.3.8 完整的Eight Ball Answer示例	35
2.4 使用其他名称空间中的类型	36
2.5 加载和编译XAML	38
2.5.1 只使用代码	38
2.5.2 使用代码和未经编译的XAML	40
2.5.3 使用代码和编译过的XAML	42
2.5.4 只使用XAML	44
2.6 小结	45
第3章 布局	47
3.1 理解WPF中的布局	47
3.1.1 WPF布局原则	47
3.1.2 布局过程	48
3.1.3 布局容器	48
3.2 使用StackPanel面板进行简单布局	50
3.2.1 布局属性	52
3.2.2 对齐方式	52
3.2.3 边距	53
3.2.4 最小尺寸、最大尺寸以及显式地设置尺寸	54
3.2.5 Border控件	56
3.3 WrapPanel和DockPanel面板	57
3.3.1 WrapPanel面板	57
3.3.2 DockPanel面板	58
3.3.3 嵌套布局容器	59
3.4 Grid面板	60
3.4.1 调整行和列	63
3.4.2 布局舍入	64
3.4.3 跨越行和列	65
3.4.4 分割窗口	66
3.4.5 共享尺寸组	69
3.4.6 UniformGrid面板	72
3.5 使用Canvas面板进行基于坐标的布局	72
3.5.1 Z顺序	73
3.5.2 lnkCanvas元素	74
3.6 布局示例	76
3.6.1 列设置	76
3.6.2 动态内容	77
3.6.3 组合式用户界面	79
3.7 小结	80
第4章 依赖项属性	83
4.1 理解依赖项属性	83
4.1.1 定义依赖项属性	84
4.1.2 注册依赖项属性	84
4.1.3 添加属性包装器	86
4.1.4 WPF使用依赖项属性的方式	87
4.1.5 共享的依赖项属性	88
4.1.6 附加的依赖项属性	88
4.2 属性验证	90
4.2.1 验证回调	90
4.2.2 强制回调	91
4.3 小结	93
第5章 路由事件	95
5.1 理解路由事件	95
5.1.1 定义、注册和封装路由事件	95
5.1.2 共享路由事件	96
5.1.3 引发路由事件	96
5.1.4 处理路由事件	97
5.2 事件路由	99
5.2.1 RoutedEventArgs类	100
5.2.2 冒泡路由事件	100
5.2.3 处理挂起的事件	103
5.2.4 附加事件	103
5.2.5 隧道路由事件	105
5.3 WPF事件	106
5.3.1 生命周期事件	106
5.3.2 输入事件	108
5.4 键盘输入	108
5.4.1 处理按键事件	109
5.4.2 焦点	111
5.4.3 获取键盘状态	112
5.5 鼠标输入	113
5.5.1 鼠标单击	115
5.5.2 捕获鼠标	115
5.5.3 鼠标拖放	116
5.6 多点触控输入	118
5.6.1 多点触控的输入层次	119
5.6.2 原始触控	119
5.6.3 操作	122
5.6.4 惯性	124
5.7 小结	125
第Ⅱ部分 进一步研究WPF
第6章 控件	129
6.1 控件类	129
6.1.1 背景画刷和前景画刷	130
6.1.2 字体	132
6.1.3 鼠标光标	136
6.2 内容控件	137
6.2.1 Content属性	138
6.2.2 对齐内容	140
6.2.3 WPF内容原则	141
6.2.4 标签	142
6.2.5 按钮	142
6.2.6 工具提示	145
6.3 特殊容器	151
6.3.1 ScrollViewer	152
6.3.2 GroupBox	154
6.3.3 TabItem	154
6.3.4 Expander	155
6.4 文本控件	158
6.4.1 多行文本	158
6.4.2 选择文本	159
6.4.3 拼写检查	160
6.4.4 PasswordBox	162
6.5 列表控件	162
6.5.1 ListBox	163
6.5.2 ComboBox	166
6.6 基于范围的控件	166
6.6.1 Slider	167
6.6.2 ProgressBar	168
6.7 日期控件	169
6.8 小结	171
第7章 Application类	173
7.1 应用程序的生命周期	173
7.1.1 创建Application对象	173
7.1.2 派生自定义的Application类	174
7.1.3 应用程序的关闭方式	176
7.1.4 应用程序事件	177
7.2 Application类的任务	179
7.2.1 显示初始界面	179
7.2.2 处理命令行参数	180
7.2.3 访问当前Application对象	181
7.2.4 在窗口之间进行交互	182
7.2.5 单实例应用程序	184
7.3 程序集资源	189
7.3.1 添加资源	189
7.3.2 检索资源	190
7.3.3 pack URI	192
7.3.4 内容文件	193
7.4 本地化	193
7.4.1 构建能够本地化的用户界面	194
7.4.2 使应用程序为本地化做好准备	194
7.4.3 管理翻译过程	195
7.5 小结	200
第8章 元素绑定	201
8.1 将元素绑定到一起	201
8.1.1 绑定表达式	202
8.1.2 绑定错误	203
8.1.3 绑定模式	203
8.1.4 使用代码创建绑定	205
8.1.5 使用代码检索绑定	206
8.1.6 多绑定	207
8.1.7 绑定更新	210
8.1.8 绑定延迟	211
8.2 绑定到非元素对象	211
8.2.1 Source属性	212
8.2.2 RelativeSource属性	212
8.2.3 DataContext属性	213
8.3 小结	214
第9章 命令	215
9.1 理解命令	215
9.2 WPF命令模型	216
9.2.1 ICommand接口	217
9.2.2 RoutedCommand类	217
9.2.3 RoutedUICommand类	218
9.2.4 命令库	219
9.3 执行命令	220
9.3.1 命令源	220
9.3.2 命令绑定	221
9.3.3 使用多命令源	223
9.3.4 微调命令文本	224
9.3.5 直接调用命令	224
9.3.6 禁用命令	225
9.3.7 具有内置命令的控件	227
9.4 高级命令	229
9.4.1 自定义命令	229
9.4.2 在不同位置使用相同的命令	230
9.4.3 使用命令参数	232
9.4.4 跟踪和翻转命令	233
9.5 小结	237
第10章 资源	239
10.1 资源基础	239
10.1.1 资源集合	239
10.1.2 资源的层次	241
10.1.3 静态资源和动态资源	242
10.1.4 非共享资源	243
10.1.5 通过代码访问资源	244
10.1.6 应用程序资源	244
10.1.7 系统资源	245
10.2 资源字典	246
10.2.1 创建资源字典	246
10.2.2 使用资源字典	247
10.2.3 在程序集之间共享资源	248
10.3 小结	251
第11章 样式和行为	253
11.1 样式基础	253
11.1.1 创建样式对象	256
11.1.2 设置属性	257
11.1.3 关联事件处理程序	258
11.1.4 多层样式	259
11.1.5 通过类型自动应用样式	261
11.2 触发器	262
11.2.1 简单触发器	262
11.2.2 事件触发器	264
11.3 行为	266
11.3.1 获取行为支持	266
11.3.2 理解行为模型	267
11.3.3 创建行为	268
11.3.4 使用行为	270
11.3.5 Blend中的设计时行为支持	271
11.4 小结	271
第Ⅲ部分 图画和动画
第12章 形状、画刷和变换	275
12.1 理解形状	275
12.1.1 Shape类	276
12.1.2 矩形和椭圆	277
12.1.3 改变形状的尺寸和放置形状	278
12.1.4 使用Viewbox控件缩放形状	280
12.1.5 直线	282
12.1.6 折线	283
12.1.7 多边形	284
12.1.8 直线线帽和直线交点	286
12.1.9 点划线	287
12.1.10 像素对齐	288
12.2 画刷	289
12.2.1 SolidColorBrush画刷	290
12.2.2 LinearGradientBrush画刷	290
12.2.3 RadialGradientBrush画刷	292
12.2.4 ImageBrush画刷	294
12.2.5 平铺的ImageBrush画刷	295
12.2.6 VisualBrush画刷	297
12.2.7 BitmapCacheBrush画刷	298
12.3 变换	299
12.3.1 变换形状	300
12.3.2 变换元素	302
12.4 透明	303
12.4.1 使元素半透明	303
12.4.2 透明掩码	304
12.5 小结	306
第13章 几何图形和图画	307
13.1 路径和几何图形	307
13.1.1 直线、矩形和椭圆图形	308
13.1.2 使用GeometryGroup组合形状	309
13.1.3 使用CombinedGeometry融合几何图形	311
13.1.4 使用PathGeometry绘制曲线和直线	313
13.1.5 微语言几何图形	318
13.1.6 使用几何图形进行剪裁	319
13.2 图画	320
13.2.1 显示图画	322
13.2.2 导出插图	324
13.3 小结	326
第14章 效果和可视化对象	327
14.1 可视化对象	327
14.1.1 绘制可视化对象	328
14.1.2 在元素中封装可视化对象	329
14.1.3 命中测试	332
14.1.4 复杂的命中测试	334
14.2 效果	338
14.2.1 BlurEffect类	338
14.2.2 DropShadowEffect类	339
14.2.3 ShaderEffect类	340
14.3 WriteableBitmap类	342
14.3.1 生成位图	342
14.3.2 写入WriteableBitmap对象	343
14.3.3 更高效的像素写入	345
14.4 小结	347
第15章 动画基础	349
15.1 理解WPF动画	349
15.1.1 基于时间的动画	349
15.1.2 基于属性的动画	350
15.2 基本动画	351
15.2.1 Animation类	351
15.2.2 使用代码创建动画	353
15.2.3 同时发生的动画	358
15.2.4 动画的生命周期	358
15.2.5 Timeline类	359
15.3 故事板	362
15.3.1 故事板	363
15.3.2 事件触发器	363
15.3.3 重叠动画	366
15.3.4 同步的动画	367
15.3.5 控制播放	367
15.3.6 监视动画进度	371
15.4 动画缓动	373
15.4.1 使用缓动函数	373
15.4.2 在动画开始时应用缓动与在动画结束时应用缓动	374
15.4.3 缓动函数类	375
15.4.4 创建自定义缓动函数	377
15.5 动画性能	379
15.5.1 期望的帧率	380
15.5.2 位图缓存	382
15.6 小结	384
第16章 高级动画	385
16.1 动画类型回顾	385
16.1.1 动态变换	386
16.1.2 动态改变画刷	390
16.1.3 动态改变像素着色器	392
16.2 关键帧动画	393
16.2.1 离散的关键帧动画	395
16.2.2 缓动关键帧	395
16.2.3 样条关键帧动画	396
16.3 基于路径的动画	397
16.4 基于帧的动画	399
16.5 使用代码创建故事板	402
16.5.1 创建主窗口	403
16.5.2 创建Bomb用户控件	405
16.5.3 投弹	406
16.5.4 拦截炸弹	409
16.5.5 统计炸弹和清理工作	410
16.6 小结	412
第Ⅳ部分 模板和自定义元素
第17章 控件模板	417
17.1 理解逻辑树和可视化树	417
17.2 理解模板	422
17.2.1 修饰类	424
17.2.2 剖析控件	426
17.3 创建控件模板	428
17.3.1 简单按钮	429
17.3.2 模板绑定	430
17.3.3 改变属性的触发器	431
17.3.4 使用动画的触发器	434
17.4 组织模板资源	435
17.4.1 分解按钮控件模板	436
17.4.2 通过样式应用模板	438
17.4.3 自动应用模板	439
17.4.4 由用户选择的皮肤	440
17.5 构建更复杂的模板	442
17.5.1 嵌套的模板	443
17.5.2 修改滚动条	445
17.5.3 控件模板示例	450
17.6 可视化状态	451
17.7 小结	452
第18章 自定义元素	453
18.1 理解WPF中的自定义元素	454
18.2 构建基本的用户控件	456
18.2.1 定义依赖项属性	456
18.2.2 定义路由事件	459
18.2.3 添加标记	460
18.2.4 使用控件	462
18.2.5 命令支持	462
18.2.6 深入分析用户控件	465
18.3 创建无外观控件	466
18.3.1 修改颜色拾取器的代码	466
18.3.2 修改颜色拾取器的标记	467
18.3.3 精简控件模板	469
18.4 支持可视化状态	472
18.4.1 开始编写FlipPanel类	473
18.4.2 选择部件和状态	475
18.4.3 默认控件模板	476
18.4.4 使用FlipPanel控件	482
18.4.5 使用不同的控件模板	483
18.5 创建自定义面板	485
18.5.1 两步布局过程	485
18.5.2 Canvas面板的副本	488
18.5.3 更好的WrapPanel面板	489
18.6 自定义绘图元素	492
18.6.1 OnRender( )方法	493
18.6.2 评估自定义绘图	494
18.6.3 自定义绘图元素	495
18.6.4 创建自定义装饰元素	497
18.7 小结	498
第Ⅴ部分 数据
第19章 数据绑定	501
19.1 使用自定义对象绑定到数据库	501
19.1.1 构建数据访问组件	502
19.1.2 构建数据对象	504
19.1.3 显示绑定对象	505
19.1.4 更新数据库	508
19.1.5 更改通知	508
19.2 绑定到对象集合	510
19.2.1 显示和编辑集合项	510
19.2.2 插入和移除集合项	513
19.2.3 绑定到ADO.NET对象	514
19.2.4 绑定到LINQ表达式	515
19.3 提高大列表的性能	518
19.3.1 虚拟化	518
19.3.2 项容器再循环	519
19.3.3 缓存长度	519
19.3.4 延迟滚动	520
19.4 验证	521
19.4.1 在数据对象中进行验证	521
19.4.2 自定义验证规则	526
19.4.3 响应验证错误	528
19.4.4 获取错误列表	529
19.4.5 显示不同的错误指示符号	530
19.4.6 验证多个值	533
19.5 数据提供者	535
19.5.1 ObjectDataProvider	536
19.5.2 XmlDataProvider	539
19.6 小结	541
第20章 格式化绑定的数据	543
20.1 数据绑定回顾	543
20.2 数据转换	544
20.2.1 使用StringFormat属性	545
20.2.2 值转换器简介	546
20.2.3 使用值转换器设置字符串的格式	547
20.2.4 使用值转换器创建对象	549
20.2.5 应用条件格式化	551
20.2.6 评估多个属性	552
20.3 列表控件	554
20.4 列表样式	555
20.4.1 ItemContainerStyle	556
20.4.2 包含复选框或单选按钮的ListBox控件	557
20.4.3 交替条目样式	559
20.4.4 样式选择器	561
20.5 数据模板	564
20.5.1 分离和重用模板	566
20.5.2 使用更高级的模板	567
20.5.3 改变模板	569
20.5.4 模板选择器	570
20.5.5 模板与选择	573
20.5.6 改变项的布局	577
20.6 ComboBox控件	578
20.7 小结	581
第21章 数据视图	583
21.1 View对象	583
21.1.1 检索视图对象	584
21.1.2 视图导航	584
21.1.3 以声明方式创建视图	587
21.2 过滤、排序与分组	588
21.2.1 过滤集合	588
21.2.2 过滤DataTable对象	591
21.2.3 排序	592
21.2.4 分组	593
21.2.5 实时成型	598
21.3 小结	599
第22章 列表、树和网格	601
22.1 ListView控件	601
22.1.1 使用GirdView创建列	602
22.1.2 创建自定义视图	606
22.2 TreeView控件	613
22.2.1 创建数据绑定的TreeView控件	614
22.2.2 将DataSet对象绑定到TreeView控件	617
22.2.3 即时创建节点	618
22.3 DataGrid控件	621
22.3.1 改变列的尺寸与重新安排列	622
22.3.2 定义列	623
22.3.3 设置列的格式和样式	628
22.3.4 设置行的格式	629
22.3.5 显示行细节	630
22.3.6 冻结列	631
22.3.7 选择	632
22.3.8 排序	632
22.3.9 编辑	633
22.4 小结	635
第Ⅵ 窗口、页面和富控件
第23章 窗口	639
23.1 Window类	639
23.1.1 显示窗口	641
23.1.2 定位窗口	642
23.1.3 保存和还原窗口位置	642
23.2 窗口交互	644
23.2.1 窗口所有权	646
23.2.2 对话框模型	647
23.2.3 通用对话框	648
23.3 非矩形窗口	649
23.3.1 简单形状窗口	649
23.3.2 具有形状内容的透明窗口	651
23.3.3 移动形状窗口	653
23.3.4 改变形状窗口的尺寸	653
23.3.5 组合到一起：窗口的自定义控件模板	655
23.4 Windows 7任务栏编程	658
23.4.1 使用跳转列表	659
23.4.2 改变任务栏图标和预览	663
23.5 小结	667
第24章 页面和导航	669
24.1 基于页面的导航	669
24.2 基于页面的界面	670
24.2.1 创建一个具有导航窗口的基于页面的简单应用程序	670
24.2.2 Page类	672
24.2.3 超链接	673
24.2.4 在框架中驻留页面	675
24.2.5 在另一个页面中驻留页面	677
24.2.6 在Web浏览器中驻留页面	678
24.3 页面历史	678
24.3.1 深入分析WPF中的URI	678
24.3.2 导航历史	679
24.3.3 维护自定义的属性	681
24.4 导航服务	682
24.4.1 通过编程进行导航	682
24.4.2 导航事件	683
24.4.3 管理日志	684
24.4.4 向日志添加自定义项	685
24.4.5 使用页函数	689
24.5 XAML浏览器应用程序	692
24.5.1 创建XBAP应用程序	692
24.5.2 部署XBAP应用程序	693
24.5.3 更新XBAP应用程序	695
24.5.4 XBAP应用程序的安全性	695
24.5.5 完全信任的XBAP应用程序	696
24.5.6 组合XBAP/独立应用程序	697
24.5.7 为不同的安全级别编写代码	697
24.5.8 在网页中嵌入XBAP应用程序	702
24.6 WebBrowser控件	702
24.6.1 导航到页面	703
24.6.2 构建DOM树	704
24.6.3 使用.NET代码为网页添加脚本	706
24.7 小结	708
第25章 菜单、工具栏和功能区	709
25.1 菜单	709
25.1.1 Menu类	710
25.1.2 菜单项	710
25.1.3 ContextMenu类	712
25.1.4 菜单分隔条	713
25.2 工具栏和状态栏	714
25.2.1 ToolBar控件	714
25.2.2 StatusBar控件	717
25.3 功能区	718
25.3.1 添加功能区	719
25.3.2 应用程序菜单	720
25.3.3 选项卡、组与按钮	722
25.3.4 富工具提示	724
25.3.5 带有快捷键提示的键盘访问	725
25.3.6 改变功能区的大小	726
25.3.7 快速访问工具栏	729
25.4 小结	730
第26章 声音和视频	731
26.1 播放WAV音频	731
26.1.1 SoundPlayer类	731
26.1.2 SoundPlayerAction类	733
26.1.3 系统声音	733
26.2 MediaPlayer类	734
26.3 MediaElement类	735
26.3.1 使用代码播放音频	736
26.3.2 处理错误	737
26.3.3 使用触发器播放音频	737
26.3.4 播放多个声音	739
26.3.5 改变音量、平衡、速度以及位置	740
26.3.6 将动画同步到音频	742
26.3.7 播放视频	744
26.3.8 视频效果	744
26.4 语音	747
26.4.1 语音合成	747
26.4.2 语音识别	749
26.5 小结	751
第27章 3D绘图	753
27.1 3D绘图基础	753
27.1.1 视口	754
27.1.2 3D对象	754
27.1.3 摄像机	761
27.2 深入研究3D绘图	765
27.2.1 着色和法线	766
27.2.2 更复杂的形状	769
27.2.3 Model3DGroup集合	769
27.2.4 使用材质	771
27.2.5 纹理映射	773
27.3 交互和动画	777
27.3.1 变换	777
27.3.2 旋转	778
27.3.3 飞过	779
27.3.4 跟踪球	781
27.3.5 命中测试	782
27.3.6 3D表面上的2D元素	786
27.4 小结	789
第Ⅶ部分 文档和打印
第28章 文档	793
28.1 理解文档	793
28.2 流文档	794
28.2.1 流内容元素	795
28.2.2 设置内容元素的格式	796
28.2.3 创建简单的流文档	797
28.2.4 块元素	799
28.2.5 内联元素	804
28.2.6 通过代码与元素进行交互	809
28.2.7 文本对齐	812
28.3 只读流文档容器	813
28.3.1 缩放	814
28.3.2 创建页面和列	815
28.3.3 从文件加载文档	817
28.3.4 打印	818
28.4 编辑流文档	818
28.4.1 加载文件	819
28.4.2 保存文件	821
28.4.3 设置所选文本的格式	822
28.4.4 获取单个单词	824
28.5 固定文档	825
28.6 批注	826
28.6.1 批注类	827
28.6.2 启用批注服务	828
28.6.3 创建批注	829
28.6.4 检查批注	832
28.6.5 响应批注更改	835
28.6.6 在固定文档中保存批注	835
28.6.7 自定义便签的外观	836
28.7 小结	837
第29章 打印	839
29.1 基本打印	839
29.1.1 打印元素	840
29.1.2 变换打印输出	842
29.1.3 打印不显示的元素	844
29.1.4 打印文档	845
29.1.5 在文档打印输出中控制页面	848
29.2 自定义打印	851
29.2.1 使用可视化层中的类进行打印	851
29.2.2 自定义多页打印	854
29.3 打印设置和管理	859
29.3.1 保存打印设置	859
29.3.2 打印页面范围	859
29.3.3 管理打印队列	860
29.4 通过XPS进行打印	863
29.4.1 为打印预览创建XPS文档	863
29.4.2 写入内存的XPS文档	864
29.4.3 通过XPS直接打印到打印机	865
29.4.4 异步打印	866
29.5 小结	866
第Ⅷ部分 其他主题
第30章 与Windows窗体进行交互	869
30.1 访问互操作性	869
30.2 混合窗口和窗体	870
30.2.1 为WPF应用程序添加窗体	870
30.2.2 为Windows窗体应用程序添加WPF窗口	870
30.2.3 显示模态窗口和窗体	871
30.2.4 显示非模态窗口和窗体	871
30.2.5 启用Windows窗体控件的可视化风格	872
30.3 创建具有混合内容的窗口	872
30.3.1 WPF和Windows窗体“空域”	873
30.3.2 在WPF中驻留Windows窗体控件	874
30.3.3 使用WPF和Windows窗体用户控件	876
30.3.4 在Windows窗体中驻留WPF控件	877
30.3.5 访问键、助记码和焦点	879
30.3.6 属性映射	880
30.4 小结	882
第31章 多线程	883
31.1 了解多线程模型	883
31.1.1 Dispatcher类	884
31.1.2 DispatcherObject类	884
31.2 BackgroundWorker类	887
31.2.1 简单的异步操作	887
31.2.2 创建BackgroundWorker对象	888
31.2.3 运行BackgroundWorker对象	889
31.2.4 跟踪进度	891
31.2.5 支持取消	893
31.3 小结	894
第32章 插件模型	895
32.1 在MAF和MEF两者间进行选择	895
32.2 了解插件管道	896
32.2.1 管道的工作原理	897
32.2.2 插件文件夹结构	898
32.2.3 为使用插件模型准备
解决方案	899
32.3 创建使用插件模型的应用程序	900
32.3.1 协定	901
32.3.2 插件视图	901
32.3.3 插件	902
32.3.4 插件适配器	902
32.3.5 宿主视图	903
32.3.6 宿主适配器	904
32.3.7 宿主	904
32.3.8 更多插件	907
32.4 与宿主进行交互	908
32.5 可视化插件	912
32.6 小结	915
第33章 ClickOnce部署	917
33.1 理解应用程序部署	917
33.1.1 ClickOnce安装模型	918
33.1.2 ClickOnce部署的局限性	919
33.2 简单的ClickOnce发布	920
33.2.1 设置发布者和产品	920
33.2.2 启动发布向导	922
33.2.3 理解部署文件的结构	926
33.2.4 安装ClickOnce应用程序	926
33.2.5 更新ClickOnce应用程序	928
33.3 ClickOnce附加选项	928
33.3.1 发布版本	928
33.3.2 更新	929
33.3.3 文件关联	930
33.3.4 发布选项	931
33.4 小结	932
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WPF 编程宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>银河边缘005：次元壁
【主编会客厅】
美国科幻迷组织简史   1
／［美］迈克·雷斯尼克  著　华 龙  译
【必读经典】
月球孤儿（雨果奖与星云奖提名作品）   15
／［美］克莉丝汀·凯瑟琳·露什  著　艾德琳 童文  译
全损（雨果奖提名作品）   55
／ [美] 凯莉·英格利什  著  艾德琳  译
【特别策划·次元壁】
打破次元壁是一种怎样的体验？   71
／ 范轶伦
雷神遇见美国队长（雨果奖提名作品）   73
／ [美] 大卫·布林  著  罗妍莉  译
巨怪例会之夜   105
／ [美] 布伦南·哈维  著  孙梦天  译
菠菜罐头之子   113
／ [美] 罗伯特·T.杰舍尼克  著  李兴东  译
心中无壁, 方能破壁
——卢恒宇和李姝洁专访   127
／ 范轶伦 李晨旭
【中国新势力】
地穹 ／罗夏    135
万物算法／dhew    185
讨厌猫咪的小松先生／程婧波   197
上帝之手／王元    211
【科学家笔记】
与迪拉克共进晚餐  227
／［美］格里高利·本福德  著　刘博洋  译
【地球档案】
卡桑德拉（雨果奖获奖作品）   233
／［美］C.J.彻里  著　罗妍莉  译
【名家访谈】
《银河边缘》专访大卫·布林   243
／［美］乔伊·沃德  著　许卓然  译
【长篇连载】
唯恐黑暗降临 02   253
／［美］L.斯普拉格·德·坎普  著　华　龙  译
【幻想书房】
《逐影》等四部   309
／刘皖竹 张羿  译
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>银河边缘005：次元壁
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>切今之事
代译序：那些读路易斯的日子（杨伯）
译文说明
骑士品质之必要
论平等
论三种人
我的小学生活
英语是否前景堪忧?
论民主教育
记梦
毕林普恐惧症
大兵贝茨
快乐哲学
要是没了自命清高
现代人及其思想范畴
自行车对话录
生活在核弹时代
空荡荡的宇宙
正经与语文
谈谈牛津剑桥
史学岂是废话
文学中的性
译后记
答谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>切今之事
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Objective-C 2.0
译者序
前言
致谢
第1章　熟悉objective-c 1
第1条：了解objective-c语言的起源 1
第2条：在类的头文件中尽量少引入其他头文件 4
第3条：多用字面量语法，少用与之等价的方法 7
第4条：多用类型常量，少用#define预处理指令 11
第5条：用枚举表示状态、选项、状态码 14
第2章　对象、消息、运行期 21
第6条：理解“属性”这一概念 21
第7条：在对象内部尽量直接访问实例变量 28
第8条：理解“对象等同性”这一概念 30
第9条：以“类族模式”隐藏实现细节 35
第10条：在既有类中使用关联对象存放自定义数据 39
第11条：理解objc_msgsend的作用 42
第12条：理解消息转发机制 46
第13条：用“方法调配技术”调试“黑盒方法” 52
第14条：理解“类对象”的用意 56
.第3章　接口与api设计 60
第15条：用前缀避免命名空间冲突 60
第16条：提供“全能初始化方法” 64
第17条：实现description方法 69
第18条：尽量使用不可变对象 73
第19条：使用清晰而协调的命名方式 78
第20条：为私有方法名加前缀 83
第21条：理解objective-c错误模型 85
第22条：理解nscopying协议 89
第4章　协议与分类 94
第23条：通过委托与数据源协议进行对象间通信 94
第24条：将类的实现代码分散到便于管理的数个分类之中 101
第25条：总是为第三方类的分类名称加前缀 104
第26条：勿在分类中声明属性 106
第27条：使用“class-continuation分类”隐藏实现细节 108
第28条：通过协议提供匿名对象 114
第5章　内存管理 117
第29条：理解引用计数 117
第30条：以arc简化引用计数 122
第31条：在dealloc方法中只释放引用并解除监听 130
第32条：编写“异常安全代码”时留意内存管理问题 132
第33条：以弱引用避免保留环 134
第34条：以“自动释放池块”降低内存峰值 137
第35条：用“僵尸对象”调试内存管理问题 141
第36条：不要使用retaincount 146
第6章　块与大中枢派发 149
第37条：理解“块”这一概念 149
第38条：为常用的块类型创建typedef 154
第39条：用handler块降低代码分散程度 156
第40条：用块引用其所属对象时不要出现保留环 162
第41条：多用派发队列，少用同步锁 165
第42条：多用gcd，少用performselector系列方法 169
第43条：掌握gcd及操作队列的使用时机 173
第44条：通过dispatch group机制，根据系统资源状况来执行任务 175
第45条：使用dispatch_once来执行只需运行一次的线程安全代码 179
第46条：不要使用dispatch_get_current_queue 180
第7章　系统框架 185
第47条：熟悉系统框架 185
第48条：多用块枚举，少用for循环 187
第49条：对自定义其内存管理语义的collection使用无缝桥接 193
第50条：构建缓存时选用nscache而非nsdictionary 197
第51条：精简initialize与load的实现代码 200
第52条：别忘了nstimer会保留其目标对象 205
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Objective-C 2.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计
第一章 C语言概述
第二章 数据类型、运算符与表达式
第三章 最简单的C程序设计
第四章 逻辑运算和判断选取控制
第五章 循环控制
第六章 数组
第七章 函数
第八章 编译预处理
第九章 指针
第十章 结构体与共用体
第十一章 位运算
第十二章 文件
第十三章 常见错误和程序调试
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>财务管理分析
第一部分评估企业财务健康状况
第一章财务报表分析
第一节现金流量循环
第二节资产负债表
一、流动资产与流动负债
二、股东权益
第三节利润表
利润的计量
第四节资金来源与运用表
二指法
第五节现金流量表
第六节财务报表与价值问题
一、市场价值与账面价值
二、经济利润与会计利润
三、应计成本
本章摘要
补充资料
网址
本章习题
第二章财务业绩评价
第一节财务业绩杠杆
第二节股东权益收益率
一、ROE的三项决定因素
二、销售利润率
三、资产周转率
四、财务杠杆
第三节ROE是一个值得信赖的财务尺
度吗
一、时效问题
二、风险问题
三、价值问题
四、ROE与市价
第四节比率分析
一、有效地使用比率
二、森西特公司的比率分析
附录财务结构的国际间差异
一、在美国市场交易的外国公司
比较
二、公众公司
三、趋同于国际会计准则
本章摘要
补充资料
软件
网址
商业比率资料来源
本章习题
第二部分计划未来的财务工作
第三章财务预测
第一节模拟财务报表
一、销售百分比预测法
二、利息费用
三、季节性
第二节模拟财务报表与财务计划
第三节基于计算机的预测
第四节妥善处理不确定性
一、敏感性分析
二、场景分析
三、模拟
第五节现金流量预测
第六节现金预算
第七节预测方法比较
第八节大公司的计划制订
本章摘要
补充资料
软件
网址
本章习题
第四章管理增长
第一节可持续增长
可持续增长方程式
第二节增长太多
一、平衡增长
二、快验保公司的可持续
增长率
三、“倘若……将会怎样”问题
第三节当实际增长超过可持续增长时怎么办
一、发售新股
二、提高财务杠杆
三、削减股利支付比率
四、有益的剥离
五、外包
六、定价
七、合并是否就是答案
第四节增长太少
第五节当可持续增长超过实际增长时怎么办
一、忽略问题
二、把钱还给股东
三、买入增长
四、可持续增长与通货膨胀
第六节可持续增长和模拟预测
第七节新股筹资
一、发售新股
二、为什么美国公司不发行更多的股票
本章摘要
网址
本章习题
第三部分筹资运作
第五章金融工具与市场
第一节金融工具
一、债券
一、普通股
三、优先股
第二节金融市场
一、私募权益筹资
一、首次公开发行
三、增发
四、发行成本
第三节有效市场
一、什么是有效市场
一、有效市场的意义
附录利用金融工具来管理公司风险
一、远期市场
二、货币和资本市场的套期保值
三、期权套期保值
四、金融市场套期保值的局限性
五、期权价值评估
本章摘要
补充资料
网址
本章习题
第六章筹资决策
第一节财务杠杆
第二节衡量杠杆对企业的作用
一、财务杠杆与风险
二、财务杠杆与收益
第三节借贷的限度
一、无关论
二、税收利益
三、财务困境成本
四、财务弹性
五、市场信号传递
六、管理层激励
七、筹资决策与增长
第四节选择到期期限结构
附录无关论定理
一、无税的情况
二、有税的情况
本章摘要
补充资料
网址
本章习题l
第四部分投资机会评估
第七章现金流量贴现技术
第一节价值数字
一、回收期与会计收益率
一、货币的时间价值
三、约当值
四、净现值
五、效益—成本比率
六、内部收益率
七、若干应用和扩展
八、互斥选择和资本限额
九、正确认识IRR
第二节确定相关现金流量
一、折旧'
二、流动资金与自发性资源
三、沉没成本
四、间接成本
五、利润侵蚀
六、生产能力过剩
七、筹资成本
附录互斥选择和资本限额
一、其余万美元究竟怎么了
一、不等长寿命
三、资本限额
四、未来机会问题
五、决策树
本章摘要
补充资料
软件
网址
本章习题
第八章投资决策的风险分析
第一节风险的定义
风险与多样化经营
第二节估计投资风险
估计投资风险的三项技术
第三节包含风险的投资评估
风险调整贴现率
第四节资本成本
一、资本成本的定义
二、森西特技术公司的资本成本
三、投资评估中的资本成本
四、多重目标收益率
第五节利用现金流量贴现技术的四个陷阱
一、企业角度与权益角度
二、通货膨胀
三、实物期权
四、过度风险调整
第六节经济附加值
一、EVA与投资分析
二、EVA的引人入胜之处
第七节一个注意事项
附录资产贝塔与可调整现值
一、贝塔与财务杠杆
二、利用资产贝塔估计权益贝塔
三、资产贝塔与可调整现值
本章摘要
补充资料
网址
本章习题
第九章公司价值评估与重组
第一节公司价值评估
一、资产或权益
二、消亡或存活
三、少数股权或控制权
第二节现金流量贴现价值评估
一、自由现金流量
二、终值
三、一个实例
四、以现值法评估价值的问题
第三节基于可比交易的价值评估
第四节控制权市场
一、控股权溢价
二、重组的财务原因
三、经验证据
四、吉百利公司收购案
附录风险资本的价值评估方法
一、风险资本的价值评估方法——单阶段融资
二、风险资本的价值评估方法——多阶段融资
三、为何风险资本家要求如此高的收益率
本章摘要
补充资料
网址
本章习题
附录A
附录B
重要词汇中英文对照表
奇数题参考答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>财务管理分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++程序员实用大全
译者序
第一章 C语言入门
第二章 宏与常量
第三章 字符串
第四章 函数
第五章 键盘操作
第六章 数学
第七章 文件、目录和磁盘
第八章 数组指点针和结构
第九章 DOS和BIOS服务
第十章 内存管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++程序员实用大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>果壳中的C#
《果壳中的c#——c#5.0权威指南》
前言
目标读者1
本书的结构1
使用本书所需的其他材料 2
本书中使用的约定2
使用示例代码 3
联系我们3
safari. books online 4
致谢 4
第1章 c#和.net framework简介1
1.1 面向对象 1
1.2 类型安全性1
1.3 内存管理 2
1.4 平台支持 2
1.5 c#与clr的关系2
1.6 clr和.net framework3
1.7 c#与windows runtime4
1.8 c# 5.0新特性5
1.9 c# 4.0新特性5
1.10 c# 3.0新特性 5
第2章 c#语言基础7
2.1 第一个c#程序 7
2.2 语法9
2.3 类型基础11
2.4 数值类型19
2.5 布尔类型和运算符 25
2.6 字符串和字符27
2.7 数组29
2.8 变量和参数 32
2.9 表达式和运算符40
2.10 语句43
2.11 命名空间51
第3章 在c#中创建类 57
3.1 类57
3.2 继承69
3.3 object类型76
3.4 结构体80
3.5 访问权限修饰符81
3.6 接口83
3.7 枚举类型87
3.8 嵌套类型91
3.9 泛化92
第4章 c#高级特性103
4.1 委托103
4.2 事件111
4.3 lambda表达式 117
4.4 匿名方法120
4.5 try语句和异常 121
4.6 枚举类型和迭代 128
4.7 可空类型132
4.8 运算符重载137
4.9 扩展方法140
4.10 匿名类型 143
4.11 动态绑定 144
4.12 属性151
4.13 调用者信息属性（c# 5） 152
4.14 不安全代码和指针154
4.15 预处理指令157
4.16 xml文档159
第5章 框架概述163
5.1 clr和核心框架 165
5.2 应用技术168
第6章 框架基础174
6.1 字符串与文本处理 174
6.2 日期和时间185
6.3 日期与时区191
6.4 标准格式字符串与解析标记202
6.5 其他转换机制208
6.6 全球化 211
6.7 操作数字212
6.8 枚举类型216
6.9 元组219
6.10 guid结构体220
6.11 等值比较 220
6.12 顺序比较229
6.13 实用类232
第7章 集合235
7.1 枚举235
7.2 icollection和ilist接口242
7.3 array类245
7.4 复制251
7.5 list、queue、stack和set252
7.6 字典259
7.7 可定制的集合和委托264
7.8 等值和顺序插入 270
第8章 linq查询 277
8.1 入门277
8.2 运算符流语法279
8.3 查询表达式285
8.4 延迟执行289
8.5 子查询295
8.6 linq构造方式298
8.7 映射策略301
8.8 解释型的查询303
8.9 linq to sql 和 entity framework309
8.10 查询表达式的创建323
第9章 linq运算符328
9.1 概述329
9.2 筛选332
9.3 映射336
9.4 连接347
9.5 zip 运算符355
9.6 排序355
9.7 grouping358
9.8 集合运算符361
9.9 转换方法363
9.10 元素运算符365
9.11 聚合方法 367
9.12 数量词372
9.13 生成集合的方法373
第10章 linq to xml 375
10.1 架构概述 375
10.2 x-dom概述376
10.3 实例化x-dom 379
10.4 指定内容 380
10.5 导航和查询381
10.6 更新x-dom 386
10.7 使用value389
10.8 文档和声明391
10.9 名称和命名空间394
10.10 注解 400
10.11 将数据映射到x-dom 400
第11章 其他xml技术407
11.1 xmlreader 407
11.2 xmlwriter415
11.3 使用xmlreader/xmlwriter的模式 417
11.4 xmldocument421
11.5 xpath 424
11.6 xsd和模式验证428
11.7 xslt 431
第12章 销毁和垃圾回收432
12.1 idisposable接口、dispose方法和close方法432
12.2 自动垃圾回收436
12.3 终止器438
12.4 垃圾回收器如何工作442
12.5 托管内存泄露445
12.6 弱引用448
第13章 诊断和代码契约452
13.1 条件编译 452
13.2 debug和trace类455
13.3 代码契约概述458
13.4 先决条件 461
13.5 后置条件 465
13.6 断言和对象不变式467
13.7 接口和抽象方法中的契约468
13.8 处理契约错误469
13.9 选择性执行契约471
13.10 静态契约检查 472
13.11 调整器集成473
13.12 进程和处理线程474
13.13 stacktrace和stackframe类 475
13.14 windows事件日志476
13.15 性能计数器478
13.16 stopwatch类 483
第14章 并发与异步 484
14.1 简介484
14.2 线程处理 485
14.3 任务498
14.4 异步原则 506
14.5 c# 5.0的异步函数510
14.6 异步模式 523
14.7 旧模式530
第15章 流与i/o533
15.1 流体系结构533
15.2 使用流534
15.3 流适配器 546
15.4 压缩流553
15.5 操作zip文件555
15.6 文件与目录操作555
15.7 windows runtime中的文件输入/输出 565
15.8 内存映射文件567
15.9 隔离存储区569
第16章 网络 575
16.1 网络体系结构575
16.2 地址与端口577
16.3 uri 578
16.4 客户端类 579
16.5 http访问591
16.6 编写http服务器596
16.7 使用ftp 599
16.8 使用dns600
16.9 通过smtpclient发送邮件601
16.10 使用tcp602
16.11 使用tcp接收pop3邮件 605
16.12 在windows runtime中建立tcp连接 606
第17章 序列化 608
17.1 序列化概念608
17.2 数据契约的序列化611
17.3 数据契约与集合620
17.4 扩展数据契约622
17.5 二进制序列化器 625
17.6 二进制序列化属性627
17.7 使用iserializable进行二进制序列化629
17.8 xml序列化632
第18章 程序集 641
18.1 程序集包含的内容641
18.2 强名称和程序集签名 645
18.3 程序集名称647
18.4 authenticode签名649
18.5 全局程序集高速缓存 652
18.6 资源和卫星程序集654
18.7 解析和加载程序集661
18.8 在基础文件夹外部署程序集 665
18.9 打包单个可执行文件 667
18.10 处理未引用的程序集668
第19章 反射和元数据 670
19.1 反射和激活类型 670
19.2 反射和调用成员 677
19.3 反射程序集688
19.4 使用属性689
19.5 动态生成代码694
19.6 发出程序集和类型700
19.7 发出类型成员703
19.8 发出泛型方法和类型 708
19.9 复杂的发出目标 710
19.10 解析il 713
19.11 编写反编译器713
第20章 动态编程 718
20.1 动态语言运行时 718
20.2 数字类型统一719
20.3 动态成员重载解决方案720
20.4 实现动态对象726
20.5 通过动态语言交互操作729
第21章 安全 731
21.1 权限731
21.2 代码访问安全（cas）734
21.3 允许部分可信的调用程序737
21.4 clr 4.0中的透明模型739
21.5 沙箱化程序集746
21.6 操作系统安全749
21.7 身份和角色安全 751
21.8 加密综述752
21.9 windows数据保护753
21.10 散列法 754
21.11 对称加密755
21.12 公共密钥加密和签名759
第22章 高级线程 763
22.1 同步概述763
22.2 排他锁764
22.3 锁与线程安全性 771
22.4 非排他锁775
22.5 使用事件等待处理器发送信号780
22.6 barrier类787
22.7 延后初始化788
22.8 线程本地存储790
22.9 interrupt和abort 792
22.10 suspend和resume 793
22.11 定时器 793
第23章 并行编程 797
23.1 pfx 797
23.2 plinq799
23.3 parallel类810
23.4 任务并行816
23.5 处理aggregateexception异常825
23.6 并发集合827
23.7 blockingcollection 829
第24章 应用域 833
24.1 应用域架构833
24.2 创建和销毁应用域833
24.3 多应用域的使用 836
24.4 docallback的应用 837
24.5 应用域的监视838
24.6 应用域和线程838
24.7 应用域间通信839
第25章 本地化和com组件交互844
25.1 调用本地库844
25.2 类型封送845
25.3 非托管代码的回调函数847
25.4 模拟c共用体848
25.5 内存共享849
25.6 映射结构体到非托管内存区 851
25.7 com交互854
25.8 在c#中调用com对象856
25.9 内嵌互操作类型 859
25.10 主互操作程序集859
25.11 com中调用c#对象 860
第26章 正则表达式 861
26.1 正则表达式基础 861
26.2 量词865
26.3 零宽度断言866
26.4 分组869
26.5 文本替换和拆分 870
26.6 正则表达式实例 871
26.7 正则表达式语言参考 874
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>果壳中的C#
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>粉笔人
序 言
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
1986
2016
2016
1986 —1990
2016
2016
2016
两周后
致 谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>粉笔人
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧洲财政国家的兴起
总序
序
致谢
导论
第1章 中世纪的英格兰
第2章 英格兰（英国）：1485-1815年
第3章 中世纪的法国
第4章 法国：1494-1815年
第5章 中世纪的卡斯蒂利亚
第6章 卡斯蒂利亚：1504-1808年
第7章 中世纪的神圣罗马帝国
第8章 中世纪的低地国家
第9章 合省联邦：1579-1806年
第10章 瑞士联邦
第11章 罗马教廷与教宗国
第12章 威尼斯
第13章 近代早期意大利诸国
第14章 解体前的波兰-立陶宛
第15章 俄国：1200-1815年
作者简介
译丛主编后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>欧洲财政国家的兴起
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从缺陷中学习C/C++
第1章　基础问题　1
1.1　运算符优先级引起的问题　1
1.2　不加括号的宏定义引起的错误　2
1.3　污染环境的宏定义　3
1.4　多语句宏定义使用错误　4
1.5　char转为int时高位符号扩展的问题　6
1.6　int转为char时的数据损失　7
1.7　非法的数组下标　9
1.8　有符号int与无符号int比较的后果　10
1.9　有符号的困惑　11
1.10　整除的精度问题　13
1.11　浮点数比较的精度问题　14
1.12　最小负整数取相反数溢出　15
1.13　临时变量溢出　16
1.14　size_t导致的死循环　17
1.15　误用short引起缓冲区溢出　18
1.16　区分continue和return　20
1.17　指针常量和常量指针的区别　21
1.18　字符数组和指针不总是等价的　23
1.19　结构体成员变量初始化的隐患　24
1.20　返回值非void的函数没有返回值　25
1.21　cin>>和getline混用导致的奇怪问题　27
1.22　小结　29
第2章　编译问题　30
2.1　动态链接库加载错误版本　30
2.2　相同名称静态库的链接顺序　32
2.3　使用命名空间来区分不同cpp中的同名类　33
2.4　C++模板编译时依赖名称查找　34
2.5　违背ODR原则可能会带来的意想不到的问题　36
2.6　变量共用内存时使用O2优化编译　38
2.7　小结　40
第3章　库函数问题　41
3.1　sprintf函数引起的缓冲区溢出　41
3.2　snprintf函数format参数的问题　43
3.3　错误使用snprintf函数返回值　44
3.4　字符串复制不完整　45
3.5　string类的c_str方法使用不当　46
3.6　string类的“[]”操作符使用不正确　48
3.7　不正确的字符串比较　49
3.8　strncpy函数没有复制结束符　51
3.9　调用memcpy函数前未初始化缓冲区　52
3.10　误用sizeof操作符取字符串长度　53
3.11　string类find函数返回值判定　54
3.12　stringstream的清空　56
3.13　调用strptime函数前需初始化tm　57
3.14　使用feof函数的陷阱　59
3.15　for循环中调用vector容器insert函数　60
3.16　multiset容器erase函数的误用　62
3.17　慎用容器类erase函数的返回值　63
3.18　for循环中调用vector容器erase函数　65
3.19　getopt函数参数问题　67
3.20　不用errno判断系统调用是否成功　69
3.21　strcat函数造成的段错误　70
3.22　危险的strdup函数　71
3.23　小结　73
第4章　文件处理　74
4.1　程序异常退出时未关闭已打开文件　74
4.2　目录打开后未关闭　75
4.3　写文件没有调用fflush　76
4.4　读文件fread的返回值不能忽略　77
4.5　getline()使用不当导致的死循环　78
4.6　未重置流状态导致读文件错误　80
4.7　小结　82
第5章　类和对象　83
5.1　对象的浅复制　83
5.2　构造函数中的操作符重载　85
5.3　拷贝构造函数不能模板化　87
5.4　析构函数未捕获异常引发coredump　89
5.5　构造函数中抛出异常引起内存泄露　91
5.6　多态性未生效　93
5.7　基类成员函数被隐藏　94
5.8　匿名对象引起的内存泄露　96
5.9　基类非虚析构函数引发内存泄露　97
5.10　删除void*指针引发内存泄露　100
5.11　STL容器不会自动释放指针指向的对象　102
5.12　静态成员类内初始化　104
5.13　union作为类的成员时需要构造函数　105
5.14　成员函数尾部缺失const标注　107
5.15　使用memset初始化class　109
5.16　dynamic_cast转换失败返回NULL　110
5.17　小结　113
第6章　内存使用　114
6.1　数组越界　114
6.2　数组定义和值初始化形式混淆　115
6.3　数组传参时的sizeof　116
6.4　临时对象的生存期　117
6.5　变量的作用域　119
6.6　指针变量的传值和传址　120
6.7　指针赋值和指针赋址的混淆　121
6.8　指针释放后再次使用　122
6.9　重复申请内存未释放　124
6.10　delete与delete[]的区别　126
6.11　函数中途退出忘记释放内存　126
6.12　二维数组的内存泄露　127
6.13　临时变量内存不能返回　128
6.14　正确使用引用参数和引用返回值　129
6.15　试图产生的指针很可能不存在　130
6.16　结构体成员内存对齐问题　131
6.17　String对象何时需delete　134
6.18　小结　135
第7章　多线程问题　136
7.1　局部静态变量非线程安全　136
7.2　string类append操作非线程安全　138
7.3　中途退出造成的线程阻塞　142
7.4　结构体位域成员线程安全问题　144
7.5　多线程写文件引发内容被覆盖　146
7.6　线程未join引起的内存泄露　148
7.7　小结　150
第8章　性能问题　151
8.1　strlen用作循环条件影响性能　151
8.2　STL容器list使用时忌频繁调用size()　152
8.3　误用clear回收vector内存　154
8.4　calloc在glibc高版本下性能劣于低版本下　156
8.5　小结　157
第9章　C/C++编程中其他问题　158
9.1　中文截断成乱码　158
9.2　不必要的类型转换　159
9.3　不确定的函数参数赋值　161
9.4　epoll边沿触发模式下的陷阱　163
9.5　小结　166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从缺陷中学习C/C++
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇全集
第一部　魔法师的外甥
第一章 开错了门
第二章 迪戈雷和他舅舅
第三章 不同世界之间的树林
第四章 魔法钟和敲钟锤
第五章 灭绝咒语
第六章 安德鲁舅舅的麻烦开始了
第七章 正门前的变故
第八章 灯柱前的搏斗
第九章 纳尼亚的诞生
第十章 第一个笑柄和其他事情
第十一章 迪戈雷和他舅舅都陷入困境
第十二章 马儿草莓的奇遇
第十三章 不期而遇
第十四章 种树
第十五章 这个故事的结尾和其他故事的开端

第二部　狮王、女巫和魔衣柜
第一章 露茜钻进大衣柜
第二章 露茜的发现
第三章 埃德蒙和衣柜
第四章 土耳其软糖
第五章 回到柜门这一侧
第六章 走进森林
第七章 在海狸家做客一日
第八章 饭后发生的事
第九章 女巫的王宫
第十章 魔咒开始削弱
第十一章 阿斯兰靠近了
第十二章 彼得初战大捷
第十三章 远古时代的高深魔法戒律
第十四章 女巫的胜利
第十五章 太古时代的更高深魔法戒律
第十六章 石像的变化
第十七章 追猎白鹿

第三部　能言马与男孩的奇幻之旅
第一章 出逃男孩沙斯塔与会说话的马
第二章 一路狮吼
第三章 塔什班城门前的故事
第四章 逃亡男孩变王子
第五章 真假王子面对面
第六章 夜宿王陵惊魂记
第七章 受困的逃婚女孩坎塔
第八章 藏进蒂斯洛克的密室
第九章 沙漠热浪中的日夜兼程
第十章 绿围中的南征隐士
第十一章 迷雾中的随行者
第十二章 纳尼亚奇遇
第十三章 安瓦德之战
第十四章 布利变成一匹更聪明的马儿
第十五章 驴王子变形记

第四部　卡斯宾王子；重返纳尼亚
第一章 小岛
第二章 古老的宝库
第三章 小矮人
第四章 小矮人讲述卡斯宾王子的故事
第五章 卡斯宾山中探险
第六章 隐居的生灵们
第七章 危险笼罩着古老的纳尼亚
第八章 四兄妹离开小岛
第九章 露茜发现了什么
第十章 狮王归来
第十一章 狮王的吼声
第十二章 魔法与突袭复仇
第十三章 至尊国王坐阵指挥
第十四章 大家忙得不可开交
第十五章 阿斯兰在空中打开一扇门

第五部　“黎明破浪号”航行历险记
第一章 挂在卧室的画
第二章 在“黎明破浪号”上
第三章 孤独群岛
第四章 卡斯宾采取行动
第五章 遭遇风暴
第六章 尤斯塔斯的险遇
第七章 险遇结束
第八章 两次死里逃生
第九章 声音岛
第十章 魔法师的书
第十一章 傻瓜笨蛋欢天喜地
第十二章 黑暗岛
第十三章 三个沉睡的人
第十四章 世界尽头的起点
第十五章 最后一片海上奇观
第十六章 世界的终极尽头

第六部　银椅
第一章 体育馆后面
第二章 吉尔接受任务
第三章 国王出航
第四章 猫头鹰议会
第五章 帕德尔格伦
第六章 北方荒原
第七章 山丘上的奇怪壕沟
第八章 哈方王宫
第九章 发现真相
第十章 黑暗中的旅行
第十一章 在黑暗的城堡里
第十二章 地下王国的女王
第十三章 失去女王的地下王国
第十四章 世界的底层
第十五章 吉尔消失了
第十六章 治愈伤痛

第七部　最后一战
第一章 大锅潭边
第二章 国王的鲁莽
第三章 老猿猴得意猖狂
第四章 那天夜里发生的事
第五章 国王得救
第六章 漂亮的夜袭
第七章 小矮人的反应
第八章 老鹰带来的消息
第九章 马厩山丘上的集会
第十章 该由谁进马厩
第十一章 肉搏战
第十二章 穿过马厩门
第十三章 小矮人执迷不悟
第十四章 暗夜笼罩纳尼亚
第十五章 更高更远
第十六章 告别幻境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇全集
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>奥地利学派经济学入门·米塞斯思想精要
总序
译者序
关于作者
第一章 引论
第二章 社会协作与资源配置
原始经济中的实物计算
发达经济中的实物计算
协调和知识的问题
推荐阅读
第三章 经济计算
价格体系的作用
经济计算与技术计算
价值的主观性
借助货币价格实行经济计算
资本和收益的概念
风险和不确定性
脆弱的经济计算
货币计算的理性化效应
依靠市场价格进行的协调沟通
推荐阅读
第四章 主观价值论
满足与估值
边际效用原理
价值与交换
货币的使用
市场经济中的使用价值与交换价值
主观价值的普遍性
推荐阅读
第五章 市场与市场价格
市场的本质
价格的决定——消费品
转向均衡价格的趋势
过去成本的无关性
消费者估值的远见卓识
推荐阅读
第六章 均匀轮转经济中的生产
均匀轮转经济中的资源定价
资源供给、企业家行为与主观估值
均匀轮转经济中的资源配置效率
时间偏好与利息
推荐阅读
第七章 从均匀轮转经济到真实世界
企业家盈亏
消费者估值与生产资源
过去的结果
受束缚的市场与不受束缚的市场
利润的社会作用
推荐阅读
第八章 通货膨胀与商业周期
推荐阅读
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>奥地利学派经济学入门·米塞斯思想精要
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>鸡尾酒原来是这么回事儿
第一章鸡尾酒的世界
哪些人喝鸡尾酒？ 002
调酒的哲学 004
调酒师与酒保 006
鸡尾酒的种类 008
调酒学简史 012
第一本调酒学著作 014
世界各地的鸡尾酒 016
调酒必备工具 018
各式鸡尾酒杯 020
杰出酒保：尼科·德索托 027
第二章如何调制鸡尾酒？
鸡尾酒的滋味 030
打造专属迷你吧 032
管理酒柜 034
调酒基本原则 036
以雪克杯调制鸡尾酒 038
以搅拌杯或酒杯调制鸡尾酒 040
冰镇酒杯 042
杰出酒保：阿戈·佩罗内 043
削皮技巧 044
调制一口酒的艺术 046
摇荡法 V.S 搅拌法 048
摇荡的各种技巧 050
杰出酒保：吉姆·米汉 053
冰块学问大 054
苦精 056
自制苦精 058
动手做苦精 060
杰出酒保：杰克·麦格里 061
果汁与汽水 062
利口酒 064
自制利口酒 066
杰出酒保：上野秀嗣 067
蔬菜水果鸡尾酒 068
“泡”制自我风格 070
鸡尾酒醋饮“席拉布” 072
糖浆 074
来玩火吧 076
金汤力 078
“老”酒大展身手 080
“法国制造”的鸡尾酒 082
桶装陈年鸡尾酒 084
用稀奇的酒调制鸡尾酒 086
意想不到的调酒材料 088
计算鸡尾酒的酒精浓度 090
第三章鸡尾酒吧，走一趟
世界最佳酒吧 094
酒单的秘密 096
创造个人专属酒单 098
鸡尾酒的价格 100
调酒工作站 102
花式调酒 104
分子调酒学 106
其他“规格”的鸡尾酒 108
玛可缇 110
地下酒吧 112
提基酒吧 114
第四章佐餐与晚宴鸡尾酒
鸡尾酒佐餐原则 118
佐餐鸡尾酒 120
适合佐餐的基酒 124
杰出酒保：卢卡·西纳利 125
策划派对 126
完美音乐列表 128
影视里的鸡尾酒 130
现在想喝什么鸡尾酒？132
该上哪儿喝鸡尾酒？134
第五章动手调一杯鸡尾酒
基酒与鸡尾酒 138
传奇鸡尾酒140～172
杰出酒保：马蒂厄·勒弗耶 173
简易鸡尾酒174～179
现代鸡尾酒180～183
以啤酒为基酒的鸡尾酒184～187
无酒精鸡尾酒188～192
杰出酒保：马里安·贝克 193
第六章附 录
成为调酒师 196
调酒师竞赛 198
烈酒品牌与调酒师 200
慢酌 201
鸡尾酒盛事 202
推荐酒吧 203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>鸡尾酒原来是这么回事儿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity 3D脚本编程
第1 章 Hello Unity 3D 1
1.1 Unity 3D 游戏引擎进化史  1
1.2 Unity 3D 编辑器初印象 5
1.2.1 Project 视图 5
1.2.2 Inspector 视图  8
1.2.3 Hierarchy 视图  9
1.2.4 Game 视图 10
1.2.5 Scene 视图 12
1.2.6 绘图模式 14
1.2.7 渲染模式 16
1.2.8 场景视图控制 17
1.2.9 Effects 菜单和Gizmos 菜单  18
1.3 Unity 3D 的组成 18
1.4 为何需要游戏脚本 20
1.5 本章小结 21
第2 章 Mono 所搭建的脚本核心基础  22
2.1 Mono 是什么 22
2.1.1 Mono 的组成  22
2.1.2 Mono 运行时  23
2.2 Mono 如何扮演脚本的角色 24
2.2.1 Mono 和脚本  24
2.2.2 Mono 运行时的嵌入 26
2.3 Unity 3D 为何能跨平台？聊聊CIL 38
2.3.1 Unity 3D 为何能跨平台  38
2.3.2 CIL 是什么 40
2.3.3 Unity 3D 如何使用CIL 跨平台  44
2.4 脚本的选择，C# 或 JavaScript 48
2.4.1 最熟悉的陌生人——UnityScript  48
2.4.2 UnityScript 与 JavaScript  51
2.4.3 C#与UnityScript  55
2.5 本章总结 57
第3 章 Unity 3D 脚本语言的类型系统 58
3.1 C#的类型系统 58
3.2 值类型和引用类型 65
3.3 Unity 3D 脚本语言中的引用类型  73
3.4 Unity 3D 游戏脚本中的值类型 90
3.4.1 Vector2、Vector3 以及Vector4  90
3.4.2 其他常见的值类型 94
3.5 装箱和拆箱  95
3.6 本章总结 98
第4 章 Unity 3D 中常用的数据结构  99
4.1 Array 数组  100
4.2 ArrayList 数组  101
4.3 List<T>数组  102
4.4 C#中的链表——LinkedList<T>  103
4.5 队列（Queue<T>）和栈（Stack<T>） 107
4.6 Hash Table（哈希表）和Dictionary<K,T>（字典） 112
4.7 本章总结  120
第5 章 在Unity 3D 中使用泛型 121
5.1 为什么需要泛型机制 121
5.2 Unity 3D 中常见的泛型  124
5.3 泛型机制的基础 127
5.3.1 泛型类型和类型参数  128
5.3.2 泛型类型和继承  131
5.3.3 泛型接口和泛型委托  131
5.3.4 泛型方法 136
5.4 泛型中的类型约束和类型推断 139
5.4.1 泛型中的类型约束 139
5.4.2 类型推断 144
5.5 本章总结  146
第6 章 在Unity 3D 中使用委托 149
6.1 向Unity 3D 中的SendMessage 和BroadcastMessage 说拜拜 150
6.2 认识回调函数机制——委托  151
6.3 委托是如何实现的  154
6.4 委托是如何调用多个方法的  160
6.5 用事件（Event）实现消息系统  164
6.6 事件是如何工作的  169
6.7 定义事件的观察者，实现观察者模式  172
6.8 委托的简化语法 177
6.8.1 不必构造委托对象 177
6.8.2 匿名方法 178
6.8.3 Lambda 表达式  196
6.9 本章总结  201
第7 章 Unity 3D 中的定制特性  202
7.1 初识特性——Attribute 202
7.1.1 DllImport 特性 203
7.1.2 Serializable 特性 205
7.1.3 定制特性到底是谁 207
7.2 Unity 3D 中提供的常用定制特性  208
7.3 定义自己的定制特性类 213
7.4 检测定制特性  216
7.5 亲手拓展Unity 3D 的编辑器  217
7.6 本章总结  227
第8 章 Unity 3D 协程背后的迭代器  228
8.1 初识Unity 3D 中的协程  228
8.1.1 使用StartCoroutine 方法开启协程 229
8.1.2 使用StopCoroutine 方法停止一个协程 233
8.2 使用协程实现延时效果 234
8.3 Unity 3D 协程背后的秘密——迭代器  238
8.3.1 你好，迭代器 238
8.3.2 原来是状态机 242
8.3.3. 状态管理 248
8.4 WWW和协程  253
8.5 Unity 3D 协程代码实例  257
8.6 本章总结  259
第9 章 在Unity 3D 中使用可空型  260
9.1 如果没有值 260
9.2 表示空值的一些方案 261
9.2.1 使用魔值 261
9.2.2 使用标志位  261
9.2.3 借助引用类型来表示值类型的空值 265
9.3 使用可空值类型 267
9.4 可空值类型的简化语法 272
9.5 可空值类型的装箱和拆箱 278
9.6 本章总结  280
第10 章 从序列化和反序列化看Unity 3D 的存储机制 281
10.1 初识序列化和反序列化  281
10.2 控制类型的序列化和反序列化  290
10.2.1 如何使类型可以序列化  290
10.2.2 如何选择序列化的字段和控制反序列化的流程 292
10.2.3 序列化、反序列化中流的上下文介绍及应用  296
10.3 Unity 3D 中的序列化和反序列化 299
10.3.1 Unity 3D 的序列化概览 299
10.3.2 对Unity 3D 游戏脚本进行序列化的注意事项 302
10.3.3 如何利用Unity 3D 提供的序列化器对自定义类型进行序列化  305
10.4 Prefab 和实例化之谜——序列化和反序列化的过程  309
10.4.1 认识预制体Prefab 309
10.4.2 实例化一个游戏对象 311
10.4.3 序列化和反序列化之谜  314
10.5 本章总结  317
第11 章 移动平台动态读取外部文件 318
11.1 假如我想在编辑器里动态读取文件  318
11.2 移动平台的资源路径问题  320
11.3 移动平台读取外部文件的方法  323
11.4 使用Resources 类加载资源  330
11.5 使用WWW类加载资源 332
11.5.1 利用WWW类的构造函数实现资源下载 332
11.5.2 利用 WWW.LoadFromCacheOrDownload 方法实现资源下载  333
11.5.3 利用WWWForm 类实现POST 请求  335
11.6 本章总结  335
第12 章 在Unity 3D 中使用AssetBundle  336
12.1 初识AssetBundle  336
12.2 使用AssetBundle 的工作流程 337
12.2.1 开发阶段  337
12.2.2 运行阶段  340
12.3 如何使用本地磁盘中的AssetBundle 文件 344
12.4 AssetBundle 文件的平台兼容性  345
12.5 AssetBundle 如何识别资源  345
12.6 本章总结  346
第13 章 Unity 3D 优化 347
13.1 看看Unity 3D 优化需要从哪里着手 347
13.2 CPU 方面的优化 348
13.2.1 对DrawCall 的优化 348
13.2.2 对物理组件的优化  354
13.2.3 处理内存，却让CPU 受伤的GC  355
13.2.4 对代码质量的优化  356
13.3 对GPU 的优化 357
13.3.1 减少绘制的数目 358
13.3.2 优化显存带宽  358
13.4 内存的优化 359
13.4.1 Unity 3D 的内部内存  359
13.4.2 Mono 的托管内存 360
13.5 本章总结  363
第14 章 Unity 3D 的脚本编译 365
14.1 Unity 3D 脚本编译流程概览 365
14.2 JIT 即时编译  368
14.2.1 使用编译器将游戏脚本编译为托管模块  368
14.2.2 托管模块和程序集  369
14.2.3 使用JIT 编译执行程序集的代码  370
14.2.4 使用JIT 即时编译的优势  371
14.3 AOT 提前编译 372
14.3.1 在Unity 3D 中使用AOT 编译  372
14.3.2 iOS 平台和Full-AOT 编译 373
14.3.3 AOT 编译的优势  374
14.4 谁偷了我的热更新？Mono、JIT 还是iOS  374
14.4.1 从一个常见的报错说起  375
14.4.2 美丽的JIT  377
14.4.3 模拟JIT 的过程  378
14.4.4 iOS 平台的自我保护  381
14.5 Unity 3D 项目的编译与发布 382
14.5.1 选择游戏场景和目标平台 382
14.5.2 Unity 3D 发布项目的内部过程  384
14.5.3 Unity 3D 部署到Android 平台  384
14.5.4 Unity 3D 部署到iOS 平台  386
14.6 本章总结  389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity 3D脚本编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计（第4版）
前言 ........................... 1
1 基础知识 .............. 5
程序设计 .......................... 5
高级语言 .......................... 6
操作系统 .......................... 7
编译程序 .......................... 7
集成开发环境 ................ 10
语言解释器 .................... 11
2 编译和运行第一个程序 ............. 13
编译程序 ........................ 14
运行程序 ........................ 14
理解第一个程序 ............ 15
显示变量的值 ................ 17
注释 ................................ 19
练习 ................................ 21
3 变量、数据类型和算术表达式 .. 23
理解数据类型和常量 .... 23
整数类型int ....... 24
浮点数值类型float ................ 25
扩展精度类型double ............. 26
单字符类型char  26
布尔数据类型_Bool ................. 27
类型说明符：long、long long、short、unsigned 和signed ... 28
使用变量 ........................ 31
使用算术表达式 ............ 33
整数算术及一元减运算符 ......... 36
运算与赋值相结合：赋值运算符 ...... 42
_Complex 和_Imaginary 类型 ..... 43
练习 ................................ 43
4 程序循环 ............ 45
三角数 ............................ 45
for 语句 ........................ 46
关系运算符 ........... 48
输出的对齐 ........... 52
程序输入 ............... 53
嵌套for 循环 ...... 55
for 循环的变体 ... 57
while 语句 ................... 59
do 语句 .......................... 63
break 语句 .......... 65
continue 语句 ... 65
练习 ................................ 66
5 做出决策 ............ 69
if 语句 .......................... 69
if-else 构造 ..... 73
复合关系测试 ....... 76
嵌套if 语句 ........ 79
else if 构造 ..... 81
switch 语句 ................. 88
布尔变量 ........................ 91
条件运算符 .................... 96
练习 ................................ 97
6 使用数组 .......... 101
定义数组 ...................... 102
以数组元素为计数器 ............... 106
生成斐波那契数 ...... 109
用数组生成质数 ...... 111
初始化数组 .................. 113
字符数组 ...................... 115
使用数组的基数变换 ............... 116
const 限定符 .... 118
多维数组 ...................... 120
变长数组 ...................... 122
练习 .............................. 124
7 使用函数 .......... 127
定义函数 ...................... 127
参数和局部变量 .......... 131
函数原型声明 ..... 132
自动局部变量 ..... 132
返回函数结果 .............. 134
函数调用 ...................... 139
声明返回类型和参数类型 ....... 142
检查函数参数 ..... 144
自上而下的程序设计 .. 146
函数与数组 .................. 146
赋值运算符 ......... 151
数组排序 ............. 152
多维数组 ............. 155
全局变量 ...................... 161
自动变量与静态变量 .. 165
递归函数 ...................... 168
练习 .............................. 171
8 使用结构体 ....... 175
结构体的基础知识 ...... 175
用于存储日期的结构体 .................... 176
在表达式中使用结构体 ........... 178
函数与结构体 .............. 181
用于存储时间的结构体 ........... 187
初始化结构体 .............. 190
复合字面量 ......... 191
结构体的数组 .............. 192
包含结构体的结构体 .. 196
包含数组的结构体 ...... 198
结构体变体 .................. 202
练习 .............................. 203
9 字符串 .............. 205
复习字符串的基础知识 .................... 205
字符数组 ...................... 206
变长字符串 .................. 209
字符串的初始化与显示 ........... 211
判断两个字符串是否相等 ....... 214
输入字符串 ......... 216
单字符输入 ......... 219
空字符串 ............. 224
转义字符 ...................... 228
再论常量字符串 .......... 230
字符串、结构体和数组 .................... 231
一种更好的搜索方法 ............... 235
字符操作 ...................... 240
练习 .............................. 243
10 指针 ............... 247
指针和间接性 .............. 247
定义指针变量 .............. 248
在表达式中使用指针 .. 252
使用指针和结构体 ...... 253
包含指针的结构体 ................... 256
链表 ..................... 258
关键字const 和指针 ...... 266
指针和函数 .................. 267
指针和数组 .................. 273
稍许离题：程序优化 ............... 277
是数组还是指针？ ................... 278
指向字符串的指针 ................... 280
常量字符串和指针 ................... 282
递增和递减运算符回顾 ........... 283
指针操作 ...................... 287
指向函数的指针 .......... 288
指针和内存地址 .......... 289
练习 .............................. 291
11 位运算 ............ 295
位的基础知识 .............. 295
位运算符 ...................... 297
按位与运算符 ..... 297
按位或运算符 ..... 300
按位异或运算符 . 301
二进制求补运算符 ................... 301
左移运算符 ......... 304
右移运算符 ......... 304
移位函数 ............. 305
循环移位 ............. 307
位段 .............................. 309
练习 .............................. 314
12 预处理器 ........ 317
#define 语句 ............ 317
程序可扩展性 ..... 322
程序可移植性 ..... 323
更高级的定义类型 ................... 324
#运算符 ............... 330
##运算符 ............ 331
#include 语句 .......... 332
系统包含文件 ..... 335
条件编译 ...................... 335
#ifdef、#endif、#else 和#ifndef 语句  .....336
#if 和#elif 预处理器语句 .. 338
#undef 语句 ...... 339
练习 .............................. 339
13 用枚举数据类型、类型定义和数据类型转换扩展数据类型 ........................ 341
枚举数据类型 .............. 341
typedef 语句 ............ 345
数据类型转换 .............. 348
符号扩展 ............. 350
参数转换 ............. 350
练习 .............................. 351
14 处理大型程序 . 353
将程序分为多个文件 .. 353
由命令行编译多个源文件 ....... 354
模块之间的通信 .......... 356
外部变量 ............. 357
静态、动态变量与函数 ........... 359
有效使用头文件 . 362
其他处理大型程序的实用工具 ........ 364
make 实用工具 .. 364
cvs 实用工具 ..... 366
Unix 实用工具：ar、grep、sed 等 ................ 366
15 C 语言中的输入与输出操作 .. 369
字符I/O：getchar()和putchar() ...................... 369
格式化I/O：printf()和scanf() .......................... 370
printf()函数 .. 370
scanf()函数 .... 377
文件输入与输出操作 .. 382
将I/O 重定向到文件 ................ 382
文件尾 ................. 385
处理文件的特殊函数 .. 386
fopen 函数 ........ 387
getc()和putc()函数 ......... 389
fclose()函数 .. 389
feof 函数 .......... 391
fprintf()和fscanf()函数 .......................... 392
fgets()和fputs()函数 .... 392
stdin、stdout 和stderr  393
exit()函数 ....... 394
重命名和删除文件 ................... 395
练习 .............................. 396
16 其他及高级特性 ................... 397
其他语言语句 .............. 397
goto 语句 .......... 397
空语句 ................. 398
使用联合体 .................. 399
逗号运算符 .................. 402
类型限定符 .................. 403
register 限定符 ................... 403
volatile 限定符 ................... 403
restrict 限定符 ................... 404
命令行参数 .................. 404
动态内存分配 .............. 408
calloc()和malloc()函数 ............................ 409
sizeof 运算符 .. 410
free 函数 .......... 413
练习 .............................. 414
17 调试程序 ........ 415
用预处理器调试 .......... 415
用gdb 调试程序 ......... 422
处理变量 ............. 425
源文件显示 ......... 426
控制程序的执行 . 427
获得栈轨迹 ......... 432
调试函数，设置数组和结构体 ............................ 432
用gdb 命令获取帮助 .............. 433
杂项 ..................... 435
18 面向对象程序设计 ................ 437
到底什么是对象？ ...... 437
实例与方法 .................. 438
编写一个处理分数的C 程序 ........... 440
定义一个处理分数的Objective-C 类 ........................... 441
定义一个处理分数的C++类 ............ 446
定义一个处理分数的C#类 .............. 448
附录A C 语言概要 .................... 453
1.0 双字符组和标识符 ................... 453
2.0 注释 ..................... 454
3.0 常量 ..................... 455
4.0 数据类型和声明 . 458
4.6 类型限定符const、volatile 和restrict ................ 468
5.0 表达式 ................. 469
6.0 存储类和作用域 . 482
7.0 函数 ..................... 483
8.0 语句 ..................... 486
9.0 预处理器 ............. 490
附录B 标准C 语言库 ................ 497
标准头文件 .................. 497
字符串函数 .................. 500
内存函数 ...................... 502
字符函数 ...................... 503
I/O 函数 ........................ 503
内存中的格式转换函数 .................... 509
字符串转换为数字 ...... 510
动态内存分配函数 ...... 512
数学函数 ...................... 513
复数运算 ...................... 519
通用函数 ...................... 521
附录C 用gcc 编译程序 ............ 525
通用命令格式 .............. 525
命令行选项 .................. 526
附录D 常见编程错误 ................ 527
附录E 资源 ......... 533
C 程序设计语言 .......... 533
C 编译器和集成开发环境 ................ 534
其他 .............................. 535
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C大学教程
第1章 计算机、Internet和万维网导论	1
1.1 引言	2
1.2 什么是计算机	3
1.3 计算机的基本组成	3
1.4 早期的操作系统	4
1.5 个人计算、分布式计算和客户/服务器计算	4
1.6 机器语言、汇编语言和高级语言	5
1.7 著名的高级语言FORTRAN,COBOL,Pascal和Ada	6
1.8 C语言的发展历史	7
1.9 C语言标准库	8
1.10 C++语言	8
1.11 Java	9
1.12 BASIC语言，Visual Basic语言，Visual C++语言，Visual C#语言和.NET编程平台	9
1.13 软件发展的重要趋势：对象技术	10
1.14 典型的C语言程序开发环境	11
1.15 硬件的发展趋势	13
1.16 Internet的发展历史	13
1.17 万维网(WWW)的发展历史	14
1.18 关于C语言和本书的一些注解	14
1.19 有价值的Web站点	15
第2章 C语言程序设计入门	26
2.1 引言	26
2.2 一个简单的C程序：输出一行文字	27
2.3 另一个简单的C程序：两个整数求和	30
2.4 存储单元的基本概念	34
2.5 C语言中的算术运算	34
2.6 做出判断：相等和关系运算符	37
第3章 结构化的C程序设计	50
3.1 引言	50
3.2 算法	51
3.3 伪码	51
3.4 控制结构	52
3.5 if选择语句	53
3.6 if...else选择语句	54
3.7 while循环语句	57
3.8 算法设计案例1：计数控制的循环	58
3.9 算法设计案例2：自顶向下、逐步求精的标记控制循环	60
3.10 算法设计案例3：自顶向下、逐步求精的嵌套控制结构	65
3.11 赋值运算符	69
3.12 增1和减1运算符	69
第4章 C程序控制	86
4.1 引言	86
4.2 循环的基本原理	87
4.3 计数控制的循环	87
4.4 for循环语句	89
4.5 for循环语句：注意事项	91
4.6 应用for循环语句的例子	92
4.7 switch多重选择语句	94
4.8 do...while循环语句	99
4.9 break和continue语句	100
4.10 逻辑运算符	102
4.11 区分相等运算符(==)和陚值运算符(=)	104
4.12 结构化程序设计总结	105
第5章 C函数	120
5.1 引言	121
5.2 C语言中的程序模块	121
5.3 数学库函数	122
5.4 函数	123
5.5 函数定义	123
5.6 函数原型	127
5.7 函数调用栈及活动记录	129
5.8 头文件	129
5.9 主调函数：按值调用与按引用调用	130
5.10 随机数的生成	130
5.11 程序案例：运气游戏	134
5.12 存储类型	137
5.13 标识符作用域的规定	139
5.14 递归	142
5.15 使用递归的例子：Fibonacci数列	144
5.16 递归与迭代	147
第6章 C数组	165
6.1 引言	165
6.2 数组	166
6.3 数组的定义	167
6.4 数组的应用举例	167
6.5 将数组传递给函数的方法	178
6.6 数组元素的排序	182
6.7 案例分析：釆用数组来计算平均值、中值和众数	184
6.8 数组元素的查找	187
6.9 多维数组	191
第7章 C指针	213
7.1 引言	213
7.2 指针变量的定义和初始化	214
7.3 指针运算符	214
7.4 使用按引用调用方法向函数传递实参	216
7.5 对指针使用const限定符	219
7.6 使用按引用调用方法实现冒泡法排序	224
7.7 sizeof运算符	227
7.8 指针表达式和指针运算	228
7.9 指针和数组之间的关系	230
7.10 指针数组	234
7.11 案例学习：扑克牌洗牌和发牌模拟	234
7.12 函数指针	238
第8章 C字符和字符串	258
8.1 引言	258
8.2 字符串和字符基础	259
8.3 字符处理函数库	260
8.4 字符串转换函数	264
8.5 标准输入输出库函数	268
8.6 字符串处理函数库中的字符串处理函数	271
8.7 字符串处理函数库中的比较函数	273
8.8 字符串处理函数库中的查找函数	274
8.9 字符串处理函数库中的内存函数	279
8.10 字符串处理函数库中的其他函数	282
第9章 格式化输入输出	294
9.1 引言	294
9.2 流	295
9.3 用printf函数实现格式化输出	295
9.4 打印整数	295
9.5 打印浮点数	296
9.6 打印字符串或字符	298
9.7 其他的转换说明符	299
9.8 带域宽和精度的打印	300
9.9 在printf函数的格式控制字符串中使用标记	301
9.10 打印文本和转义序列	304
9.11 用scanf函数读取格式化的输入	304
第10章 结构体、共用体、位操作和枚举类型	316
10.1 引言	316
10.2 结构体的定义	317
10.3 结构体的初始化	319
10.4 对结构体成员的访问	319
10.5 在函数中使用结构体	321
10.6 typedef的使用	321
10.7 实例：高性能的洗牌与发牌模拟程序	322
10.8 共用体	324
10.9 位运算符	326
10.10 位域	332
10.11 枚举常贵	335
第11章 文件处理	345
11.1 引言	345
11.2 数据的层次结构	346
11.3 文件与流	347
11.4 顺序存取文件的创建	348
11.5 从顺序存取文件中读取数据	352
11.6 随机存取文件	355
11.7 随机存取文件的创建	356
11.8 向一个随机存取文件中随机地写入数据	357
11.9 从一个随机存取文件中读取数据	360
11.10 案例学习：事务处理程序	361
第12章 数据结构	374
12.1 引言	374
12.2 自引用结构体	375
12.3 动态内存分配	376
12.4 链表	377
12.5 堆栈	384
12.6 队列	388
12.7 树	392
第13章 C预处理	418
13.1 引言	418
13.2 #include预处理命令	419
13.3 #define预处理命令：符号常量	419
13.4 #define预处理命令：宏	419
13.5 条件编译	421
13.6 #error和#pragma预处理命令	422
13.7 #和##运算符	422
13.8 行号	423
13.9 预定义的符号常景	423
13.10 断言	423
第14章 C语言的其他专题	428
14.1 引言	428
14.2 Linux/UNIX和Windows系统中输入/输出的重定向	429
14.3 可变长的实参列表	429
14.4 使用命令行实参	431
14.5 由多个源文件组成的程序的编译问题	432
14.6 使用exit和atexit终止程序	433
14.7 volatile类型限定符	434
14.8 整型和浮点型常量的后缀	434
14.9 关于文件的深入讨论	435
14.10 信号处理	436
14.11 动态内存分配：calloc函数和realloc函数	438
14.12 用goto实现无条件转移	439
第15章 基于Allegro C函数库的游戏编程	444
15.1 引言	445
15.2 安装Allegro库	445
15.3 一个简单的Allegro库程序	445
15.4 简单的图形：位图的导入和块传送	446
15.5 双缓冲动画显示技术	450
15.6 导入和播放声音	455
15.7 键盘输入	457
15.8 字体和文本显示	461
15.9 实现Pong游戏	465
15.10 Allegro库的定时器	470
15.11 Allegro库的Grabber工具和数据文件	473
15.12 Allegro库的其他功能	480
15.13 Allegro库的网络资源	480
第16章 排序：更深入的透视	487
16.1 引言	487
16.2 大O记号	488
16.3 选择排序	488
16.4 插入排序	491
16.5 归并排序	493
第17章 C99简介	502
17.1 引言	503
17.2 对C99的支持	503
17.3 新的C99头文件	504
17.4 //单行注释符	504
17.5 声明语句和可执行代码的混合使用	504
17.6 在for语句头声明一个变量	505
17.7 指派初始化和复合文本	506
17.8 布尔类型	508
17.9 函数声明中的隐式int类型	509
17.10 复数	510
17.11 可变长数组	511
17.12 C99其他的特征	512
17.13 因特网和万维网上的资源	515
第18章 C++，一个更好的C；介绍对象技术	519
18.1 引言	520
18.2 C++	520
18.3 简单程序：两个整数相加	520
18.4 C++标准库	522
18.5 头文件	522
18.6 内联函数	523
18.7 引用和引用形参	525
18.8 空形参列表	528
18.9 默认实参	529
18.10 一元作用域运算符	530
18.11 函数重载	531
18.12 函数模板	533
18.13 对象技术与UML简介	535
18.14 本章小结	539
第19章 类与对象简介	544
19.1 引言	544
19.2 类、对象、成员函数以及数据成员	545
19.3 本章实例概述	545
19.4 定义一个具有成员函数的类	546
19.5 定义一个有参成员函数	548
19.6 数据成员、set函数与get函数	551
19.7 用构造函数初始化对象	556
19.8 将类放在单独的文件中以增强重用性	558
19.9 将接口与实现分离	561
19.10 用set函数验证数据	565
19.11 本章小结	569
第20章 类：深入剖析(第1部分)	574
20.1 引言	574
20.2 Time类的案例学习	575
20.3 类域和访问类的成员	580
20.4 将接口与实现分离	581
20.5 访问函数和工具函数	581
20.6 Time类的案例学习：具有默认实参的构造函数	584
20.7 析构函数	587
20.8 构造函数与析构函数的调用时间	588
20.9 Time类的案例学习：隐蔽陷阱——返回private数据成员的引用	590
20.10 默认按成员赋值	592
20.11 软件重用性	594
20.12 本章小结	594
第21章 类：深入剖析(第2部分)	599
21.1 引言	600
21.2 const对象和const成员函数	600
21.3 组合：对象作为类的成员	607
21.4 友元函数和友元类	612
21.5 使用this指针	614
21.6 用new和delete运算符进行动态内存管理	618
21.7 static类成员	620
21.8 数据抽象和信息隐藏	624
21.9 容器类和迭代器	626
21.10 代理类	626
21.11 本章小结	628
第22章 运算符重载	633
22.1 引言	633
22.2 运算符重载基础	634
22.3 运算符重载的限制	635
22.4 作为类的成员和作为全局函数的运算符函数的比较	636
22.5 重载流插入和流读取运算符	637
22.6 重载一元运算符	640
22.7 重载二元运算符	640
22.8 案例学习：Array类	640
22.9 类型转换	649
22.10 重载++和--	650
22.11 explicit构造函数	651
22.12 本章小结	653
第23章 面向对象编程：继承	663
23.1 引言	664
23.2 基类和派生类	664
23.3 protected成员	666
23.4 基类和派生类的关系	667
23.5 派生类的构造函数与析构函数	689
23.6 public,protected和private继承	695
23.7 关于继承的软件工程	696
23.8 本章小结	696
第24章 面向对象编程：多态	701
24.1 引言	702
24.2 多态的实例	703
24.3 继承层次结构中对象间的关系	703
24.4 类型域和switch语句	716
24.5 抽象类和纯虚函数	716
24.6 案例学习：利用多态的工资系统	718
24.7 (选修)多态、虚函数以及动态绑定	730
24.8 案例学习：利用多态的和运行时类型信息的工资系统,通过向下类型转换、dynamic_cast、typeid 以及type_info 使用运行时类型信息	733
24.9 虚析构函数	736
24.10 本章小结	736
第25章 模板	740
25.1 引言	740
25.2 函数模板	741
25.3 重载函数模板	743
25.4 类模板	744
25.5 类模板的非类型形参和默认类型	748
25.6 模板与继承	749
25.7 模板与友元	749
25.8 模板与static成员	750
25.9 本章小结	750
第26章 输入/输出流	755
26.1 引言	756
26.2 流	756
26.3 输出流	759
26.4 输入流	760
26.5 用read，write和gcount进行无格式I/O	763
26.6 流操纵符简介	764
26.7 流格式状态和流操纵符	768
26.8 流错误状态	775
26.9 将输出流绑定到输入流上	777
26.10 本章小结	777
第27章 异常处理	786
27.1 引言	787
27.2 异常处理概述	787
27.3 实例：处理除数为0的异常	788
27.4 何时使用异常处理	792
27.5 重新拋出异常	793
27.6 异常规范	794
27.7 处理未预料的异常	794
27.8 栈展开	795
27.9 构造函数、析构函数与异常处理	796
27.10 异常与继承	796
27.11 处理new故障	797
27.12 auto_ptr类与动态内存分配	800
27.13 标准库的异常层次结构	801
27.14 其他错误处理技术	802
27.15 本章小结	803
附录A 因特网和Web资源	809
附录B 运算符优先级表	822
附录C ASCII字符集	825
附录D 数制系统	826
附录E 游戏编程：求解Sudoku问题	836
索引	843
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C大学教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人力资源成为战略性业务伙伴
译者序前言开篇人力资源要从无为向为企业创造价值转变第一部分 人力资源成为SBP的概念和模型第1章 战略性合作的关键概念第2章 SBP模型第二部分 与客户建立合作伙伴关系第3章 确定客户并建立联系第4章 建立可靠性与信任第三部分 识别战略性项目并开展合作第5章 寻找战略性机遇的思路第6章 重构需求并寻找战略性机遇第7章 主动寻找战略性机遇第8章 当客户批准行动时第四部分 对商业战略和方向施加影响第9章 在公司层面工作第10章 使SBP角色成为现实结束语附录A工具作者简介参考文献资源列表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人力资源成为战略性业务伙伴
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哥伦布、大航海时代与地理大发现
第1章
大航海时代：克里斯托弗·哥伦布的远航之梦/001
第2章
伊莎贝拉一世与克里斯托弗·哥伦布第一次远航/027
第3章
大航海时代里程碑：首次发现新大陆/045
第4章
探索西印度群岛/061
第5章
探索新大陆/077
第6章
艰难返航/095
第7章
第二次远航/117
第8章
在伊斯帕尼奥拉岛建立殖民地/141
第9章
探索古巴海岸/159
第10章
返航与第三次远航/179
第11章
返航与第四次远航/201
第12章
因船难在牙买加滞留/223
第13章
克里斯托弗·哥伦布返航与生命终结/239
附录1
斐迪南二世/251
附录二
伊莎贝拉一世/269
专有名词英汉对照/291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哥伦布、大航海时代与地理大发现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计伴侣
目　　录
注：浅灰色的目录标题是本书所对应的谭浩强《C程序设计》（第四版）中的相应章节的目录标题。
第1章 C语言背后的故事　程序设计和C语言 1
1.1 计算机程序是什么　什么是计算机程序 1
1.2 计算机语言又是什么　什么是计算机语言 1
1.2.A 如何用计算机语言来表达一个程序 2
1.2.B 从汇编语言到高级语言——风格各异的计算机语言 4
1.3 C语言真正的特点及其演变　C语言的发展及其特点 6
1.3A C语言与C++不得不说的那点事 8
1.3B 我们为什么现在还要学习C语言 9
1.4 第一次的亲密接触——Hello，World　最简单的C语言程序 11
1.4.A 最简单的C语言程序背后的故事——它的汇编代码是如何被执行的 12
1.4.1 比最简单再复杂一点点　最简单的C语言程序举例 15
1.4.2 程序的三要素：数据输入、数据处理与数据输出　C语言程序的结构 18
1.4.B 编码规范——如何写出简洁优美的代码 19
1.5 C程序开发的两个循环和四个步骤　运行C程序的步骤与方法 21
1.5A 工欲善其事，必先利其器——使用Eclipse编写C程序 22
1.5B 使用GCC编译C语言程序 24
1.6 程序设计的瀑布模型　程序设计的任务 25
第2章 解决问题的思路——算法　算法——程序的灵魂 28
2.1 先有算法，后有程序　什么是算法 28
2.1A 算法的时间复杂度和空间复杂度 31
2.2 如何将抽象的算法实现为具体的代码　简单的算法举例 36
2.3 算法的特征——简单，没啥可说的　算法的特性 38
2.4 一群聪明的程序员是怎么把事情搞砸的　怎样表示一个算法 38
2.5 掌握结构化的程序设计　结构化程序设计方法 39
2.5A 结构化程序设计的基本思想、步骤与流程 39
2.5B“自顶向下，逐步求精”：把“问题”变成“程序”的魔法 40
第3章 顺序结构的程序设计　最简单的C程序设计——顺序程序设计 44
3.1 顺序结构程序举例——简单，没啥可说的　顺序程序设计举例 45
3.1A 如何理解程序的执行顺序 45
3.2 如何描述数据，如何对数据进行运算　数据的表现形式及其运算 46
3.2.1 常量、变量、常变量及符号　常量和变量 46
3.2.2 数据类型及举例　数据类型 48
3.2.3 整型数据及如何选择合适的类型　整型数据 51
3.2.4 字符型数据及举例　字符型数据 52
3.2.5 浮点型数据及比较大小时的特别注意　浮点型数据 53
3.2.6 如何强制指定常量的数据类型　怎样确定常量的类型 55
3.2.7 运算符和表达式及使用经验和建议　运算符和表达式 55
3.3 基本程序单位——语句　C语句 58
3.3.1 C语言的语句分类　C语句的作用和分类 58
3.3.2 赋值语句及其使用注意　最基本的语句——赋值语句 60
3.4 数据从哪里来，又到哪里去？　数据的输入输出 61
3.4.1 输入输出举例——简单，没啥可说的　输入输出举例 61
3.4.2 输入输出的概念——简单，没啥可说的　有关数据输入输出的概念 61
3.4.3 使用printf函数进行格式化数据输出　用printf函数输出数据 61
3.4.4 使用scanf函数进行格式化数据输入　用scanf函数输入数据 63
3.4.5 单字符的输入输出及敏感信息输入函数　字符数据的输入输出 64
3.4.5A 字符串数据的简单输入输出 66
第4章 选择结构的程序设计　选择结构程序设计 67
4.1 选择结构和条件判断——交通灯例子　选择结构和条件判断 67
4.2—4.3　使用if语句实现选择结构 69
4.4 逻辑运算符及表达式　逻辑运算符和逻辑表达式 69
4.4.1 逻辑运算符及优先级　逻辑运算符及其优先次序 69
4.4.1A 合理的出错处理——让你的程序更受欢迎 71
4.4.2 逻辑表达式及其使用注意　逻辑表达式 71
4.4.3 逻辑型变量——时控灯例子　逻辑型变量 72
4.5 条件运算符及表达式　条件运算符和条件表达式 73
4.6 条件结构的嵌套——拜金女择偶例子　选择结构的嵌套 73
4.7 使用switch语句实现多分支选择结构——看天穿衣例子　用switch语句实现多分支选择结构 75
4.8 综合运用——猜数字游戏　选择结构程序综合举例 78
第5章 循环结构的程序设计　循环结构程序设计 82
5.1 为什么需要循环控制——简单，没啥可说的　为什么需要循环控制 82
5.1A 循环结构的四个要素 82
5.2 如果条件满足，就一直做某事的while　用while语句实现循环 84
5.3 一直做某事，直到条件不满足的do…while　用do…while语句实现循环 86
5.4 最完备最复杂的循环语句for　用for语句实现循环 87
5.5 更复杂的数据处理——嵌套的循环　循环的嵌套 89
5.6 如何选择合适的循环结构　几种循环的比较 89
5.7 改变循环的状态　改变循环执行的状态 90
5.7.1—5.7.2　用break和continue语句提前终止循环 90
5.7.3 break和continue的不同　break语句和continue语句的区别 90
5.8 综合运用——检测磁盘剩余容量与统计字符串中的单词数　循环程序举例 91
第6章 处理批量数据的利器——数组　利用数组处理批量数据 95
6.1 如何定义和引用一维数组　怎样定义和引用一维数组 95
6.1.1 如何定义一维数组——保存学生成绩的例子　怎样定义一维数组 95
6.1.2 如何引用一维数组　怎样引用一维数组元素 96
6.1.3 使用memset()函数进行一维数组的初始化　一维数组的初始化 98
6.1.4 用qsort()函数对数组进行排序　一维数组程序举例 99
6.2 如何定义和引用二维数组　怎样定义和引用二维数组 101
6.2.1 如何定义二维数组及二维数组的内存排列方式　怎样定义二维数组 101
6.2.2 如何引用二维数组　怎样引用二维数组的元素 102
6.2.3 使用memset()函数进行二维数组的初始化　二维数组的初始化 102
6.2.4 对二维数组中的数据进行排序　二维数组程序举例 103
6.2.4.A　分析问题，定义二维数组描述批量数据 103
6.2.4.B　向二维数组输入数据 104
6.2.4.C　用qsort()函数对二维数组进行排序 105
6.2.4.D　输出二维数组结果 106
6.2.A 扩展：多维数组的使用 107
6.3 字符数组的本质　字符数组 108
6.3.1—6.3.3　如何定义字符数组 108
6.3.4 字符串和字符数组的区别　字符串和字符串结束标志 108
6.3.5 字符数组和字符串的输入输出　字符数组的输入输出 109
6.3.6 使用字符串处理函数完成字符串处理任务　使用字符串处理函数 110
6.3.6.A　用gets()和puts()输入输出字符串 110
6.3.6.B　用strcat()连接两个字符串 110
6.3.6.C　用strchr()和strstr()查找字符串 112
6.3.6.D　用strcmp()比较字符串 113
6.3.7 综合运用——自己写一个strsub()函数截取字符串　字符数组应用举例 115
6.A 如何运用数组处理批量数据——一个计算平均血糖的例子 117
6.A.A 什么时候应该使用数组 117
6.A.B 如何将数据输入到数组 117
6.A.C 如何处理数组中的数据 118
6.A.D 数组使用的三部曲：定义数组、输入数据、处理数据 119
第7章 模块化程序设计的根基——函数　用函数实现模块化程序设计 121
7.1 为什么要用函数——便于代码的管理和复用　为什么要用函数 121
7.2 如何声明函数　怎样定义函数 122
7.2.1 为什么要声明函数　为什么要定义函数 123
7.2.2 声明函数的方法　定义函数的方法 123
7.2.2A 声明函数的三要素：返回值、函数名、参数列表 124
7.3 如何调用函数　调用函数 128
7.3.1 调用的形式及调用语句　函数调用的形式 128
7.3.2 函数调用时的数据传递——两个方向的传递　函数调用时的数据传递 129
7.3.2A 如何向函数传递体积很大的数据 130
7.3.3 调用的过程——简单，没啥可说的　函数调用的过程 132
7.3.4 关于函数的返回值　函数的返回值 133
7.3.4A 如何从函数返回多个结果数据 133
7.4 编译器对函数声明的要求　对被调用函数的声明和函数原型 137
7.4A 创建一个我们自己的头文件 137
7.A 站在巨人的肩膀上——如何使用已有的函数库 140
7.B 我也能成为巨人——如何创建一个函数库 146
7.5 嵌套的函数调用　函数的嵌套调用 151
7.6 函数的递归调用——统计字符串出现的次数　函数的递归调用 152
7.C 让函数飞——在C语言中嵌入汇编代码 155
7.7 将数组作为函数参数传递　数组作为函数参数 157
7.8 变量的生存期　局部变量和全局变量 157
7.8.1 局部变量的定义及作用域　局部变量 158
7.8.1A 不要从函数返回指向局部变量的指针 161
7.8.2 全局变量及跨文件的全局变量　全局变量 161
7.9 变量的存储方式及其区别　变量的存储方式和生存期 163
7.10 变量的声明和定义的区别——是否建立存储空间　关于变量的声明和定义 164
7.11 控制函数的访问范围　内部函数和外部函数 165
7.D 函数使用的四项基本原则 167
第8章 指针？没啥好怕的！　善于利用指针 170
8.1 什么是指针　指针是什么 170
8.2 什么是指针变量　指针变量 171
8.2.1 使用指针变量的例子——指针的四大用途　使用指针变量的例子 171
8.2.1A 什么是NULL指针 176
8.2.2 如何定义指针变量　怎样定义指针变量 178
8.2.2A 内存的动态申请与释放 180
8.2.3 如何引用指针变量　怎样引用指针变量 182
8.2.3A 指针变量存放在哪里呢？ 183
8.2.4 使用指针变量作为函数参数的场合　指针变量作为函数参数 184
8.3 更灵活的数组访问方式——使用指针访问数组　通过指针引用数组 185
8.3.1—8.3.3A　使用指针访问数组的要点 185
8.3.4 如何向函数传递一个数组　用数组名作函数参数 188
8.3.5 通过指针引用多维数组的要点——统计学生成绩的例子　通过指针引用多维数组 188
8.4 利用指针引用字符串　通过指针引用字符串 193
8.5 定义指向函数的指针　指向函数的指针 195
8.5.1 了解函数指针　什么是函数指针 195
8.5.1A 函数指针背后的故事——剖析它的汇编代码 195
8.5.2 利用函数指针变量调用函数　用函数指针变量调用函数 198
8.5.3 函数指针变量的定义和使用　怎样定义和使用指向函数的指针变量 199
8.5.4 用函数指针作函数参数——在函数之间传递函数，即传递操作　用指向函数的指针作函数参数 201
8.6 使用指针作为函数的返回值　返回指针值的函数 206
8.7 指针数组及指向指针的指针　指针数组和多重指针 207
8.7.1 什么是指针数组——一个电磁炉火力控制程序　什么是指针数组 207
8.7.2 指向指针的指针　指向指针数据的指针 209
8.7.3 向main()函数传递数据　指针数组作main函数的形参 212
8.8 动态内存分配及动态调整　动态内存分配与指向它的指针变量 214
8.9 指针的“醒世恒言”　有关指针的小结 214
8.A 如何避免错误地使用指针 216
第9章 建立自己的数据类型　用户自己建立数据类型 220
9.1 结构体变量登场　定义和使用结构体变量 221
9.1.1—9.1.3　关于这三小节的特别说明 221
9.1.A 定义结构体应该注意的问题 221
9.1.B 使用结构体以及它的数据成员 222
9.2 使用结构体数组——利用qsort()函数对数组排序　使用结构体数组 225
9.2.1—9.2.2　关于这两小节的特别说明 227
9.3 利用结构体指针减少传递的数据量　结构体指针 227
9.3.1—9.3.3　关于这三小节的特别说明 229
9.4 笔试必考，面试必问的数据结构——链表　用指针处理链表 229
9.4.1 链表是神马　什么是链表 230
9.4.2 如何建立静态链表　建立简单的静态链表 230
9.4.3 如何建立动态链表　建立动态链表 230
9.4.4 如何输出链表　输出链表 233
9.4.A 链表数据的处理：对链表进行排序和查找 233
9.4.B 链表数据的处理：查找结点 238
9.4.C 释放一个链表 241
9.5 共用体类型的定义和使用　共用体类型 242
9.5.1—9.5.3　关于这三小节的特别说明 244
9.6 什么是枚举类型　使用枚举类型 244
9.7 数据类型也可以有个更好记更好用的绰号——用typedef声明新的数据类型　用typedef声明新类型名 245
第10章　文件的输入与输出　对文件的输入输出 246
10.1 在C中文件的概念是怎样的　C文件的有关基本知识 246
10.1.1—10.1.5　关于这五小节的特别说明 247
10.1A　C语言所处理的文件类型 247
10.2 如何打开与关闭文件　打开与关闭文件 248
10.2.1 使用fopen函数打开数据文件及注意事项　用fopen函数打开数据文件 248
10.2.1A 用freopen()重定向标准输入输出流 249
10.2.2 使用fclose函数关闭数据文件及注意事项　用fclose函数关闭数据文件 251
10.3 对数据文件进行顺序读写　顺序读写数据文件 251
10.3.1—10.3.2　怎样向文件读写字符和字符串 251
10.3.3 使用函数来进行数据文件的格式化读写　用格式化的方式读写文件 254
10.3.4 二进制方式的文件读写——读写一张图片　用二进制方式向文件读写一组数据 254
10.3.A 文件读写的“三大纪律” 259
10.4 在任意位置读写数据文件　随机读写数据文件 260
10.4.1—10.4.2　关于这两小节的特别说明 264
10.5—10.5A　扩展：访问文件的各种属性 264
10.5A.A　如何判断文件是否存在 264
10.5A.B　如何获得文件的日期和大小 266
第A章 程序是如何炼成的 268
A.A 问题的提出——统计网页中的词频 268
A.B 自顶向下：分析问题，划分模块 268
A.B.A　分析数据输入模块 269
A.B.B　分析数据处理模块 269
A.B.C　分析数据输出模块 271
A.C 逐步求精：用函数实现各个模块 271
A.C.A　实现数据输入模块 271
A.C.B　实现数据处理模块 273
A.C.C　组装实现数据预处理模块 276
A.C.D　实现计算词频模块 279
A.C.E　实现文件排序模块 281
A.C.F　实现数据输出模块 282
A.C.G　打扫战场：释放动态申请的内存 282
A.D 百炼成钢：如何调试我们的程序 284
A.E 程序就是这样炼成的 287
第B章 接下来我该…… 288
B.A 接下来要读的书 288
B.A.A　提升对C语言的理解和掌握 288
B.A.B　做一个有思想的程序员 290
B.B 接下来要做的事 293
B.B.A　编码、编码、再编码 293
B.B.B　软件开发模型：一个项目是如何运作的 293
B.B.C　实际参与一个项目 300
B.C 接下来该走的路 300
B.C.A　开发方向的选择：底层开发、应用开发还是网络开发？ 301
B.C.B　开发语言的选择：C语言、C++还是C#？ 304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计伴侣
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C程序设计大全
第1篇 Linux下C语言基础
第1章 Linux简介
1.1 GNU简介
1.2 Linux简介
1.2.1 Linux发展史
1.2.2 Linux发行版
1.2.3 Linux内核版本
1.2.4 Linux与UNIX的关系
1.2.5 Linux在服务器方面的发展
1.2.6 Linux在嵌入式系统方面的发展
1.2.7 Linux在桌面系统方面的发展
1.3　Linux环境下的其他编程语言
1.3.1 C++
1.3.2 Java
1.3.3 Perl
1.3.4 Python
1.3.5 Ruby
1.3.6 PHP
第2章 控制结构
2.1 goto语句
2.1.1 C语言中的无条件跳转
2.1.2 使用goto语句进行出错处理
2.1.3 出错处理的一般模型
2.2 C语言中的分支结构
2.2.1 分支结构的翻译
2.2.2 使用goto语句实现分支结构
2.3　短路计算
2.3.1 短路计算
2.3.2 &&运算的短路计算
2.3.3 ||运算的短路计算
2.4 C语言中的循环结构
2.4.1 while循环
2.4.2 do…while循环
2.4.3 for循环
2.5 switch语句
2.5.1 switch语句的应用
2.5.2 使用goto语句实现switch语句
2.6 优化控制结构
2.6.1 表达式优化——使用替换程序中的乘除法
2.6.2 　表达式优化——常量折叠
2.6.3 表达式优化——使用数学公式
2.6.4 表达式优化——存储问题
2.6.5 分支优化——改变判断顺序
2.6.6 分支优化——使用switch语句
2.6.7　循环优化——一次性计算
第3章 C语言中的函数
3.1 函数的本质
3.2 变量的作用域和生命期
3.2.1 全局变量
3.2.2 局部变量
3.3 变量的初始值
3.3.1 全局变量的初始值
3.3.2 局部变量的初始值
3.4 与函数有关的优化
3.4.1 函数调用与程序优化
3.4.2 变量存储优化
3.5 编写多文件程序——变量的存储类别
3.5.1 存储类别
3.5.2 static变量的作用——改变变量的生命期
3.5.3 static变量的作用——实现封装和模块化设计
3.6 编写多文件的程序——链接的作用
3.6.1 链接多个文件
3.6.2 链接时符号解析规则
3.6.3 链接规则的应用
3.7 可变参数
3.7.1 可变参数的概念
3.7.2 实现一个简单的可变参数的函数
3.7.3 可变参数实例
3.7.4　关于printf函数的疑问——缺少整型参数
3.7.5 关于printf函数的疑问——缺少字符串地址参数
第4章 C语言中的指针与字符串
4.1 sizeof运算符
4.1.1 sizeof运算符的应用——得到内置类型的大小
4.1.2 sizeof运算符的应用——得到复合类型的大小
4.2 指针的应用
4.2.1 指针与别名陷阱
4.2.2　数组的指针
4.2.3 指针的指针
4.2.4 指针与参数传递
4.2.5 指针类型的意义
4.2.6 void*型指针
4.3 函数的指针
4.3.1 C语言中的函数指针
4.3.2 函数指针的应用——回调函数
4.3.3 函数指针数组
4.4 字符串
4.4.1 字符串与字符数组
4.4.2 字符串与指针
4.4.3 限定修饰符const
4.4.4 const关键字修饰指针——在指针定义之前
4.4.5 const关键字修饰指针——在指针定义之中
4.4.6 const关键字修饰指针——在指针定义之前和定义之中
4.4.7 使用const关键字的意义
第5章 C语言的高级技术
第2篇 C语言开发环境
第6章 vi与vim编辑器
第7章 gcc编译器
第8章 makefile
第9章 gdb
第3篇 Linux进程操作
第10章 进程环境
第11章 进程控制
第12章 时间和日历历程
第13章 信号及信号处理
第14章 进程间通信
第15章 线程
第4篇 Linux文件操作
第17章 文件I/O
第18章 文件管理
第19章 目录操作
第20章 特殊文件
第21章 基于流的I/O
第5篇 Linux网络编程
第22章 TCP和UDP协议
第23章 网络编程基础
第24章 网络编程进阶
第25章 网络编程实例——实现文件传输程序
第26章 网络编程实例——简单的Web服务器
第6篇 shell脚本知识
第27章 shell脚本基础
第28章 shell脚本中的控制结构 844
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C程序设计大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#高级编程(第9版)——C# 5.0 &.NET 4.5.1
第Ⅰ部分  C# 语 言
第1章  .NET体系结构	2
1.1  C#与.NET的关系	2
1.2  公共语言运行库	3
1.2.1  平台无关性	3
1.2.2  提高性能	3
1.2.3  语言的互操作性	4
1.3  中间语言	6
1.3.1  面向对象和接口的支持	6
1.3.2  不同的值类型和引用类型	7
1.3.3  强数据类型化	7
1.3.4  通过异常处理错误	12
1.3.5  特性的使用	12
1.4  程序集	12
1.4.1  私有程序集	13
1.4.2  共享程序集	13
1.4.3  反射	14
1.4.4  并行编程	14
1.4.5  异步编程	14
1.5  .NET Framework类	15
1.6  名称空间	15
1.7  用C#创建.NET应用程序	16
1.7.1  创建ASP.NET应用程序	16
1.7.2  使用WPF	17
1.7.3  Windows Store应用程序	18
1.7.4  Windows服务	18
1.7.5  WCF	18
1.7.6  Windows WF	19
1.8  C#在.NET企业体系结构中的作用	19
1.9  小结	20
第2章  核心C#	22
2.1  C#基础	23
2.2  第一个C#程序	23
2.2.1  代码	23
2.2.2  编译并运行程序	23
2.2.3  详细介绍	24
2.3  变量	26
2.3.1  变量的初始化	26
2.3.2  类型推断	27
2.3.3  变量的作用域	28
2.3.4  常量	30
2.4  预定义数据类型	31
2.4.1  值类型和引用类型	31
2.4.2  CTS类型	32
2.4.3  预定义的值类型	32
2.4.4  预定义的引用类型	35
2.5  流控制	37
2.5.1  条件语句	37
2.5.2  循环	40
2.5.3  跳转语句	43
2.6  枚举	44
2.7  名称空间	46
2.7.1  using语句	47
2.7.2  名称空间的别名	48
2.8  Main()方法	48
2.8.1  多个Main()方法	49
2.8.2  给Main()方法传递参数	50
2.9  有关编译C#文件的更多内容	50
2.10  控制台I/O	52
2.11  使用注释	54
2.11.1  源文件中的内部注释	54
2.11.2  XML文档	54
2.12  C#预处理器指令	56
2.12.1  #define和#undef	57
2.12.2  #if、#elif、#else和#endif	57
2.12.3  #warning和# error	58
2.12.4  #region和#endregion	58
2.12.5  #line	59
2.12.6  #pragma	59
2.13  C#编程规则	59
2.13.1  关于标识符的规则	59
2.13.2  用法约定	60
2.14  小结	66
第3章  对象和类型	67
3.1  创建及使用类	67
3.2  类和结构	68
3.3  类	69
3.3.1 数据成员	69
3.3.2  函数成员	69
3.3.3  只读字段	81
3.4  匿名类型	82
3.5  结构	82
3.5.1  结构是值类型	84
3.5.2  结构和继承	84
3.5.3  结构的构造函数	85
3.6  弱引用	85
3.7  部分类	86
3.8  静态类	87
3.9  Object类	88
3.9.1  System.Object()方法	88
3.9.2  ToString()方法	89
3.10  扩展方法	90
3.11  小结	91
第4章  继承	92
4.1  继承	92
4.2  继承的类型	92
4.2.1  实现继承和接口继承	92
4.2.2  多重继承	93
4.2.3  结构和类	93
4.3  实现继承	93
4.3.1  虚方法	94
4.3.2  隐藏方法	95
4.3.3  调用函数的基类版本	96
4.3.4  抽象类和抽象函数	97
4.3.5  密封类和密封方法	97
4.3.6  派生类的构造函数	98
4.4  修饰符	102
4.4.1  可见性修饰符	103
4.4.2  其他修饰符	103
4.5  接口	104
4.5.1  定义和实现接口	105
4.5.2  派生的接口	108
4.6  小结	109
第5章  泛型	110
5.1  泛型概述	110
5.1.1  性能	111
5.1.2  类型安全	112
5.1.3  二进制代码的重用	112
5.1.4  代码的扩展	113
5.1.5  命名约定	113
5.2  创建泛型类	113
5.3  泛型类的功能	117
5.3.1  默认值	118
5.3.2  约束	118
5.3.3  继承	120
5.3.4  静态成员	121
5.4  泛型接口	122
5.4.1  协变和抗变	122
5.4.2  泛型接口的协变	123
5.4.3  泛型接口的抗变	125
5.5  泛型结构	125
5.6  泛型方法	128
5.6.1  泛型方法示例	128
5.6.2  带约束的泛型方法	129
5.6.3  带委托的泛型方法	130
5.6.4  泛型方法规范	131
5.7  小结	132
第6章  数组	133
6.1  同一类型和不同类型的多个对象	133
6.2  简单数组	134
6.2.1  数组的声明	134
6.2.2  数组的初始化	134
6.2.3  访问数组元素	135
6.2.4  使用引用类型	136
6.3  多维数组	137
6.4  锯齿数组	138
6.5  Array类	139
6.5.1  创建数组	139
6.5.2  复制数组	140
6.5.3  排序	141
6.6  数组作为参数	144
6.6.1  数组协变	144
6.6.2  ArraySegment<T>	144
6.7  枚举	145
6.7.1  IEnumerator接口	146
6.7.2  foreach语句	146
6.7.3  yield语句	147
6.8  元组	152
6.9  结构比较	152
6.10  小结	155
第7章  运算符和类型强制转换	156
7.1  运算符和类型转换	156
7.2  运算符	156
7.2.1  运算符的简化操作	158
7.2.2  运算符的优先级	162
7.3  类型的安全性	163
7.3.1  类型转换	163
7.3.2  装箱和拆箱	167
7.4  比较对象的相等性	168
7.4.1  比较引用类型的相等性	168
7.4.2  比较值类型的相等性	169
7.5  运算符重载	169
7.5.1  运算符的工作方式	170
7.5.2  运算符重载的示例：Vector结构	171
7.6  用户定义的类型强制转换	178
7.6.1  实现用户定义的类型强制转换	179
7.6.2  多重类型强制转换	185
7.7  小结	188
第8章  委托、lambda表达式和事件	189
8.1  引用方法	189
8.2  委托	190
8.2.1  声明委托	190
8.2.2  使用委托	191
8.2.3  简单的委托示例	194
8.2.4  Action<T>和Func<T>委托	196
8.2.5  BubbleSorter示例	197
8.2.6  多播委托	199
8.2.7  匿名方法	203
8.3  lambda表达式	204
8.3.1  参数	204
8.3.2  多行代码	205
8.3.3  闭包	205
8.3.4  使用foreach语句的闭包	206
8.4  事件	207
8.4.1  事件发布程序	207
8.4.2  事件侦听器	209
8.4.3  弱事件	210
8.5  小结	214
第9章  字符串和正则表达式	215
9.1  System.String类	216
9.1.1  创建字符串	217
9.1.2  StringBuilder成员	220
9.1.3  格式字符串	221
9.2  正则表达式	227
9.2.1  正则表达式概述	227
9.2.2  RegularExpressionsPlayaround示例	228
9.2.3  显示结果	230
9.2.4  匹配、组合和捕获	232
9.3  小结	233
第10章  集合	234
10.1  概述	235
10.2  集合接口和类型	235
10.3  列表	236
10.3.1  创建列表	238
10.3.2  只读集合	247
10.4  队列	247
10.5  栈	251
10.6  链表	252
10.7  有序列表	258
10.8  字典	259
10.8.1  键的类型	260
10.8.2  字典示例	261
10.8.3  Lookup类	265
10.8.4  有序字典	265
10.9  集	266
10.10  可观察的集合	268
10.11  位数组	269
10.11.1  BitArray类	270
10.11.2  BitVector32结构	272
10.12  不变的集合	274
10.13  并发集合	276
10.13.1  创建管道	277
10.13.2  使用BlockingCollection	279
10.13.3  使用ConcurrentDictionary	281
10.13.4  完成管道	282
10.14  性能	284
10.15  小结	285
第11章  LINQ	286
11.1  LINQ概述	286
11.1.1  列表和实体	287
11.1.2  LINQ查询	290
11.1.3  扩展方法	291
11.1.4  推迟查询的执行	292
11.2  标准的查询操作符	294
11.2.1  筛选	296
11.2.2  用索引筛选	296
11.2.3  类型筛选	297
11.2.4  复合的from子句	297
11.2.5  排序	298
11.2.6  分组	299
11.2.7  对嵌套的对象分组	300
11.2.8  内连接	301
11.2.9  左外连接	303
11.2.10  组连接	303
11.2.11  集合操作	306
11.2.12  合并	308
11.2.13  分区	309
11.2.14  聚合操作符	310
11.2.15  转换操作符	311
11.2.16  生成操作符	312
11.3  并行LINQ	313
11.3.1  并行查询	313
11.3.2  分区器	314
11.3.3  取消	314
11.4  表达式树	315
11.5  LINQ提供程序	318
11.6  小结	319
第12章  动态语言扩展	320
12.1  DLR	320
12.2  dynamic类型	321
12.3  包含DLR ScriptRuntime	325
12.4  DynamicObject和ExpandoObject	328
12.4.1  DynamicObject	328
12.4.2  ExpandoObject	330
12.5  小结	331
第13章  异步编程	332
13.1  异步编程的重要性	332
13.2  异步模式	333
13.2.1  同步调用	340
13.2.2  异步模式	341
13.2.3  基于事件的异步模式	342
13.2.4  基于任务的异步模式	343
13.3  异步编程的基础	345
13.3.1  创建任务	345
13.3.2  调用异步方法	346
13.3.3  延续任务	346
13.3.4  同步上下文	347
13.3.5  使用多个异步方法	347
13.3.6  转换异步模式	348
13.4  错误处理	349
13.4.1  异步方法的异常处理	350
13.4.2  多个异步方法的异常处理	350
13.4.3  使用AggregateException信息	351
13.5  取消	352
13.5.1  开始取消任务	352
13.5.2  使用框架特性取消任务	352
13.5.3  取消自定义任务	353
13.6  小结	353
第14章  内存管理和指针	354
14.1  内存管理	354
14.2  后台内存管理	354
14.2.1  值数据类型	355
14.2.2  引用数据类型	356
14.2.3  垃圾回收	358
14.3  释放非托管的资源	360
14.3.1  析构函数	360
14.3.2  IDisposable接口	361
14.3.3  实现IDisposable接口和析构函数	362
14.4  不安全的代码	364
14.4.1  用指针直接访问内存	364
14.4.2  指针示例：PointerPlayground	373
14.4.3  使用指针优化性能	377
14.5  小结	380
第15章  反射	381
15.1  在运行期间处理和检查代码	381
15.2  自定义特性	382
15.2.1  编写自定义特性	382
15.2.2  自定义特性示例：WhatsNewAttributes	386
15.3  反射	388
15.3.1  System.Type类	388
15.3.2  TypeView示例	391
15.3.3  Assembly类	393
15.3.4  完成WhatsNewAttributes示例	394
15.4  小结	397
第16章  错误和异常	398
16.1  简介	398
16.2  异常类	399
16.3  捕获异常	400
16.3.1  实现多个catch块	402
16.3.2  在其他代码中捕获异常	406
16.3.3  System.Exception属性	406
16.3.4  没有处理异常时所发生的情况	406
16.3.5  嵌套的try块	407
16.4  用户定义的异常类	409
16.4.1  捕获用户定义的异常	410
16.4.2  抛出用户定义的异常	411
16.4.3  定义用户定义的异常类	414
16.5  调用者信息	416
16.6  小结	417
第Ⅱ部分  Visual Studio
第17章  Visual Studio 2013	419
17.1  使用Visual Studio 2013	419
17.1.1  项目文件的改进	421
17.1.2  Visual Studio的版本	422
17.1.3  Visual Studio设置	423
17.2  创建项目	423
17.2.1  面向多个版本的.NET Framework	424
17.2.2  选择项目类型	426
17.3  浏览并编写项目	429
17.3.1  Solution Explorer	429
17.3.2  使用代码编辑器	435
17.3.3  学习和理解其他窗口	437
17.3.4  排列窗口	441
17.4  构建项目	441
17.4.1  构建、编译和生成	441
17.4.2  调试版本和发布版本	442
17.4.3  选择配置	443
17.4.4  编辑配置	444
17.5  调试代码	445
17.5.1  设置断点	445
17.5.2  使用数据提示和调试器可视化工具	446
17.5.3  监视和修改变量	447
17.5.4  异常	448
17.5.5  多线程	449
17.5.6  IntelliTrace	449
17.6  重构工具	450
17.7  体系结构工具	451
17.7.1  依赖项关系图	452
17.7.2  层关系图	453
17.8  分析应用程序	454
17.8.1  代码地图	454
17.8.2  序列图	454
17.8.3  探查器	455
17.8.4  Concurrency Visualizer	457
17.8.5  Code Analysis	458
17.8.6  Code Metrics	459
17.9  单元测试	459
17.9.1  创建单元测试	459
17.9.2  运行单元测试	460
17.9.3  预期异常	462
17.9.4  测试全部代码路径	462
17.9.5  外部依赖	463
17.9.6  Fakes Framework	466
17.10  Windows Store应用程序、WCF、WF等	467
17.10.1  使用Visual Studio 生成WCF应用程序	467
17.10.2  使用Visual Studio 生成WF应用程序	468
17.10.3  使用Visual Studio 2013生成Windows Store应用程序	469
17.11  小结	470
第18章  部署	471
18.1  部署是应用程序生命周期的一部分	471
18.2  部署的规划	472
18.2.1  部署选项	472
18.2.2  部署要求	472
18.2.3  部署.NET运行库	473
18.3  传统的部署选项	473
18.3.1  xcopy部署	474
18.3.2  xcopy和Web应用程序	475
18.3.3  Windows Installer	475
18.4  ClickOnce	475
18.4.1  ClickOnce操作	476
18.4.2  发布ClickOnce应用程序	476
18.4.3  ClickOnce设置	477
18.4.4  ClickOnce文件的应用程序缓存	479
18.4.5  应用程序的安装	479
18.4.6  ClickOnce部署API	480
18.5  Web部署	481
18.5.1  Web应用程序	481
18.5.2  配置文件	482
18.5.3  创建Web Deploy包	482
18.6  Windows Store应用程序	483
18.6.1  创建应用程序包	484
18.6.2  Windows App
Certification Kit	485
18.6.3  旁加载	486
18.6.4  Windows部署API	486
18.7  小结	488
第Ⅲ部分  基    础
第19章  程序集	490
19.1  程序集的含义	490
19.1.1  程序集的功能	491
19.1.2  程序集的结构	492
19.1.3  程序集清单	492
19.1.4  名称空间、程序集和组件	493
19.1.5  私有程序集和共享程序集	493
19.1.6  附属程序集	493
19.1.7  查看程序集	493
19.2  构建程序集	494
19.2.1  创建模块和程序集	494
19.2.2  程序集的特性	495
19.2.3  创建和动态加载程序集	497
19.3  应用程序域	500
19.4  共享程序集	504
19.4.1  强名	504
19.4.2  使用强名获得完整性	505
19.4.3  全局程序集缓存	506
19.4.4  创建共享程序集	506
19.4.5  创建强名	507
19.4.6  安装共享程序集	508
19.4.7  使用共享程序集	508
19.4.8  程序集的延迟签名	509
19.4.9  引用	510
19.4.10  本机映像生成器	511
19.5  配置.NET应用程序	512
19.5.1  配置类别	512
19.5.2  绑定程序集	513
19.6  版本问题	514
19.6.1  版本号	515
19.6.2  通过编程方式获取版本	515
19.6.3  绑定到程序集版本	516
19.6.4  发行者策略文件	517
19.6.5  运行库的版本	518
19.7  在不同的技术之间共享程序集	519
19.7.1  共享源代码	519
19.7.2  可移植类库	520
19.8  小结	521
第20章  诊断	522
20.1  诊断概述	522
20.2  代码协定	523
20.2.1  前提条件	524
20.2.2  后置条件	525
20.2.3  不变量	526
20.2.4  纯粹性	527
20.2.5  接口的协定	527
20.2.6  简写	528
20.2.7  协定和遗留代码	529
20.3  跟踪	529
20.3.1  跟踪源	530
20.3.2  跟踪开关	532
20.3.3  跟踪侦听器	532
20.3.4  筛选器	534
20.3.5  相关性	535
20.3.6  使用ETW进行跟踪	539
20.3.7  使用EventSource	539
20.3.8  使用EventSource进行高级跟踪	541
20.4  事件日志	543
20.4.1  事件日志体系结构	543
20.4.2  事件日志类	544
20.4.3  创建事件源	546
20.4.4  写入事件日志	546
20.4.5  资源文件	547
20.5  性能监视	551
20.5.1  性能监视类	551
20.5.2  性能计数器生成器	551
20.5.3  添加PerformanceCounter组件	554
20.5.4  perfmon.exe	556
20.6  小结	557
第21章  任务、线程和同步	558
21.1  概述	558
21.2  Parallel类	560
21.2.1  用Parallel.For()方法循环	560
21.2.2  使用Parallel.ForEach()方法循环	563
21.2.3  通过Parallel.Invoke()方法调用多个方法	564
21.3  任务	564
21.3.1  启动任务	565
21.3.2  Future——任务的结果	567
21.3.3  连续的任务	568
21.3.4  任务层次结构	569
21.4  取消架构	570
21.4.1  Parallel.For()方法的取消	570
21.4.2  任务的取消	571
21.5  线程池	572
21.6  Thread类	574
21.6.1  给线程传递数据	575
21.6.2  后台线程	576
21.6.3  线程的优先级	577
21.6.4  控制线程	578
21.7  线程问题	578
21.7.1  争用条件	578
21.7.2  死锁	581
21.8  同步	583
21.8.1  lock语句和线程安全	583
21.8.2  Interlocked类	588
21.8.3  Monitor类	589
21.8.4  SpinLock结构	590
21.8.5  WaitHandle基类	591
21.8.6  Mutex类	591
21.8.7  Semaphore类	593
21.8.8  Events类	595
21.8.9  Barrier类	598
21.8.10  ReaderWriterLockSlim类	600
21.9  Timer类	602
21.10  数据流	604
21.10.1  使用动作块	604
21.10.2  源和目标数据块	605
21.10.3  连接块	606
21.11  小结	608
第22章  安全性	609
22.1  概述	609
22.2  身份验证和授权	610
22.2.1  标识和Principal	610
22.2.2  角色	611
22.2.3  声明基于角色的安全性	612
22.2.4  声称	613
22.2.5  客户端应用程序服务	614
22.3  加密	619
22.3.1  签名	621
22.3.2  交换密钥和安全传输	622
22.4  资源的访问控制	625
22.5  代码访问安全性	628
22.5.1  第2级安全透明性	628
22.5.2  权限	629
22.6  使用证书发布代码	634
22.7  小结	635
第23章  互操作	636
23.1  .NET和COM技术	636
23.1.1  元数据	637
23.1.2  释放内存	638
23.1.3  接口	638
23.1.4  方法绑定	639
23.1.5  数据类型	640
23.1.6  注册	640
23.1.7  线程	640
23.1.8  错误处理	641
23.1.9  事件	642
23.1.10  封送	642
23.2  在.NET客户端中使用COM组件	643
23.2.1  创建COM组件	643
23.2.2  创建运行库可调用包装	649
23.2.3  使用RCW	650
23.2.4  通过动态语言扩展使用COM服务	651
23.2.5  线程问题	652
23.2.6  添加连接点	652
23.3  在COM客户端中使用.NET组件	654
23.3.1  COM可调用包装	655
23.3.2  创建.NET组件	655
23.3.3  创建类型库	656
23.3.4  COM互操作特性	658
23.3.5  COM注册	660
23.3.6  创建COM客户端应用程序	661
23.3.7  添加连接点	662
23.3.8  使用sink对象创建客户端	663
23.4  平台调用	665
23.5  小结	669
第24章  文件和注册表操作	670
24.1  文件和注册表	670
24.2  管理文件系统	671
24.2.1  表示文件和文件夹的.NET类	672
24.2.2  Path类	674
24.2.3  FileProperties示例	674
24.3  移动、复制和删除文件	679
24.3.1  FilePropertiesAndMovement示例	679
24.3.2  FilePropertiesAndMovement示例的代码	680
24.4  读写文件	682
24.4.1  读取文件	683
24.4.2  写入文件	684
24.4.3  流	685
24.4.4  缓存的流	687
24.4.5  使用FileStream类读写二进制文件	687
24.4.6  读写文本文件	692
24.5  映射内存的文件	698
24.6  读取驱动器信息	699
24.7  文件的安全性	701
24.7.1  从文件中读取ACL	701
24.7.2  从目录中读取ACL	702
24.7.3  添加和删除文件中的ACL项	704
24.8  读写注册表	705
24.8.1  注册表	706
24.8.2  .NET注册表类	708
24.9  读写独立存储器	710
24.10  小结	714
第25章  事务处理	715
25.1  简介	715
25.2  概述	716
25.2.1  事务处理阶段	716
25.2.2  ACID属性	717
25.3  数据库和实体类	717
25.4  传统的事务	719
25.4.1  ADO.NET事务	719
25.4.2  System.EnterpriseServices	721
25.5  System.Transactions	722
25.5.1  可提交的事务	723
25.5.2  事务处理的升级	725
25.5.3  依赖事务	727
25.5.4  环境事务	729
25.6  隔离级别	736
25.7  自定义资源管理器	737
25.8  文件系统事务	743
25.9  小结	747
第26章  网络	748
26.1  网络	748
26.2  HttpClient类	749
26.2.1  异步调用Web服务	749
26.2.2  标题	750
26.2.3  HttpContent	752
26.2.4  HttpMessageHandler	752
26.3  把输出结果显示为HTML页面	753
26.3.1  从应用程序中进行简单的Web浏览	754
26.3.2  启动Internet Explorer实例	755
26.3.3  给应用程序提供更多IE类型的功能	756
26.3.4  使用WebBrowser控件打印	761
26.3.5  显示所请求页面的代码	761
26.3.6  WebRequest类和WebResponse类的层次结构	763
26.4  实用工具类	763
26.4.1  URI	763
26.4.2  IP地址和DNS名称	764
26.5  较低层的协议	766
26.5.1  使用SmtpClient	767
26.5.2  使用TCP类	769
26.5.3  TcpSend和TcpReceive示例	769
26.5.4  TCP和UDP	771
26.5.5  UDP类	771
26.5.6  Socket类	772
26.5.7  WebSocket	776
26.6  小结	779
第27章  Windows服务	780
27.1  Windows服务	780
27.2  Windows服务的体系结构	781
27.2.1  服务程序	782
27.2.2  服务控制程序	783
27.2.3  服务配置程序	783
27.2.4  Windows服务的类	783
27.3  创建Windows服务程序	784
27.3.1  创建服务的核心功能	784
27.3.2  QuoteClient示例	787
27.3.3  Windows服务程序	791
27.3.4  线程化和服务	795
27.3.5  服务的安装	795
27.3.6  安装程序	796
27.4  Windows服务的监控和控制	800
27.4.1  MMC管理单元	800
27.4.2  net.exe实用程序	801
27.4.3  sc.exe实用程序	801
27.4.4  Visual Studio Server Explorer	801
27.4.5  编写自定义ServiceController类	802
27.5  故障排除和事件日志	809
27.6  小结	810
第28章  本地化	811
28.1  全球市场	811
28.2  System.Globalization名称空间	812
28.2.1  Unicode问题	812
28.2.2  区域性和区域	813
28.2.3  使用区域性	817
28.2.4  排序	823
28.3  资源	824
28.3.1  创建资源文件	824
28.3.2  资源文件生成器	824
28.3.3  ResourceWriter	825
28.3.4  使用资源文件	826
28.3.5  System.Resources名称空间	830
28.4  使用Visual Studio的Windows Forms本地化	830
28.4.1  通过编程方式修改区域性	835
28.4.2  使用自定义资源消息	836
28.4.3  资源的自动回退	837
28.4.4  外包翻译	837
28.5  ASP.NET Web Forms的本地化	838
28.6  用WPF本地化	839
28.6.1  用于WPF的.NET资源	840
28.6.2  XAML资源字典	841
28.7  自定义资源读取器	845
28.7.1  创建DatabaseResourceReader类	845
28.7.2  创建DatabaseResourceSet类	847
28.7.3  创建DatabaseResourceManager类	847
28.7.4  DatabaseResourceReader的客户端应用程序	848
28.8  创建自定义区域性	848
28.9  用Windows Store应用程序进行本地化	850
28.9.1  使用资源	851
28.9.2  使用多语言应用程序工具集进行本地化	851
28.10  小结	852
第29章  核心XAML	853
29.1  XAML的作用	853
29.2  XAML概述	854
29.2.1  元素如何映射到.NET对象上	854
29.2.2  使用自定义.NET类	856
29.2.3  把属性用作特性	857
29.2.4  把属性用作元素	857
29.2.5  基本的.NET类型	858
29.2.6  使用集合和XAML	858
29.2.7  用XAML代码调用构造函数	859
29.3  依赖属性	859
29.3.1  创建依赖属性	860
29.3.2  强制值回调	861
29.3.3  值变更回调和事件	862
29.3.4  事件的冒泡和隧道	863
29.4  附加属性	866
29.5  标记扩展	868
29.6  创建自定义标记扩展	869
29.7  XAML定义的标记扩展	870
29.8  读写XAML	871
29.9  小结	872
第30章  Managed Extensibility Framework	873
30.1  概述	873
30.2  MEF的体系结构	874
30.2.1  使用属性的MEF	875
30.2.2  基于约定的部件注册	880
30.3  定义协定	882
30.4  导出部件	883
30.4.1  创建部件	883
30.4.2  导出属性和方法	888
30.4.3  导出元数据	890
30.4.4  使用元数据进行惰性加载	892
30.5  导入部件	893
30.5.1  导入连接	895
30.5.2  部件的惰性加载	897
30.5.3  用惰性实例化的部件读取元数据	898
30.6  容器和出口提供程序	900
30.7  类别	902
30.8  小结	904
第31章  Windows运行库	905
31.1  概述	905
31.1.1  .NET与Windows运行库的比较	906
31.1.2  名称空间	906
31.1.3  元数据	908
31.1.4  语言投射	909
31.1.5  Windows运行库中的类型	911
31.2  Windows运行库组件	912
31.2.1  集合	912
31.2.2  流	913
31.2.3  委托与事件	914
31.2.4  异步操作	914
31.3  Windows Store应用程序	915
31.4  应用程序的生命周期	917
31.4.1  应用程序的执行状态	918
31.4.2  Suspension Manager	919
31.4.3  导航状态	921
31.4.4  测试暂停	922
31.4.5  页面状态	922
31.5  应用程序的设置	924
31.6  小结	927
第Ⅳ部分	 数    据
第32章  核心ADO.NET	929
32.1  ADO.NET概述	929
32.1.1  名称空间	930
32.1.2  共享类	931
32.1.3  数据库专用类	931
32.2  使用数据库连接	932
32.2.1  管理连接字符串	933
32.2.2  高效地使用连接	934
32.2.3  事务	936
32.3  命令	938
32.3.1  执行命令	938
32.3.2  调用存储过程	941
32.4  快速数据访问：数据读取器	944
32.5  异步数据访问：使用Task和await	946
32.6  管理数据和关系：DataSet类	948
32.6.1  数据表	949
32.6.2  数据列	950
32.6.3  数据关系	955
32.6.4  数据约束	956
32.7  XML架构：用XSD生成代码	958
32.8  填充DataSet类	965
32.8.1  用数据适配器填充DataSet	965
32.8.2  从XML中填充DataSet类	966
32.9  持久化DataSet类的修改	966
32.9.1  通过数据适配器进行更新	966
32.9.2  写入XML输出结果	969
32.10  使用ADO.NET	970
32.10.1  分层开发	970
32.10.2  生成SQL Server的键	972
32.10.3  命名约定	974
32.11  小结	975
第33章  ADO.NET Entity Framework	976
33.1  用Entity Framework编程	976
33.2  Entity Framework映射	978
33.2.1  逻辑层	978
33.2.2  概念层	980
33.2.3  映射层	982
33.2.4  连接字符串	983
33.3  实体	983
33.4  对象上下文	984
33.5  关系	986
33.5.1  一个层次结构一个表	986
33.5.2  一种类型一个表	988
33.5.3  懒惰加载、延迟加载和预先加载	989
33.6  查询数据	991
33.6.1  Entity SQL	991
33.6.2  使用DbSqlQuery	992
33.6.3  LINQ to Entities	993
33.7  把数据写入数据库	994
33.7.1  对象跟踪	994
33.7.2  改变信息	995
33.7.3  附加和分离实体	996
33.7.4  使用最后一个更改操作
写入实体的更改	997
33.7.5  使用第一个更改操作写入实体的更改	997
33.7.6  写入实体的更改并处理冲突	998
33.8  使用Code First编程模型	999
33.8.1  定义实体类型	999
33.8.2  创建数据上下文	1000
33.8.3  创建数据库，存储实体	1000
33.8.4  数据库	1001
33.8.5  查询数据	1001
33.8.6  定制数据库的生成	1002
33.8.7  数据库的自动填充	1003
33.8.8  连接的弹性	1004
33.8.9  架构的迁移	1005
33.9  小结	1007
第34章  处理XML	1008
34.1  XML	1008
34.2  .NET支持的XML标准	1009
34.3  System.Xml名称空间	1009
34.4  使用System.Xml类	1010
34.5  读写流格式的XML	1011
34.5.1  使用XmlReader类	1011
34.5.2 使用XmlReader类进行验证	1015
34.5.3  使用XmlWriter类	1017
34.6  在.NET中使用DOM	1018
34.7  使用XPathNavigator类	1023
34.7.1  System.Xml.XPath名称空间	1023
34.7.2  System.Xml.Xsl名称空间	1028
34.7.3  调试XSLT	1032
34.8  XML和ADO.NET	1034
34.8.1  将ADO.NET数据转换为XML文档	1034
34.8.2  把XML文档转换为
ADO.NET数据	1040
34.9  在XML中序列化对象	1041
34.10  LINQ to XML和.NET	1051
34.11  使用不同的XML对象	1051
34.11.1  XDocument对象	1051
34.11.2  XElement对象	1052
34.11.3  XNamespace对象	1053
34.11.4  XComment对象	1055
34.11.5  XAttribute对象	1056
34.12  使用LINQ查询XML文档	1057
34.12.1  查询静态的XML文档	1057
34.12.2  查询动态的XML文档	1058
34.13  XML文档的更多查询技术	1060
34.13.1  读取XML文档	1060
34.13.2  写入XML文档	1061
34.14  小结	1063
第Ⅴ部分  显    示
第35章  核心WPF	1065
35.1  理解WPF	1066
35.1.1  名称空间	1066
35.1.2  类层次结构	1067
35.2  形状	1069
35.3  几何图形	1070
35.4  变换	1072
35.5  画笔	1073
35.5.1  SolidColorBrush	1073
35.5.2  LinearGradientBrush	1074
35.5.3  RadialGradientBrush	1074
35.5.4  DrawingBrush	1075
35.5.5  ImageBrush	1076
35.5.6  VisualBrush	1076
35.6  控件	1077
35.6.1  简单控件	1077
35.6.2  内容控件	1078
35.6.3  带标题的内容控件	1079
35.6.4  项控件	1081
35.6.5  带标题的项控件	1081
35.6.6  修饰	1081
35.7  布局	1082
35.7.1  StackPanel	1082
35.7.2  WrapPanel	1083
35.7.3  Canvas	1084
35.7.4  DockPanel	1084
35.7.5  Grid	1085
35.8  样式和资源	1086
35.8.1  样式	1087
35.8.2  资源	1088
35.8.3  系统资源	1090
35.8.4  从代码中访问资源	1090
35.8.5  动态资源	1090
35.8.6  资源字典	1091
35.9  触发器	1092
35.9.1  属性触发器	1093
35.9.2  多触发器	1094
35.9.3  数据触发器	1095
35.10  模板	1096
35.10.1  控件模板	1097
35.10.2  数据模板	1099
35.10.3  样式化列表框	1101
35.10.4  ItemTemplate	1102
35.10.5  列表框元素的控件模板	1103
35.11  动画	1105
35.11.1  时间轴	1105
35.11.2  非线性动画	1108
35.11.3  事件触发器	1109
35.11.4  关键帧动画	1111
35.12  可见状态管理器	1112
35.12.1  可见的状态	1113
35.12.2  变换	1115
35.13  3-D	1116
35.13.1  模型	1116
35.13.2  照相机	1118
35.13.3  光线	1118
35.13.4  旋转	1118
35.14  小结	1119
第36章  用WPF编写业务应用程序	1120
36.1  概述	1120
36.2  菜单和功能区控件	1121
36.2.1  菜单控件	1121
36.2.2  功能区控件	1122
36.3  Commanding	1124
36.3.1  定义命令	1125
36.3.2  定义命令源	1126
36.3.3  命令绑定	1126
36.4  数据绑定	1127
36.4.1  BooksDemo应用程序内容	1128
36.4.2  用XAML绑定	1129
36.4.3  简单对象的绑定	1131
36.4.4  更改通知	1134
36.4.5  对象数据提供程序	1136
36.4.6  列表绑定	1138
36.4.7  主从绑定	1141
36.4.8  多绑定	1142
36.4.9  优先绑定	1144
36.4.10  值的转换	1145
36.4.11  动态添加列表项	1147
36.4.12  动态添加选项卡中的项	1148
36.4.13  数据模板选择器	1149
36.4.14  绑定到XML上	1151
36.4.15  绑定的验证和错误处理	1153
36.5  TreeView	1161
36.6  DataGrid	1165
36.6.1  自定义列	1167
36.6.2  行的细节	1168
36.6.3  用DataGrid进行分组	1168
36.6.4  实时成型	1171
36.7  小结	1177
第37章  用WPF创建文档	1178
37.1  简介	1178
37.2  文本元素	1179
37.2.1  字体	1179
37.2.2  TextEffect	1180
37.2.3  内联	1181
37.2.4  块	1183
37.2.5  列表	1185
37.2.6  表	1185
37.2.7  块的锚定	1186
37.3  流文档	1188
37.4  固定文档	1192
37.5  XPS文档	1196
37.6  打印	1197
37.6.1  用PrintDialog打印	1198
37.6.2  打印可见元素	1198
37.7  小结	1200
第38章  Windows Store应用程序：用户界面	1201
38.1  概述	1201
38.2  Microsoft的现代设计	1202
38.2.1  内容，不是边框	1202
38.2.2  快速流畅	1203
38.2.3  可读性	1204
38.3  示例应用程序的核心功能	1204
38.3.1  文件和目录	1204
38.3.2  应用程序页面	1205
38.4  应用程序工具栏	1210
38.5  启动与导航	1213
38.6  布局的变化应用程序数据	1215
38.7  存储	1220
38.7.1  定义数据协定	1220
38.7.2  写入移动数据	1222
38.7.3  读取数据	1223
38.7.4  写入图像	1224
38.7.5  读取图像	1226
38.8  选择器	1227
38.9  活动的磁贴	1228
38.10  小结	1230
第39章  Windows Store应用程序：协定和设备	1231
39.1  概述	1231
39.2  搜索	1232
39.3  共享协定	1234
39.3.1  共享源	1234
39.3.2  共享目标	1237
39.4  相机	1239
39.5  定位	1240
39.6  感应器	1243
39.6.1  光线	1244
39.6.2  罗盘	1244
39.6.3  加速计	1245
39.6.4  倾斜计	1246
39.6.5  陀螺仪	1246
39.6.6  方向	1246
39.6.7  Rolling Marble示例	1247
39.7  小结	1249
第40章  核心ASP.NET	1250
40.1  用于Web应用程序的.NET Framework	1250
40.1.1  ASP.NET Web Forms	1251
40.1.2  ASP.NET Web Pages	1251
40.1.3  ASP.NET MVC	1252
40.2  Web技术	1252
40.2.1  HTML	1253
40.2.2  CSS	1253
40.2.3  JavaScript和jQuery	1253
40.3  托管和配置	1254
40.4  处理程序和模块	1256
40.4.1  创建自定义处理程序	1257
40.4.2  ASP.NET处理程序	1258
40.4.3  创建自定义模块	1259
40.4.4  通用模块	1260
40.5  全局的应用程序类	1261
40.6  请求和响应	1262
40.6.1  使用HttpRequest对象	1262
40.6.2  使用HttpResponse对象	1264
40.7  状态管理	1264
40.7.1  视图状态	1265
40.7.2  cookie	1266
40.7.3  会话	1267
40.7.4  应用程序状态	1270
40.7.5  缓存	1270
40.7.6  配置文件	1271
40.8  ASP.NET身份系统	1275
40.8.1  基础知识	1276
40.8.2  存储和检索用户信息	1277
40.8.3  安全启动	1278
40.8.4  使用注册和身份验证	1278
40.9  小结	1279
第41章  ASP.NET Web Forms	1281
41.1  概述	1281
41.2  ASPX页面模型	1282
41.2.1  添加控件	1283
41.2.2  使用事件	1284
41.2.3  使用回送	1284
41.2.4  使用自动回送	1285
41.2.5  回送到其他页面	1285
41.2.6  定义强类型化的跨页面回送	1286
41.2.7  使用页面事件	1287
41.2.8  ASPX代码	1288
41.2.9  服务器端控件	1290
41.3  母版页	1291
41.3.1  创建母版页	1291
41.3.2  使用母版页	1293
41.3.3  在内容页中定义母版页内容	1294
41.4  导航	1296
41.4.1  站点地图	1296
41.4.2  Menu控件	1296
41.4.3  菜单路径	1297
41.5  验证用户输入	1297
41.5.1  使用验证控件	1298
41.5.2  使用验证摘要	1299
41.5.3  验证组	1300
41.6  访问数据	1300
41.6.1  使用Object Framework	1301
41.6.2  创建库	1302
41.6.3  使用Object Data Source	1303
41.6.4  编辑	1306
41.6.5  定制列	1307
41.6.6  在网格中使用模板	1308
41.7  安全性	1309
41.7.1  建立 ASP.NET身份	1309
41.7.2  用户注册	1310
41.7.3  用户的身份验证	1311
41.7.4  用户授权	1312
41.8  Ajax	1313
41.8.1  ASP.NET AJAX的概念	1314
41.8.2  ASP.NET AJAX网站示例	1316
41.8.3  支持ASP.NET AJAX的网站配置	1319
41.8.4  添加ASP.NET AJAX功能	1320
41.9  小结	1326
第42章  ASP.NET MVC	1328
42.1  ASP.NET MVC概述	1328
42.2  定义路由	1330
42.2.1  添加路由	1330
42.2.2  路由约束	1331
42.3  创建控制器	1331
42.3.1  动作方法	1332
42.3.2  参数	1332
42.3.3  返回数据	1333
42.4  创建视图	1335
42.4.1  向视图传递数据	1336
42.4.2  Razor语法	1337
42.4.3  强类型视图	1338
42.4.4  布局	1339
42.4.5  部分视图	1342
42.5  从客户端提交数据	1346
42.5.1  模型绑定器	1347
42.5.2  注释和验证	1348
42.6  HTML Helper	1350
42.6.1  简单的Helper	1350
42.6.2  使用模型数据	1351
42.6.3  定义HTML特性	1352
42.6.4  创建列表	1352
42.6.5  强类型化的Helper	1353
42.6.6  编辑器扩展	1354
42.6.7  创建自定义Helper	1355
42.6.8  模板	1355
42.7  创建数据驱动的应用程序	1356
42.7.1  定义模型	1357
42.7.2  创建控制器和视图	1358
42.8  动作过滤器	1364
42.9  身份验证和授权	1366
42.9.1  登录模型	1366
42.9.2  登录控制器	1366
42.9.3  登录视图	1368
42.10  小结	1370
第Ⅵ部分	 通    信
第43章  WCF	1372
43.1  WCF概述	1372
43.1.1  SOAP	1374
43.1.2  WSDL	1374
43.1.3  REST	1375
43.1.4  JSON	1375
43.2  创建简单的服务和客户端	1375
43.2.1  定义服务和数据协定	1376
43.2.2  数据访问	1378
43.2.3  服务的实现	1379
43.2.4  WCF服务宿主和WCF测试客户端	1380
43.2.5  自定义服务宿主	1382
43.2.6  WCF客户端	1384
43.2.7  诊断	1386
43.2.8  与客户端共享协定程序集	1388
43.3  协定	1389
43.3.1  数据协定	1390
43.3.2  版本问题	1390
43.3.3  服务协定	1391
43.3.4  消息协定	1392
43.3.5  错误协定	1392
43.4  服务的行为	1394
43.5  绑定	1397
43.5.1  标准的绑定	1397
43.5.2  标准绑定的特性	1399
43.5.3  Web套接字	1400
43.6  宿主	1403
43.6.1  自定义宿主	1403
43.6.2  WAS宿主	1404
43.6.3  预配置的宿主类	1405
43.7  客户端	1406
43.7.1  使用元数据	1406
43.7.2  共享类型	1407
43.8  双工通信	1408
43.8.1  双工通信的协定	1408
43.8.2  双工通信的服务	1408
43.8.3  双工通信的客户端应用程序	1409
43.9  路由	1410
43.9.1  示例应用程序	1411
43.9.2  路由接口	1412
43.9.3  WCF路由服务	1412
43.9.4  为失败使用路由器	1413
43.9.5  改变协定的桥梁	1415
43.9.6  过滤器的类型	1415
43.10  小结	1415
第44章  ASP.NET Web API	1416
44.1  概述	1416
44.2  创建服务	1417
44.2.1  定义模型	1418
44.2.2  创建控制器	1418
44.2.3  错误处理	1420
44.3  创建.NET客户程序	1420
44.3.1  发送GET请求	1421
44.3.2  发送POST请求	1422
44.3.3  发送PUT请求	1423
44.3.4  发送DELETE请求	1423
44.4  Web API路由和操作	1424
44.4.1  给操作添加HTTP方法	1424
44.4.2  基于特性的路由	1425
44.5  使用OData	1427
44.5.1  创建数据模型	1427
44.5.2  创建服务	1428
44.5.3  OData查询	1430
44.5.4  WCF Data Services客户程序	1431
44.6  保护Web API	1436
44.6.1  创建账户	1437
44.6.2  创建验证令牌	1439
44.6.3  发送验证过的调用	1440
44.6.4  获取用户信息	1440
44.7  自驻留	1441
44.8  小结	1443
第45章  Windows Workflow Foundation	1444
45.1  工作流概述	1444
45.2  Hello World示例	1445
45.3  活动	1446
45.3.1  If活动	1447
45.3.2  InvokeMethod活动	1448
45.3.3  Parallel活动	1448
45.3.4  Delay活动	1449
45.3.5  Pick活动	1449
45.4  自定义活动	1450
45.4.1  活动的验证	1451
45.4.2  设计器	1452
45.4.3  自定义复合活动	1454
45.5  工作流	1456
45.5.1  实参和变量	1457
45.5.2  WorkflowApplication	1458
45.5.3  存放WCF工作流	1461
45.5.4  工作流的版本	1465
45.5.5  驻留设计器	1466
45.6  小结	1471
第46章  对等网络	1472
46.1  P2P网络概述	1472
46.1.1  客户端-服务器体系结构	1473
46.1.2  P2P体系结构	1473
46.1.3  P2P体系结构的挑战	1474
46.1.4  P2P术语	1475
46.1.5  P2P解决方案	1475
46.2  PNRP	1475
46.3  构建P2P应用程序	1478
46.4  小结	1484
第47章  消息队列	1485
47.1  概述	1486
47.1.1  使用消息队列的场合	1486
47.1.2  消息队列功能	1487
47.2  Message Queuing产品	1488
47.3  消息队列体系结构	1489
47.3.1  消息	1489
47.3.2  消息队列	1489
47.4  Message Queuing管理工具	1490
47.4.1  创建消息队列	1490
47.4.2  消息队列属性	1491
47.5  消息队列的编程实现	1492
47.5.1  创建消息队列	1492
47.5.2  查找队列	1493
47.5.3  打开已知队列	1493
47.5.4  发送消息	1495
47.5.5  接收消息	1497
47.6  课程订单应用程序	1499
47.6.1  课程订单类库	1499
47.6.2  课程订单消息发送程序	1502
47.6.3  发送优先级和可恢复的消息	1504
47.6.4  课程订单消息接收应用程序	1505
47.7  接收结果	1511
47.7.1  确认队列	1511
47.7.2  响应队列	1512
47.8  事务队列	1512
47.9  消息队列和WCF	1514
47.9.1  带数据协定的实体类	1514
47.9.2  WCF服务协定	1515
47.9.3  WCF消息接收应用程序	1516
47.9.4  WCF消息发送应用程序	1519
47.10  消息队列的安装	1520
47.11  小结	1520
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#高级编程(第9版)——C# 5.0 &.NET 4.5.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C Program Language
第1章 导言 1 　　1.1 入门 1 　　1.2 变量与算术表达式 3 　　1.3 for语句 8 　　1.4 符号常量 9 　　1.5 字符输入/输出 9 　　1.5.1 文件复制 10 　　1.5.2 字符计数 11 　　1.5.3 行计数 13 　　1.5.4 单词计数 14 　　1.6 数组 15 　　1.7 函数 17 　　.1.8 参数—传值调用 19 　　1.9 字符数组 20 　　1.10 外部变量与作用域 22 　　第2章 类型、运算符与表达式 27 　　2.1 变量名 27 　　2.2 数据类型及长度 27 　　2.3 常量 28 　　2.4 声明 31 　　2.5 算术运算符 32 　　2.6 关系运算符与逻辑运算符 32 　　2.7 类型转换 33 　　2.8 自增运算符与自减运算符 37 　　2.9 按位运算符 38 　　2.10 赋值运算符与表达式 40 　　2.11 条件表达式 41 　　2.12 运算符优先级与求值次序 42 　　第3章 控制流 45 　　3.1 语句与程序块 45 　　3.2 if-else语句 45 　　3.3 else-if语句 46 　　3.4 switch语句 48 　　3.5 while循环与for循环 49 　　3.6 do-while循环 52 　　3.7 break语句与continue语句 53 　　3.8 goto语句与标号 54 　　第4章 函数与程序结构 57 　　4.1 函数的基本知识 57 　　4.2 返回非整型值的函数 60 　　4.3 外部变量 62 　　4.4 作用域规则 68 　　4.5 头文件 69 　　4.6 静态变量 70 　　4.7 寄存器变量 71 　　4.8 程序块结构 72 　　4.9 初始化 72 　　4.10 递归 73 　　4.11 c预处理器 75 　　4.11.1 文件包含 75 　　4.11.2 宏替换 76 　　4.11.3 条件包含 78 　　第5章 指针与数组 79 　　5.1 指针与地址 79 　　5.2 指针与函数参数 81 　　5.3 指针与数组 83 　　5.4 地址算术运算 86 　　5.5 字符指针与函数 89 　　5.6 指针数组以及指向指针的指针 92 　　5.7 多维数组 95 　　5.8 指针数组的初始化 97 　　5.9 指针与多维数组 97 　　5.10 命令行参数 98 　　5.11 指向函数的指针 102 　　5.12 复杂声明 105 　　第6章 结构 111 　　6.1 结构的基本知识 111 　　6.2 结构与函数 113 　　6.3 结构数组 115 　　6.4 指向结构的指针 119 　　6.5 自引用结构 121 　　6.6 表查找 125 　　6.7 类型定义（typedef） 127 　　6.8 联合 128 　　6.9 位字段 130 　　第7章 输入与输出 133 　　7.1 标准输入/输出 133 　　7.2 格式化输出—printf函数 135 　　7.3 变长参数表 136 　　7.4 格式化输入—scanf函数 137 　　7.5 文件访问 140 　　7.6 错误处理—stderr和exit 143 　　7.7 行输入和行输出 144 　　7.8 其他函数 145 　　7.8.1 字符串操作函数 145 　　7.8.2 字符类别测试和转换函数 146 　　7.8.3 ungetc函数 146 　　7.8.4 命令执行函数 146 　　7.8.5 存储管理函数 147 　　7.8.6 数学函数 147 　　7.8.7 随机数发生器函数 148 　　第8章 unix系统接口 149 　　8.1 文件描述符 149 　　8.2 低级i/o—read和write 150 　　8.3 open、creat、close和unlink 151 　　8.4 随机访问—lseek 153 　　8.5 实例—fopen和getc函数的实现 154 　　8.6 实例—目录列表 157 　　8.7 实例—存储分配程序 162 　　附录a 参考手册 167 　　a.1 引言 167 　　a.2 词法规则 167 　　a.2.1 记号 167 　　a.2.2 注释 167 　　a.2.3 标识符 167 　　a.2.4 关键字 168 　　a.2.5 常量 168 　　a.2.6 字符串字面值 170 　　a.3 语法符号 170 　　a.4 标识符的含义 170 　　a.4.1 存储类 171 　　a.4.2 基本类型 171 　　a.4.3 派生类型 172 　　a.4.4 类型限定符 172 　　a.5 对象和左值 172 　　a.6 转换 173 　　a.6.1 整型提升 173 　　a.6.2 整型转换 173 　　a.6.3 整数和浮点数 173 　　a.6.4 浮点类型 173 　　a.6.5 算术类型转换 173 　　a.6.6 指针和整数 174 　　a.6.7 void 175 　　a.6.8 指向void的指针 175 　　a.7 表达式 175 　　a.7.1 指针生成 176 　　a.7.2 初等表达式 176 　　a.7.3 后缀表达式 177 　　a.7.4 一元运算符 179 　　a.7.5 强制类型转换 180 　　a.7.6 乘法类运算符 180 　　a.7.7 加法类运算符 181 　　a.7.8 移位运算符 181 　　a.7.9 关系运算符 182 　　a.7.10 相等类运算符 182 　　a.7.11 按位与运算符 183 　　a.7.12 按位异或运算符 183 　　a.7.13 按位或运算符 183 　　a.7.14 逻辑与运算符 183 　　a.7.15 逻辑或运算符 183 　　a.7.16 条件运算符 184 　　a.7.17 赋值表达式 184 　　a.7.18 逗号运算符 185 　　a.7.19 常量表达式 185 　　a.8 声明 185 　　a.8.1 存储类说明符 186 　　a.8.2 类型说明符 187 　　a.8.3 结构和联合声明 188 　　a.8.4 枚举 191 　　a.8.5 声明符 191 　　a.8.6 声明符的含义 192 　　a.8.7 初始化 195 　　a.8.8 类型名 197 　　a.8.9 typedef 198 　　a.8.10 类型等价 199 　　a.9 语句 199 　　a.9.1 带标号语句 199 　　a.9.2 表达式语句 199 　　a.9.3 复合语句 200 　　a.9.4 选择语句 200 　　a.9.5 循环语句 201 　　a.9.6 跳转语句 201 　　a.10 外部声明 202 　　a.10.1 函数定义 202 　　a.10.2 外部声明 204 　　a.11 作用域与连接 204 　　a.11.1 词法作用域 205 　　a.11.2 连接 205 　　a.12 预处理 205 　　a.12.1 三字符序列 206 　　a.12.2 行连接 206 　　a.12.3 宏定义和扩展 206 　　a.12.4 文件包含 208 　　a.12.5 条件编译 209 　　a.12.6 行控制 210 　　a.12.7 错误信息生成 210 　　a.12.8 pragma 210 　　a.12.9 空指令 210 　　a.12.10 预定义名字 211 　　a.13 语法 211 　　附录b 标准库 219 　　b.1 输入与输出：[stdio.h] 219 　　b.1.1 文件操作 220 　　b.1.2 格式化输出 221 　　b.1.3 格式化输入 223 　　b.1.4 字符输入/输出函数 224 　　b.1.5 直接输入/输出函数 225 　　b.1.6 文件定位函数 225 　　b.1.7 错误处理函数 226 　　b.2 字符类别测试：[ctype.h] 226 　　b.3 字符串函数：[string.h] 227 　　b.4 数学函数：[math.h] 228 　　b.5 实用函数：[stdlib.h] 229 　　b.6 诊断：[assert.h] 232 　　b.7 可变参数表：[stdarg.h] 232 　　b.8 非局部跳转：[setjmp.h] 232 　　b.9 信号：[signal.h] 233 　　b.10 日期与时间函数：[time.h] 234 　　b.11 与具体实现相关的限制： 　　[limits.h] 和 [float.h] 236 　　附录c 变更小结 237 　　索引 241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C Program Language
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言其实很简单
第1章 从这里爱上编程——程序设计和C语言概述
1.1 水面下的冰山——计算机程序和计算机语言
1.2 第一次亲密接触——纵览C语言
1.2.1 一窥程序之美——Ｃ语言程序的结构
1.2.2 循序渐进，快乐学习——语句的光和影
1.2.3 程序里的说明书——注释
1.2.4 免费翻译服务——编译和链接
1.3 先其利器——Visual C++ 6.0上机指导
1.4 天平称物问题——进制转换
1.4.1 这些进制是哪来的——二进制、八进制、十六进制
1.4.2 你还应知道这几招——不同进制之间的转换
第2章 色彩斑斓的积木——数据类型、运算符和表达式
2.1 标识符、常量和变量
2.1.1 给我起个名字吧——标识符
2.1.2 有一说一——常量
2.1.3 程序里的储物盒——变量
2.2 追根“数”源——细说数据类型
2.2.1 整型数据用C语言怎样说
2.2.2 实型数据用C语言怎样说
2.2.3 字符型数据用C语言怎样说
2.2.4 字符串型常量用C语言怎样说
2.3 诸算达人——运算符和表达式
2.3.1 再谈加减乘除——算术运算
2.3.2 走，给我进去！——赋值
2.3.3 加加和减减——自增、自减
2.3.4 神秘的倒数第一——逗号运算
2.4 位在我心中——位运算
第3章 一战到底——顺序结构
3.1 整装待发——C语言中的语句
3.2 别急，一个一个来——单个字符的输出与输入
3.2.1 拿好了钥匙进仓库——输出与输入概述
3.2.2 向屏幕开火——单个字符的输出
3.2.3 饭要一口一口地吃——单个字符的输入
3.3 更过瘾的输出与输入——格式输出与输入
3.3.1 我有私人警察——格式输出函数printf
3.3.2 我是快乐的快递员——格式输入函数scanf
3.4 常用系统数学函数
3.5 是不是有点专业级软件的意思了——顺序结构程序举例
……
第4章 程序也能跑捷径——选择结构
第5章 不必亲手愚公移山——循环结构
第6章 把平房升级为高楼大厦——数组
第7章 蒙着面干活——函数
第8章 璀璨的星星——指针
第9章 我的类型我做主——结构体与共用体
第10章 得文件者得天下——文件
第11章 编程的经验财富——算法与数据结构基础
第12章 程林高手武功秘籍——软件开发基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言其实很简单
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言入门经典（第5版）
第1章 C语言编程
1.1 C语言
1.2 标准库
1.3 学习C
1.4 创建C程序
1.4.1 编辑
1.4.2 编译
1.4.3 链接
1.4.4 执行
1.5 创建第一个程序
1.6 编辑第一个程序
1.7 处理错误
1.8 剖析一个简单的程序
1.8.1 注释
1.8.2 预处理指令
1.8.3 定义main()函数
1.8.4 关键字
1.8.5 函数体
1.8.6 输出信息
1.8.7 参数
1.8.8 控制符
1.8.9 三字母序列
1.9 预处理器
1.10 用C语言开发程序
1.10.1 了解问题
1.10.2 详细设计
1.10.3 实施
1.10.4 测试
1.11 函数及模块化编程
1.12 常见错误
1.13 要点
1.14 小结
1.15 习题
第2章 编程初步
2.1 计算机的内存
2.2 什么是变量
2.3 存储整数的变量
2.3.1 变量的使用
2.3.2 变量的初始化
2.4 变量与内存
2.4.1 带符号的整数类型
2.4.2 无符号的整数类型
2.4.3 指定整数常量
2.5 使用浮点数
2.6 浮点数变量
2.6.1 使用浮点数完成除法运算
2.6.2 控制输出中的小数位数
2.6.3 控制输出的字段宽度
2.7 较复杂的表达式
2.8 定义命名常量
2.8.1 极限值
2.8.2 sizeof运算符
2.9 选择正确的类型
2.10 强制类型转换
2.10.1 自动转换类型
2.10.2 隐式类型转换的规则
2.10.3 赋值语句中的隐式类型转换
2.11 再谈数值数据类型
2.11.1 字符类型
2.11.2 字符的输入输出
2.11.3 枚举
2.11.4 存储布尔值的变量
2.12 赋值操作的op=形式
2.13 数学函数
2.14 设计一个程序
2.14.1 问题
2.14.2 分析
2.14.3 解决方案
2.15 小结
2.16 练习
第3章 条件判断
3.1 判断过程
3.1.1 算术比较
3.1.2 基本的if语句
3.1.3 扩展if语句：if-else
3.1.4 在if语句中使用代码块
3.1.5 嵌套的if语句
3.1.6 测试字符
3.1.7 逻辑运算符
3.1.8 条件运算符
3.1.9 运算符的优先级
3.2 多项选择问题
3.2.1 给多项选择使用else-if语句
3.2.2 switch语句
3.2.3 goto语句
3.3 按位运算符
3.3.1 按位运算符的op=用法
3.3.2 使用按位运算符
3.4 设计程序
3.4.1 问题
3.4.2 分析
3.4.3 解决方案
3.5 小结
3.6 练习
第4章 循环
4.1 循环
4.2 递增和递减运算符
4.3 for循环
4.4 for循环的一般语法
4.5 再谈递增和递减运算符
4.5.1 递增运算符
4.5.2 递增运算符的前置和后置形式
4.5.3 递减运算符
4.6 再论for循环
4.6.1 修改for循环变量
4.6.2 没有参数的for循环
4.6.3 循环内的break语句
4.6.4 使用for循环限制输入
4.6.5 生成伪随机整数
4.6.6 再谈循环控制选项
4.6.7 浮点类型的循环控制变量
4.7 while循环
4.8 嵌套循环
4.9 嵌套循环和goto语句
4.10 do-while循环
4.11 continue语句
4.12 设计程序
4.12.1 问题
4.12.2 分析
4.12.3 解决方案
4.13 小结
4.14 习题
第5章 数组
5.1 数组简介
5.1.1 不用数组的程序
5.1.2 什么是数组
5.1.3 使用数组
5.2 寻址运算符
5.3 数组和地址
5.4 数组的初始化
5.5 确定数组的大小
5.6 多维数组
5.7 多维数组的初始化
5.8 变长数组
5.9 设计一个程序
5.9.1 问题
5.9.2 分析
5.9.3 解决方案
5.10 小结
5.11 习题
第6章 字符串和文本的应用
6.1 什么是字符串
6.2 存储字符串的变量
6.3 字符串操作
6.3.1 检查对C11的支持
6.3.2 确定字符串的长度
6.3.3 复制字符串
6.3.4 连接字符串
6.3.5 比较字符串
6.3.6 搜索字符串
6.3.7 单元化字符串
6.3.8 将换行符读入字符串
6.4 分析和转换字符串
6.4.1 转换字符的大小写形式
6.4.2 将字符串转换成数值
6.5 设计一个程序
6.5.1 问题
6.5.2 分析
6.5.3 解决方案
6.6 小结
6.7 习题
第7章 指针
7.1 指针初探
7.1.1 声明指针
7.1.2 通过指针访问值
7.1.3 使用指针
7.1.4 指向常量的指针
7.1.5 常量指针
7.1.6 指针的命名
7.2 数组和指针
7.3 多维数组
7.3.1 多维数组和指针
7.3.2 访问数组元素
7.4 内存的使用
7.4.1 动态内存分配：malloc()函数
7.4.2 释放动态分配的内存
7.4.3 用calloc()函数分配内存
7.4.4 扩展动态分配的内存
7.5 使用指针处理字符串
7.5.1 使用指针数组
7.5.2 指针和数组记号
7.6 设计程序
7.6.1 问题
7.6.2 分析
7.6.3 解决方案
7.7 小结
7.8 习题
第8章 编程的结构
8.1 程序的结构
8.1.1 变量的作用域和生存期
8.1.2 变量的作用域和函数
8.2 函数
8.2.1 定义函数
8.2.2 return语句
8.3 按值传递机制
8.4 函数原型
8.5 指针用作参数和返回值
8.5.1 常量参数
8.5.2 返回指针的风险
8.6 小结
8.7 习题
第9章 函数再探
9.1 函数指针
9.1.1 声明函数指针
9.1.2 通过函数指针调用函数
9.1.3 函数指针的数组
9.1.4 作为变元的函数指针
9.2 函数中的变量
9.2.1 静态变量：函数内部的追踪
9.2.2 在函数之间共享变量
9.3 调用自己的函数：递归
9.4 变元个数可变的函数
9.4.1 复制va_list
9.4.2 长度可变的变元列表的基本规则
9.5 main()函数
9.6 结束程序
9.6.1 abort()函数
9.6.2 exit()和atexit()函数
9.6.3 _Exit()函数
9.6.4 quick_exit()和at_quick_exit()函数
9.7 提高性能
9.7.1 内联声明函数
9.7.2 使用restrict关键字
9.7.3 _Noreturn函数限定符
9.8 设计程序
9.8.1 问题
9.8.2 分析
9.8.3 解决方案
9.9 小结
9.10 习题
第10章 基本输入和输出操作
10.1 输入和输出流
10.2 标准流
10.3 键盘输入
10.3.1 格式化键盘输入
10.3.2 输入格式控制字符串
10.3.3 输入格式字符串中的字符
10.3.4 输入浮点数的各种变化
10.3.5 读取十六进制和八进制值
10.3.6 用scanf_s()读取字符
10.3.7 从键盘上输入字符串
10.3.8 单个字符的键盘输入
10.4 屏幕输出
10.4.1 使用printf_s()的格式化输出
10.4.2 转义序列
10.4.3 整数输出
10.4.4 输出浮点数
10.4.5 字符输出
10.5 其他输出函数
10.5.1 屏幕的非格式化输出
10.5.2 数组的格式化输出
10.5.3 数组的格式化输入
10.6 小结
10.7 习题
第11章 结构化数据
11.1 数据结构：使用struct
11.1.1 定义结构类型和结构变量
11.1.2 访问结构成员
11.1.3 未命名的结构
11.1.4 结构数组
11.1.5 表达式中的结构成员
11.1.6 结构指针
11.1.7 为结构动态分配内存
11.2 再探结构成员
11.2.1 将一个结构作为另一个结构的成员
11.2.2 声明结构中的结构
11.2.3 将结构指针用作结构成员
11.2.4 双向链表
11.2.5 结构中的位字段
11.3 结构与函数
11.3.1 结构作为函数的变元
11.3.2 结构指针作为函数变元
11.3.3 作为函数返回值的结构
11.3.4 二叉树
11.4 共享内存
11.5 设计程序
11.5.1 问题
11.5.2 分析
11.5.3 解决方案
11.6 小结
11.7 习题
第12章 处理文件
12.1 文件的概念
12.1.1 文件中的位置
12.1.2 文件流
12.2 文件访问
12.2.1 打开文件
12.2.2 缓存文件操作
12.2.3 文件重命名
12.2.4 关闭文件
12.2.5 删除文件
12.3 写入文本文件
12.4 读取文本文件
12.5 在文本文件中读写字符串
12.6 格式化文件的输入输出
12.6.1 格式化文件输出
12.6.2 格式化文件输入
12.7 错误处理
12.8 再探文本文件操作模式
12.9 freopen_s()函数
12.10 二进制文件的输入输出
12.10.1 以二进制模式打开文件
12.10.2 写入二进制文件
12.10.3 读取二进制文件
12.11 在文件中移动
12.11.1 文件定位操作
12.11.2 找出我们在文件中的位置
12.11.3 在文件中设定位置
12.12 使用临时文件
12.12.1 创建临时文件
12.12.2 创建唯一的文件名
12.13 更新二进制文件
12.13.1 修改文件的内容
12.13.2 从键盘输入创建记录
12.13.3 将记录写入文件
12.13.4 从文件中读取记录
12.13.5 写入文件
12.13.6 列出文件内容
12.13.7 更新已有的文件内容
12.14 文件打开模式小结
12.15 设计程序
12.15.1 问题
12.15.2 分析
12.15.3 解决方案
12.16 小结
12.17 习题
第13章 支持功能
13.1 预处理
13.1.1 在程序中包含头文件
13.1.2 定义自己的头文件
13.1.3 管理多个源文件
13.1.4 外部变量
13.1.5 静态函数
13.1.6 替换程序源代码
13.2 宏
13.2.1 看起来像函数的宏
13.2.2 字符串作为宏参数
13.2.3 在宏展开式中结合两个变元
13.3 多行上的预处理器指令
13.3.1 预处理器逻辑指令
13.3.2 条件编译
13.3.3 测试多个条件
13.3.4 取消定义的标识符
13.3.5 测试标识符的指定值的指令
13.3.6 多项选择
13.3.7 标准预处理宏
13.4 调试方法
13.4.1 集成的调试器
13.4.2 调试阶段的预处理器
13.4.3 断言
13.5 日期和时间函数
13.5.1 获取时间值
13.5.2 获取日期
13.5.3 确定某一天是星期几
13.6 小结
13.7 习题
第14章 高级专用主题
14.1 使用国际字符集
14.1.1 理解Unicode
14.1.2 设置区域
14.1.3 宽字符类型wchar_t
14.1.4 宽字符串的操作
14.1.5 宽字符的文件流操作
14.1.6 存储Unicode字符的固定大小类型
14.2 用于可移植性的专用整数类型
14.2.1 固定宽度的整型
14.2.2 最小宽度的整型
14.2.3 最大宽度的整型
14.3 复数类型
14.3.1 复数基础
14.3.2 复数类型和操作
14.4 用线程编程
14.4.1 创建线程
14.4.2 退出线程
14.4.3 把一个线程连接到另一个线程上
14.4.4 挂起线程
14.4.5 管理线程对数据的访问
14.5 小结
附录A 计算机中的数学知识
附录B ASCII字符代码定义
附录C C语言中的保留字
附录D 输入输出格式说明符
附录E 标准库头文件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言入门经典（第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和C++安全编码
译者序
序
前言
致谢
第1章 夹缝求生 1
1.1 衡量危险 4
1.1.1 损失的现状 4
1.1.2 威胁的来源 6
1.1.3 软件安全 7
1.2 安全概念 8
1.2.1 安全策略 9
1.2.2 安全缺陷 10
1.2.3 漏洞 10
1.2.4 漏洞利用 11
1.2.5 缓解措施 12
1.3 C和C++ 12
1.3.1 C和C++简史 13
1.3.2 C存在的问题 14
1.3.3 遗留代码 17
1.3.4 其他语言 17
1.4 开发平台 17
1.4.1 操作系统 18
1.4.2 编译器 18
1.5 小结 18
1.6 阅读材料 19
第2章 字符串 20
2.1 字符串 20
2.1.1 字符串数据类型 20
2.1.2 UTF-8 22
2.1.3 宽字符串 23
2.1.4 字符串字面值 23
2.1.5 C++中的字符串 25
2.1.6 字符类型 26
2.1.7 计算字符串大小 27
2.2 常见的字符串操作错误 29
2.2.1 无界字符串复制 29
2.2.2 差一错误 32
2.2.3 空字符结尾错误 33
2.2.4 字符串截断 34
2.2.5 与函数无关的字符串错误 34
2.3 字符串漏洞及其利用 35
2.3.1 被污染的数据 35
2.3.2 IsPasswordOK()的安全缺陷 36
2.3.3 缓冲区溢出 37
2.3.4 进程内存组织 37
2.3.5 栈管理 38
2.3.6 栈溢出 40
2.3.7 代码注入 44
2.3.8 弧注入 47
2.3.9 返回导向编程 48
2.4 字符串漏洞缓解策略 49
2.4.1 字符串处理 49
2.4.2 C11附录K边界检查接口 50
2.4.3 动态分配函数 52
2.4.4 C++ std::basic_string 54
2.4.5 使字符串对象的引用失效 55
2.4.6 使用basic_string的其他常见错误 57
2.5 字符串处理函数 57
2.5.1 gets() 57
2.5.2 C99 57
2.5.3 C11附录K边界检查接口：gets_s() 59
2.5.4 动态分配函数 60
2.5.5 strcpy()和strcat() 61
2.5.6 C99 61
2.5.7 strncpy()和strncat() 64
2.5.8 memcpy()和memmove() 68
2.5.9 strlen() 68
2.6 运行时保护策略 69
2.6.1 检测和恢复 69
2.6.2 输入验证 70
2.6.3 对象大小检查 70
2.6.4 Visual Studio中编译器生成的运行时检查 73
2.6.5 栈探测仪 74
2.6.6 栈溢出保护器 75
2.6.7 操作系统策略 76
2.6.8 检测和恢复 76
2.6.9 不可执行栈 77
2.6.10 W^X 77
2.6.11 PaX 79
2.6.12 未来发展方向 79
2.7 著名的漏洞 80
2.7.1 远程登录 80
2.7.2 Kerberos 81
2.8 小结 81
2.9 阅读材料 82
第3章 指针诡计 83
3.1 数据位置 83
3.2 函数指针 84
3.3 对象指针 85
3.4 修改指令指针 86
3.5 全局偏移表 87
3.6 .dtors区 89
3.7 虚指针 90
3.8 atexit()和on_exit()函数 91
3.9 longjmp()函数 93
3.10 异常处理 94
3.10.1 结构化异常处理 94
3.10.2 系统默认异常处理 96
3.11 缓解策略 96
3.11.1 栈探测仪 96
3.11.2 W^X 97
3.11.3 对函数指针编码和解码 97
3.12 小结 98
3.13 阅读材料 98
第4章 动态内存管理 99
4.1 C内存管理 100
4.1.1 C标准内存管理函数 100
4.1.2 对齐 101
4.1.3 alloca()和变长数组 102
4.2 常见的C内存管理错误 103
4.2.1 初始化错误 103
4.2.2 未检查返回值 104
4.2.3 Null或无效指针解引用 106
4.2.4 引用已释放内存 106
4.2.5 多次释放内存 107
4.2.6 内存泄漏 108
4.2.7 零长度分配 108
4.2.8 DR # 400 110
4.3 C++的动态内存管理 110
4.3.1 分配函数 111
4.3.2 释放函数 115
4.3.3 垃圾回收 115
4.4 常见的C++内存管理错误 117
4.4.1 未能正确检查分配失败 117
4.4.2 不正确配对的内存管理函数 118
4.4.3 多次释放内存 120
4.4.4 释放函数抛出一个异常 123
4.5 内存管理器 123
4.6 Doug Lea的内存分配器 124
4.7 双重释放漏洞 131
4.7.1 写入已释放的内存 134
4.7.2 RtlHeap 135
4.7.3 缓冲区溢出（终极版） 140
4.8 缓解策略 146
4.8.1 空指针 146
4.8.2 一致的内存管理约定 146
4.8.3 phkmalloc 147
4.8.4 随机化 148
4.8.5 OpenBSD 148
4.8.6 jemalloc内存管理器 149
4.8.7 静态分析 149
4.8.8 运行时分析工具 150
4.9 值得注意的漏洞 153
4.9.1 CVS缓冲区溢出漏洞 153
4.9.2 Microsoft数据访问组件 153
4.9.3 CVS服务器双重释放漏洞 154
4.9.4 MIT Kerberos 5中的漏洞 154
4.10 小结 154
第5章 整数安全 155
5.1 整数安全导论 155
5.2 整数数据类型 156
5.2.1 无符号整数类型 156
5.2.2 回绕 157
5.2.3 有符号整数类型 159
5.2.4 有符号整数的取值范围 162
5.2.5 整数溢出 163
5.2.6 字符类型 165
5.2.7 数据模型 165
5.2.8 其他整数类型 166
5.3 整数转换 169
5.3.1 转换整数 169
5.3.2 整数转换级别 169
5.3.3 整数类型提升 170
5.3.4 普通算术转换 171
5.3.5 由无符号整数类型转换 171
5.3.6 由有符号整数类型转换 173
5.3.7 转换的影响 176
5.4 整数操作 176
5.4.1 赋值 177
5.4.2 加法 179
5.4.3 减法 183
5.4.4 乘法 185
5.4.5 除法和求余 188
5.4.6 移位 192
5.5 整数漏洞 194
5.5.1 漏洞 194
5.5.2 回绕 194
5.5.3 转换和截断错误 196
5.5.4 非异常的整数逻辑错误 197
5.6 缓解策略 198
5.6.1 整数类型的选择 198
5.6.2 抽象数据类型 200
5.6.3 任意精度算术 200
5.6.4 范围检查 201
5.6.5 前提条件和后验条件测试 203
5.6.6 安全整数库 204
5.6.7 溢出检测 205
5.6.8 编译器生成的运行时检查 206
5.6.9 可验证范围操作 207
5.6.10 仿佛无限范围整数模型 208
5.6.11 测试与分析 208
5.7 小结 210
第6章 格式化输出 211
6.1 变参函数 212
6.2 格式化输出函数 214
6.2.1 格式字符串 215
6.2.2 GCC 216
6.2.3 Visual C++ 217
6.3 对格式化输出函数的漏洞利用 217
6.3.1 缓冲区溢出 218
6.3.2 输出流 219
6.3.3 使程序崩溃 219
6.3.4 查看栈内容 219
6.3.5 查看内存内容 221
6.3.6 覆写内存 222
6.3.7 国际化 226
6.3.8 宽字符格式字符串漏洞 226
6.4 栈随机化 226
6.4.1 阻碍栈随机化 227
6.4.2 以双字的格式写地址 227
6.4.3 直接参数访问 228
6.5 缓解策略 230
6.5.1 排除用户输入的格式字符串 230
6.5.2 静态内容的动态使用 230
6.5.3 限制字节写入 231
6.5.4 C11附录K边界检查接口 232
6.5.5 iostream与stdio 233
6.5.6 测试 234
6.5.7 编译器检查 234
6.5.8 静态污点分析 234
6.5.9 调整变参函数的实现 235
6.5.10 Exec Shield 236
6.5.11 FormatGuard 236
6.5.12 静态二进制分析 237
6.6 著名的漏洞 238
6.6.1 华盛顿大学FTP Daemon 238
6.6.2 CDE ToolTalk 238
6.6.3 Ettercap NG-0.7.2版 238
6.7 小结 239
6.8 阅读材料 240
第7章 并发 241
7.1 多线程 241
7.2 并行 242
7.2.1 数据并行 243
7.2.2 任务并行 245
7.3 性能目标 245
7.4 常见错误 247
7.4.1 竞争条件 247
7.4.2 损坏的值 248
7.4.3 易变的对象 249
7.5 缓解策略 250
7.5.1 内存模型 251
7.5.2 同步原语 253
7.5.3 线程角色分析（研究） 259
7.5.4 不可变的数据结构 260
7.5.5 并发代码属性 261
7.6 缓解陷阱 261
7.6.1 死锁 262
7.6.2 过早释放锁 266
7.6.3 争用 267
7.6.4 ABA问题 268
7.7 值得注意的漏洞 272
7.7.1 在多核动态随机访问存储器系统中的DoS攻击 272
7.7.2 系统调用包装器中的并发漏洞 272
7.8 小结 273
第8章 文件I/O 275
8.1 文件I/O基础 275
8.1.1 文件系统 275
8.1.2 特殊文件 277
8.2 文件I/O接口 278
8.2.1 数据流 278
8.2.2 打开和关闭文件 279
8.2.3 POSIX 280
8.2.4 C++中的文件I/O 281
8.3 访问控制 282
8.3.1 UNIX文件权限 282
8.3.2 进程特权 284
8.3.3 更改特权 285
8.3.4 管理特权 288
8.3.5 管理权限 292
8.4 文件鉴定 295
8.4.1 目录遍历 295
8.4.2 等价错误 297
8.4.3 符号链接 298
8.4.4 规范化 300
8.4.5 硬链接 302
8.4.6 设备文件 304
8.4.7 文件属性 306
8.5 竞争条件 308
8.5.1 检查时间和使用时间 308
8.5.2 创建而不替换 309
8.5.3 独占访问 312
8.5.4 共享目录 313
8.6 缓解策略 315
8.6.1 关闭竞争窗口 315
8.6.2 消除竞争对象 319
8.6.3 控制对竞争对象的访问 320
8.6.4 竞争检测工具 322
8.7 小结 322
第9章 推荐的实践 324
9.1 安全开发生命周期 324
9.1.1 TSP-Secure 326
9.1.2 计划和跟踪 327
9.1.3 质量管理 328
9.2 安全培训 329
9.3 要求 330
9.3.1 安全编码标准 330
9.3.2 安全质量需求工程 330
9.3.3 用例/误用例 332
9.4 设计 333
9.4.1 安全的软件开发原则 334
9.4.2 威胁建模 337
9.4.3 分析攻击面 338
9.4.4 现有代码中的漏洞 338
9.4.5 安全包装器 339
9.4.6 输入验证 339
9.4.7 信任边界 340
9.4.8 黑名单 342
9.4.9 白名单 343
9.4.10 测试 343
9.5 实现 344
9.5.1 编译器检查 344
9.5.2 仿佛无限范围整数模型 345
9.5.3 有安全保证的C/C++ 345
9.5.4 静态分析 346
9.5.5 源代码分析实验室 348
9.5.6 深层防御 349
9.6 验证 350
9.6.1 静态分析 350
9.6.2 渗透测试 350
9.6.3 模糊测试 351
9.6.4 代码审计 352
9.6.5 开发人员准则与检查清单 352
9.6.6 独立安全审查 353
9.6.7 攻击面回顾 353
9.7 小结 354
9.8 阅读材料 354
参考文献 355
缩略语 373
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C和C++安全编码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言的科学和艺术
译者序
前言
第1章 概述
1.1 计算简史
1.2 什么是计算机科学
1.3 计算机硬件简介
1.3.1 cpu
1.3.2 内存
1.3.3 辅助存储器
1.3.4 i/o设备
1.4 算法
1.5 程序设计语言和编译
1.6 编程错误和调试
1.7 软件维护
1.8 软件工程的重要性
1.9 关于c程序设计语言的一些思考
小结
复习题
第一部分 c语言程序设计基础
第2章 通过例子学习
2.1 “hello world”程序
2.1.1 注释
2.1.2 库包含
2.1.3 主程序
2.2 两个数的加法程序
2.2.1 输入阶段
2.2.2 计算阶段
2.2.3 输出阶段
2.3 有关程序设计过程的观点
2.4 数据类型
2.4.1 浮点型数据
2.4.2 字符串类型的数据
2.5 表达式
2.5.1 常量
2.5.2 变量
2.5.3 赋值语句
2.5.4 运算符和操作数
2.5.5 整型数和浮点型数的结合
2.5.6 整数除法和求余运算符
2.5.7 优先级
2.5.8 优先级法则的应用
2.5.9 类型转换
小结
复习题
程序设计练习
第3章 问题求解
3.1 程序设计习语和范例
3.1.1 复合赋值习语
3.1.2 自增和自减运算符
3.2 解决规模稍大的问题
3.3 控制语句
3.3.1 重复n次习语
3.3.2 迭代和循环
3.3.3 下标变量
3.3.4 初始化的重要性
3.3.5 读入-直到-标志习语
3.3.6 创造一个更实用的应用程序
3.3.7 条件执行和if语句
3.4 一个调试练习
3.5 格式化输出
3.5.1 printf的格式码
3.5.2 控制空格、对齐方式和精度
3.6 构思一个程序
3.6.1 程序设计风格
3.6.2 设计时考虑将来的修改
3.6.3 #define机制
小结
复习题
程序设计练习
第4章 语句形式
4.1 简单语句
4.1.1 赋值的嵌套
4.1.2 多重赋值
4.1.3 程序块
4.2 控制语句
4.3 布尔型数据
4.3.1 关系运算符
4.3.2 逻辑运算符
4.3.3 简化求值
4.3.4 标志
4.3.5 避免布尔表达式中的冗余
4.3.6 布尔计算示例
4.4 if语句
4.4.1 单行if语句
4.4.2 多行if语句
4.4.3 if/else语句
4.4.4 级联if语句
4.4.5 ?: 运算符（可选的）
4.5 switch语句
4.6 while语句
4.6.1 while循环的应用
4.6.2 无限循环
4.6.3 解决半途退出问题
4.7 for语句
4.7.1 嵌套的for循环
4.7.2 for和while的关系
4.7.3 for语句中浮点型数据的使用问题
小结
复习题
程序设计练习
第5章 函数
5.1 使用库函数
5.2 函数声明
5.3 自己编写函数
5.3.1 return语句
5.3.2 将函数与主程序放在一起
5.3.3 包含内部控制结构的函数
5.3.4 返回非数字值的函数
5.3.5 谓词函数
5.3.6 测试字符串是否相等的谓词函数
5.4 函数调用过程机制
5.4.1 参数传递
5.4.2 在其他函数中调用函数
5.5 过程
5.6 逐步精化
5.6.1 从顶开始
5.6.2 实现printcalendar
5.6.3 实现printcalendarmonth
5.6.4 完成最后的片段
小结
复习题
程序设计练习
第6章 算法
6.1 测试素数
6.1.1 一个isprime的简单版本
6.1.2 验证一个策略是否表示一个算法
6.1.3 说明isprime算法的正确性
6.1.4 改进算法的效率
6.1.5 在各个可选方案中选择
6.2 计算最大公约数
6.2.1 brute-force算法
6.2.2 欧几里得算法
6.2.3 欧几里得算法的正确性说明（可选）
6.2.4 比较gcd算法的效率
6.3 数值算法
6.3.1 连续逼近
6.3.2 报告错误
6.4 级数展开
6.4.1 zeno悖论
6.4.2 用级数展开法设计平方根函数
6.4.3 估计平方根的泰勒级数展开 （可选）
6.4.4 泰勒级数近似的实现
6.4.5 停留在收敛半径之内
6.5 指定数值类型的大小
6.5.1 整数类型
6.5.2 无符号类型
6.5.3 浮点类型
小结
复习题
程序设计练习
第二部分 库和模块化开发
第7章 库和接口：一个简单的图形库
7.1 接口的概念
7.2 图形库介绍
7.2.1 graphics.h的基本模型
7.2.2 graphics.h接口的函数
7.2.3 软件包初始化
7.2.4 画直线
7.2.5 画圆和弧
7.2.6 获取有关图形窗口的信息
7.3 建立自己的工具
7.3.1 定义drawbox
7.3.2 定义drawcenteredcircle
7.3.3 绝对坐标和相对坐标间的切换
7.3.4 定义过程的好处
7.4 解决一个较大的问题
7.4.1 使用逐步精化
7.4.2 实现drawhouse过程
7.4.3 寻找共同的模式
7.4.4 结束分解
小结
复习题
程序设计练习
第8章 设计接口：一个随机数库
8.1 接口设计
8.1.1 同一主题的重要性
8.1.2 简单性和信息隐藏的原则
8.1.3 满足客户的需要
8.1.4 通用工具的优势
8.1.5 稳定性的价值
8.2 用计算机生成随机数
8.2.1 确定行为与非确定行为
8.2.2 随机数和伪随机数
8.2.3 ansi c中生成伪随机数
8.2.4 改变随机数的范围
8.2.5 将此问题通用化
8.3 在库中保存工具
8.3.1 接口的内容
8.3.2 写random.h接口
8.3.3 random.c的实现
8.3.4 构造客户程序
8.3.5 初始化随机数发生器
8.4 评价random.h接口的设计
8.4.1 产生随机实数
8.4.2 模拟一个概率事件
8.4.3 在接口中包含头文件
8.4.4 完成随机数软件包的实现
8.5 使用随机数软件包
小结
复习题
程序设计练习
第9章 字符串和字符
9.1 枚举的原理
9.1.1 在机器内部表示枚举类型
9.1.2 将枚举类型表示为整数
9.1.3 定义新的枚举类型
9.1.4 枚举类型的操作
9.1.5 标量类型
9.2 字符
9.2.1 数据类型char
9.2.2 ascii代码
9.2.3 字符常量
9.2.4 ascii代码方案的重要特性
9.2.5 特殊字符
9.2.6 字符运算
9.2.7 ctype.h接口
9.2.8 涉及字符的控制语句
9.2.9 字符的输入输出
9.3 字符串作为抽象数据类型
9.3.1 分层抽象
9.3.2 抽象类型的概念
9.4 strlib.h接口
9.4.1 确定字符串的长度
9.4.2 从一个字符串中选择字符
9.4.3 连接
9.4.4 将字符转换为字符串
9.4.5 抽取字符串的一部分
9.4.6 比较两个字符串
9.4.7 在一个字符串内搜索
9.4.8 大小写转换
9.4.9 数值转换
9.4.10 效率和strlib.h库
小结
复习题
程序设计练习
第10章 模块化开发
10.1 pig latin-一个模块化开发的 案例研究
10.1.1 应用自顶向下的设计
10.1.2 使用伪代码
10.1.3 实现translateline
10.1.4 考虑空格和标点符号的问题
10.1.5 精化单词的定义
10.1.6 设计记号扫描器
10.1.7 完成translateline的实现
10.1.8 定义扫描器模块接口
10.2 在模块中维护内部状态
10.2.1 全局变量
10.2.2 使用全局变量的危险性
10.2.3 保持变量的模块私有化
10.2.4 初始化全局变量
10.2.5 私有函数
10.3 实现扫描器抽象
小结
复习题
程序设计练习
第三部分 复合数据类型
第11章 数组
11.1 数组
11.1.1 数组声明
11.1.2 数组选择
11.1.3 一个简单的数组实例
11.1.4 改变下标值的范围
11.2 数据的内部表示法
11.2.1 比特、字节和字
11.2.2 内存地址
11.2.3 运算符sizeof
11.2.4 变量的内存分配
11.2.5 引用超出数组范围的元素
11.3 数组作为参数进行传递
11.3.1 元素个数的通用化
11.3.2 数组参数传递机制
11.3.3 实现函数printintegerarray和getintegerarray
11.3.4 实现函数reverseintegerarray
11.3.5 实现函数swapintegerelements
11.4 使用数组制作表格
11.5 数组的静态初始化
11.5.1 自动确定数组大小
11.5.2 确定初始化数组的大小
11.5.3 初始化数组和标量类型
11.6 多维数组
11.6.1 向函数传送多维数组
11.6.2 初始化多维数组
小结
复习题
程序设计练习
第12章 查找和排序
12.1 查找
12.1.1 在整数数组中查找
12.1.2 关于查找的另一个更复杂 的例子
12.1.3 线性查找
12.1.4 二分查找
12.1.5 查找算法的相对效率
12.2 排序
12.2.1 对一个整数数组排序
12.2.2 选择排序算法
12.2.3 选择排序效率的评估
12.2.4 测试程序的运行时间
12.2.5 选择排序的算法分析
小结
复习题
程序设计练习
第13章 指针
13.1 将地址作为数据值
13.2 c语言的指针操作
13.2.1 在c语言中声明指针变量
13.2.2 基本的指针操作
13.2.3 特殊指针null
13.3 通过引用传递参数
13.3.1 设计函数swapinteger
13.3.2 用引用调用返回多个结果
13.3.3 过度使用引用调用的危险
13.4 指针和数组
13.4.1 指针运算
13.4.2 运算符＋＋和－－的新作用
13.4.3 指针的自增和自减
13.4.4 指针和数组的关系
13.5 动态分配
13.5.1 void *类型
13.5.2 动态数组
13.5.3 查找malloc中的错误
13.5.4 释放内存
小结
复习题
程序设计练习
第14章 再论字符串
14.1 string类型的概念表示
14.1.1 字符串作为数组
14.1.2 字符串作为指针
14.1.3 字符串作为抽象类型
14.1.4 字符串参数
14.1.5 字符串变量
14.1.6 指针和数组变量间的区别
14.1.7 决定字符串的表示方法
14.2 ansi字符串库
14.2.1 strcpy函数
14.2.2 strncpy函数
14.2.3 strcat和strncat函数
14.2.4 strlen、strcmp和strncmp函数
14.2.5 strchr、strrchr和strstr函数
14.2.6 ansi字符串函数的应用
14.3 strlib库的实现
14.3.1 实现转换函数
14.3.2 strlib分配函数的实现
小结
复习题
程序设计练习
第15章 文件
15.1 文本文件
15.2 c语言中文件的使用
15.2.1 声明file*类型的变量
15.2.2 打开文件
15.2.3 执行i/o操作
15.2.4 关闭文件
15.2.5 标准文件
15.3 字符i/o
15.3.1 文件更新
15.3.2 在输入文件中重新读取字符
15.4 面向行的i/o
15.5 格式化i/o
15.5.1 printf的三种形式
15.5.2 scanf函数
15.5.3 用scanf读入字符串
15.5.4 格式化i/o的一个实例
15.5.5 使用scanf的局限
小结
复习题
程序设计练习
第16章 记录
16.1 数据记录的概念
16.2 记录在c语言中的使用
16.2.1 定义一个结构类型
16.2.2 声明结构变量
16.2.3 记录选择
16.2.4 记录初始化
16.2.5 简单记录
16.3 数组与记录的结合
16.4 记录的指针
16.4.1 定义一个指向记录类型的指针
16.4.2 为记录数据分配空间
16.4.3 对记录指针进行操作
16.5 创建记录的数据库
16.5.1 创建员工信息数据库
16.5.2 数据库的使用
16.6 基于记录的应用程序设计
16.6.1 使用数据库的重要性
16.6.2 问题的框架
16.6.3 设计内部表示
16.6.4 设计外部结构
16.6.5 程序代码
16.6.6 数据驱动设计方法的重要性
小结
复习题
程序设计练习
第17章 深入学习
17.1 递归
17.1.1 递归的简单说明
17.1.2 factorial函数
17.1.3 递归信任
17.1.4 递归范例
17.1.5 排列的生成
17.1.6 用递归的思想思考
17.2 抽象数据类型
17.2.1 队列抽象
17.2.2 以队列抽象表示类型
17.2.3 queue.h 接口
17.2.4 实现队列抽象
17.2.5 队列抽象的另一种实现方法
17.3 算法分析
17.3.1 评估算法效率
17.3.2 标记
17.3.3 再看选择排序
17.3.4 分而治之策略
17.3.5 合并两个数组
17.3.6 合并排序算法
17.3.7 合并排序的计算复杂性
17.3.8 比较平方复杂性与nlogn复杂性的性能
小结
复习题
程序设计练习
附 录
附录a c语言的语法和结构总结
附录b 库源代码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言的科学和艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#本质论
第1章　C#概述　1
1.1　Hello, World　1
1.2　C#语法基础　3
1.2.1　C#关键字　3
1.2.2　类型定义　5
1.2.3　Main　5
1.2.4　语句和语句分隔符　7
1.2.5　空白　7
1.3　使用变量　8
1.3.1　数据类型　9
1.3.2　变量的声明　9
1.3.3　变量的赋值　10
1.3.4　变量的使用　11
1.4　控制台输入和输出　11
1.4.1　从控制台获取输入　11
1.4.2　将输出写入控制台　13
1.5　注释　14
1.6　托管执行和公共语言基础结构　16
1.7　C#和.NET版本　18
1.8　CIL和ILDASM　18
.1.9　小结　21
第2章　数据类型　22
2.1　基本数值类型　22
2.1.1　整数类型　22
2.1.2　浮点类型　23
2.1.3　decimal类型　24
2.1.4　字面值　24
2.2　更多基本类型　28
2.2.1　布尔类型　28
2.2.2　字符类型　28
2.2.3　字符串　30
2.3　null和void　36
2.3.1　null　36
2.3.2　void　36
2.4　类型的分类　38
2.4.1　值类型　38
2.4.2　引用类型　39
2.5　可空修饰符　40
2.6　数据类型之间的转换　41
2.6.1　显式转型　41
2.6.2　隐式转型　43
2.6.3　不进行转型的类型转换　44
2.7　数组　45
2.7.1　数组的声明　46
2.7.2　数组的实例化和赋值　46
2.7.3　数组的使用　50
2.7.4　字符串作为数组使用　54
2.7.5　常见错误　56
2.8　小结　57
第3章　运算符和控制流　58
3.1　运算符　58
3.1.1　一元运算符正和负　59
3.1.2　二元算术运算符　59
3.1.3　圆括号运算符　65
3.1.4　赋值运算符　65
3.1.5　递增和递减运算符　66
3.1.6　常量表达式　68
3.2　流控制概述　69
3.2.1　if语句　71
3.2.2　嵌套if　71
3.3　代码块　73
3.4　作用域和声明空间　75
3.5　布尔表达式　76
3.5.1　关系运算符和相等性运算符　77
3.5.2　逻辑布尔运算符　78
3.5.3　逻辑求反运算符　79
3.5.4　条件运算符　79
3.5.5　空接合运算符　80
3.6　按位运算符　81
3.6.1　移位运算符　82
3.6.2　按位运算符　82
3.6.3　按位赋值运算符　84
3.6.4　按位取反运算符　85
3.7　控制流语句　85
3.7.1　while和do/while循环　85
3.7.2　for循环　87
3.7.3　foreach循环　89
3.7.4　switch语句　92
3.8　跳转语句　94
3.8.1　break语句　94
3.8.2　continue语句　96
3.8.3　goto语句　97
3.9　C#预处理器指令　99
3.9.1　排除和包含代码　100
3.9.2　定义预处理器符号　100
3.9.3　生成错误和警告　101
3.9.4　关闭警告消息　101
3.9.5　nowarn:[warn list]选项　102
3.9.6　指定行号　102
3.9.7　可视编辑器提示　103
3.10　小结　104
第4章　方法和参数　106
4.1　方法的调用　107
4.1.1　命名空间　108
4.1.2　类型名称　109
4.1.3　作用域　110
4.1.4　方法名称　110
4.1.5　参数　110
4.1.6　方法返回值　110
4.1.7　语句与方法调用的比较　111
4.2　方法的声明　111
4.2.1　参数声明　113
4.2.2　方法返回值声明　113
4.3　using指令　114
4.4　Main()的返回值和参数　117
4.5　参数　120
4.5.1　值参数　120
4.5.2　引用参数　121
4.5.3　输出参数　122
4.5.4　参数数组　124
4.6　递归　126
4.7　方法重载　128
4.8　可选参数　131
4.9　用异常实现基本错误处理　134
4.9.1　捕捉错误　135
4.9.2　使用throw语句报告错误　141
4.10　小结　143
第5章　类　145
5.1　类的定义和实例化　148
5.2　实例字段　150
5.2.1　实例字段的声明　150
5.2.2　实例字段的访问　151
5.3　实例方法　152
5.4　使用this关键字　153
5.5　访问修饰符　159
5.6　属性　161
5.6.1　属性的声明　162
5.6.2　自动实现的属性　164
5.6.3　命名规范　165
5.6.4　提供属性验证　166
5.6.5　只读和只写属性　167
5.6.6　为取值方法和赋值方法指定访问修饰符　168
5.6.7　属性作为虚字段使用　170
5.6.8　属性和方法调用不允许作为ref或out参数值使用　171
5.7　构造器　173
5.7.1　构造器的声明　173
5.7.2　默认构造器　175
5.7.3　对象初始化器　175
5.7.4　构造器的重载　177
5.7.5　使用this调用另一个构造器　178
5.8　静态成员　181
5.8.1　静态字段　182
5.8.2　静态方法　184
5.8.3　静态构造器　186
5.8.4　静态属性　187
5.8.5　静态类　187
5.9　扩展方法　189
5.10　封装数据　190
5.10.1　const　190
5.10.2　readonly　191
5.11　嵌套类　192
5.12　分部类　194
5.12.1　定义分部类　194
5.12.2　分部方法　195
5.13　小结　197
第6章　继承　198
6.1　派生　198
6.1.1　基类型和派生类型之间的转型　201
6.1.2　private访问修饰符　202
6.1.3　protected访问修饰符　203
6.1.4　扩展方法　205
6.1.5　单一继承　205
6.1.6　密封类　207
6.2　基类的重写　207
6.2.1　virtual修饰符　208
6.2.2　new修饰符　211
6.2.3　sealed修饰符　215
6.2.4　base成员　215
6.2.5　构造器　216
6.3　抽象类　217
6.4　所有类都从System.Object派生　221
6.5　使用is运算符验证基础类型　222
6.6　使用as运算符进行转换　223
6.7　小结　224
第7章　接口　226
7.1　接口概述　226
7.2　通过接口来实现多态性　227
7.3　接口实现　232
7.3.1　显式成员实现　234
7.3.2　隐式成员实现　235
7.3.3　显式接口实现与隐式接口实现的比较　235
7.4　“实现类”与其接口之间的转型　236
7.5　接口继承　237
7.6　多接口继承　239
7.7　接口上的扩展方法　239
7.8　通过接口来实现多重继承　241
7.9　版本控制　243
7.10　接口与类的比较　245
7.11　小结　245
第8章　值类型　246
8.1　结构　246
8.1.1　struct的初始化　249
8.1.2　default运算符的使用　251
8.1.3　值类型的继承和接口　251
8.2　装箱　251
8.3　枚举　257
8.3.1　枚举之间的类型兼容性　259
8.3.2　枚举和字符串之间的转换　260
8.3.3　枚举作为标志使用　261
8.4　小结　265
第9章　合式类型　266
9.1　重写object的成员　266
9.1.1　重写ToString()　266
9.1.2　重写GetHashCode()　267
9.1.3　重写Equals()　269
9.1.4　相等性实现的指导原则　275
9.2　运算符重载　275
9.2.1　比较运算符　275
9.2.2　二元运算符　276
9.2.3　赋值运算符与二元运算符的结合　278
9.2.4　条件逻辑运算符　279
9.2.5　一元运算符　279
9.2.6　转换运算符　280
9.2.7　转换运算符的指导原则　282
9.3　引用其他程序集　282
9.3.1　更改程序集目标　282
9.3.2　引用程序集　283
9.3.3　类型封装　283
9.4　定义命名空间　285
9.5　XML注释　287
9.5.1　将XML注释与代码构造关联到一起　288
9.5.2　生成XML文档文件　290
9.6　垃圾回收　291
9.7　资源清理　293
9.7.1　终结器　293
9.7.2　使用using语句进行确定性终结　295
9.7.3　垃圾回收和终结　297
9.7.4　资源利用和终结的指导原则　299
9.8　延迟初始化　299
9.9　小结　301
第10章　异常处理　302
10.1　多异常类型　302
10.2　捕捉异常　303
10.3　常规catch块　305
10.4　异常处理的指导原则　306
10.5　定义自定义异常　308
10.6　小结　312
第11章　泛型　313
11.1　如果C#没有泛型　313
11.2　泛型类型概述　318
11.2.1　泛型类的使用　318
11.2.2　简单泛型类的定义　320
11.2.3　泛型的优点　321
11.2.4　类型参数命名的指导原则　321
11.2.5　泛型接口和struct　321
11.2.6　构造器和终结器的定义　323
11.2.7　默认值的指定　324
11.2.8　多个类型参数　325
11.2.9　元数　326
11.2.10　嵌套泛型类型　327
11.3　约束　328
11.3.1　接口约束　331
11.3.2　基类约束　332
11.3.3　struct/class约束　332
11.3.4　多个约束　333
11.3.5　构造器约束　334
11.3.6　约束继承　334
11.4　泛型方法　339
11.4.1　类型推断　340
11.4.2　约束的指定　341
11.5　协变性和逆变性　342
11.5.1　在C# 4.0中使用out类型参数修饰符允许协变性　343
11.5.2　在C# 4.0中使用in类型参数修饰符允许逆变性　345
11.5.3 数组的协变性和逆变性　347
11.6　泛型的内部机制　347
11.6.1　基于值类型的泛型的实例化　348
11.6.2　基于引用类型的泛型实例化　349
11.7　小结　350
第12章　委托和Lambda表达式　351
12.1　委托概述　351
12.1.1　背景　351
12.1.2　委托数据类型　353
12.1.3　委托的内部机制　355
12.1.4　委托类型的定义　355
12.1.5　委托的实例化　356
12.2　匿名方法　361
12.3　系统定义的委托：Func[]　363
12.4　Lambda表达式　365
12.4.1　语句Lambda　365
12.4.2　表达式Lambda　368
12.4.3　外部变量　371
12.4.4　表达式树　374
12.5　小结　379
第13章　事件　380
13.1　使用多播委托来编码Observer模式　380
13.1.1　定义订阅者方法　381
13.1.2　定义发布者　382
13.1.3　连接发布者和订阅者　383
13.1.4　调用委托　384
13.1.5　检查空值　385
13.1.6　委托运算符　386
13.1.7　顺序调用　387
13.1.8　错误处理　390
13.1.9　方法返回值和传引用　392
13.2　事件　393
13.2.1　事件的作用　393
13.2.2　事件的声明　395
13.2.3　编码规范　396
13.2.4　泛型和委托　397
13.2.5　自定义事件的实现　400
13.3　小结　401
第14章　支持标准查询运算符的集合接口　402
14.1　匿名类型和隐式类型的局部变量声明　403
14.1.1　匿名类型　403
14.1.2　隐式类型的局部变量(var)　404
14.1.3　匿名类型和隐式局部变量的更多注意事项　405
14.2　集合初始化器　408
14.3　是什么使类成为一个集合：IEnumerable[T]　410
14.3.1　foreach和数组　410
14.3.2　foreach和IEnumerable[T]　411
14.3.3　foreach循环内不要修改集合　415
14.4　标准查询运算符　415
14.4.1　使用Where()来筛选　418
14.4.2　使用Select()来投射　420
14.4.3　用Count()对元素进行计数　422
14.4.4　推迟执行　423
14.4.5　使用OrderBy()和ThenBy()来排序　427
14.4.6　使用Join()来执行内部联接　432
14.4.7　使用GroupBy分组结果　435
14.4.8　使用GroupJoin()实现一对多关系　436
14.4.9　调用SelectMany()　439
14.4.10　更多标准查询运算符　441
14.5　小结　444
第15章　使用查询表达式的LINQ　445
15.1　查询表达式概述　445
15.1.1　投射　447
15.1.2　筛选　453
15.1.3　排序　454
15.1.4　let子句　454
15.1.5　分组　456
15.1.6　使用into进行查询延续　459
15.2　查询表达式作为方法调用　461
15.3　小结　462
第16章　构建自定义集合　463
16.1　更多集合接口　464
16.1.1　IList[T]与IDictionary [TKey,TValue]　465
16.1.2　IComparable[T]　465
16.1.3　ICollection[T]　467
16.2　主要集合类　467
16.2.1　列表集合：List[T]　467
16.2.2　字典集合：Dictionary[TKey,TValue]　471
16.2.3　已排序集合：SortedDicti-onary[TKey,TValue]和SortedList[T]　475
16.2.4　栈集合：Stack[T]　477
16.2.5　队列集合：Queue[T]　477
16.2.6　链表：LinkedList[T]　478
16.3　提供一个索引运算符　479
16.4　返回Null或者空集合　482
16.5　迭代器　482
16.5.1　迭代器的定义　483
16.5.2　迭代器语法　483
16.5.3　从迭代器生成值　485
16.5.4　迭代器和状态　486
16.5.5　更多的迭代器例子　488
16.5.6　将yield return语句放到循环中　489
16.5.7　取消更多的迭代：yield break　491
16.5.8　在单个类中创建多个迭代器　493
16.5.9　yield语句的特征　494
16.6　小结　495
第17章　反射、特性和动态编程　496
17.1　反射　496
17.1.1　使用System.Type访问元数据　497
17.1.2　成员调用　499
17.1.3　泛型类型上的反射　503
17.2　特性　506
17.2.1　自定义特性　509
17.2.2　查找特性　509
17.2.3　使用构造器来初始化特性　510
17.2.4　System.AttributeUsage-Attribute　515
17.2.5　具名参数　516
17.3　使用动态对象进行编程　527
17.3.1　使用dynamic调用反射　527
17.3.2　dynamic的原则和行为　528
17.3.3　为什么需要动态绑定　530
17.3.4　静态编译与动态编程的比较　531
17.3.5　实现自定义动态对象　532
17.4　小结　534
第18章　多线程处理　536
18.1　独立线程的运行和控制　539
18.1.1　ContinueWith()　543
18.1.2　Task上的未处理异常　546
18.1.3　取消任务　549
18.1.4　长时间运行的任务　552
18.1.5　释放一个任务　552
18.2　并行迭代　553
18.2.1　使用System.AggregateEx-ception进行并行异常处理　556
18.2.2　取消并行循环　557
18.3　并行执行LINQ查询　560
18.4　.NET Framework 4之前的多线程处理　564
18.4.1　使用System.Threading.Thread进行异步操作　564
18.4.2　线程管理　566
18.4.3　线程池处理　567
18.5　AppPomain的未处理异常　568
18.6　小结　570
第19章　同步和更多多线程处理模式　571
19.1　同步　572
19.1.1　使用Monitor来同步　574
19.1.2　使用lock关键字　576
19.1.3　lock对象的选择　578
19.1.4　为什么要避免锁定this、typeof(type)和string　578
19.1.5　将字段声明为volatile　579
19.1.6　使用System.Threading.Interlocked类　579
19.1.7　多个线程时的事件通知　581
19.1.8　同步设计最佳实践　582
19.1.9　更多的同步类型　583
19.1.10　线程本地存储　588
19.2　计时器　591
19.3　异步编程模型　596
19.3.1　调用APM　596
19.3.2　使用TPC调用APM　602
19.4　异步委托调用　608
19.5　基于事件的异步模式(EAP)　610
19.6　Background Worker模式　613
19.6.1　模式的建立　616
19.6.2　异常处理　616
19.7　Windows UI编程　617
19.7.1　Windows窗体　617
19.7.2　Windows Presentation Foundation(WPF)　619
19.8　小结　621
第20章　平台互操作性和不安全的代码　623
20.1　平台调用　624
20.1.1　外部函数的声明　624
20.1.2　参数的数据类型　624
20.1.3　使用ref而不是指针　626
20.1.4　为顺序布局使用StructLayoutAttribute　626
20.1.5　错误处理　627
20.1.6　使用SafeHandle　629
20.1.7　外部函数的调用　632
20.1.8　用包装简化API调用　634
20.1.9　函数指针映射到委托　635
20.1.10　指导原则　635
20.2　指针和地址　635
20.2.1　不安全的代码　635
20.2.2　指针的声明　637
20.2.3　指针的赋值　638
20.2.4　指针的解引用　640
20.2.5　访问被引用物类型的成员　642
20.3　小结　642
第21章　CLI　645
21.1　CLI的定义　645
21.2　CLI实现　646
21.3　C#编译成机器码　647
21.4　运行时　649
21.4.1　垃圾回收　649
21.4.2　.NET的垃圾回收　650
21.4.3　类型安全　650
21.4.4　代码访问安全性　651
21.4.5　平台可移植性　651
21.4.6　性能　651
21.5　应用程序域　652
21.6　程序集、清单和模块　652
21.7　公共中间语言　654
21.8　公共类型系统　655
21.9　公共语言规范　655
21.10　基类库　655
21.11　元数据　656
21.12　小结　656
附录A 下载和安装C#编译器与CLI平台　658
附录B 完整源代码清单　660
附录C 来自System.Collections.Concurrent的并发类　686
附录D C# 2.0主题　689
附录E C# 3.0主题　691
附录F C# 4.0主题　693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#本质论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C函数库详解词典
第1章  字符测试函数第2章  数据转换函数第3章  内存分配函数第4章  时间函数第5章  字符串处理函数第6章  数学计算函数第7章  用户和组函数第8章  数据加密函数第9章  数据结构函数第10章  随机数函数第11章  初级I/O函数第12章  标准I/O函数第13章  进程及流程控制第14章  格式化输入输出函数第15章  文件及目录函数第16章  信号函数第17章  错误处理函数第18章  管道相关函数第19章  socket相关函数第20章  进程间通信（IPC）函数第21章  日志函数第22章  环境变量函数第23章  正则表达式第24章  动态函数第25章  其他函数附录A  编译程序—gcc 附录B  宏与函数  附录C  不定参数  附录D  Linux信号列表  附录E  常见错误代码及原因
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C函数库详解词典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>弱者的武器
前　言……………………………………………………………………………………………………………………
第一章　阶级战争中的短兵相接………………………………………………………………………………………
拉扎克………………………………………………………………………………………………………………
哈吉·“布鲁姆”…………………………………………………………………………………………………
权力的象征性平衡…………………………………………………………………………………………………

第二章　常规的剥削，常规的反抗……………………………………………………………………………………
未被书写的反抗史…………………………………………………………………………………………………
作为思想和象征的反抗……………………………………………………………………………………………
人类行动者的经验与意识…………………………………………………………………………………………

第三章　反抗的景观……………………………………………………………………………………………………
背景：马来西亚和水稻主产区……………………………………………………………………………………
中层背景：吉打州和穆达地区的灌溉系统………………………………………………………………………

第四章　塞达卡：从1967年到1979年………………………………………………………………………………
村庄…………………………………………………………………………………………………………………
富与穷………………………………………………………………………………………………………………
村庄构成……………………………………………………………………………………………………………
土地占有与使用……………………………………………………………………………………………………
租佃的变化…………………………………………………………………………………………………………
水稻生产的变化和工资的变化……………………………………………………………………………………
地方机构和经济权力………………………………………………………………………………………………

第五章　胜利者和失败者眼中的历史…………………………………………………………………………………
分类…………………………………………………………………………………………………………………
夜行船………………………………………………………………………………………………………………
绿色革命的阶级史…………………………………………………………………………………………………
双耕与双重看法……………………………………………………………………………………………………
从活租到死租………………………………………………………………………………………………………
联合收割机…………………………………………………………………………………………………………
失去的地盘：土地的获得…………………………………………………………………………………………
慈善的仪式与社会控制……………………………………………………………………………………………
记忆中的村庄………………………………………………………………………………………………………

第六章　延展事实：意识形态的运作…………………………………………………………………………………
特定情境中的意识形态运作………………………………………………………………………………………
剥削的词汇表………………………………………………………………………………………………………
歪曲事实：分层与收入……………………………………………………………………………………………
合理化的剥削………………………………………………………………………………………………………
意识形态冲突：村庄大门…………………………………………………………………………………………
意识形态冲突：村庄改进计划……………………………………………………………………………………
作为反抗的争论……………………………………………………………………………………………………

第七章　超越口舌之战：谨慎反抗与适度遵从………………………………………………………………………
公开的集体反抗的障碍……………………………………………………………………………………………
抵制联合收割机的努力……………………………………………………………………………………………
“常规的”反抗……………………………………………………………………………………………………
“常规的”镇压……………………………………………………………………………………………………
常规的顺从与不留痕迹的反抗……………………………………………………………………………………
服从以及部分的文本………………………………………………………………………………………………
何谓反抗？…………………………………………………………………………………………………………

第八章　霸权与意识：…………………………………………………………………………………………………
意识形态斗争的日常形式…………………………………………………………………………………………
塞达卡的物质基础和规范性上层建筑……………………………………………………………………………
重新思考霸权概念…………………………………………………………………………………………………

附　录……………………………………………………………………………………………………………………
附录Ａ　村庄人口记录，1967—1979 …………………………………………………………………………
附录Ｂ　不同土地使用类型／农场规模的农场收入比较（穆达地区，1966、1974和1979年） …………
附录Ｃ　关于土地使用情况变更、净利润及政治事务的数据…………………………………………………
附录Ｄ　飞翔信的译文……………………………………………………………………………………………
参考文献…………………………………………………………………………………………………………………
索　引……………………………………………………………………………………………………………………
译后记……………………………………………………………………………………………………………………
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>弱者的武器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇：黎明踏浪号
1.卧室里的画
2.在黎明跳浪号上
3.孤独群岛
4.凯斯宾巧施奇计
5.风暴和余波
6.尤斯塔斯的历险
7.脱险
8.两次死里逃生
9.声音岛
10.魔法书
11.笨蛋瓜皆大欢喜
12.黑暗岛
13.三个沉睡的人
14.世界尽头的起点
15.最后一片大海的奇观
16.真正的世界尽头
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚传奇：黎明踏浪号
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言进阶
前言
第1章　必须厘清的核心概念/1
1.1　堆栈/2
1.2　全局变量和局部变量/5
1.3　生存期和作用域/7
1.3.1　生存期/7
1.3.2　作用域/10
1.4　内部函数和外部函数/11
1.5　指针变量/14
1.6　指针数组和数组指针/17
1.7　指针函数和函数指针/20
1.8　传值和传址/22
1.9　递归和嵌套/25
1.10　结构体/29
1.11　共用体/32
1.12　枚举/37
1.13　位域/39
第2章　预处理/47
2.1　文件的包含方式/48
2.2　宏定义/50
2.2.1　简单宏替换/50
2.2.2　带参数的宏替换/52
2.2.3　嵌套宏替换/56
2.3　宏定义常见错误解析/56
2.3.1　不带参数的宏/56
2.3.2　带参数的宏/59
2.4　条件编译指令的使用/62
2.5　#pragma指令的使用/65
第3章　选择结构和循环结构的程序设计/69
3.1　if语句及其易错点解析/70
3.2　条件表达式的使用/76
3.3　switch语句的使用及注意事项/78
3.4　goto语句的使用及注意事项/85
3.5　for语句的使用及注意事项/87
3.6　while循环与do while循环的使用及区别/92
3.7　循环结构中break、continue、goto、return和exit的区别/98
第4章　数组/103
4.1　一维数组的定义及引用/104
4.2　二维数组的定义及引用/110
4.3　多维数组的定义及引用/117
4.4　字符数组的定义及引用/119
4.5　数组作为函数参数的易错点解析/124
4.6　动态数组的创建及引用/130
第5章　指针/139
5.1　不同类型指针之间的区别和联系 /140
5.2　指针的一般性用法及注意事项/144
5.3　指针与地址之间的关系/148
5.4　指针与数组之间的关系/153
5.5　指针与字符串之间的关系/161
5.6　指针与函数之间的关系/163
5.7　指针与指针之间的关系/169
第6章　数据结构/172
6.1　枚举类型的使用及注意事项/173
6.2　结构体变量的初始化方法及引用/177
6.2.1　结构体的初始化/177
6.2.2　结构体的引用/180
6.3　结构体字节对齐详解/184
6.4　共用体变量的初始化方法及成员的引用/193
6.5　传统链表的实现方法及注意事项/196
6.6　颠覆传统链表的实现方法/214
6.6.1　头结点的创建/214
6.6.2　结点的添加/215
6.6.3　结点的删除/217
6.6.4　结点位置的调整/219
6.6.5　检测链表是否为空/221
6.6.6　链表的合成/222
6.6.7　宿主结构指针/225
6.6.8　链表的遍历/225
第7章　函数/230
7.1　函数参数/231
7.2　变参函数的实现方法/235
7.3　函数指针的使用方法/241
7.4　函数之间的调用关系/245
7.5　函数的调用方式及返回值/251
第8章　文件/255
8.1　文件及文件指针/256
8.2　EOF和FEOF的区别/259
8.3　读写函数的选用原则/264
8.4　位置指针对文件的定位/270
8.5　文件中的出错检测/275
第9章　调试和异常处理/279
9.1　assert宏的使用及注意事项/280
9.2　如何设计一种灵活的断言/283
9.3　如何实现异常处理/287
9.4　如何处理段错误/293
第10章　陷阱知识点解剖/299
10.1　strlen和sizeof的区别/300
10.2　const修饰符/301
10.3　volatile修饰符/305
10.4　void和void*的区别/311
10.5　#define和typedef的本质区别/314
10.6　条件语句的选用/317
10.7　函数realloc、malloc和calloc的区别/319
10.8　函数和宏/322
10.9　运算符==、=和！=的区别/323
10.10　类型转换/324
第11章　必须掌握的常用算法/326
11.1　时间复杂度/327
11.2　冒泡法排序/329
11.3　选择法排序/332
11.4　快速排序/334
11.5　归并排序/337
11.6　顺序查找/340
11.7　二分查找/341
附录　如何养成良好的编程习惯/344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>荣格分析心理学导论
目录
2012版腓利门系列丛书前言：索努·沙姆达萨尼
导读（2012年版）索努·沙姆达萨尼
导读（1989版）威廉·麦圭尔
致谢
讲座的成员
缩写表
序言：卡莉·F.德·安古洛
001  /　第1讲
009  /　第2讲
017  /　第3讲
031  /　第4讲
041  /　第5讲
051  /　第6讲
059  /　第7讲
069  /　第8讲
077  /　第9讲
085  /　第10讲
095  /　第11讲
105  /　第12讲
115  /　第13讲
125  /　第14讲
133  /　第15讲
137  /　第16讲
索引  /185
1.通用索引  /187
2.案例  /192
3.梦、幻想和幻象  /193
4.引用和讨论的荣格作品年代表  /194
荣格作品全集  /199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>荣格分析心理学导论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通C#游戏编程
第Ⅰ部分  背景知识  第1章  C#的历史    1.1 C#基础    1.2 小结  第2章  OpenGL简介    2.10 penGL的架构      2.1.1 顶点：3D图形的基础      2.1.2 流水线    2.2 变化中的OpenGL      2.2.1 OpenGLES      2.2.2 WebGL    2.3 OpentGL和图形卡    2.4 Tao框架    2.5 小结  第3章  现代方法    3.1 实效编程      3.1.1 游戏编程中的陷阱      3.1.2 KISS      3.1.3 DRY      3.1.4 源代码控制      3.1.5 单元测试    3.2 小结第Ⅱ部分  实现  第4章  设置    4.1 VisualStudiOEXpress——C#可以使用的免费IDE      4.1.1 Hello World程序      4.1.2 关于VisualStudioExpress的提示    4.2 Subversion      4.2.1 获取      4.2.2 安装      4.2.3 创建源代码控制库      4.2.4 添加到库中      4.2.5 历史记录      4.2.6 扩展Hello World    4.3 Tao    4.4 NUnit      4.4.1 在项目中使用NUnit      4.4.2 运行测试      4.4.3 示例项目    4.5 小结  第5章  游戏循环和图形    5.1 游戏的工作方式    5.2 使用C#实现一个快速的游戏循环    5.3 图形      5.3.1 全屏模式      5.3.2 渲染    5.4 小结  第6章  游戏结构    6.1 游戏对象的基本模式    6.2 处理游戏状态    6.3 游戏状态演示    6.4 使用投影设置场景      6.4.1 字体大小和OpenGL视口大小      6.4.2 宽高比      6.4.3 投影矩阵      6.4.4 2D图形    6.5 精灵      6.5.1 定位精灵      6.5.2 使用四方形管理纹理      6.5.3 纹理精灵      6.5.4 alpha混合精灵      6.5.5 颜色调制精灵      6.5.6 Sprite类和Render。类      6.5.7 使用Sprite类  第7章  渲染文本    7.1 字体纹理    7.2 字体数据      7.2.1 解析字体数据      7.2.2 使用CharacterData    7.3 渲染文本      7.3.1 计算FPS      7.3.2 垂直同步和帧率      7.3.3 性能分析    7.4 优化Text类    7.5 使用glDrawAlTays进行快速渲染      7.5.1 修改渲染器      7.5.2 对批(batch)绘制方法执行性能分析    7.6 小结  第8章  游戏数学    8.1 三角函数      8.1.1 绘制图形      8.1.2 使用三角函数实现特殊效果    8.2 向量      8.2.1 向量的定义      8.2.2 长度操作      8.2.3 向量的相等性      8.2.4 向量加法、减法和乘法      8.2.5 法向量      8.2.6 点积运算      8.2.7 叉积运算      8.2.8 关于向量结构的最后一点内容    8.3 二维相交      8.3.1 圆      8.3.2 矩形    8.4 补间      8.4.1 补问概述      8.4.2 Tween类      8.4.3 使用补间    8.5 矩阵      8.5.1 矩阵的定义      8.5.2 单位矩阵      8.5.3 矩阵乘法和矩阵与向量的乘法      8.5.4 平移和缩放      8.5.5 旋转      8.5.6 求逆矩阵      8.5.7 对精灵执行矩阵操作      8.5.8 修改精灵来使用矩阵      8.5.9 优化  第9章  创建游戏引擎    9.1 新的游戏引擎项目    9.2 扩展游戏引擎      9.2.1 在项目中使用游戏引擎      9.2.2 多个纹理    9.3 添加声音支持      9.3.1 创建声音文件      9.3.2 开发SoundManager    9.4 改进输入      9.4.1 包装游戏控制器      9.4.2 添加更好的鼠标支持      9.4.3 添加键盘支持  第10章  创建一个简单的卷轴射击游戏    10.1 一个简单的游戏    10.2 第一遍实现      10.2.1 开始菜单的状态      10.2.2 游戏主体状态      10.2.3 游戏结束状态    10.3 开发游戏主体      10.3.1 移动玩家角色      10.3.2 使用卷动背景模拟移动      10.3.3 添加一些简单的敌人      10.3.4 添加简单的武器      10.3.5 伤害和爆炸      10.3.6 管理爆炸和敌人      10.3.7 定义关卡      10.3.8 敌人的移动      10.3.9 敌人攻击    10.4 继续迭代  第11章  创建自己的游戏    11.1 项目管理    11.2 显示方法      11.2.1 2D游戏      11.2.2 3D游戏    11.3 游戏类型      11.3.1 文字类游戏      11.3.2 益智游戏      11.3.3 第一人称射击游戏      11.3.4 策略游戏      11.3.5 角色扮演游戏      11.3.6 平台游戏    11.4 结束语附录A  推荐阅读材料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通C#游戏编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验C语言项目开发
第1章  俄罗斯方块游戏  1.1  第一个项目	  1.1.1  老师的作业  1.1.2  准备工作	  1.2  功能分析	  1.2.1  系统需求分析	  1.2.2  结构规划	  1.2.3  选择工具	  1.3  总体设计  1.3.1  运行流程分析  1.3.2  核心处理模块分析	  1.4  数据结构  1.5  一个神秘的箱子  1.6  具体实现  1.6.1  预处理  1.6.2  主函数  1.6.3  界面初始化  1.6.4  时钟中断处理  1.6.5  更新速度和成绩，显示帮助信息  1.6.6  满行处理  1.6.7  显示/消除方块  1.6.8  对方块的操作处理	  1.7  最后的战役——测试运行  1.8  我的总结第2章  成绩管理系统第3章  PING和TCP网络系统第4章  工资管理系统第5章  绘图板系统第6章  文本编辑器系统第7章  图书借阅系统第8章  UDP传输系统第9章  推箱子游戏第10章  媒体播放器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验C语言项目开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>威士忌原来是这么回事儿
0_威士忌的来龙去脉
哪些人喝威士忌？ 2
威士忌的种类 4
是谁发明了威士忌 ？ 6
威士忌热潮蔓延全球 8
威士忌大事记 10
威士忌的神秘象征：蒸馏器 12
1_探索威士忌蒸馏厂
威士忌的原料 16
酿制威士忌的七个步骤 18
威士忌的泥煤味 20
发麦 22
磨碎、搅拌与糖化 24
发酵 26
蒸馏 28
人物速写：埃尼亚斯·科菲 31
筛选酒心 32
入桶熟成 34
如何制作木桶？ 36
各式各样的木桶 38
木桶的生命周期 39
人物速写：杰克·丹尼 40
人物速写：查尔斯·多伊格 41
酒窖洞天 42
口味调和 44
装瓶乾坤 46
首席酿酒师 48
蒸馏厂内的其他人员 50
人物速写：陶瑟 52
参观蒸馏厂的黄金守则 53
2_威士忌品饮之道
品酒前的准备 56
酒精对人体的影响 58
人物速写：卡里·纳辛 61
洞悉品酒 62
挑选适合的酒杯 64
酒瓶或醒酒器 66
挑选水质 68
鉴赏威士忌的三个步骤 70
威士忌的千滋百味 74
截然不同的威士忌 76
品酒记录表 78
人物速写：威廉·皮尔逊 81
品酒会尾声 82
预防及缓解宿醉 84
威士忌俱乐部 86
3_选购威士忌有窍门
什么场合喝什么威士忌 90
解读威士忌酒标 92
何处选购威士忌？ 94
打造个人酒柜 96
如何存放威士忌 98
瓶塞的功能 100
当心营销陷阱 102
威士忌的价格 104
4_威士忌也能上餐桌
晚餐来杯威士忌 108
喝威士忌该搭配什么食物？ 110
适合威士忌的地方特色料理 112
威士忌拿手菜 114
5_威士忌也有鸡尾酒
在酒吧如何挑选威士忌 118
水割威士忌 120
威士忌冰球 122
调酒的基本工具 124
无可取代的经典威士忌调酒 126
以波本威士忌为主角的鸡尾酒132
人物速写：杰瑞·托马斯 135
以调和式威士忌为主角的鸡尾酒 136
以单一麦芽威士忌为主角的鸡尾酒 137
以百利甜酒为主角的鸡尾酒 138
人物速写：约翰·沃克 139
以威士忌为基底的酒 140
6_威士忌的世界版图
苏格兰 144
苏格兰格纹 146
艾雷岛 148
斯佩河畔区 150
低地区 152
高地区 154
坎贝尔敦 156
爱尔兰 158
英国其他地区 160
日本 162
美国 164
加拿大 166
法国 168
其他地区 170
7_附录
威士忌相关词汇 174
威士忌相关数字 177
威士忌界的大人物 178
人物速写：竹鹤政孝 179
章节索引 180
威士忌索引 181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>威士忌原来是这么回事儿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>品牌源动力
第一章 品牌战略溯源
从矮穷矬到高富帅——品牌的起源
统领江湖五种力量——愿景与使命
品牌殿堂的秘钥——广义品牌SIC模型
从三级片到文艺片——品牌战略路径
特劳特定位的局限——6C定位模型
图解品牌构建方法——PSA三部曲
品牌的混沌与秩序——品牌族群战略
占卜问卦不如调查——品牌调研与诊断
第二章 品牌价值与顾客体验
品牌信仰的根基——CAPE价值理论
释放品牌的荷尔蒙——顾客体验MEC模型
从洗脑到自我救赎——媒体感受
攻克心扉的特洛伊木马——公关体验
顾客拦截的艺术——终端体验
超越金钱的心灵陶醉——消费体验
顾客流失漏斗揭秘——电商品牌体验
第三章 顾客定位
神爱世人我独爱你——目标顾客定位
勾画目标人群的风骨——定客ABCD模型
唤醒沉睡的宝藏——重构需求力
危机下的消费抑制——重启购买力
市场的颠覆性力量——重塑价值观
中了品牌的毒——创建顾客黏度
第四章 品类定位
上帝创造了品类——品牌与品类
宝洁细分出300个品牌——细分定类法
迪斯尼开发3000个地产——整合定类法
时装设计师孙中山——创新定类法
霸王凉茶与马应龙眼霜——A模式与J模式
做第一还是做唯一——品类竞争梯队
屈臣氏的边界与方寸——定类与商品规划
第五章  格调定位
从孔夫子到犀利哥——古今格调纵横谈
小萝莉大战OL——品牌格调经典范式
争奇斗艳夺花魁——格调定位矩阵
换标风波犯众怒——定调与VIS设计
玻璃卖出水晶价——定调与产品设计
视觉创意的灵魂——定调与广告设计
快时尚的江湖演义——ZARA深度分析
第六章 溢价定位
叠石桥的传说——价格的生死符咒
品牌吸金有道——溢价定位与竞争策略
纠葛的双刃剑——价位、价宽和价让
英雄的阵营与座次——PE与PR定价矩阵
妥协才能共赢——多方权益定价法
定立营销的格局——价格与产品规划
高街品牌的二次革命——平价主导的业态变革
第七章  个性定位
对号入座测个性——品牌个性维度量表
良民最爱亡命徒——品牌个性12种原型
狼老板不做羊品牌——品牌个性定位方法
有了个性你就喊——品牌个性与品牌主张
上层建筑一脉相通——品牌个性与企业文化
第八章 核心定位
择其善者而从之——择优法则
四海归于一统——归纳法则
自立山头称大王——唯一法则
天下英雄谁敌手——第一法则
不畏浮云遮望眼——前瞻法则
灵感源于勤调研——3C法则
第九章  集团品牌战略管控
五步可成诗——集团品牌战略5大模块
捍卫价值的藩篱——集团品牌管控12项任务
好戏在高台——集团品牌管控组织与流程
阵亡率极高的游戏——品牌资产评估与并购
门当户对好联姻——集团品牌联合 406
掐灭危险的火花——品牌危机公关3道防线
参考文献
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>品牌源动力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚世界的构建者
译者序
前 言
第一章 “叫我杰克”
第二章 学习的呼唤
第三章 奖学金与战争
第四章 “母亲”
第五章 研究员职位
第六章 幻想
第七章 友谊
第八章 从战争到欢悦
第九章 乔伊
第十章 没有乔伊的日子
第十一章 遗产
附录 C.S.刘易斯生平
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>纳尼亚世界的构建者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C现代编程
第1章　概要　　1
1.1　现在C依然很热门　　1
1.2　使用C进行嵌入式开发的特点　　3
1.3　本书的目标　　5
1.3.1　C与集成开发环境　　5
1.3.2　C与设计模式　　6
1.3.3　C与极限编程　　7
1.3.4　C与现代开发方式　　9
1.4　总结　　11
第2章　搭建开发环境　　13
2.1　概要　　13
2.2　获取Linux　　13
2.3　在Windows PC上搭建环境　　14
2.4　安装Linux　　20
2.4.1　准备工作　　20
2.4.2　制作安装介质　　21
2.4.3　安装Xubuntu　　24
2.5　安装Eclipse　　29
2.5.1　安装Java　　29
2.5.2　安装Eclipse　　30
2.5.3　安装其他工具　　33
2.6　Eclipse的基本操作　　34
2.6.1　Hello, World　　34
2.6.2　视图　　38
2.6.3　工程、工作区和透视图　　38
2.7　Eclipse的功能　　41
2.7.1　可视化调试　　41
2.7.2　导航器　　48
2.7.3　代码补全　　51
2.7.4　宏展开　　53
2.7.5　本地代码历史　　54
2.7.6　TODO注释　　55
2.7.7　与外部编辑器协作　　56
2.8　总结　　58
第3章　C语言与面向对象　　59
3.1　概要　　59
3.2　C的模块化与面向对象　　59
3.2.1　C与模块化　　60
3.2.2　使用结构体将数据结构与代码块分离　　62
3.2.3　使用C进行面向对象编程　　66
3.2.4　面向对象与多态性　　75
3.2.5　继承　　76
3.2.6　封装　　79
3.2.7　虚函数表　　80
3.2.8　非虚函数　　82
3.3　总结　　84
第4章　C语言与设计模式　　85
4.1　状态模式　　85
4.1.1　状态迁移图　　85
4.1.2　状态迁移表　　89
4.1.3　面向对象的状态模式　　90
4.1.4　多个状态集合相互关联的情况　　93
4.1.5　状态模式与内存管理　　94
4.2　模板方法模式　　95
4.2.1　返回非int值　　99
4.2.2　处理其他资源　　100
4.2.3　上下文　　107
4.3　观察者模式　　114
4.4　职责链模式　　125
4.5　访问者模式　　128
4.6　总结　　134
第5章　C语言与重构　　135
5.1　概要　　135
5.2　测试驱动开发　　136
5.3　TDD入门　　137
5.3.1　设置Eclipse　　137
5.3.2　初次测试驱动开发　　142
5.3.3　测试静态函数　　147
5.4　重构　　150
5.4.1　对外接口　　150
5.4.2　重构与投资　　150
5.5　TDD实践篇　　151
5.5.1　怪兽方法　　152
5.5.2　C语言的Mock测试　　162
5.5.3　完成重构　　182
5.5.4　获取代码覆盖率　　186
5.6　总结　　188
第6章　持续集成与部署　　191
6.1　概要　　191
6.2　持续集成的前提　　192
6.2.1　软件配置管理工具　　192
6.2.2　构建工具　　192
6.2.3　Bug跟踪系统（BTS）　　193
6.3　引入CI服务器　　193
6.4　CI入门　　196
6.4.1　本次CI的自动化目标　　196
6.4.2　Scons构建脚本　　197
6.4.3　gcovr的安装　　199
6.4.4　构建　　200
6.4.5　提交至SCM　　202
6.4.6　创建Jenkins任务　　203
6.5　内存Bug大作战　　214
6.5.1　安装　　214
6.5.2　运行Valgrind　　214
6.5.3　Valgrind可以检测出的错误　　215
6.5.4　Valgrind中检测出的内存错误的特点与对策　　220
6.5.5　在Jenkins中使用Valgrind　　221
6.6　CI实践篇　　228
6.6.1　Microchip工具　　229
6.6.2　构建内容　　230
6.6.3　分割构建文件　　234
6.6.4　独立构建服务器　　240
6.6.5　设置自动构建计划　　247
6.7　总结　　249
附录A　示例代码　　251
A.1　注意事项　　251
A.2　添加C99标准　　251
A.3　在Eclipse中导入示例代码　　252
A.3.1　解压示例代码压缩文件　　252
A.3.2　Eclipse中新建空白工程　　252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C现代编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 4入门经典（第6版）
第1章 ASP.NET4入门
第2章 构建ASP.NET Web 站点
第3章 设计Web页页
第4章 使用ASP.NET服务器控件
第5章 ASP.NET Web页面编程
第6章 创建外观一致的Web站点
第7章 导航
第8章 用户控件
第9章 验证用户输入有效性
第10章 ASP.NET AJAX
第11章 jQuery
第12章 初识数据库
第13章 显示和更新数据
第14章 LINQ和ADO.NET Entity Framework
第15章 处理数据——高级主题
第16章 ASP.NET 4 Web站点中的安全性
第17章 个性化Wed站点
第18章 异常处理、调试和跟踪
第19章 部署Wed站点
附录A 练习答案
附录B 配置SQL Server 2008
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 4入门经典（第6版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C开发范例代码大全
第1章  应用开发	1
1.1  创建终端应用	1
1.2  输出到控制台	3
1.3  创建新的自定义类	5
1.4  编写属性访问器	7
1.5  使用@synthesize编写属性
访问器	10
1.6  向自定义类中添加类方法	12
1.7  向自定义类中添加
实例方法	14
1.8  使用类别对类进行扩展	15
1.9  从终端创建基于窗口的
Mac应用	17
1.10  向Mac应用添加用户控件	20
1.11  从Xcode创建基于窗口的
Mac应用	23
1.12  从Xcode创建iOS应用	25
1.13  使用目标-动作向iOS应用
添加用户控件	29
1.14  使用委托向iOS应用添加
用户控件	33
第2章  使用字符串与数字	37
2.1  创建字符串对象	37
2.2  在Mac上从文件读取
字符串	39
2.3  在iOS上从文件读取
字符串	41
2.4  在Mac上将字符串写到
文件中	43
2.5  在iOS上将字符串写到
文件中	45
2.6  比较字符串	48
2.7  操纵字符串	50
2.8  搜索字符串	53
2.9  本地化字符串	54
2.10  将数字转换为字符串	56
2.11  将字符串转换为数字	58
2.12  格式化数字	59
第3章  使用对象集合	61
3.1  创建数组	62
3.2  引用数组中的对象	63
3.3  获取数组中元素的数量	65
3.4  遍历数组	66
3.5  排序数组	68
3.6  查询数组	72
3.7  操纵数组内容	75
3.8  将数组保存到文件系统中	78
3.9  从文件系统读取数组	80
3.10  创建字典	81
3.11  引用数组中的对象	83
3.12  获取字典中元素的数量	84
3.13  遍历字典	85
3.14  操纵字典内容	87
3.15  将字典保存到文件系统中	89
3.16  从文件系统读取字典	90
3.17  创建集合	92
3.18  获取集合中元素的数量	93
3.19  比较集合	94
3.20  遍历集合	96
3.21  操纵集合内容	97
第4章  文件系统	101
4.1  引用并使用文件管理器	101
4.2  获得指向Mac系统目录的
引用	103
4.3  获得指向关键iOS目录的
引用	105
4.4  获取文件属性	107
4.5  获得目录下的文件与子目录
列表	109
4.6  管理目录	111
4.7  管理文件	114
4.8  查看文件状态	117
4.9  修改文件属性	119
4.10  使用NSFileManager
委托	121
4.11  使用NSData处理数据	127
4.12  使用NSCache缓存内容	131
第5章  使用日期、时间与定时器	137
5.1  创建表示今天的日期对象	137
5.2  通过Component创建
自定义日期	138
5.3  比较两个日期	140
5.4  将字符串转换为日期	143
5.5  格式化日期以便显示	144
5.6  加减日期	146
5.7  使用定时器调度并重复
执行任务	147
第6章  异步处理	151
6.1  在新线程中执行处理	151
6.2  主线程与后台线程之间的
通信	156
6.3  使用NSLock锁定线程	163
6.4  使用@synchronized
锁定线程	167
6.5  使用Grand Central Dispatch(GCD)
进行异步处理	171
6.6  在GCD中使用顺序队列	177
6.7  使用NSOperationQueue
实现异步处理	182
第7章  使用Web服务	187
7.1  下载文件	187
7.2  通过XML使用Web服务	189
7.3  通过JSON使用Web服务	195
7.4  异步地使用Web服务	198
第8章  内存管理	201
8.1  理解内存管理	201
8.2  创建不使用ARC的应用	203
8.3  使用引用计数管理内存	205
8.4  为自定义类添加内存管理	207
8.5  使用autorelease消息	210
8.6  为Mac应用启用垃圾收集	215
第9章  使用对象图	217
9.1  创建对象图	218
9.2  使用键-值编码	229
9.3  在对象图中使用键路径	236
9.4  使用键路径聚合信息	241
9.5  实现观察者模式	247
9.6  探查类与对象	252
9.7  归档对象图	257
第10章  Core Data	267
10.1  向应用添加Core Data
支持	267
10.2  添加实体描述	274
10.3  向应用添加托管对象	276
10.4  向Core Data添加
托管对象	280
10.5  从数据存储中检索对象	285
10.6  将变更发回数据存储	290
10.7  使用Core Data管理一对
一关联关系	296
10.8  使用Core Data管理一对
多关联关系	304
10.9  管理数据存储的版本	315
第11章  Objective-C：超越Mac与
iOS	325
11.1  在Windows上安装
GNUstep	325
11.2  Windows上的Objective-C
程序Hello World	327
11.3  下载Objective-J以进行
Web应用开发	330
11.4  编写Objective-J应用
Hello World	331
11.5  向Objective-J应用添加
按钮	336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C开发范例代码大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南（第3版）
第0 章导读..................................................1
0.1 关于本书.........................................1
0.2 读者对象.........................................1
0.3 术语与风格.....................................2
0.4 C++标准..........................................3
0.5 本书的结构.....................................4
0.6 如何阅读本书..................................5
0.7 本书的源码.....................................5
第1 章 Boost 程序库总论...........................7
1.1 关于Boost .......................................7
1.1.1 获取方式................................... 8
1.1.2 目录结构................................... 8
1.1.3 使用方式................................... 9
1.2 开发环境.........................................9
1.2.1 操作系统和编译器................. 10
1.2.2 快捷安装Boost ....................... 10
1.2.3 完全安装Boost ....................... 10
1.2.4 定制安装Boost ....................... 11
1.2.5 验证开发环境......................... 11
1.3 构建工具.......................................12
1.3.1 安装b2 .................................... 12
1.3.2 构建脚本................................. 12
1.3.3 构建语言................................. 13
1.3.4 构建命令................................. 14
1.4 总结...............................................14
第2 章时间与日期.....................................15
2.1 timer 库概述..................................15
2.2 timer...............................................16
2.2.1 用法......................................... 16
2.2.2 类摘要..................................... 17
2.2.3 使用建议................................. 18
2.3 progress_timer ...............................18
2.3.1 用法......................................... 18
2.3.2 类摘要..................................... 19
2.4 progress_display ............................20
2.4.1 类摘要..................................... 20
2.4.2 用法......................................... 21
2.4.3 注意事项................................. 22
2.5 date_time库概述...........................23
2.5.1 编译与使用............................. 24
2.5.2 基本概念................................. 24
2.6 处理日期.......................................25
2.6.1 日期......................................... 25
2.6.2 创建日期对象......................... 26
2.6.3 访问日期................................. 27
2.6.4 日期的输出............................. 28
2.6.5 转换tm 结构........................... 29
2.6.6 日期长度................................. 29
2.6.7 日期运算................................. 31
2.6.8 日期区间................................. 32
2.6.9 日期区间运算......................... 33
2.6.10 日期迭代器........................... 35
2.6.11 其他功能............................... 36
2.6.12 综合运用............................... 36
2.7 处理时间.......................................39
2.7.1 时间长度................................. 39
2.7.2 操作时间长度......................... 40
2.7.3 时间长度的精确度................. 42
2.7.4 时间点..................................... 43
2.7.5 创建时间点对象..................... 44
2.7.6 操作时间点对象..................... 45
2.7.7 转换tm/time_t结构................ 46
2.7.8 时间区间................................. 46
2.7.9 时间迭代器............................. 47
2.7.10 综合运用............................... 47
2.8 date_time库的高级议题...............50
2.8.1 编译配置宏............................. 50
2.8.2 自定义字面值......................... 51
2.8.3 格式化时间............................. 51
2.8.4 本地时间................................. 52
2.8.5 序列化..................................... 54
2.9 总结...............................................54
第3 章内存管理.........................................57
3.1 smart_ptr库概述...........................57
3.1.1 RAII 机制................................ 57
3.1.2 智能指针................................. 58
3.2 scoped_ptr......................................59
3.2.1 类摘要..................................... 59
3.2.2 操作函数................................. 60
3.2.3 用法......................................... 61
3.2.4 对比unique_ptr....................... 63
3.2.5 make_unique............................ 64
3.3 scoped_array ..................................65
3.3.1 类摘要..................................... 65
3.3.2 用法......................................... 66
3.3.3 对比unique_ptr....................... 66
3.3.4 使用建议................................. 67
3.4 shared_ptr.......................................68
3.4.1 类摘要..................................... 68
3.4.2 操作函数................................. 69
3.4.3 用法......................................... 70
3.4.4 工厂函数................................. 72
3.4.5 应用于标准容器..................... 73
3.4.6 应用于桥接模式..................... 74
3.4.7 应用于工厂模式..................... 75
3.4.8 定制删除器............................. 77
3.4.9 高级议题................................. 78
3.5 shared_array...................................82
3.5.1 类摘要..................................... 82
3.5.2 用法......................................... 82
3.6 weak_ptr.........................................83
3.6.1 类摘要..................................... 83
3.6.2 用法......................................... 84
3.6.3 enable_shared_from_this......... 85
3.6.4 enable_shared_from_raw......... 86
3.6.5 打破循环引用......................... 88
3.7 intrusive_ptr ...................................89
3.7.1 类摘要..................................... 89
3.7.2 用法......................................... 90
3.7.3 引用计数器............................. 91
3.8 pool 库概述...................................92
3.9 pool ................................................93
3.9.1 类摘要..................................... 93
3.9.2 操作函数................................. 94
3.9.3 用法......................................... 95
3.10 object_pool...................................95
3.10.1 类摘要................................... 96
3.10.2 操作函数............................... 96
3.10.3 用法....................................... 97
3.10.4 使用更多的构造参数............ 97
3.11 singleton_pool..............................99
3.11.1 类摘要................................... 99
3.11.2 用法....................................... 99
3.12 pool_alloc...................................100
3.13 总结...........................................101
第4 章实用工具.......................................103
4.1 noncopyable .................................103
4.1.1 原理....................................... 104
4.1.2 用法....................................... 104
4.1.3 实现....................................... 105
4.2 ignore_unused..............................106
4.2.1 基本用法............................... 106
4.2.2 模板用法............................... 107
4.3 optional ........................................108
4.3.1 类摘要................................... 108
4.3.2 操作函数............................... 109
4.3.3 用法....................................... 111
4.3.4 工厂函数............................... 112
4.4 assign ........................................... 113
4.4.1 list_inserter ............................ 113
4.4.2 使用operator+=..................... 114
4.4.3 使用operator () ..................... 115
4.4.4 generic_list............................. 116
4.4.5 初始化容器........................... 117
4.4.6 减少重复输入....................... 119
4.4.7 操作非标准容器................... 120
4.4.8 其他议题............................... 121
4.5 swap .............................................122
4.5.1 原理....................................... 122
4.5.2 交换数组............................... 123
4.5.3 特化std::swap ....................... 124
4.5.4 特化ADL 可找到的swap.... 125
4.5.5 使用建议............................... 126
4.6 singleton.......................................126
4.6.1 类摘要................................... 126
4.6.2 用法....................................... 127
4.7 tribool...........................................128
4.7.1 类摘要................................... 129
4.7.2 用法....................................... 130
4.7.3 为第三态更名....................... 131
4.7.4 输入/输出.............................. 131
4.7.5 与optional<bool>的区别...... 132
4.8 operators.......................................133
4.8.1 基本运算概念....................... 134
4.8.2 算术操作符的用法............... 135
4.8.3 基类链................................... 137
4.8.4 复合运算概念....................... 138
4.8.5 相等与等价........................... 140
4.8.6 解引用操作符....................... 141
4.8.7 下标操作符........................... 142
4.8.8 bool转型操作符................... 143
4.8.9 二元操作符........................... 145
4.9 exception......................................145
4.9.1 标准库中的异常................... 146
4.9.2 类摘要................................... 146
4.9.3 向异常传递信息................... 148
4.9.4 错误信息类........................... 149
4.9.5 包装标准异常....................... 151
4.9.6 使用函数抛出异常............... 152
4.9.7 获得更多的调试信息........... 152
4.9.8 高级议题............................... 154
4.10 uuid ............................................155
4.10.1 类摘要................................. 156
4.10.2 用法..................................... 157
4.10.3 生成器................................. 158
4.10.4 增强的uuid类.................... 160
4.10.5 转换字符串......................... 162
4.10.6 SHA1 摘要算法.................. 163
4.11 config .........................................164
4.11.1 BOOST_STRINGIZE.......... 164
4.11.2 BOOST_STATIC_
CONSTANT........................ 165
4.12 utility..........................................165
4.12.1 BOOST_BINARY ............... 165
4.12.2 BOOST_CURRENT_
FUNCTION......................... 167
4.13 总结...........................................168
第5 章字符串与文本处理.......................171
5.1 lexical_cast...................................171
5.1.1 函数声明............................... 172
5.1.2 用法....................................... 172
5.1.3 错误处理............................... 173
5.1.4 对转换对象的要求............... 174
5.1.5 应用于自定义类................... 175
5.1.6 对比C++11 标准.................. 176
5.2 format...........................................177
5.2.1 简单的例子........................... 178
5.2.2 输入操作符%........................ 179
5.2.3 类摘要................................... 180
5.2.4 格式化语法........................... 182
5.2.5 format 的性能........................ 183
5.2.6 高级用法............................... 183
5.3 string_ref......................................184
5.3.1 类摘要................................... 185
5.3.2 用法....................................... 186
5.4 string_algo ...................................188
5.4.1 简单的例子........................... 188
5.4.2 string_algo概述.................... 189
5.4.3 大小写转换........................... 190
5.4.4 判断式（算法） ................... 191
5.4.5 判断式（函数对象） ........... 193
5.4.6 分类....................................... 193
5.4.7 修剪....................................... 194
5.4.8 查找....................................... 195
5.4.9 替换与删除........................... 197
5.4.10 分割..................................... 199
5.4.11 合并..................................... 200
5.4.12 查找（分割）迭代器......... 201
5.5 tokenizer.......................................203
5.5.1 类摘要................................... 203
5.5.2 用法....................................... 204
5.5.3 分词函数对象....................... 204
5.5.4 char_separator........................ 205
5.5.5 escaped_list_separator ........... 206
5.5.6 offset_separator ..................... 207
5.5.7 tokenizer库的缺陷............... 208
5.6 xpressive ......................................210
5.6.1 两种使用方式....................... 210
5.6.2 正则表达式语法简介........... 211
5.6.3 类摘要................................... 212
5.6.4 正则匹配............................... 214
5.6.5 正则查找............................... 217
5.6.6 正则替换............................... 218
5.6.7 正则迭代............................... 219
5.6.8 正则分词............................... 221
5.6.9 对比boost.regex.................... 222
5.6.10 高级议题............................. 223
5.7 总结.............................................225
第6 章正确性与测试...............................227
6.1 assert ............................................227
6.1.1 基本用法............................... 227
6.1.2 禁用断言............................... 229
6.1.3 扩展用法............................... 229
6.2 static_assert..................................231
6.2.1 定义....................................... 231
6.2.2 用法....................................... 231
6.2.3 使用建议............................... 233
6.3 lightweight_test............................233
6.3.1 测试断言............................... 233
6.3.2 用法....................................... 234
6.3.3 测试元编程........................... 235
6.4 test................................................235
6.4.1 最小化的测试套件............... 236
6.4.2 单元测试框架简介............... 237
6.4.3 测试断言............................... 238
6.4.4 测试用例与测试套件............ 239
6.4.5 测试实例............................... 240
6.4.6 测试夹具............................... 242
6.4.7 测试日志............................... 244
6.4.8 运行参数............................... 245
6.4.9 函数执行监视器................... 246
6.4.10 程序执行监视器................. 249
6.4.11 高级议题............................. 249
6.5 总结.............................................251
第7 章容器与数据结构...........................253
7.1 array .............................................253
7.1.1 类摘要................................... 254
7.1.2 操作函数............................... 254
7.1.3 用法....................................... 255
7.1.4 能力限制............................... 256
7.1.5 初始化................................... 257
7.1.6 零长度的数组....................... 257
7.1.7 对比C++11 标准.................. 258
7.2 dynamic_bitset .............................258
7.2.1 类摘要................................... 259
7.2.2 创建与赋值........................... 260
7.2.3 容器操作............................... 261
7.2.4 位运算与比较运算............... 262
7.2.5 访问元素............................... 263
7.2.6 类型转换............................... 264
7.2.7 集合操作............................... 265
7.2.8 综合运用............................... 265
7.3 unordered .....................................267
7.3.1 散列集合简介....................... 267
7.3.2 散列集合的用法................... 269
7.3.3 散列映射简介....................... 271
7.3.4 散列映射的用法................... 272
7.3.5 高级议题............................... 274
7.4 bimap ...........................................276
7.4.1 类摘要................................... 276
7.4.2 基本用法............................... 277
7.4.3 值的集合类型....................... 278
7.4.4 集合类型的用法................... 279
7.4.5 使用标签类型....................... 281
7.4.6 使用assign 库....................... 282
7.4.7 查找与替换........................... 283
7.4.8 投射....................................... 285
7.4.9 高级议题............................... 285
7.5 circular_buffer..............................286
7.5.1 类摘要................................... 287
7.5.2 用法....................................... 288
7.5.3 环形缓冲区........................... 288
7.5.4 空间优化型缓冲区............... 290
7.6 tuple .............................................290
7.6.1 最简单的tuple:pair............... 291
7.6.2 类摘要................................... 292
7.6.3 创建与赋值........................... 292
7.6.4 访问元素............................... 293
7.6.5 比较操作............................... 295
7.6.6 输入输出............................... 295
7.6.7 联结变量............................... 296
7.6.8 应用于assign 库................... 297
7.6.9 应用于exception 库.............. 298
7.6.10 内部结构............................. 298
7.6.11 使用访问者模式................. 299
7.6.12 高级议题............................. 301
7.7 any................................................303
7.7.1 类摘要................................... 303
7.7.2 访问元素............................... 304
7.7.3 用法....................................... 305
7.7.4 简化的操作函数................... 306
7.7.5 保存指针............................... 307
7.7.6 输出....................................... 308
7.7.7 应用于容器........................... 309
7.8 variant ..........................................310
7.8.1 类摘要................................... 310
7.8.2 访问元素............................... 311
7.8.3 用法....................................... 312
7.8.4 访问器................................... 313
7.8.5 与any 的区别........................ 315
7.8.6 高级议题............................... 316
7.9 multi_array...................................317
7.9.1 类摘要................................... 318
7.9.2 用法....................................... 319
7.9.3 改变形状和大小................... 321
7.9.4 创建子视图........................... 321
7.9.5 适配普通数组....................... 323
7.9.6 高级议题............................... 324
7.10 property_tree..............................326
7.10.1 类摘要................................. 327
7.10.2 读取配置信息..................... 328
7.10.3 写入配置信息..................... 330
7.10.4 更多用法............................. 331
7.10.5 XML 数据格式.................... 332
7.10.6 其他数据格式..................... 333
7.10.7 高级议题............................. 335
7.11 总结............................................336
第8 章算法..............................................339
8.1 foreach .........................................339
8.1.1 用法....................................... 340
8.1.2 详细解说............................... 341
8.1.3 更优雅的名字....................... 342
8.1.4 支持的序列类型................... 343
8.1.5 存在的问题........................... 344
8.2 minmax ........................................344
8.2.1 用法....................................... 345
8.2.2 存在的问题........................... 345
8.3 minmax_element..........................346
8.3.1 用法....................................... 346
8.3.2 其他函数的用法................... 347
8.4 algorithm......................................348
8.4.1 clamp ..................................... 348
8.4.2 clamp_range .......................... 349
8.4.3 hex 和unhex ......................... 349
8.5 总结.............................................350
第9 章数学与数字...................................353
9.1 math.constants..............................353
9.1.1 基本用法............................... 354
9.1.2 高级用法............................... 355
9.2 integer ..........................................355
9.2.1 integer_traits.......................... 355
9.2.2 标准整数类型....................... 357
9.2.3 整数类型模板类................... 359
9.3 rational .........................................362
9.3.1 类摘要................................... 362
9.3.2 创建与赋值........................... 363
9.3.3 算术运算与比较运算........... 364
9.3.4 类型转换............................... 365
9.3.5 输入输出............................... 365
9.3.6 分子与分母........................... 365
9.3.7 与数学函数配合工作............ 366
9.3.8 rational 的精确度.................. 366
9.3.9 最大公约数和最小公倍数.... 366
9.4 ratio ..............................................367
9.4.1 类摘要................................... 367
9.4.2 用法....................................... 368
9.4.3 数字单位............................... 369
9.4.4 字符串表示........................... 371
9.4.5 对比C++11 标准.................. 372
9.5 crc ................................................372
9.5.1 类摘要................................... 372
9.5.2 预定义的实现类................... 373
9.5.3 用法....................................... 373
9.6 random.........................................375
9.6.1 随机数发生器....................... 375
9.6.2 随机数发生器的拷贝............ 377
9.6.3 随机数分布器....................... 377
9.6.4 随机数分布器类摘要............ 378
9.6.5 随机数分布器用法............... 381
9.6.6 变量发生器........................... 382
9.6.7 产生随机数据块................... 383
9.6.8 真随机数发生器................... 384
9.6.9 实现真随机数发生器............ 385
9.7 总结.............................................387
第10 章操作系统相关............................389
10.1 system ........................................389
10.1.1 错误值枚举......................... 390
10.1.2 错误类别............................. 390
10.1.3 错误代码............................. 392
10.1.4 错误异常............................. 394
10.2 chrono ........................................395
10.2.1 时间长度............................. 395
10.2.2 使用时间长度..................... 396
10.2.3 时钟..................................... 398
10.2.4 时间点................................. 400
10.2.5 综合运用............................. 402
10.3 cpu_timer ...................................404
10.3.1 时间类型............................. 404
10.3.2 cpu_timer............................. 405
10.3.3 auto_cpu_timer .................... 406
10.3.4 定制输出格式..................... 407
10.4 filesystem ...................................408
10.4.1 类摘要................................. 409
10.4.2 路径表示............................. 411
10.4.3 可移植的文件名................. 412
10.4.4 路径处理............................. 413
10.4.5 异常处理............................. 415
10.4.6 文件状态............................. 416
10.4.7 文件属性............................. 418
10.4.8 文件操作............................. 419
10.4.9 迭代目录............................. 420
10.4.10 实例1：实现查找
文件功能........................... 423
10.4.11 实例2：实现模糊查找
文件功能........................... 424
10.4.12 实例3：实现拷贝
目录功能........................... 426
10.4.13 文件流操作....................... 427
10.5 program_options ........................428
10.5.1 概述..................................... 429
10.5.2 选项值................................. 431
10.5.3 选项描述器......................... 432
10.5.4 选项描述器的用法............. 433
10.5.5 分析器................................. 435
10.5.6 存储器................................. 436
10.5.7 使用位置选项值................. 437
10.5.8 分析环境变量..................... 439
10.5.9 分组选项信息..................... 440
10.5.10 高级用法........................... 442
10.6 总结...........................................445
第11 章函数与回调................................447
11.1 ref ...............................................447
11.1.1 类摘要................................. 448
11.1.2 基本用法............................. 449
11.1.3 工厂函数............................. 450
11.1.4 操作包装............................. 450
11.1.5 综合应用............................. 451
11.1.6 对比C++11 标准................ 452
11.2 bind ............................................453
11.2.1 工作原理............................. 454
11.2.2 绑定普通函数..................... 455
11.2.3 绑定成员函数..................... 456
11.2.4 绑定成员变量..................... 458
11.2.5 绑定函数对象..................... 458
11.2.6 使用ref 库........................... 459
11.2.7 对比C++11 标准................ 460
11.2.8 高级议题............................. 460
11.3 function ......................................463
11.3.1 类摘要................................. 464
11.3.2 function 的声明................... 465
11.3.3 操作函数............................. 465
11.3.4 比较操作............................. 466
11.3.5 用法..................................... 466
11.3.6 使用ref 库........................... 468
11.3.7 用于回调............................. 469
11.3.8 对比C++11 的auto ............ 471
11.3.9 对比std::function ................ 472
11.4 signals2 ......................................472
11.4.1 类摘要................................. 473
11.4.2 操作函数............................. 474
11.4.3 插槽的连接与调用.............. 475
11.4.4 信号的返回值..................... 477
11.4.5 合并器................................. 477
11.4.6 管理信号的连接................. 479
11.4.7 更灵活的管理信号连接..... 480
11.4.8 自动连接管理..................... 483
11.4.9 应用于观察者模式............. 485
11.4.10 高级议题........................... 488
11.5 总结............................................492
第12 章并发编程....................................495
12.1 atomic.........................................495
12.1.1 类摘要................................. 496
12.1.2 基本用法............................. 498
12.1.3 整数atomic 的用法............ 499
12.1.4 并发顺序一致性................. 500
12.2 thread .........................................503
12.2.1 mutex................................... 503
12.2.2 lock_guard ........................... 506
12.2.3 unique_lock ......................... 507
12.2.4 lock 适配器......................... 510
12.2.5 lockable 概念检查类........... 512
12.2.6 lock 函数............................. 512
12.2.7 thread................................... 513
12.2.8 使用线程............................. 515
12.2.9 中断线程............................. 518
12.2.10 thread_group...................... 521
12.2.11 call_once............................ 522
12.2.12 条件变量........................... 523
12.2.13 shared_mutex..................... 527
12.2.14 future ................................. 529
12.2.15 shared_future ..................... 533
12.2.16 高级议题........................... 534
12.3 asio.............................................536
12.3.1 概述..................................... 537
12.3.2 UNIX 信号.......................... 543
12.3.3 定时器................................. 549
12.3.4 网络通信概述..................... 554
12.3.5 同步TCP 通信.................... 560
12.3.6 异步TCP 通信.................... 562
12.3.7 解析网络地址..................... 568
12.3.8 协程..................................... 570
12.3.9 其他议题............................. 573
12.4 总结...........................................577
第13 章 Boost 组件速览.........................579
13.1 算法...........................................579
13.2 字符串和文本处理....................580
13.3 容器与数据结构........................580
13.4 迭代器.......................................581
13.5 函数对象与高级编程................582
13.6 泛型编程...................................583
13.7 模板元编程................................585
13.8 预处理元编程............................585
13.9 并发编程...................................586
13.10 数学与数字..............................587
13.11 TR1 实现..................................588
13.12 输入输出.................................588
13.13 C++11 特性模拟实现..............588
13.14 杂项.........................................589
13.15 总结.........................................591
第14 章 Boost 与设计模式.....................593
14.1 创建型模式...............................594
14.2 结构型模式...............................595
14.3 行为模式...................................598
14.4 其他模式...................................601
14.5 总结...........................................603
第15 章结束语........................................605
15.1 未臻完美的Boost .....................605
15.2 让Boost 工作得更好................606
15.3 工夫在诗外...............................608
15.4 临别赠言...................................610
附录A 推荐书目.......................................611
附录B C++标准简述................................613
附录C C++关键字浅谈...........................617
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>像丘吉尔一样演讲  像林肯一样站立
第1章　停顿的力量
——开启非凡魅力的钥匙
以停顿提高听众们的预期／2
开口之前沉默片刻／3
有力的停顿犹如心理调节器／5
站立、凝视并控制你的听众／6
第2章　开场的力量
——以一鸣惊人的方式开始你的发言
取悦他人的开场是愚蠢的开场／8
以巨大的反响开场／9
以一个领袖的魄力开场／13
第3章　仪态的力量
——让衣着宣告你的专业素养
风度翩翩的领袖／16
个性化的标志／19
配饰的威力／20
明星式的造型／22
轻便低调的职业装／23
让自己变得明智／28
第4章　要点的力量
——主要目标优先法则
理出概要性信息／30
有力主旨的秘密／31
停顿、思考、计划／33
锁定你的目的地／36
心口不一／37
第5章　精炼的力量
——简短的才是明智的
少即是多／38
简明扼要胜过冗长乏味／40
更短更甜蜜／43
单刀直入听起来果断坚定／44
讲故事，勿说教／45
标新立异往往出人意料／46
第6章　引用的力量
——扩大信息的影响力
尼克松的“引用部长”／51
引文的重构和戏剧化／53
交叉引用／55
戏剧化地强调／57
提出、呈现、表演你的引用／58
第7章　数据的力量
——用数据讲述一个故事，让听众记住它
比往返月球的路程还要长／64
太多的数据让听众麻木／65
信赖还是记住／65
使用听众熟悉的措词和事例类比／70
用数据骗人与欺骗性的数据／73
第8章　“不插电”的力量
——不要用PPT代替演说
幻灯片：不能替代演说／76
强调而非代替／77
让幻灯片简洁／78
第9章　幽默的力量
——在娱乐的同时启发他人
不要刻意添加笑话／84
幽默的3R原则／86
让故事逼真并切中要害／87
讲述而不是朗读一个有趣的故事／95
以幽默开场或结束／100
第10章　比喻的力量
——挖出一个支持你观点的故事
寓言使抽象事物形象化／104
把概念变得具体／105
逸闻兵工厂／106
故事仓库／108
用案例支持你的观点／111
第11章　姿势的力量
——用行动为自己说话
姿势比词汇表达得更多／114
肢体语言大师／116
在正确的时间用正确的信号／118
铅笔比利剑更强大／119
寻找正确展示的良机／121
第12章　朗读的力量
——把你的讲稿与听众分享
记住内容并转化为对话／124
不要在低头浏览时发声／125
“看—停—说”技术／127
第13章　诗化的力量
——像领袖那样谋篇布局
“演讲即诗”／133
把讲稿转化为诗篇／135
让你的布局发光／138
第14章　韵律的力量
——让句子可供记忆并长久流传
异质相吸／149
主要策略：韵律／152
“反复”效应／157
押头韵并激活语句／163
比喻的方法／166
第15章　提问的力量
——巧妙的问题胜过千言万语
重要的问题／171
变陈述为提问／173
修辞的力量／174
第16章　词语的力量
——确立并强化一个关键词
引入有力的词语／178
引入有力的短语／180
用形容词锁定要害／182
第17章　主动的力量
——主动句让陈述更有力度
被动句苍白无力／185
被动的语调，被动的想法／189
辩解的声音（“用被动词遮住你的屁股”）／191
第18章　筹码的力量
——把决斗的心态作为心理武器
伟大的说服者／193
反抗：获取财富的入场券／195
设计：画一幅画／196
捐赠：脆弱的心赢不了／198
决斗：在正午的O.K. 畜栏边／199
第19章　启动的力量
——点亮你的句子，燃起听众的热情
准备、布置、聆听／202
像点亮霓虹灯般让一个句子闪耀／204
用有力的启动语来点火／205
推出你的启动句／206
与众不同的里根／207
每场演讲都用一个启动句／208
第20章　结尾的力量
——在由衷的掌声中结束演讲
一个强大的最后印象／210
应用他们的逸事／215
以历史逸闻收尾／217
我钟爱的三大结束语／219
选择一个可信的结束语／220
找到你自己的结尾／225
简洁干脆的结尾与令人激动的结尾／225
第21章　创新的力量
——让你的演讲与众不同
让你的听众惊讶／227
使用舞台场景／229
敢于与众不同／233
忘掉会议，获得关注／235
打破先例，胆大敢为／237
附录：世界名人演讲词选编
1. 华盛顿　第一次就职演讲（节选）／239
2. 华盛顿　告别演说（节选）／242
3. 杰斐逊　第一次就职演讲／246
4. 华雷斯　誓死保卫独立／251
5. 林肯　连任总统就职演讲词／254
6. 林肯　葛底斯堡演说／257
7. 罗斯福　恐惧本身乃唯一值得恐惧之物（节选）／259
8. 罗斯福　就“珍珠港事件”发表的全国演说（节选）／262
9. 丘吉尔　对英国人民第一次广播演讲（节选）／264
10. 丘吉尔　最光荣的时刻（节选）／266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>像丘吉尔一样演讲  像林肯一样站立
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自我与他者
导论
第一部分 路易斯“他者性”美学观根基：恒存的他者——“道”
第一章《人的消解》的核心思想
第一节 理性、情感对客观价值的“合宜”反应：《无心胸之人》
第二节 客观价值之道的必然性：《常道》
第三节 “道”的消解与人的消解：《人的消解》
第二章《人的消解》与路易斯“他者性”美学思想
第一节 恒存之道——路易斯“他者性”美学的根基
第二节 “道”的客观性与文本与批评的“他者性”
第三节 对于“道”的依从与对于文本的接受
第四节 超越时代的“道”与超越时代的文本传统
第五节 人与“道”的和谐与阅读批评实践中自我对他者的仁爱
第六节 “道”的包容性与路易斯美学中的“埃及金银”
第二部分 阅读、批评与创作的他者性
第三部分 路易斯的“他者性”美学及其中世纪与文艺复兴时期文学研究
第四部分 路易斯美学观的思想溯源
结语虽不能至，心向往之：路易斯与当代批评语境
参考文献
致谢
英文摘要(synopsis)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自我与他者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>农民的道义经济学
前言
导论
第一章 生存伦理的经济与社会学
“安全第一”：生存经济学
生存伦理的社会学
农民社会中的风险分配
生存作为道义承诺
第二章 农民的选择和价值标准中的生存保障
风险与社会分层
乡村的风险保障
租佃与分成租佃的风险
风险和政府
第三章 风险分配与殖民地变革
市场取向的不稳定性
乡村保护的弱化
辅助生存资源的丧失
农村阶级关系的恶化
土地所有制的变革与世界经济
第四章 作为勒索者的政府
缅甸
越南
第五章 经济萧条导致的起义
交趾支那：“红色恐怖”
义安与河静的苏维埃
起义过程
下缅甸——沙耶山起义
第六章 剥削的分析意义：互惠与生存的公正
剥削的标准
剥削——一个道德难题
互惠与交换的平衡
生存——基本的社会权利
传统与稳定交换的打破
社会分层、义务和权利
第七章 反叛、幸存和镇压
反叛的结构性背景
反叛与农民的社会结构
不反叛，自助，或溃散
不反叛：镇压和“错觉”问题
索引
译后感言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>农民的道义经济学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新概念51单片机C语言教程
第1篇 入门篇
1.1 单片机概述
1.1.1 什么是单片机
1.1.2 单片机标号信息及封装类型
1.1.3 单片机能做什么
1.1.4 如何开始学习单片机
1.2 51单片机外部引脚介绍
1.3 电平特性
1.4 二进制与十六进制
1.4.1 二进制
1.4.2 十六进制
1.5 二进制的逻辑运算
1.5.1 与
1.5.2 或
1.5.3 非
1.5.4 同或
1.5.5 异或
1.6 单片机的C51基础知识介绍
1.6.1 利用C语言开发单片机的优点
1.6.2 C51中的基本数据类型
1.6.3 C51数据类型扩充定义
1.6.4 C51中常用的头文件
1.6.5 C51中的运算符
1.6.6 C51中的基础语句
1.6.7 学习单片机应该掌握的主要内容
2.1 Keil工程建立及常用按钮介绍
2.1.1 Keil工程的建立
2.1.2 常用按钮介绍
2.2 点亮第一个发光二极管
2.3 while语句
2.4 for语句及简单延时语句
2.5 Keil仿真及延时语句的精确计算
2.6 不带参数函数的写法及调用
2.7 带参数函数的写法及调用
2.8 利用C51库函数实现流水灯
第2篇 内外部资源操作篇
3.1 数码管显示原理
3.2 数码管静态显示
3.3 数码管动态显示
3.4 中断概念
3.5 单片机的定时器中断
4.1 独立键盘检测
4.2 矩阵键盘检测
5.1 模拟量与数字量概述
5.2 A/D转换原理及参数指标
5.3 ADC0804工作原理及其实现方法
5.4 D/A转换原理及其参数指标
5.5 DAC0832工作原理及实现方法
5.6 DAC0832输出电流转换成电压的方法
第6章 串行口通信原理及操作流程
6.1 并行与串行基本通信方式
6.2 RS-232电平与TTL电平的转换
6.3 波特率与定时器初值的关系
6.4 51单片机串行口结构描述
6.5 串行口方式1编程与实现
6.6 串行口打印在调试程序中的应用
第7章 通用型1602，12232，12864液晶操作方法
7.1 液晶概述
7.2 常用1602液晶操作实例
7.3 常用12232液晶操作实例
7.4 常用12864液晶操作实例
第8章 I2C总线AT24C02芯片应用
8.1 I2C总线概述
8.2 单片机模拟I2C总线通信
8.3 E2PROM AT24C02与单片机的通信实例
第9章 基础运放电路专题
9.1 运放概述及参数介绍
9.2 反相放大器
9.3 同相放大器
9.4 电压跟随器
9.5 加法器
9.6 差分放大器
9.7 微分器
9.8 积分器
第3篇 提高篇
第10章 定时器/计数器应用提高
10.1 方式0应用
10.2 方式2应用
10.3 方式3 应用
10.4 52单片机定时器2介绍
10.5 计数器应用
第11章 串行口应用提高
11.1 方式0应用
11.2 方式2和方式3应用
11.3 单片机双机通信
11.4 单片机多机通信
第12章 指针
12.1 指针与指针变量
12.1.1 内存单元、地址和指针
12.1.2 指针变量的定义、赋值与引用
12.2 指针变量的运算
12.3 指针与数组
12.3.1 指针与一维数组
12.3.2 指针与多维数组
12.4 指针与函数
12.4.1 指针作为函数的参数
12.4.2 指向函数的指针
12.4.3 指针型函数
12.5 指针与字符串
12.5.1 字符串的表达形式
12.5.2 字符指针作为函数参数
12.5.3 使用字符指针与字符数组的区别
12.6 指针数组与命令行参数
12.6.1 指针数组的定义和使用
12.6.2 指向指针的指针
12.6.3 指针数组作为main()函数的命令行参数
12.7 指针小结
12.7.1 指针概念综述
12.7.2 指针运算小结
12.7.3 等价表达式
12.8 C51中指针的使用
12.8.1 指针变量的定义
12.8.2 指针应用
第13章 STC系列51单片机功能介绍
13.1 单片机空闲与掉电模式应用
13.2 “看门狗”概念及其应用
13.3 用软件实现系统复位
13.4 内部扩展RAM的应用
13.5 扩展P4口的应用
13.6 内部E2PROM的应用
13.7 STC89系列单片机内部A/D应用
13.8 STC12系列单片机内部A/D应用
13.9 STC12系列单片机的PCA/PWM介绍
13.10 STC12系列单片机的SPI接口介绍
13.11 STC12系列单片机的“576MHz”超速运行
第4篇 实战篇
第14章 利用51单片机的定时器设计一个时钟
14.1 如何从矩阵键盘中分解出独立按键
14.2 原理图分析
14.3 实例讲解
第15章 使用DS12C887时钟芯片设计高精度时钟
15.1 时钟芯片概述
15.2 DS12C887时钟芯片介绍
15.3 如何用TX-1C实验板扩展本实验
15.4 原理图分析
15.5 实例讲解
第16章 使用DS18B20温度传感器设计温控系统
16.1 温度传感器概述
16.2 DS18B20温度传感器介绍
16.3 实例讲解
第17章 太阳能充/放电控制器
17.1 控制器原理图分析
17.2 控制器板上元件介绍
17.3 实例讲解
第18章 VC、VB（MSCOMM控件）与单片机通信实现温度显示
18.1 VC MSCOMM控件与单片机通信实现温度显示
18.2 VB MSCOMM控件与单片机通信实现温度显示
第5篇 拓展篇
第19章 使用Protell 99绘制电路图全过程
19.1 绘制电路板概述
19.2 建立工程
19.3 制作元件库
19.4 添加封装及制作PCB封装库
19.5 错误检查及生成PCB
19.6 布线电气特性设置
19.7 自动布线和手动布线
第20章 ISD400x系列语音芯片应用
20.1 ISD400x系列语音芯片介绍
20.2 ISD400x系列语音芯片操作规则
20.3 ISD400x系列语音芯片应用实现
第21章 电机专题
21.1 直流电机原理及应用
21.2 步进电机原理及应用
21.3 舵机原理及其应用
第22章 常用元器件介绍
22.1 二极管
22.2 电容
22.3 场效应管
22.4 光耦
22.5 蜂鸣器
22.6 继电器
22.7 自恢复保险
22.8 瞬态电压抑制器
22.9 晶闸管（可控硅）
22.10 电荷泵
第23章 直流稳压电源专题
23.1 整流电路
23.2 滤波电路
23.3 稳压电路
23.4 集成稳压模块的使用
23.5 串联开关型稳压电源
第24章 运放扩展专题
24.1 简单低通滤波器
24.2 “电流-电压”转换电路
24.3 光电放大器
24.4 精密电流源
24.5 可调参考电压源
24.6 复位稳定放大器
24.7 模拟乘法器
24.8 全波整流器和平均值滤波器
24.9 正弦波振荡器
24.10 三角波发生器
24.11 自动跟踪对称电源
24.12 可调实验电源
24.13 运放相关术语表
附录A 天祥电子开发实验板简介
A.1 TX-1C 51单片机开发板（配套详细视频教程）
A.2 AVR单片机开发板（配套详细视频教程）
A.3 PIC单片机开发板（配套详细视频教程）
A.4 J-Link全功能ARM仿真器
A.5 三星S3C44B0 ARM7入门级开发板
A.6 三星S3C44B0 ARM7提高级开发板
A.7 TX-51STAR 51单片机开发板（配套详细视频教程）
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新概念51单片机C语言教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>文明的崩塌
目  录
丛书编辑序
前言
致谢
序曲
文明的崩溃：公元前1177年
第一幕
武器与人类：公元前15世纪
第二幕
爱琴故事：公元前14世纪
第三幕
为诸神和国家而战：公元前13世纪
第四幕
时代的终结：公元前12世纪
终章
大难来临的“完美风暴“？
收场白
人物表
注释
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>文明的崩塌
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学C语言
第1篇  C语言入门第1章 C语言入门基础第2章 认识C语言程序第2篇 C语言基础第3章 常量、变量与标识符第4章 数据类型第5章 运算符及其表达式第6章 输入与输出第7章 顺序结构与选择结构第8章 循环结构程序设计第9章 结构语句的转移第3篇  C语言进阶第10章 数组第11章 字符数组第12章 函数第13章 函数的调用第14章 指针操作第15章 结构体第16章 共用体第17章 文件第4篇  案例实例第18章 学生成绩管理系统设计附录A ASCII字符集附录B 运算符的优先级与结合性附录C C语言常用库函数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
第1章 C++面向对象程序设计
1.1 抽象数据类型
1.2 封装
1.3 继承
1.4 指针
1.4.1 指针和数组
1.4.2 指针和复制构造函数
1.4.3 指针和析构函数
1.4.4 指针和引用变量
1.4.5 函数指针
1.5 多态性
1.6 C++和面向对象程序设计
1.7 标准模板库
1.7.1 容器
1.7.2 迭代器
1.7.3 算法
1.7.4 函数对象
1.8 标准模板库中的向量
1.9 数据结构与面向对象编程
1.10 案例分析：随机访问文件
1.11 习题
1.12 程序设计作业
第2章 复杂度分析
2.1 计算复杂度和渐近复杂度
2.2 大O符号
2.3 大O符号的性质
2.4 Q符号与@符号
2.5 可能的问题
2.6 复杂度举例
2.7 确定渐近复杂度举例
2.8 最好、平均和最坏情况
2.9 阻尼复杂度
2.10 NP完整性
2.11 习题
第3章 链表
3.1 单链表
3.1.1 插入
3.1.2 删除
3.1.3 查找
3.2 双链表
3.3 循环链表
3.4 跳跃链表
3.5 自组织链表
3.6 稀疏表
3.7 标准模板库中的链表
3.8 标准模板库中的双端队列
3.9 小结
3.10 案例分析：图书馆
3.11 习题
3.12 程序设计作业
第4章 栈与队列
4.1 栈
4.2 队列
4.3 优先队列
4.4 标准模板库中的栈
4.5 标准模板库中的队列
4.6 标准模板库中的优先队列
4.7 案例分析：迷宫问题
4.8 习题
4.9 程序设计作业
第5章 递归
5.1 递归定义
5.2 函数调用与递归实现
5.3 递归调用的剖析
5.4 尾部递归
5.5 非尾部递归
5.6 间接递归
5.7 嵌套递归
5.8 不合理递归
5.9 回溯
5.10 小结
5.11 案例分析：递归下降解释器
5.12 习题
5.13 程序设计作业
第6章 二叉树
6.1 树、二叉树和二叉搜索树
6.2 二叉树的实现
6.3 二叉搜索树的查找
6.4 树的遍历
6.4.1 广度优先遍历
6.4.2 深度优先遍历
6.4.3 不用栈实现的深度优先遍历
6.5 插入
6.6 删除
6.6.1 合并删除
6.6.2 通过复制进行删除
6.7 树的平衡
6.7.1 DSW算法
6.7.2 AVL树
6.8 自调整树
6.8.1 自重新构造树
6.8.2 “张开”策略
6.9 堆
6.9.1 将堆作为优先队列
6.9.2 将数组组织为堆
6.10 波兰记号和表达式树
6.11 案例分析：计算单词出现的频率
6.12 习题
6.13 程序设计作业
第7章 多叉树
7.1 B树家族
7.1.1 B树
7.1.2 B*树
7.1.3 B+树
7.1.4 前缀B+树
7.1.5 位树
7.1.6 R树
7.1.7 2-4树
7.1.8 标准模板库中的集和多集
7.1.9 标准模板库中的映射和多映射
7.2 trie
7.3 小结
7.4 案例分析：拼写检查器
7.5 习题
7.6 程序设计作业
第8章 图
8.1 图的表示法
8.2 图的遍历
8.3 最短路径
8.4 环的检测
8.5 生成树
8.6 连通性
8.6.1 无向图中的连通性
8.6.2 有向图中的连通性
8.7 拓扑排序
8.8 网络
8.8.1 最大流
8.8.2 成本最低的最大流
8.9 匹配
8.9.1 稳定匹配问题
8.9.2 分配问题
8.9.3 非二分图中的匹配集合
8.10 欧拉（Eulerian）图与汉密尔顿（Hamil tonian）图
8.10.1 欧拉图
8.10.2 汉密尔顿图
8.11 给图加上颜色
8.12 图理论中的NP完整性问题
8.12.1 派系问题
8.12.2 三色问题
8.12.3 顶点覆盖问题
8.12.4 汉密尔顿环问题
8.13 案例分析：唯一代表
8.14 习题
8.15 程序设计作业
第9章 排序
第10章 散列
第11章 数据压缩
第12章 内存管理
第13章 字符串匹配
附录A 计算大O
附录B 标准模板库中的算法
附录C NP完整性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>皮尔士论符号
致谢
导言
1．论宗教思维的界限以证明我们能就上帝的本性进
行推理
2．[形而上学论]
3．论一个新范畴表
4．对于据称为人所具有的某些机能的质疑
5．四种机能缺失之结论
6．逻辑规律有效性的基础：四种机能缺失的进一步
结论
7．[弗雷泽版《贝克莱著作集》](书评)
8．论符号特性
9．确立信念
10．如何澄清观念
11．一、二、三：思维与自然的基本范畴
12．试猜这个谜
13．詹姆斯的心理学
14．人的脆弱本质
15．精密逻辑
16．符号
17．实用主义演讲
18．“实用主义”定义
19．为实效主义申辩序
20．实效主义的基础
21．上帝实在性的一个被疏忽的论证
参考文献
译后记：皮尔士的符号学设想与文本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>皮尔士论符号
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
第1章 概要
1.1 本书的主要内容
1.2 面向对象的设计
1.3 对象分级与设计方法
1.4 需要了解的C＋＋特性
1.5 本书是如何组织的？

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自制搜索引擎
第1章　搜索引擎是如何工作的　　1
1-1　理解搜索引擎的构成　　3
什么是搜索引擎　　3
构成搜索引擎的组件　　4
与搜索引擎相关的组件　　5
1-2　 实现了快速全文搜索的索引结构　　7
全文搜索的两种方法　　7
倒排索引的结构　　8
倒排索引的构建方法　　9
倒排索引中的术语　　10
1-3　深入理解倒排索引　　12
倒排索引=词典+倒排文件　　12
从倒排索引中查找单词　　13
将单词的位置信息加入倒排文件中　　13
从倒排索引中查找短语　　14
1-4　制作中文文档的倒排索引　　16
分割中文句子的方法　　16
权衡分割方法　　17
1-5　实现倒排索引　　19
实现词典　　19
实现倒排文件　　22
1-6　使用倒排索引进行检索　　24
布尔检索　　24
使用倒排索引的检索处理流程　　24
关联度的计算方法　　26
信息检索中的检索　　27
1-7　构建倒排索引　　29
使用内存构建倒排索引　　29
使用二级存储构建倒排索引　　29
静态索引构建和动态索引构建　　32
1-8　准备要检索的文档　　34
收集数据　　34
数据规范化　　35
第2章　准备全文搜索引擎的检索样本　　37
2-1　全文搜索引擎wiser　　39
wiser的构成　　39
准备用于检索的文档　　40
2-2　安装wiser　　42
构建wiser　　42
启动wiser　　43
解压缩Wikipedia的副本　　44
2-3　运行wiser　　45
构建倒排索引　　45
使用倒排索引查询　　46
比较grep和wiser的运行速度　　46
第3章　构建倒排索引　　49
3-1　复习有关倒排索引的知识　　51
提取词元　　51
为每个词元创建倒排列表　　53
3-2　构建倒排索引　　54
在存储器上创建倒排列表　　54
倒排列表和倒排文件的数据结构　　54
从源代码级别梳理倒排索引的构建顺序　　56
进一步阅读源代码　　59
专栏　根据实际情况设计搜索引擎（系统）　　68
第4章　开始检索吧　　71
4-1　检索处理的大致流程　　73
充分理解检索处理的流程　　73
4-2　使用倒排索引进行检索　　75
从源代码级别梳理检索处理的流程　　75
解读split_query_to_tokens()函数的具体实现　　76
使用具体示例加深对检索处理流程的理解　　77
解读函数search_docs()的实现细节　　80
解读函数search_phrase()的实现　　84
专栏　如何实现标签检索　　88
第5章　压缩倒排索引　　89
5-1　压缩的基础知识　　90
压缩倒排索引的好处　　90
专栏　压缩的目的　　90
倒排索引的压缩方法　　91
倒排文件的压缩方法　　91
压缩的原理　　94
5-2　实现wiser中的压缩功能　　97
压缩功能源代码的概要　　97
了解无需进行压缩时的操作　　99
抓住Golomb编码的要点　　101
解读Golomb编码中的编码处理　　105
解读Golomb编码的解码处理　　108
第6章　挑战wiser的优化及参数的调整　　113
6-1　提高检索处理的效率　　115
优化检索处理　　115
将查询分割为无重复部分的词元序列　　116
6-2　禁用短语检索　　119
分析对2字符的字符串进行检索时的行为　　119
分析对3字符的字符串进行检索时的行为　　120
6-3　改变检索结果的输出顺序　　122
作为检索结果排序核心的指标　　122
按照文档大小降序排列的检索结果　　124
专栏　排名欺诈　　128
6-4　 让1个字符的查询也能检索出结果　　29
获取以特定字符开头的词元的列表　　129
合并检索到的结果　　131
专栏　如何实现相似文档的检索　　131
6-5　 调整控制倒排索引更新的缓冲区容量　　133
确认由缓冲区容量的差异带来的不同效果　　133
用sar命令分析负载　　134
6-6　 调整只有英文字母的词元的分割方法　　135
如何避免用英文单词检索时准确率下降的问题　　135
如何判断某字符是否属于索引对象　　135
修改负责分割词元的函数　　136
6-7　确认压缩的效果　　138
观察Golomb编码的效果　　138
对比压缩启用前后的索引大小　　138
专栏　避免滥用全文搜索引擎　　139
第7章　为今后更加深入的学习做准备　　141
7-1　wiser没能实现的功能　　143
倒排索引之外的全文搜索索引　　143
高效处理大规模数据的存储器　　143
利用缓存提高检索的速度　　143
使用各种各样的压缩方法　　144
优化搜索结果的排名　　144
调整准确率和召回率　　145
降低检索结果排序处理的负载　　147
并行处理　　147
结合对属性的筛选过滤　　148
分面搜索　　148
专栏　时延和吞吐量　　149
7-2　 全文搜索引擎Groonga的特点　　150
通过词元的部分一致检索提升召回率　　150
使用内存映射文件　　151
片段　　152
专栏　宣传活动的重要性　　152
7-3　 实现出考虑到用户意图的搜索引擎　　153
引入停用词　　153
应对词素解析的错误　　153
专栏　断句错误　　154
处理全角字符和半角字符　　155
对查询进行归一化　　156
留意布尔检索的解析过程　　156
通过词素解析器适当地解析查询　　157
对错误的输入进行修正　　157
输入补全　　158
建议用户检索相关的关键词　　159
7-4　收集、提取文档时的要点　　160
制作爬虫时的处理要点　　160
在提取文本时需要处理的要点　　163
Appendix　附录　　165
A-1　深度话题 166
近几年的压缩方法　　166
动态索引构建　　169
分布式索引　　174
A-2　wiser中的文本提取和存储　　178
用于处理XML的2 种API——DOM和SAX　　178
提取文档的标题和正文　　179
掌握状态的迁移　　182
构建文档数据库　　187
后记　　191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自制搜索引擎
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C游戏编程从入门到精通
第1章 猜数字游戏
第2章 用C语言函数库画图
第3章 简单动画
第4章 简单图形游戏
第5章 图形模式
第6章 二维图形
第7章 中文显示
第8章 图形文件
第9章 动画原理
第10章 子画面技术
第11章 文件操作
第12章 声音技术
第13章 内存技术
第14章 接口技术
第15章 界面技术
第16章 其他问题
第17章 游戏例程
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C游戏编程从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Exceptional C++（中文版）
目录回到顶部↑
与大师面对面（译序） ⅸ
序 ?
前言 ?ⅰ
泛型程序设计与c++标准库 1
条款1：流 1
条款2：predicates，之一：remove()删除了什么？ 7
条款3：predicates，之二：状态带来的问题 12
条款4：可扩充的模板：使用继承还是traits？ 22
条款5：typename 40
条款6：容器、指针和“不是容器的容器” 45
条款7：使用vector和deque 56
条款8：使用set和map 65
条款9：等同的代码吗？ 72
条款10：模板特殊化与重载 78
条款11：mastermind 84
优化与性能 100
条款12：内联 100
条款13：缓式优化，之一：一个普通的旧式string 104
条款14：缓式优化，之二：引入缓式优化 108
条款15：缓式优化，之三：迭代器与引用 113
.条款16：缓式优化，之四：多线程环境 125
异常安全议题及技术 139
条款17：构造函数失败，之一：对象生命期 139
条款18：构造函数失败，之二：吸收异常？ 144
条款19：未捕获的异常 153
条款20：未管理指针存在的问题，之一：参数求值 160
条款21：未管理指针存在的问题，之二：使用auto_ptr？ 164
条款22：异常安全与类的设计，之一：复制赋值 171
条款23：异常安全与类的设计，之二：继承 181
继承与多态 187
条款24：为什么要使用多继承？ 187
条款25：模拟多继承 191
条款26：多继承与连体双婴问题 195
条款27：（非）纯虚函数 200
条款28：受控的多态 207
内存及资源管理 210
条款29：使用auto_ptr 210
条款30：智能指针成员，之一：auto_ptr存在的问题 219
条款31：智能指针成员，之二：设计valueptr 225
自由函数与宏 239
条款32：递归声明 239
条款33：模拟嵌套函数 245
条款34：预处理宏 256
条款35：宏定义 260
杂项议题 265
条款36：初始化 265
条款37：前置声明 269
条款38：typedef 271
条款39：名字空间，之一：using声明和using指令 275
条款40：名字空间，之二：迁徙到名字空间 278
后记 293
附录a：（在多线程环境下）并非优化 294
附录b：单线程string实现与多线程安全string实现的对比测试结果 313
参考文献 323
索引 325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Exceptional C++（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通C++
第一部分　基础知识
第1章　绪论　2
1.1　C++简史　2
1.1.1　解释器和编译器　3
1.1.2　不断变化的需求和平台　3
1.1.3　过程化编程、结构化编程和面向对象编程　4
1.1.4　面向对象编程(OOP)　4
1.1.5　C++和面向对象编程　4
1.2　C++的发展历程　5
1.3　应该先学习C语言吗　5
1.4　微软的C++托管扩展　6
1.5　ANSI标准　6
1.6　编程准备　6
1.7　开发环境　7
1.8　创建程序的步骤　7
1.8.1　用编译器生成对象文件　7
1.8.2　用链接器生成可执行文件　7
1.9　程序开发周期　8
1.10　HELLO.cpp：第一个C++程序　9
1.11　编译器初步　10
1.12　编译错误　11
1.13　总结　11
1.14　问与答　11
1.15　作业　12
1.15.1　测验　12
1.15.2　练习　12
第2章　C++程序的组成部分　13
2.1　一个简单程序　13
2.2　cout简介　14
2.3　使用标准名称空间　16
2.4　对程序进行注释　17
2.4.1　注释的类型　17
2.4.2　使用注释　18
2.4.3　有关注释的警告　18
2.5　函数　18
2.5.1　使用函数　19
2.5.2　方法和函数　21
2.6　总结　21
2.7　问与答　21
2.8　作业　21
2.8.1　测验　21
2.8.2　练习　21
第3章　使用变量和常量　23
3.1　什么是变量　23
3.1.1　将数据存储在内存中　23
3.1.2　预留内存　24
3.1.3　整型变量的大小　24
3.1.4　基本变量类型　24
3.2　定义变量　25
3.2.1　区分大小写　26
3.2.2　命名规则　26
3.2.3　关键字　27
3.3　确定变量类型占用的内存量　27
3.4　一次创建多个变量　28
3.5　给变量赋值　28
3.6　使用typedef创建别名　29
3.7　何时使用short和long　30
3.7.1　unsigned整型变量的回绕　31
3.7.2　signed整型变量的回绕　31
3.8　使用字符　32
3.8.1　字符和数字　32
3.8.2　特殊打印字符　33
3.9　常量　34
3.9.1　字面常量　34
3.9.2　符号常量　34
3.10　枚举常量　35
3.11　总结　36
3.12　问与答　37
3.13　作业　37
3.13.1　测验　37
3.13.2　练习　38
第4章　管理数组和字符串　39
4.1　什么是数组　39
4.1.1　访问数组元素　39
4.1.2　在数组末尾后写入数据　40
4.1.3　护栏柱错误　42
4.1.4　初始化数组　42
4.1.5　声明数组　43
4.2　使用多维数组　44
4.2.1　声明多维数组　44
4.2.2　初始化多维数组　44
4.3　字符数组和字符串　46
4.4　使用方法strcpy()和strncpy()　48
4.5　string类　49
4.6　总结　50
4.7　问与答　51
4.8　作业　51
4.8.1　测验　51
4.8.2　练习　51
第5章　使用表达式、语句和运算符　53
5.1　语句简介　53
5.1.1　使用空白　53
5.1.2　语句块和复合语句　54
5.2　表达式　54
5.3　使用运算符　55
5.3.1　赋值运算符　55
5.3.2　数学运算符　55
5.3.3　整数除法和求模　56
5.4　结合使用赋值运算符与数学运算符　57
5.5　递增和递减　57
5.6　理解运算符优先级　59
5.7　括号的嵌套　59
5.8　真值的本质　60
5.9　if语句　61
5.9.1　缩进风格　63
5.9.2　else语句　63
5.9.3　高级if语句　65
5.10　在嵌套if语句中使用大括号　66
5.11　使用逻辑运算符　68
5.11.1　逻辑AND运算符　68
5.11.2　逻辑OR运算符　68
5.11.3　逻辑NOT运算符　68
5.12　简化求值　68
5.13　关系运算符的优先级　69
5.14　再谈真和假　69
5.15　条件运算符(三目运算符)　70
5.16　总结　71
5.17　问与答　71
5.18　作业　71
5.18.1　测验　71
5.18.2　练习　72
第6章　使用函数组织代码　73
6.1　什么是函数　73
6.2　返回值、参数和实参　74
6.3　声明和定义函数　74
6.3.1　函数原型　74
6.3.2　定义函数　75
6.4　函数的执行　76
6.5　确定变量的作用域　77
6.5.1　局部变量　77
6.5.2　作用域为语句块的局部变量　78
6.6　参数是局部变量　79
6.6.1　全局变量　80
6.6.2　有关全局变量的注意事项　81
6.7　创建函数语句时的考虑因素　81
6.8　再谈函数实参　81
6.9　再谈返回值　82
6.10　默认参数　83
6.11　重载函数　85
6.12　函数特有的主题　87
6.12.1　内联函数　87
6.12.2　递归　89
6.13　函数的工作原理　92
6.13.1　抽象层次　92
6.13.2　划分RAM　92
6.13.3　堆栈和函数　93
6.14　总结　94
6.15　问与答　94
6.16　作业　95
6.16.1　测验　95
6.16.2　练习　95
第7章　控制程序流程　97
7.1　循环　97
7.1.1　循环的鼻祖：goto　97
7.1.2　为何避免使用goto语句　98
7.2　使用while循环　98
7.2.1　更复杂的while语句　99
7.2.2　continue和break简介　100
7.2.3　while(true)循环　102
7.3　实现do...while循环　103
7.4　使用do...while　103
7.5　for循环　105
7.5.1　高级for循环　106
7.5.2　空for循环　108
7.5.3　循环嵌套　109
7.5.4　for循环中声明的变量的作用域　110
7.6　循环小结　111
7.7　使用switch语句控制程序流程　112
7.8　总结　116
7.9　问与答　117
7.10　作业　117
7.10.1　测验　117
7.10.2　练习　117
第8章　阐述指针　119
8.1　什么是指针　119
8.1.1　内存简介　119
8.1.2　获取变量的内存地址　120
8.1.3　将变量的地址存储到指针中　120
8.1.4　指针名　121
8.1.5　获取指针指向的变量的值　121
8.1.6　使用间接运算符解除引用　122
8.1.7　指针、地址和变量　122
8.1.8　使用指针来操纵数据　123
8.1.9　查看地址　124
8.1.10　指针和数组名　125
8.1.11　数组指针和指针数组　126
8.2　为什么使用指针　127
8.3　栈和自由存储区(堆)　127
8.3.1　使用关键字new分配内存　128
8.3.2　使用关键字delete归还内存　128
8.4　再谈内存泄漏　130
8.5　在自由存储区上创建对象　130
8.6　删除自由存储区中的对象　130
8.7　迷途指针　131
8.8　使用const指针　133
8.9　总结　134
8.10　问与答　134
8.11　作业　134
8.11.1　测验　134
8.11.2　练习　135
第9章　使用引用　136
9.1　什么是引用　136
9.2　将地址运算符用于引用　137
9.3　空指针和空引用　139
9.4　按引用传递函数参数　139
9.4.1　使用指针让swap()管用　140
9.4.2　使用引用来实现swap()　141
9.5　返回多个值　142
9.6　按引用传递以提高效率　145
9.6.1　传递const指针　147
9.6.2　用引用代替指针　148
9.7　何时使用引用和指针　150
9.8　混合使用引用和指针　150
9.9　返回指向不在作用域中的对象的引用　151
9.10　总结　153
9.11　问与答　153
9.12　作业　153
9.12.1　测验　154
9.12.2　练习　154
第二部分　面向对象编程和C++基础
第10章　类和对象　156
10.1　C++是面向对象的吗　156
10.2　创建新类型　157
10.3　类和成员简介　157
10.3.1　声明类　158
10.3.2　有关命名规则的说明　158
10.3.3　定义对象　159
10.3.4　类与对象　159
10.4　访问类成员　159
10.4.1　给对象而不是类赋值　159
10.4.2　类不能有没有声明的功能　159
10.5　私有和公有　160
10.6　实现类方法　163
10.7　添加构造函数和析构函数　165
10.7.1　默认构造函数和析构函数　166
10.7.2　使用默认构造函数　166
10.8　const成员函数　168
10.9　将类声明和方法定义放在什么地方　169
10.10　内联实现　169
10.11　将其他类用作成员数据的类　171
10.12　探索结构　174
10.13　总结　174
10.14　问与答　174
10.15　作业　175
10.15.1　测验　175
10.15.2　练习　176
第11章　实现继承　177
11.1　什么是继承　177
11.1.1　继承和派生　177
11.1.2　动物世界　178
11.1.3　派生的语法　178
11.2　私有和保护　180
11.3　构造函数和析构函数的继承性　181
11.4　覆盖基类函数　186
11.4.1　隐藏基类的方法　187
11.4.2　调用基类方法　189
11.5　虚方法　190
11.5.1　虚函数的工作原理　193
11.5.2　通过基类指针访问派生类的方法　193
11.5.3　切除　194
11.5.4　创建虚析构函数　195
11.5.5　虚复制构造函数　195
11.5.6　使用虚方法的代价　198
11.6　私有继承　198
11.6.1　使用私有继承　198
11.6.2　私有继承和聚合(组合)　199
11.7　总结　200
11.8　问与答　201
11.9　作业　201
11.9.1　测验　201
11.9.2　练习　202
第12章　多态　203
12.1　单继承存在的问题　203
12.1.1　提升　205
12.1.2　向下转换　205
12.1.3　将对象添加到链表中　207
12.2　多重继承　207
12.2.1　多重继承对象的组成部分　209
12.2.2　多重继承对象中的构造函数　210
12.2.3　避免歧义　212
12.2.4　从共同基类继承　212
12.2.5　虚继承　215
12.2.6　多重继承存在的问题　217
12.2.7　混合(功能)类　217
12.3　抽象数据类型　218
12.3.1　纯虚函数　220
12.3.2　实现纯虚函数　221
12.3.3　复杂的抽象层次结构　224
12.3.4　哪些类是抽象的　226
12.4　总结　226
12.5　问与答　227
12.6　作业　227
12.6.1　测验　227
12.6.2　练习　228
第13章　运算符类型与运算符重载　229
13.1　C++中的运算符　229
13.2　单目运算符　229
13.2.1　单目运算符的类型　230
13.2.2　单目递增与单目递减运算符　230
13.2.3　解除引用运算符*与成员选择运算符-的编程　232
13.2.4　转换运算符的编程　234
13.3　双目运算符　235
13.3.1　双目运算符的类型　235
13.3.2　双目加与双目减运算符的编程　236
13.3.3　运算符+=与-=的编程　237
13.3.4　重载比较运算符　238
13.3.5　重载运算符、、=和=　241
13.3.6　下标运算符　243
13.4　operator()函数　244
13.5　不能重新定义的运算符　245
13.6　总结　245
13.7　问与答　245
13.8　作业　246
13.8.1　测验　246
13.8.2　练习　246
第14章　类型转换运算符　247
14.1　什么是类型转换　247
14.2　为何需要类型转换　247
14.3　为何有些C++程序员不喜欢C风格类型转换　248
14.4　C++类型转换运算符　248
14.4.1　使用static_cast　248
14.4.2　使用dynamic_cast和运行阶段类型识别　249
14.4.3　使用reinterpret_cast　250
14.4.4　使用const_cast　251
14.5　C++类型转换运算符存在的问题　252
14.6　总结　252
14.7　问与答　252
14.8　作业　253
第15章　宏和模板简介　254
15.1　预处理器与编译器　254
15.2　预处理器指令#define　254
15.3　宏函数　255
15.3.1　为什么要使用括号　255
15.3.2　宏与类型安全问题　256
15.3.3　宏与函数及模板之比较　256
15.3.4　内联函数　256
15.4　模板简介　258
15.4.1　模板声明语法　258
15.4.2　各种类型的模板声明　258
15.4.3　模板类　259
15.4.4　模板的实例化和具体化　259
15.4.5　模板与类型安全　259
15.4.6　使用多个参数声明模板　259
15.4.7　使用默认参数来声明模板　260
15.4.8　一个模板示例　260
15.4.9　在实际C++编程中使用模板　261
15.5　总结　262
15.6　问与答　262
15.7　作业　263
15.7.1　测验　263
15.7.2　练习　263
第三部分　学习标准模板库(STL)
第16章　标准模板库简介　266
16.1　STL容器　266
16.1.1　顺序容器　266
16.1.2　关联容器　266
16.1.3　选择正确的容器　267
16.2　STL迭代器　267
16.3　STL算法　268
16.4　使用迭代器在容器和算法之间交互　268
16.5　总结　270
16.6　问与答　270
16.7　作业　270
第17章　STL string类　271
17.1　为何需要字符串操作类　271
17.2　使用STL string类　272
17.2.1　实例化STL string及复制　272
17.2.2　访问string及其内容　273
17.2.3　字符串连接　274
17.2.4　在string中查找字符或子字符串　275
17.2.5　截短STL string　276
17.2.6　字符串反转　278
17.2.7　字符串的大小写转换　278
17.3　基于模板的STL string实现　279
17.4　总结　279
17.5　问与答　279
17.6　作业　280
17.6.1　测验　280
17.6.2　练习　280
第18章　STL动态数组类　281
18.1　std::vector的特点　281
18.2　典型的vector操作　281
18.2.1　实例化vector　281
18.2.2　在vector中插入元素　282
18.2.3　访问vector中的元素　285
18.2.4　删除vector中的元素　286
18.3　理解size()和capacity()　287
18.4　STL deque 类　288
18.5　总结　290
18.6　问与答　290
18.7　作业　290
18.7.1　测验　291
18.7.2　练习　291
第19章　STL list　292
19.1　std::list的特点　292
19.2　基本的list操作　292
19.2.1　实例化std::list对象　292
19.2.2　在list开头插入元素　293
19.2.3　在list末尾插入元素　293
19.2.4　在list中间插入元素　294
19.2.5　删除list中的元素　296
19.3　对list中元素进行反转和排序　297
19.3.1　反转元素的排列顺序　297
19.3.2　元素排序　298
19.4　总结　305
19.5　问与答　305
19.6　作业　305
19.6.1　测验　305
19.6.2　练习　305
第20章　STL set与multiset　306
20.1　简介　306
20.2　STL set和multiset的基本操作　306
20.2.1　实例化std::set对象　306
20.2.2　在STL set或multiset中插入元素　307
20.2.3　在STL set或multiset中查找元素　308
20.2.4　删除STL set或multiset中的元素　309
20.3　使用STL set和multiset的优缺点　315
20.4　总结　316
20.5　问与答　316
20.6　作业　316
20.6.1　测验　316
20.6.2　练习　316
第21章　STL map和multimap　317
21.1　简介　317
21.2　STL map和multimap的基本操作　317
21.2.1　实例化std::map对象　317
21.2.2　在STL map或multimap中插入元素　318
21.2.3　在STL map或multimap中查找元素　320
21.2.4　删除STL map或multimap中的元素　321
21.3　提供自定义的排序谓词　323
21.4　总结　325
21.5　问与答　325
21.6　作业　326
21.6.1　测验　326
21.6.2　练习　326
第四部分　再谈STL
第22章　理解函数对象　328
22.1　函数对象与谓词的概念　328
22.2　函数对象的典型用途　328
22.2.1　一元函数　328
22.2.2　一元谓词　331
22.2.3　二元函数　332
22.2.4　二元谓词　334
22.3　总结　336
22.4　问与答　336
22.5　作业　336
22.5.1　测验　336
22.5.2　练习　336
第23章　STL算法　337
23.1　什么是STL算法　337
23.2　STL算法的分类　337
23.2.1　非变序算法　337
23.2.2　变序算法　338
23.3　STL算法的应用　339
23.3.1　计算元素个数与查找元素　339
23.3.2　在集合中搜索元素或序列　340
23.3.3　将容器中的元素初始化为指定值　342
23.3.4　用for_each处理范围内的元素　344
23.3.5　使用std::transform对范围进行变换　345
23.3.6　复制和删除操作　347
23.3.7　替换值以及替换满足给定条件的元素　349
23.3.8　排序、在有序集合中搜索以及删除重复元素　350
23.3.9　将范围分区　351
23.3.10　在有序集合中插入元素　353
23.4　总结　354
23.5　问与答　354
23.6　作业　355
23.6.1　测验　355
23.6.2　练习　355
第24章　自适应容器：栈和队列　356
24.1　栈和队列的行为特征　356
24.1.1　栈　356
24.1.2　队列　356
24.2　使用STL stack类　356
24.2.1　实例化stack　357
24.2.2　stack的成员函数　357
24.3　使用STL queue类　359
24.3.1　实例化queue　359
24.3.2　queue的成员函数　359
24.4　使用STL优先级队列　361
24.4.1　实例化priority_queue类　361
24.4.2　priority_queue的成员函数　362
24.5　总结　364
24.6　问与答　364
24.7　作业　364
24.7.1　测验　364
24.7.2　练习　364
第25章　使用STL位标志　365
25.1　bitset类　365
25.2　使用std::bitset及其成员　366
25.2.1　std:bitset的运算符　366
25.2.2　std::bitset的成员方法　366
25.3　vectorbool　368
25.3.1　实例化vectorbool　368
25.3.2　使用vectorbool　369
25.4　总结　370
25.5　问与答　370
25.6　作业　370
25.6.1　测验　370
25.6.2　练习　370
第五部分　高级C++概念
第26章　理解智能指针　372
26.1　什么是智能指针　372
26.1.1　使用常规(原始)指针有何问题　372
26.1.2　智能指针有何帮助　372
26.2　智能指针是如何实现的　373
26.3　智能指针类型　374
26.3.1　深度复制　374
26.3.2　写时复制机制　375
26.3.3　引用计数智能指针　375
26.3.4　引用链接智能指针　376
26.3.5　破坏性复制　376
26.4　使用std::auto_ptr　377
26.5　流行的智能指针库　378
26.6　总结　378
26.7　问与答　379
26.8　作业　379
26.8.1　测试　379
26.8.2　练习　379
第27章　处理流　380
27.1　流概述　380
27.1.1　数据流的封装　380
27.1.2　理解缓冲技术　381
27.2　流和缓冲区　382
27.3　标准I/O对象　382
27.4　重定向标准流　382
27.5　使用cin进行输入　382
27.5.1　输入字符串　384
27.5.2　字符串的问题　384
27.5.3　的返回值　386
27.6　cin的其他成员函数　386
27.6.1　单字符输入　386
27.6.2　从标准输入读取字符串　388
27.6.3　使用cin.ignore()　390
27.6.4　查看和插入字符：peek()和putback()　391
27.7　使用cout进行输出　391
27.7.1　刷新输出　391
27.7.2　执行输出的函数　392
27.7.3　控制符、标记和格式化指令　393
27.8　流和printf()函数之比较　396
27.9　文件输入和输出　398
27.9.1　使用ofstream　398
27.9.2　条件状态　398
27.9.3　打开文件进行输入和输出　398
27.9.4　修改ofstream打开文件时的默认行为　400
27.10　二进制文件和文本文件　401
27.11　命令行处理　403
27.12　总结　405
27.13　问与答　405
27.14　作业　406
27.14.1　测验　406
27.14.2　练习　406
第28章　处理异常　407
28.1　程序中的各种错误　407
28.2　异常的基本思想　408
28.2.1　异常处理的组成部分　409
28.2.2　手工引发异常　411
28.2.3　创建异常类　412
28.3　使用try块和catch块　414
28.4　捕获异常的工作原理　415
28.4.1　使用多条catch语句　415
28.4.2　异常层次结构　417
28.5　异常中的数据及给异常对象命名　419
28.6　异常和模板　424
28.7　没有错误的异常　426
28.8　bug和调试　426
28.8.1　断点　427
28.8.2　监视点　427
28.8.3　查看内存　427
28.8.4　查看汇编代码　427
28.9　总结　427
28.10　问与答　427
28.11　作业　428
28.11.1　测验　428
28.11.2　练习　428
第29章　杂项内容　430
29.1　预处理器和编译器　430
29.2　预编译器指令#define　430
29.2.1　使用#define定义常量　431
29.2.2　将#define用于检测　431
29.2.3　预编译器命令#else　431
29.3　包含和防范多重包含　432
29.4　字符串操纵　433
29.4.1　字符串化　433
29.4.2　拼接　433
29.5　预定义的宏　433
29.6　assert()宏　434
29.6.1　使用assert()进行调试　435
29.6.2　assert()与异常之比较　435
29.6.3　副作用　435
29.6.4　类的不变量　436
29.6.5　打印中间值　439
29.7　位运算　440
29.7.1　“与”运算符　441
29.7.2　“或”运算符　441
29.7.3　“异或”运算符　441
29.7.4　“求反”运算符　441
29.7.5　设置位　441
29.7.6　清除位　441
29.7.7　反转位　442
29.7.8　位字段　442
29.8　编程风格　444
29.8.1　缩进　444
29.8.2　大括号　444
29.8.3　长代码行和函数长度　445
29.8.4　格式化switch语句　445
29.8.5　程序文本　445
29.8.6　标识符命名　446
29.8.7　名称的拼写和大写　446
29.8.8　注释　446
29.8.9　设置访问权限　447
29.8.10　类定义　447
29.8.11　包含文件　447
29.8.12　使用assert()　447
29.8.13　使用const　447
29.9　C++开发工作的下一步　447
29.9.1　从何处获得帮助和建议　448
29.9.2　相关的C++主题：托管C++、C#和微软的.NET　448
29.10　总结　448
29.11　问与答　449
29.12　作业　450
29.12.1　测验　450
29.12.2　练习　450
附录A　二进制和十六进制　451
A.1　其他进制　451
A.2　不同进制之间的转换　452
A.2.1　二进制　452
A.2.2　为什么使用二进制　453
A.2.3　位、字节和半字节　453
A.2.4　什么是KB　453
A.2.5　二进制数　454
A.3　十六进制　454
附录B　C++关键字　457
附录C　运算符优先级　458
附录D　答案　459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通C++
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MonoTouch应用开发实践指南
译者序
序
前言
第1章　Hello，MonoTouch / 1
1.1　搭建开发环境 / 2
1.1.1　安装iOS SDK和苹果开发工具 / 2
1.1.2　安装MonoTouch / 5
1.2　创建MonoTouch应用程序 / 9
1.2.1　创建用户界面 / 9
1.2.2　添加outlet / 10
1.3　在设备上进行开发 / 15
1.4　使用MonoTouch调试器 / 20
1.5　小结 / 21
第2章　iOS SDK与MonoTouch / 22
2.1　iOS SDK概述 / 23
2.2　通过示例将Object-C与MonoTouch进行对比 / 24
2.2.1　从Xcode开始编写应用程序 / 25
2.2.2　在MonoTouch中实现相同的功能 / 29
2.2.3　AppDelegate实现的比较 / 30
2.2.4　通过Xcode实现UIActionSheet / 33
2.2.5　在MonoTouch中实现UIActionSheet / 35
2.3　MonoTouch的工作原理 / 38
2.4　小结 / 41
第3章　视图和视图控制器 / 42
3.1　构建MonoTouch MVC应用程序 / 43
3.2　在IB中使用视图和控制器 / 44
3.3　为视图控制器及其视图添加功能 / 50
3.4　使用多个视图和控制器 / 53
3.5　实现自定义UIView / 57
3.6　小结 / 61
第4章　常用的iOS类 / 62
4.1　用户界面视图和控件 / 63
4.1.1　UISegmentedControl / 63
4.1.2　UISlider / 66
4.1.3　UISwitch / 68
4.1.4　UIPageControl和UIScrollView / 69
4.1.5　UIActivityIndicatorView / 71
4.1.6　UIProgressView / 73
4.1.7　UIImageView / 74
4.1.8　UIWebView / 75
4.1.9　ADBannerView / 77
4.2　设备功能 / 80
4.2.1　MFMailComposeViewController / 80
4.2.2　MPMediaPickerController和MPMusicPlayerController / 81
4.2.3　地址簿 / 84
4.2.4　UIImagePickerController / 87
4.3　小结 / 91
第5章　表格和导航 / 92
5.1　UITableView和UITableViewController的概述 / 93
5.1.1　表格有什么用 / 93
5.1.2　在UITableView中显示数据 / 94
5.1.3　UITableViewCell部件与样式 / 99
5.1.4　使用表格和导航 / 102
5.2　其他的UITableView自定义功能 / 115
5.2.1　自定义表格及其单元格 / 115
5.2.2　增加多个区域 / 119
5.2.3　MonoTouch.Dialog / 123
5.3　小结 / 124
第6章　图形和动画 / 125
6.1　核心图形 / 126
6.1.1　核心图形基础 / 126
6.1.2　绘制图像 / 131
6.1.3　绘制PDF / 134
6.2　动画 / 143
6.2.1　UIView动画 / 143
6.2.2　核心动画 / 147
6.3　小结 / 155
第7章　核心定位 / 156
7.1　核心定位概述 / 157
7.2　标准定位服务 / 158
7.3　检索方向变更 / 166
7.4　显著位置变更服务 / 168
7.5　区域监测 / 170
7.6　后台定位 / 172
7.7　小结 / 175
第8章　MapKit / 176
8.1　MapKit概述 / 177
8.2　添加标注 / 181
8.3　地图叠加 / 188
8.4　小结 / 193
第9章　连接Web服务 / 194
9.1　连接基于REST的Web服务 / 195
9.1.1　通过HTTP连接 / 195
9.1.2　解析XML结果 / 197
9.1.3　解析JSON结果 / 200
9.2　使用基于SOAP的Web服务 / 201
9.2.1　使用.NET 2.0客户端代理 / 201
9.2.2　MonoTouch下的WCF / 203
9.3　使用CocoaTouch的HTTP类 / 204
9.4　小结 / 206
第10章　联网 / 207
10.1　GameKit联网功能 / 208
10.1.1　GameKit联网核心类 / 208
10.1.2　使用GKPeerPickerController / 216
10.1.3　GameKit语音聊天 / 219
10.2　Bonjour / 223
10.3　小结 / 231
第11章　保存应用程序的数据 / 232
11.1　记事本示例应用程序 / 233
11.2　SQLite / 238
11.3　序列化 / 243
11.4　Settings Bundle和NSUserDefaults / 245
11.5　小结 / 252
第12章　iPad开发 / 253
12.1　移植到iPad / 254
12.1.1　在iPhone应用程序使用像素倍增技术 / 254
12.1.2　通用应用程序 / 255
12.2　基于iPad的设计 / 258
12.2.1　UISplitViewController / 258
12.2.2　UIPopoverController / 267
12.3　小结 / 270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MonoTouch应用开发实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计 软件工程环境
者序
前言
第1章 计算机导论
1.1 计算机系统
1.2 计算环境
1.3 计算机语言
1.4 创建和运行程序
1.5 系统开发
1.6 软件工程
1.7 要点和常见错误
1.8 关键术语
1.9 习题
第2章 C语言介绍
2.1 背景
2.2 C程序
2.3 标识符
2.4 类型
2.5 变量
2.6 常量
2.7 输入/输出
2.8 程序示例
2.9 软件工程
2.10 要点和常见错误
2.11 关键术语
2.12 习题
第3章 C程序结构
3.1 表达式
3.2 优先级和结合性
3.3 副作用
3.4 表达式求值
3.5 类型转换
3.6 语句
3.7 示例程序
3.8 软件工程
3.9 要点和常见错误
3.10 关键术语
3.11 习题
第4章 函数
4.1 结构化程序设计
4.2 C语言函数
4.3 函数间通信
4.5 标准函数
4.6 作用域
4.7 编程举例——增量式开发
4.8 软件工程
4.9 要点和常见错误
4.10 关键术语
4.11 习题
第5章 选择——作出决定
第6章 循环
第7章 文本输入/输出
第8章 数组
第9章 指针
第10章 指针应用
第11章 字符串
第12章 枚举、结构及联合类型
第13章 二进制输入/输出
第14章 位运算符
第15章 列表
附录A 字符集
附录B 关键字
附录C 流程图
附录D 计数系统
附录E 整数和浮点数库
附录F 函数库
附录G 预处理器命令
附录H 命令行参数
附录I void指针和函数指针
附录J 存储类和类型限定词
附录K 程序开发
附录L 理解复杂声明
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C程序设计 软件工程环境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++面向对象程序设计题解与上机指导
第1部分  《C++面向对象程序设计》习题与参考解答第1章 C++的初步知识第2章 类和对象第3章 关于类和对象的进一步讨论第4章 运算符重载第5章 继承与派生第6章 多态性与虚函数第7章 输入输出流第8章 C++工具第2部分  C++的上机操作第9章 Visual C++的上机操作9.1 Visual C++的安装和启动9.2 输入和编辑源程序9.2.1 新建一个C++源程序的方法9.2.2 打开一个已有的程序9.2.3 通过已有的程序建立一个新程序的方法9.3 编译、连接和运行9.3.1 程序的编译9.3.2 程序的调试9.3.3 程序的连接9.3.4 程序的执行9.4 建立和运行包含多个文件的程序的方法9.4.1 由用户建立项目工作区和项目文件9.4.2 用户只建立项目文件第lO章 GCC的上机操作10.1 GCC简介10.1.1 什么是GCC10.1.2 GCC和DJGPP10.1.3 DJGPP与RHIDE10.2 安装DJGPP10.3 进入DJGPP开发环境RHIDE10.4 使用RHIDE窗口10.4.1 RHIDE窗口10.4.2 在RHIDE中使用鼠标10.5 输入一个新程序10.6 打开已有的文件10.7 源程序的编译和连接10.7.1 关于项目10.7.2 编译源程序10.7.3 程序的连接10.8 运行可执行文件10.9 建立和运行包含多文件的项目文件的方法10.10 程序的调试10.11 退出RHIDE第3部分  上机实验内容与安排第ll章 实验指导11.1 上机实验的指导思想和要求11.2 关于程序的调试和测试第12章 实验内容与安排12.1 实验1 C++程序的运行环境和运行C++程序的方法12.2 实验2 C++对C的扩充12.3 实验3 类和对象(一)12.4 实验4 类和对象(二)12.5 实验5 运算符重载12.6 实验6 继承与派生12.7 实验7 多态性与虚函数12.8 实验8 输入输出流12.9 实验9 C++工具参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++面向对象程序设计题解与上机指导
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows应用高级编程
第1章 Windows编程基础
第2章 简单用户界面控件
第3章 高级用户界面控件
第4章 菜单和工具栏
第5章 使用图形
第6章 打印
第7章 链接数据库
第8章 文件和注册表操作
第9章 使用文档/视图模式
第10章 提供帮助
第11章 部署Windows应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows应用高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>美学史
前辅文
序言
第一章 最初的思想
第二章 柏拉图
艺术与模仿
美
道德
第三章 亚里士多德
悲剧所特有的快感
亚里士多德对柏拉图的回应
第四章 古典晚期的哲学家们
希腊化与罗马古典主义
普罗提诺
第五章 中世纪
圣奥古斯丁
圣托马斯•阿奎那
阐释理论
第六章 文艺复兴
新柏拉图主义
绘画理论
音乐与诗
第七章 启蒙运动：笛卡儿的理性主义
诗学
绘画与音乐理论
走向一个统一的美学
第八章 启蒙运动：经验主义
想象与艺术创造
趣味问题：从夏夫茨伯里到休谟
审美性质：从荷加兹到艾利森
第九章 德国唯心主义
伊曼努尔•康德
客观唯心主义
第十章 浪漫主义
感受的美学
诸种想象的理论
叔本华和尼采
第十一章 艺术家与社会
为艺术而艺术
现实主义
社会责任
第十二章 当代发展
克罗齐与形而上学家们
桑塔耶纳和杜威
符号学的方法
马克思列宁主义
现象学和存在主义
经验主义
索引（按英文顺序）
索引（按汉语拼音顺序）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>美学史
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>罗杰斯心理治疗（万千心理）
第1章　罗杰斯临床治疗中的基本概念
情感回应
营造相互适应氛围
明确表达关注
理解核查
复述
表示理解
消除疑虑
解释
正视问题
直接提问
根据求助问题提出反问
保持沉默和打破沉默
自我暴露
接受更正
第一部分　人本主义学派治疗师对罗杰斯五例面询个案的点评
简　介
洛蕾塔个案
格洛利亚个案
吉尔个案
玛丽个案
路易丝个案
第2章　洛蕾塔个案（1958）
面谈记录
对洛蕾塔个案的点评　来访者中心疗法在精神病患者治疗中的应用
第3章　格洛利亚个案（1964）
罗杰斯和格洛利亚的谈话概要
对格洛利亚个案的点评　“来访者中心”治疗中的必要条件
第4章　吉尔个案（1983）
罗杰斯和吉尔的谈话记录
对吉尔个案的点评　“非指导性咨询”的来源与实践
第5章　玛丽个案（1986）和路易丝个案（1986）
罗杰斯和玛丽的谈话记录
罗杰斯和路易丝的谈话记录
对玛丽个案和路易丝个案的点评　来访者自我决定的重要性
第二部分　不同学派治疗师对罗杰斯五例面询个案的点评
简　介
蒂尔登个案
布朗个案
西尔维亚个案
“愤怒与受伤害”个案
马克个案
第6章　蒂尔登个案（1946）
谈话记录稿
第1次面询
第2次面询小结
第3次面询
第3次面询与第4次面询之间的情况
第4次面询小结
第5次面询
第6次面询小结
第7次面询摘要
第8次面询小结
第9次面询
第10次面询
第11次面询
随访信息
对蒂尔登个案的点评1　完整性注意在来访者中心治疗中的作用
对蒂尔登个案的点评2　从当代精神分析理论的观点看
罗杰斯治疗
第7章　布朗个案（1962）
谈话记录稿
对布朗个案的点评1　罗杰斯怎样为一个沉默的年轻精神病
患者作面询
对布朗个案的点评2　共情的力量—从“过程—体验”的
格式塔观点看罗杰斯的治疗
第8章　西尔维亚个案（1976）
谈话记录稿
西尔维亚个案点评1　罗杰斯如何帮助来访者学会自我治疗
西尔维亚个案点评2　从男女平等的观点看罗杰斯治疗
第9章　“愤怒与受伤害”个案（1977）
“愤怒与受伤害”个案点评1　非同寻常的指导
“愤怒与受伤害”个案点评2　罗杰斯对超自然心理疗法发展的贡献
第10章　马克个案（1982）—一个南非白人的两难处境
谈话记录稿
马克的批评和罗杰斯的回答
罗杰斯的反思
罗杰斯谈16个月之后与马克的通信
马克在面询3年之后写给罗杰斯的信
罗杰斯的结束语
对马克个案的点评1　一次性面询的持续性效果
马克个案点评2　对马克个案的实证分析研究和基于认知—行为理论的述评
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>罗杰斯心理治疗（万千心理）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重新设计社会科学研究
【目录】
中文版序
译者序
前言
第一篇　集合关系与相关关系
第1章　社会科学研究中的集合关系：基本概念 /3
集合关系的本质 /3
集合关系是非对称的 /4
集合关系的两种重要类型 /7
相关方法有时会错失关系 /9
定性比较分析与显式关系 /10
展望 /13
实用附录：构建真值表 /13
第2章　模糊集和模糊集合关系 /15
模糊集的本质 /16
使用模糊集：基础 /18
模糊集关系 /21
展望 /24
实用附录：模糊集合关系 /25
第3章　评估集合关系：一致性与覆盖度 /27
集合论的一致性 /28
集合关系的覆盖度 /35
分隔覆盖度 /41
展望 /44
第二篇　校准与测量
第4章　为什么要校准 /47
什么是校准 /48
定量研究中的常用测量实践 /49
定性研究中的常用测量实践 /52
模糊集：两种方法之间的桥梁 /54
模糊集与常规变量的区别 /55
展望 /56
第5章　校准模糊集 /57
将定距尺度变量转化为模糊集 /58
直接校准法 /60
间接校准法 /64
使用已校准的测量 /67
结论 /71
实用附录：使用fsQCA校准模糊集（直接法） /72
第三篇　条件组态与“自”变量
第6章　组态思维 /75
组态思维和案例导向的研究 /75
组态和传统定量分析 /77
评估组态中的隶属度 /79
比较前因配方 /80
实用附录：如何评估前因配方 /84
第7章　使用模糊集和真值表进行组态分析 /87
模糊集和真值表 /89
向量空间角与真值表行的对应关系 /90
案例在前因条件组合中的分布 /92
评估模糊子集关系的一致性 /94
真值表分析 /95
为什么不简单地二分类化模糊集 /98
结论 /100
实用附录：模糊集真值表程序 /100
第四篇　因果复杂性分析与净效应分析
第8章　有限多样性和反事实案例 /105
反事实案例 /107
案例匹配问题的正式分析 /109
反事实案例和定性比较分析 /111
与传统定量研究的对比 /113
第9章　容易反事实与困难反事实 /115
容易的反事实和QCA /117
示范 /120
反事实分析与案例导向的研究 /124
实用附录：使用模糊集定性比较分析推导中间解 /125
第10章　“净效应”思维的局限性 /127
净效应思维 /128
净效应方法的问题 /129
把焦点转移到案例类别上 /132
组态比较 /134
模糊集和组态分析 /135
展望 /136
第11章　净效应与组态：实证演示 /137
贝尔曲线数据的净效应分析 /138
使用fsQCA重新分析贝尔曲线数据 /140
讨论 /149
实用附录：模糊集分析中的校准 /150
参考文献 /154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重新设计社会科学研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
第1章 程序设计：综述 1
1．1 本书讨论的内容 1
1．2 数学知识复习 2
1．2．1 指数(exponent) 2
1．2．2 对数(logarithm) 2
1．2．3 级数(series) 3
1．2．4 模运算(modular arithmetic) 4
1．2．5 证明方法 5
1．3 递归简论 7
1．4 C++类 10
1．4．1 基本的class语法 10
1．4．2 构造函数的附加语法和访问
函数 11
1．4．3 接口与实现的分离 13
1．4．4 vector类和string类 16
1．5 C++细节 17
1．5．1 指针(pointer) 18
1．5．2 左值、右值和引用 19
1．5．3 参数传递 21
1．5．4 返回值传递 23
1．5．5 std：：swap和std：：move 25
1．5．6 五大函数：析构函数，拷贝构造
函数，移动构造函数，拷贝赋值
operator=，移动赋值operator= 26
1．5．7 C风格数组和字符串 30
1．6 模板 31
1．6．1 函数模板 31
1．6．2 类模板 32
1．6．3 Object、Comparable和一个
例子 33
1．6．4 函数对象 34
1．6．5 类模板的分离式编译 37
1．7 使用矩阵 37
1．7．1 数据成员、构造函数和基本访问
函数 38
1．7．2 operator[] 38
1．7．3 五大函数 39
小结 39
练习 39
参考文献 41
第2章 算法分析 42
2．1 数学基础 42
2．2 模型 44
2．3 要分析的问题 44
2．4 运行时间计算 47
2．4．1 一个简单的例子 47
2．4．2 一般法则 47
2．4．3 最大子序列和问题的求解 49
2．4．4 运行时间中的对数 54
2．4．5 最坏情形分析的局限性 57
小结 58
练习 58
参考文献 63
第3章 表、栈和队列 64
3．1 抽象数据类型(ADT) 64
3．2 表ADT 64
3．2．1 表的简单数组实现 65
3．2．2 简单链表 65
3．3 STL中的vector和list 67
3．3．1 迭代器 68
3．3．2 例子：对表使用erase 69
3．3．3 const_iterators 70
3．4 vector的实现 72
3．5 list的实现 76
3．6 栈ADT 86
3．6．1 栈模型 86
3．6．2 栈的实现 86
3．6．3 应用 87
3．7 队列ADT 93
3．7．1 队列模型 93
3．7．2 队列的数组实现 93
3．7．3 队列的应用 95
小结 96
练习 96
第4章 树 100
4．1 预备知识 100
4．1．1 树的实现 101
4．1．2 树的遍历及应用 102
4．2 二叉树 105
4．2．1 实现 105
4．2．2 一个例子――表达式树 105
4．3 查找树ADT――二叉查找树 108
4．3．1 contains 110
4．3．2 findMin和findMax 111
4．3．3 insert 112
4．3．4 remove 113
4．3．5 析构函数和拷贝构造函数 115
4．3．6 平均情况分析 115
4．4 AVL树 118
4．4．1 单旋转 119
4．4．2 双旋转 121
4．5 伸展树 128
4．5．1 一个简单的想法(不能直接
使用) 128
4．5．2 展开 130
4．6 树的遍历 134
4．7 B树 135
4．8 标准库中的集合与映射 140
4．8．1 集合(set) 140
4．8．2 映射(map) 141
4．8．3 set和map的实现 142
4．8．4 使用多个映射(map)的例 142
小结 147
练习 147
参考文献 153
第5章 散列 155
5．1 一般想法 155
5．2 散列函数 155
5．3 分离链接法 157
5．4 不用链表的散列表 161
5．4．1 线性探测法 161
5．4．2 平方探测法 163
5．4．3 双散列 166
5．5 再散列 167
5．6 标准库中的散列表 169
5．7 以最坏情形O(1)访问的散列表 170
5．7．1 完美散列 170
5．7．2 杜鹃散列 172
5．7．3 跳房子散列 181
5．8 通用散列 184
5．9 可扩散列 186
小结 188
练习 189
参考文献 193
第6章 优先队列(堆) 196
6．1 模型 196
6．2 一些简单的实现 197
6．3 二叉堆 197
6．3．1 结构性质 197
6．3．2 堆序性质 198
6．3．3 基本的堆操作 199
6．3．4 其他的堆操作 203
6．4 优先队列的应用 206
6．4．1 选择问题 206
6．4．2 事件模拟 207
6．5 d堆 208
6．6 左式堆 209
6．6．1 左式堆的性质 209
6．6．2 左式堆操作 210
6．7 斜堆 215
6．8 二项队列 216
6．8．1 二项队列构建 216
6．8．2 二项队列操作 217
6．8．3 二项队列的实现 219
6．9 标准库中的优先队列 224
小结 225
练习 225
参考文献 229
第7章 排序 232
7．1 预备知识 232
7．2 插入排序 233
7．2．1 算法 233
7．2．2 插入排序的STL实现 233
7．2．3 插入排序的分析 235
7．3 一些简单排序算法的下界 235
7．4 希尔排序 236
7．4．1 希尔排序的最坏情形分析 237
7．5 堆排序 239
7．5．1 堆排序的分析 241
7．6 归并排序 242
7．6．1 归并排序的分析 245
7．7 快速排序 247
7．7．1 选取枢纽元 249
7．7．2 分割策略 250
7．7．3 小数组 252
7．7．4 实际的快速排序例程 252
7．7．5 快速排序的分析 254
7．7．6 选择问题的线性期望时间
算法 256
7．8 排序算法的一般下界 258
7．8．1 决策树 258
7．9 选择问题的决策树下界 260
7．10 对手下界(adversary lower
bounds) 262
7．11 线性时间排序：桶式排序和
基数排序 265
7．12 外部排序 269
7．12．1 为什么需要一些新的算法 269
7．12．2 外部排序模型 269
7．12．3 简单算法 269
7．12．4 多路合并 270
7．12．5 多相合并 271
7．12．6 替换选择 272
小结 273
练习题 273
参考文献 278
第8章 不相交集类 281
8．1 等价关系 281
8．2 动态等价性问题 281
8．3 基本数据结构 283
8．4 灵巧求并算法 286
8．5 路径压缩 288
8．6 按秩求并和路径压缩的最坏
情形 289
8．6．1 缓慢增长的函数 289
8．6．2 通过递归分解进行的分析 290
8．6．3 一个O(M log*N)界 295
8．6．4 一个O(Mα(M， N))界 296
8．7 一个应用 297
小结 299
练习 299
参考文献 301
第9章 图论算法 303
9．1 若干定义 303
9．1．1 图的表示 304
9．2 拓扑排序 305
9．3 最短路径算法 308
9．3．1 无权最短路径 309
9．3．2 Dijkstra算法 312
9．3．3 具有负边值的图 317
9．3．4 无圈图 318
9．3．5 所有顶点对间的最短路径 320
9．3．6 最短路径的例 320
9．4 网络流问题 322
9．4．1 一个简单的最大流算法 323
9．5 最小生成树 326
9．5．1 Prim算法 327
9．5．2 Kruskal算法 329
9．6 深度优先搜索的应用 330
9．6．1 无向图 331
9．6．2 双连通性 332
9．6．3 欧拉回路 335
9．6．4 有向图 338
9．6．5 查找强分支 339
9．7 NP完全性介绍 340
9．7．1 难与易 341
9．7．2 NP类 341
9．7．3 NP完全问题 342
小结 344
练习 344
参考文献 350
第10章 算法设计技巧 353
10．1 贪婪算法 353
10．1．1 一个简单的调度问题 354
10．1．2 哈夫曼编码 355
10．1．3 近似装箱问题 359
10．2 分治算法 366
10．2．1 分治算法的运行时间 367
10．2．2 最近点问题 369
10．2．3 选择问题 371
10．2．4 一些算术问题的理论改进 374
10．3 动态规划 377
10．3．1 用表代替递归 377
10．3．2 矩阵乘法的顺序安排 379
10．3．3 最优二叉查找树 382
10．3．4 所有点对最短路径 384
10．4 随机化算法 386
10．4．1 随机数发生器 387
10．4．2 跳跃表 392
10．4．3 素性测试 393
10．5 回溯算法 396
10．5．1 收费公路重建问题 396
10．5．2 博弈 400
小结 405
练习 406
参考文献 413
第11章 摊还分析 418
11．1 一个无关的智力问题 418
11．2 二项队列 419
11．3 斜堆 423
11．4 斐波那契堆 425
11．4．1 切除左式堆中的节点 425
11．4．2 二项队列的懒惰合并 427
11．4．3 斐波那契堆操作 429
11．4．4 时间界的证明 430
11．5 伸展树 432
小结 436
练习 436
参考文献 437
第12章 高级数据结构及其实现 439
12．1 自顶向下伸展树 439
12．2 红黑树 445
12．2．1 自底向上的插入 446
12．2．2 自顶向下红黑树 447
12．2．3 自顶向下删除 452
12．3 treap树 453
12．4 后缀数组和后缀树 456
12．4．1 后缀数组 456
12．4．2 后缀树 458
12．4．3 后缀数组和后缀树的线性
时间构建 461
12．5 k-d树 471
12．6 配对堆 474
小结 479
练习 479
参考文献 483
附录A 类模板的分离式编译 486
索引 489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言接口与实现
第1 章 引言　　1
1.1 文学程序　　2
1.2 程序设计风格　　 6
1.3 效率　　8
1.4 扩展阅读　　9
1.5 习题　　 9
第2 章 接口与实现　　11
2.1 接口　　11
2.2 实现　　 13
2.3 抽象数据类型　　15
2.4 客户程序的职责　　17
2.5 效率　　21
2.6 扩展阅读　　22
2.7 习题　　22
第3 章 原子　　24
3.1 接口　　24
3.2 实现　　25
3.3 扩展阅读　　30
3.4 习题　　31
第4 章 异常与断言　　33
4.1 接口　　35
4.2 实现　　38
4.3 断言　　44
4.4 扩展阅读　　46
4.5 习题　　47
第5 章 内存管理　　49
5.1 接口　　 50
5.2 产品实现　　54
5.3 稽核实现　　55
5.4 扩展阅读　　62
5.5 习题　　63
第6 章 再谈内存管理　　65
6.1 接口　　65
6.2 实现　　67
6.3 扩展阅读　　 72
6.4 习题　　 73
第7 章 链表　　 75
7.1 接口　　 75
7.2 实现　　79
7.3 扩展阅读　　83
7.4 习题　　83
第8 章 表　　84
8.1 接口　　84
8.2 例子：词频　　 87
8.3 实现　　 91
8.4 扩展阅读　　97
8.5 习题　　 97
第9 章 集合　　 99
9.1 接口　　99
9.2 例子：交叉引用列表　　101
9.3 实现　　 107
9.3.1 成员操作　　109
9.3.2 集合操作　　111
9.4 扩展阅读　　114
9.5 习题　　115
第10 章 动态数组　　116
10.1 接口　　116
10.2 实现　　119
10.3 扩展阅读　　122
10.4 习题　　122
第11 章 序列　　123
11.1 接口　　123
11.2 实现　　125
11.3 扩展阅读　　129
11.4 习题　　129
第12 章 环　　131
12.1 接口　　131
12.2 实现　　134
12.3 扩展阅读　　141
12.4 习题　　141
第13 章 位向量　　142
13.1 接口　　142
13.2 实现　　144
13.2.1 成员操作　　146
13.2.2 比较　　150
13.2.3 集合操作　　151
13.3 扩展阅读　　 152
13.4 习题　　153
第14 章 格式化　　154
14.1 接口　　154
14.1.1 格式化函数　　155
14.1.2 转换函数　　 157
14.2 实现　　160
14.2.1 格式化函数　　161
14.2.2 转换函数　　166
14.3 扩展阅读　　170
14.4 习题　　171
第15 章 低级字符串　　 172
15.1 接口　　173
15.2 例子：输出标识符　　178
15.3 实现　　179
15.3.1 字符串操作　　180
15.3.2 分析字符串　　184
15.3.3 转换函数　　188
15.4 扩展阅读　　 189
15.5 习题　　189
第16 章 高级字符串　　192
16.1 接口　　192
16.2 实现　　197
16.2.1 字符串操作　　200
16.2.2 内存管理　　 204
16.2.3 分析字符串　　205
16.2.4 转换函数　　209
16.3 扩展阅读　　210
16.4 习题　　 210
第17 章 扩展精度算术　　212
17.1 接口　　212
17.2 实现　　217
17.2.1 加减法　　218
17.2.2 乘法　　220
17.2.3 除法和比较　　 221
17.2.4 移位　　226
17.2.5 字符串转换　　228
17.3 扩展阅读　　230
17.4 习题　　230
第18 章 任意精度算术　　232
18.1 接口　　 232
18.2 例子：计算器　　235
18.3 实现　　240
18.3.1 取反和乘法　　242
18.3.2 加减法　　 243
18.3.3 除法　　 246
18.3.4 取幂　　 247
18.3.5 比较　　 249
18.3.6 便捷函数　　 250
18.3.7 移位　　 251
18.3.8 与字符串和整数的转换　　 252
18.4 扩展阅读　　 254
18.5 习题　　 255
第19 章 多精度算术　　 257
19.1 接口　　 257
19.2 例子：另一个计算器　　263
19.3 实现　　269
19.3.1 转换　　 272
19.3.2 无符号算术　　275
19.3.3 有符号算术　　277
19.3.4 便捷函数　　280
19.3.5 比较和逻辑操作　　285
19.3.6 字符串转换　　288
19.4 扩展阅读　　290
19.5 习题　　291
第20 章 线程　　292
20.1 接口　　294
20.1.1 线程　　 294
20.1.2 一般信号量　　 298
20.1.3 同步通信通道　　301
20.2 例子　　301
20.2.1 并发排序　　302
20.2.2 临界区　　305
20.2.3 生成素数　　307
20.3 实现　　311
20.3.1 同步通信通道　　311
20.3.2 线程　　313
20.3.3 线程创建和上下文切换　　322
20.3.4 抢占　　328
20.3.5 一般信号量　　330
20.3.6 MIPS 和ALPHA 上的上下文切换　　332
20.4 扩展阅读　　 335
20.5 习题　　336
附录A 接口摘要　　339
参考书目　　363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言接口与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DSP原理及其C编程开发技术
第1章 DSP开发系统
1.1 引言
1.2 DSK支持工具
1.3 程序代码编辑调试软件
1.4 测试DSK工具的编程实例
1.5 支持程序坟件的一些考虑
1.6 编译器/汇编器琏接器的Shell程序
第2章DSK的输入和输出
2.1 引言
2.2 利用TLC320AD535编解码器输入输出
2.3 利用PCM3003立体声编解码器输人输出
2.4 C程序编程实例
第3章 C6x理结构和指令系统
3.1 引言
3.2 TMS320C6x的结构
3.3 功能单元
3.4 取指和执行包
3.5 流水线技术
3.6 寄存器
3.7 线性和循环寻址方式
3.8 TMS320C6x指令集
3.9 汇编器指令
3.10 线性汇编
3.11 在C程序中使用汇编语句
3.12 C可调用汇编函数
3.13 定时器
3.14 中断
3.15 多通道缓冲串行口
3.16 直接存储器存取方式
3.17 存储数据需要考虑的问题
3.18 定点和浮点格式
3.19 程序改进
3.20 约束因素
3.21 TMS320C64x处理器
3.22 程序范例
第4章 有限冲激响应滤波器
4.1 Z变换基础
4.2 离散信号
4.3 有限冲激响应滤波器
4.4 利用傅里叶级数实现FIR滤波器
4.5 窗函数
4.6 语言和汇编程序编程实例
第5章 无限冲激响应滤波器
5.1 引言
5.2 IIR滤波器的结构
5.3 双线性变换法
5.4 设计IIR的C语言程序实例
第6章 快速傅里叶变换
6.1 引言
6.2 基2FFT算法
6.3 频域抽取的基2FFT算法
6.4 时间抽取的基2FFT算法
6.5 位反转整序方法
6.6 基4FFT算法
6.7 快速傅里叶逆变换
6.8 编程举例
第7章 自适应滤波器
第8章 程序优化方法
第9章 DSP的应用及学生的课题
附录A AMS320C6x指令集
附录B 循环寻址寄存器和中断寄存器
附录C 定点运算需要考虑的问题
附录D MATLAB支持工具
附录E 其他的支持工具
附录F 用PCM3003立体声编解码器作为输入输出
附录G 用于实时数据变换的DSP/BIOS和RTDX
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DSP原理及其C编程开发技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言参悟之旅
第1章 程序设计与C语言概述	1
1.1 计算机程序	2
1.1.1 什么是程序	2
1.1.2 什么是计算机程序	3
1.1.3 程序设计	4
1.2 计算机语言	4
1.2.1 语言	4
1.2.2 什么是计算机语言	4
1.2.3 计算机语言简史	4
1.2.4 高级语言的执行方式	6
1.3 C语言概述	7
1.3.1 为什么叫“C语言”	7
1.3.2 C语言的版本	7
1.3.3 C语言的特点	7
1.3.4 C语言的应用	9
1.4 第一个C程序	9
1.4.1 为什么选“Hello,World”	9
1.4.2 “Hello,World”程序	10
1.4.3 “Hello,World”程序解析	10
1.4.4 C程序结构特点解析	10
1.4.5 C程序是如何执行的	12
1.5 Microsoft Visual C++ 6.0集成开发环境简介	13
1.5.1 集成开发环境（IDE）	13
1.5.2 集成开发环境的功能	13
1.5.3 为什么选择Microsoft Visual C++ 6.0	14
1.5.4 Microsoft Visual C++ 6.0的版本	15
1.5.5 Microsoft Visual C++ 6.0的安装	15
1.5.6 项目和工作区	18
1.5.7 VisualC++6.0界面简介	19
1.5.8 常用菜单项	21
1.5.9 常用工具栏	22
1.5.10 视图窗格简介	23
1.5.11 代码颜色	26
1.5.12 使用Visual C++ 6.0编写和运行“Hello,World”程序	26
第2章 数据及数据类型	30
2.1 数据在计算机中的表示	31
2.1.1 数据	31
2.1.2 字符集和标识符	31
2.1.3 数据在计算机中的表示	33
2.2 数据类型	34
2.2.1 数据类型的解释	35
2.2.2 C语言中的数据类型	35
2.3 常量	36
2.3.1 整型常量	36
2.3.2 实型常量	38
2.3.3 字符常量	39
2.3.4 字符串常量	40
2.3.5 符号常量	41
2.4 变量	42
2.4.1 给变量命名	42
2.4.2 变量定义	42
2.4.3 变量名与变量的值	43
2.4.4 变量初始化	44
2.4.5 赋值	44
2.4.6 整型变量	45
2.4.7 实型变量	48
2.4.8 字符变量	50
2.5 数据的输入/输出	50
2.5.1 什么是输入/输出	51
2.5.2 C语言中输入/输出的实现	51
2.5.3 格式化输出——printf()函数	51
2.5.4 格式化输入——scanf()函数	56
2.5.5 字符的输出——putchar()函数	60
2.5.6 字符的输入——getchar()函数	61
2.5.7 输出字符串——puts()函数	61
2.5.8 读取字符串——gets()函数	62
第3章 运算符、表达式和语句	64
3.1 运算符和表达式概述	65
3.1.1 运算符	65
3.1.2 表达式	65
3.1.3 运算符的优先级和结合性	66
3.2 算术运算符与算术表达式	67
3.2.1 算术运算符	67
3.2.2 算术表达式	68
3.2.3 算术表达式的求值	68
3.3 赋值运算符与赋值表达式	69
3.3.1 简单赋值	69
3.3.2 左值和右值	70
3.3.3 复合赋值	71
3.3.4 赋值运算符的副作用	71
3.3.5 子表达式的求值顺序	72
3.4 类型转换	72
3.4.1 类型转换简述	72
3.4.2 自动类型转换	73
3.4.3 强制类型转换	76
3.5 自增和自减运算符	78
3.5.1 简化特殊的运算符	78
3.5.2 使用自增和自减运算符注意事项	79
3.6 逗号运算符与逗号表达式	79
3.6.1 逗号表达式	80
3.6.2 使用逗号表达式注意事项	80
3.7 关系运算符与关系表达式	81
3.7.1 关系运算符	81
3.7.2 关系表达式的值	81
3.7.3 使用关系运算符注意事项	81
3.8 逻辑运算符与逻辑表达式	82
3.8.1 逻辑运算符	82
3.8.2 逻辑表达式	82
3.8.3 “短路”计算	83
3.9 位运算符	83
3.9.1 C语言的位运算符	83
3.9.2 按位与运算符	84
3.9.3 按位或运算符	85
3.9.4 按位异或运算符	85
3.9.5 按位取反运算符	86
3.9.6 左移运算符	87
3.9.7 右移运算符	88
3.9.8 位运算中的整数提升	88
3.9.9 位运算赋值运算符	89
3.10 sizeof运算符	89
3.10.1 使用sizeof	89
3.10.2 sizeof的结果	90
3.10.3 sizeof的优先级	91
3.10.4 各种类型数据长度的计算	91
3.11 语句	91
3.11.1 什么是语句	92
3.11.2 语句类型	92
3.11.3 赋值语句	93
第4章 流程控制	95
4.1 流程的表示方法	96
4.1.1 自然语言表示法	96
4.1.2 流程图表示法	96
4.2 顺序结构	97
4.2.1 什么是顺序结构	97
4.2.2 顺序结构程序设计方法	98
4.3 分支结构	100
4.3.1 什么是分支结构	100
4.3.2 if语句的解释	101
4.3.3 if语句的3种形式	101
4.3.4 嵌套的if语句	105
4.3.5 应用if语句注意事项	106
4.3.6 条件运算符的解释	109
4.3.7 应用条件运算符注意事项	110
4.3.8 switch语句的解释	111
4.3.9 应用switch语句注意事项	113
4.3.10 分支结构程序设计方法	113
4.4 循环结构	116
4.4.1 什么是循环结构	116
4.4.2 关于while语句的解释	116
4.4.3 应用while语句注意事项	117
4.4.4 关于do…while语句的解释	118
4.4.5 应用do…while语句时防止死循环	119
4.4.6 不确定循环和计数循环	119
4.4.7 关于for语句的解释	120
4.4.8 使用for语句注意事项	121
4.4.9 选择哪种循环实现方式	123
4.4.10 循环中的循环	124
4.4.11 循环结构程序设计方法	125
4.5 跳转结构	128
4.5.1 什么是跳转结构	128
4.5.2 break语句	129
4.5.3 continue语句	131
4.5.4 goto语句	132
4.5.5 C语言中保留goto语句的原因	133
第5章 函数	136
5.1 函数与结构化程序设计	137
5.1.1 函数是“黑盒子”	137
5.1.2 数学函数与C语言函数	138
5.1.3 C语言函数中的库函数	139
5.1.4 结构化的程序设计	139
5.2 函数的使用	140
5.2.1 函数的定义	140
5.2.2 函数的类型	141
5.2.3 函数的返回值	142
5.2.4 函数的参数	145
5.2.5 函数的调用	148
5.2.6 函数的嵌套——蒙特卡罗法求圆周率	151
5.3 递归	153
5.3.1 递归的定义	154
5.3.2 使用递归的原则	155
5.3.3 分治法与汉诺塔	162
5.3.4 回溯法与八皇后问题	164
5.4 变量的作用域	168
5.4.1 局部变量	168
5.4.2 局部变量的作用域	168
5.4.3 全局变量	169
5.5 变量的存储类型	171
5.5.1 auto变量	172
5.5.2 static局部变量	173
5.5.3 register变量	174
5.5.4 extern变量	176
5.5.5 static外部变量	178
5.6 执行多文件程序	179
5.6.1 内部函数	179
5.6.2 外部函数	179
5.6.3 多文件程序实例	181
第6章 数组与字符串	183
6.1 一维数组的使用	184
6.1.1 数组概念的引入——中国古代军队编制	184
6.1.2 数组元素的使用	185
6.1.3 数组的初始化	185
6.1.4 小心访问越界	187
6.1.5 数组应用举例	187
6.2 数组类型的参数	190
6.2.1 以数组作为参数	190
6.2.2 避免数组被修改	191
6.2.3 函数返回数组的两种方法	192
6.3 多维数组的使用	195
6.3.1 从一维到二维	195
6.3.2 初始化及使用二维数组	195
6.3.3 多维数组应用举例	197
6.4 字符数组	201
6.4.1 定义与初始化	201
6.4.2 字符串的使用	201
6.4.3 字符串的处理——大小写转换函数	203
6.4.4 字符串的处理——字符串比较函数	203
6.4.5 字符串的处理——字符串长度的获得	204
6.4.6 字符串的处理——字符串连接函数	204
6.4.7 字符串的处理——字符串复制函数	205
6.4.8 字符串应用举例	207
第7章 指针	210
7.1 指针与地址	211
7.1.1 内存和地址的概念	211
7.1.2 定义指针变量	213
7.1.3 使用指针变量	214
7.2 指针与数组	217
7.2.1 用指针访问数组元素	217
7.2.2 直接插入排序	219
7.2.3 用指针操作多维数组	220
7.2.4 Z字形编排过程	223
7.2.5 复杂指针运算的解析	225
7.3 使用字符串指针变量	226
7.3.1 指向字符串的指针	226
7.3.2 与字符数组的比较	230
7.3.3 如何输出其自身的程序	233
7.4 指针与函数	234
7.4.1 将指针用作函数参数	234
7.4.2 指向函数的指针	236
7.4.3 指针对于指令的访问是受限制的	238
7.4.4 使用指向函数指针的语法来实现编程	238
7.4.5 返回值为指针的函数	240
7.5 复合多维指针的使用	244
7.5.1 指针数组的使用	244
7.5.2 指向指针的指针	247
7.5.3 main()函数的参数	249
7.5.4 main()函数参数应用实例	249
第8章 预处理	252
8.1 预处理器概述	253
8.1.1 预处理器的工作方式	253
8.1.2 使用Microsoft Visual C++ 6.0生成预编译程序	254
8.1.3 预处理指示分类	256
8.1.4 预处理指示规则	256
8.2 宏定义	257
8.2.1 无参宏定义	257
8.2.2 带参宏定义	258
8.2.3 带参宏定义与函数	259
8.2.4 使用宏时注意事项	261
8.2.5 至关重要的圆括号	262
8.2.6 预定义宏	263
8.3 条件编译	264
8.3.1 条件编译的形式	264
8.3.2 条件编译的作用	267
8.4 文件包含	268
8.4.1 头文件	268
8.4.2 文件包含的形式	269
8.4.3 使用文件包含时注意事项	270
8.5 其他指示	271
8.5.1 #error指示	271
8.5.2 #line指示	271
8.5.3 #pragma指示	272
8.6 “#”和“##”运算符	272
8.6.1 “#”运算符	272
8.6.2 “##”运算符	273
8.7 预处理实例	273
8.7.1 简单计算器程序	273
8.7.2 程序分析	276
8.7.3 程序中的预处理	277
第9章 结构体与共用体	279
9.1 结构体	280
9.1.1 什么是结构体	280
9.1.2 结构体实例——《水浒传》中的一百单八将	280
9.1.3 结构体类型与结构体变量	281
9.1.4 结构体变量的定义	282
9.1.5 定义结构体变量注意事项	283
9.1.6 结构体变量的初始化	283
9.1.7 结构体变量的引用	284
9.1.8 引用结构体变量注意事项	285
9.1.9 结构体数组	286
9.1.10 指向结构体的指针	289
9.1.11 结构体与函数	291
9.1.12 位域	298
9.2 共用体	301
9.2.1 什么是共用体	301
9.2.2 共用体与结构体	302
9.2.3 共用体变量的初始化	303
9.2.4 使用共用体注意事项	304
9.2.5 结构体和共用体综合实例——“梁山好汉的比武大会”	305
9.3 枚举	308
9.3.1 什么是枚举	308
9.3.2 枚举变量的定义与取值	309
9.3.3 “表里不一”的类型	310
9.3.4 枚举应用举例——“向你问好的程序”	311
9.4 用户自定义类型——typedef	312
9.4.1 什么是typedef	312
9.4.2 创建typedef简单方法	313
9.4.3 typedef和#define	313
9.4.4 typedef的两个重要作用	314
第10章 文件	316
10.1 理解文件的基本概念	317
10.1.1 什么是文件	317
10.1.2 什么是流	318
10.1.3 处理文件的方法	319
10.1.4 缓存	320
10.1.5 文本文件和二进制文件	321
10.2 文件的打开与关闭	321
10.2.1 文件类型指针	321
10.2.2 文件的打开	323
10.2.3 文件操作类型及应用	323
11.2.4 文件的关闭	325
10.3 文件的基本操作	327
10.3.1 文件中的字符读/写	327
10.3.2 按字符进行读/写文件——文件复制的功能	329
10.3.3 文件中字符串读/写	330
10.3.4 其他文件读/写函数	334
10.3.5 文件位置定位	334
10.3.6 数据块的读/写	336
10.4 处理二进制文件	338
10.5 文件缓冲区处理	341
10.5.1 文件缓冲区的清除	341
10.5.2 文件缓冲区的设置	343
10.6 文件操作的检测	345
第11章 动态数据结构	347
11.1 动态内存管理	348
11.1.1 为什么使用动态内存分配	348
11.1.2 如何实现动态内存管理	348
11.1.3 关于动态内存分配的说明	351
11.2 链表概述	352
11.2.1 单向链表与数组	353
11.2.2 单向链表——老鹰捉小鸡	353
11.2.3 链表存储方式优缺点	354
11.2.4 不同单向链表间的合并	354
11.3 链表的操作及实现	355
11.3.1 链表的建立	355
11.3.2 链表的遍历	358
11.3.3 链表结点的删除	359
11.3.4 链表结点的增加	361
11.3.5 结点删除函数中的free()函数	363
11.3.6 链表的应用实例	363
11.4 栈	364
11.4.1 栈定义——散乱的盘子	364
11.4.2 栈的特点	365
11.4.3 栈工作原理	365
11.4.4 栈与链表	366
11.4.5 栈的应用举例——括号匹配问题	368
11.5 队列	369
11.5.1 队列的特点	369
11.5.2 队列定义——排队等待买票的人	370
11.5.3 队列应用	370
11.5.4 队列与栈的不同	370
11.5.5 队列创建	370
11.5.6 基于链表实现的队列——链式队列	371
11.5.7 队列的实现	372
附录Ⅰ C语言运算符及其优先级汇总表	376
附录Ⅱ 标准ASCII码字符集	378
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言参悟之旅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>炼金术之梦
目 录
第一章 导言
一、 材料
二、 方法
第二章 初始的梦
第三章 曼荼罗的象征作用
一、 关于曼荼罗
二、 梦中的曼荼罗
三、 关于世界时钟的幻象
四、 自性的象征
译名对照表
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>炼金术之梦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++编程风格
1 抽象 1
1.1 编程风格示例：计算机的定价 1
1.2 找出共同的抽象 5
1.3 类之间的区别 9
1.4 属性与行为 9
1.5 再次引入继承 12
1.6 去掉枚举 13
小结 16
参考文献 17
练习 17
2 一致性 21
2.1 编程风格示例：string类 21
2.2 明确定义的状态 23
2.3 物理状态的一致性 24
2.4 类不变性 25
2.5 动态内存的一致性 27
2.6 动态内存的回收 28
2.7 编程风格示例：第二种方法 29
小结 35
参考文献 36
练习 36
3 不必要的继承 41
3.1 编程风格示例：堆栈 41
3.2 继承作用域准则 44
3.3 继承关系 46
3.4 封装 50
3.5 接口与实现 52
3.6 模板 56
小结 58
参考文献 58
练习 58
4 虚函数 59
4.1 编程风格示例：车辆与车库 59
4.2 一致性 63
4.3 基类的析构函数 65
4.4 继承 66
4.5 耦合 69
小结 75
参考文献 75
练习 75
5 运算符的重载 77
5.1 运算符重载的基本概念 77
5.2 编程风格示例：FileArray类 82
5.3 对实现的继承 89
5.4 程序设计中的权衡：重载运算符和成员函数 94
小结 95
参考文献 96
练习 96
6 包装 97
6.1 一个用C编写的库 97
6.2 编程风格示例：用C++对dirent进行包装 98
6.3 多个Directory对象 100
6.4 构造函数中的失败 103
6.5 对失败状态的公有访问 105
6.6 错误信息参数 107
小结 111
参考文献 111
练习 111
7 效率 113
7.1 编程风格示例：BigInt类 114
7.2 BigInt的使用 120
7.3 动态字符串的长度 121
7.4 动态字符串的数量 123
7.5 客户代码 127
7.6 改写BigInt 129
小结 135
参考文献 135
练习 135
8 案例研究 137
8.1 编程风格示例：有限状态机 137
8.2 初始化 142
8.3 耦合 150
8.4 内聚 154
8.5 模块类与抽象数据类型 157
8.6 属性与行为 160
8.7 泛化 165
参考文献 169
练习 170
9 多重继承 171
9.1 多重继承中的二义性 171
9.2 有向无环继承图 173
9.3 分析虚基类 176
9.4 编程风格示例：Monitor类 183
9.5 编程风格示例：虚基类 187
9.6 多重协议继承 192
小结 195
参考文献 195
练习 195
10 摘要 199
第1章：抽象 199
第2章：一致性 199
第3章：不必要的继承 200
第4章：虚函数 200
第5章：运算符的重载 201
第6章：包装 201
第7章：效率 201
第8章：案例研究 202
第9章：多重继承 202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++编程风格
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言编程常见问题解答
第1章  C语言
1. 1  什么是局部程序块 localblock
1. 2  可以把变量保存在局部程序块中吗
1. 3  什么时候用一条switch语句比用多条if语句更好
1. 4  switch语句必须包含default分支吗

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言编程常见问题解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白盒测试之道
第一篇  基础知识第1章  软件测试语言基础  1.1  C语言基础    1.1.1  C语言简介    1.1.2  C语言特点    1.1.3  C语言的数据类型    1.1.4  算术运算符与算术表达式    1.1.5  数据类型转换规则    1.1.6  程序结构  1.2  C++基础    1.2.1  C++基介绍    1.2.2  C++基的特点    1.2.3  C++基程序的构成元素    1.2.4  C++基程序的开发步骤    1.2.5  对象和类    1.2.6  成员函数的定义    1.2.7  对象的定义    1.2.8  构造函数与析构函数    1.2.9  静态成员    1.2.10  类的继承与派生    1.2.11  运算符重载的意义与规则第2章  软件测试基础  2.1  软件测试现状    2.1.1  国外软件测试现状    2.1.2  国内软件测试现状与发展趋势  2.2  软件质量与开发效率的博弈  2.3  软件测试概念    2.3.1  软件测试的哲学思考    2.3.2  软件测试    2.3.3  软件测试的目的    2.3.4  测试和调试的区别  2.4  软件测试心理学    2.4.1  程序测试的过程具有破坏性    2.4.2  程序员应避免测试自己的程序    2.4.3  程序设计机构不应测试自己的程序  2.5  测试工程师应具备的素质  2.6  软件测试的分类  2.7  软件测试的流程  2.8  软件测试的原则  2.9  AEP自动化错误预防    2.9.1  自动错误预防五大法则    2.9.2  自动化错误预防的标准流程    2.9.3  质量一可靠性+安全性  2.10  ParasoftC++test简介第3章  软件测试环境  3.1  测试环境    3.1.1  测试环境的主要构成    3.1.2  规划测试环境    3.1.3  管理测试环境  3.2  搭建C++test测试环境    3.2.1  支持的主机系统与编译器    3.2.2  C+-t-test基于Windows单机安装    3.2.3  C+A-test基于Windows插件安装    3.2.4  C+-t-test基于Linux／Solaris单机安装    3.2.5  C++test基于Linux／Solari插件安装    3.2.6  许可授权  3.3  C++test：界面    3.3.1  C++test透视图    3.3.2  视图    3.3.3  C++test常用菜单命令  3.4  简单的测试工程实例  3.5  C++testp工程的建立    3.5.1  通过链接打开工程    3.5.2  使用CVS和源目录    3.5.3  MicrosoftVisualC++6.0项目选项  3.6  C++test中项目的导入    3.6.1  导人VisualStudio6.0项目  ……第二篇  白盒测试第三篇  C++test使用数据源测试第四篇  团队测试第五篇  问题汇总
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白盒测试之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言解惑：指针、数组、函数和多文件编程
前言
第1章 引入指针变量
1.1 变量的三要素
1.2 变量的操作
1.3 指针变量
1.4 指针类型
第2章 指针基础知识
2.1 指针运算符
2.2 指针移动
2.3 指针地址的有效性
2.4 指针的初始化
2.5 指针相等
2.6 对指针使用const限定符
2.7 使用动态内存
2.7.1 动态内存分配函数
2.7.2 内存分配实例
2.7.3 NULL指针
第3章 一维数组
3.1 一维数值数组
3.2 一维字符串数组
3.3 使用一维数组容易出现的错误
3.3.1 一维数组越界错误
3.3.2 一维数组初始化错误
3.3.3 数组赋值错误
3.3.4 求值顺序产生歧义错误
3.4 综合实例
第4章 指针与数组
4.1 数组与指针的关系
4.2 一维字符串数组与指针
4.3 字符串常量
4.4 指针数组
4.5 配合使用一维数组与指针
4.5.1 使用一维数组名简化操作
4.5.2 使用指针操作一维数值数组
4.5.3 使用一维字符数组
4.5.4 指针初始化实例
4.6 动态内存分配与非数组的指针
4.7 二维数组与指针
4.7.1 二维数组
4.7.2 二维数组操作实例
4.7.3 二维数组与指针的关系
4.7.4 二维数组与指向一维数组的指针
4.7.5 二维字符串数组
4.8 综合设计实例
4.8.1 使用数组求解
4.8.2 使用动态内存求解
4.8.3 使用二级字符串指针求解
第5章 函数基础知识
5.1 函数
5.1.1 函数和函数原型
5.1.2 函数值和return语句
5.1.3 函数调用形式
5.1.4 函数参数的基础知识
5.1.5 被调用函数的返回位置
5.2 C程序的典型结构
5.2.1 单文件结构
5.2.2 一个源文件和一个头文件
5.2.3 多文件结构
5.3 变量的作用域
5.3.1 单文件里的块结构及函数
5.3.2 单文件多函数的变量
5.3.3 多文件变量作用域
5.4 变量的存储地址分配
5.4.1 单文件变量的存储地址分配
5.4.2 多文件变量的存储地址分配
5.5 main函数原型及命令行参数
第6章 函数设计
6.1 函数设计的一般原则
6.1.1 函数设计基础
6.1.2 函数设计的注意事项
6.1.3 函数的一般结构
6.2 函数的返回值
6.2.1 无返回值的void类型函数
6.2.2 非void类型的函数必须返回一个值
6.2.3 使用临时变量作为返回值的函数
6.2.4 不能使用临时数组名作为返回值
6.2.5 返回临时指针必须是首地址
6.2.6 返回结构的函数
6.2.7 返回结构指针的函数
6.2.8 返回枚举的函数
6.3 函数参数的传递方式
6.3.1 传数值
6.3.2 传地址值
6.4 函数指针
6.5 理解函数声明
6.5.1 词法分析中的“贪心法”
6.5.2 克服语法“陷阱”读懂函数
6.6 函数设计举例
6.6.1 完璧归赵
6.6.2 多余的参数
6.6.3 传递的参数与函数参数匹配问题
6.6.4 等效替换参数
6.6.5 设计状态机函数
第7章 函数设计实例
7.1 函数的类型和返回值
7.1.1 函数的类型应力求简单
7.1.2 实参要与函数形参的类型匹配
7.1.3 正确设计函数的返回方式
7.1.4 正确区别指针函数和函数指针
7.2 正确选择函数参数
7.2.1 使用结构作为参数
7.2.2 使用键盘为参数赋值
7.2.3 结构的内存分配
7.3 算法基本概念
7.4 使用库函数
7.5 设计实例
7.5.1 递推与递归
7.5.2 递推求解切饼问题
7.5.3 八皇后问题
7.5.4 疑案求解
7.5.5 二分查找
7.5.6 汉诺塔问题
7.5.7 青蛙过河
7.5.8 猜数游戏
7.5.9 生死游戏
7.5.10 最短路径
第8章 多文件中的函数设计
8.1 C语言预处理器
8.1.1 宏定义与const修饰符
8.1.2 文件包含
8.1.3 条件编译
8.2 模块化程序设计基础
8.2.1 模块化程序设计
8.2.2 分块开发
8.2.3 工程文件
8.2.4 函数设计的注意事项
8.3 使用两个文件的设计实例
8.3.1 设计题目和实现方法
8.3.2 算法和函数设计
8.3.3 完整源程序
8.3.4 组成工程并运行程序
8.4 使用3个文件的设计实例
8.4.1 设计思想
8.4.2 算法分析
8.4.3 完整源程序
8.4.4 程序运行
8.5 使用条件编译的多文件设计实例
8.5.1 实现功能
8.5.2 设计思想
8.5.3 参考程序
8.5.4 程序运行
第9章 多文件综合设计实例
9.1 使用链表设计一个小型通讯录程序
9.1.1 功能设计要求
9.1.2 设计思想
9.1.3 程序设计
9.1.4 运行示范
9.2 使用数组设计一个实用的小型学生成绩管理程序
9.2.1 功能设计要求
9.2.2 总体设计
9.2.3 函数设计
9.2.4 参考程序
9.2.5 运行示范
第10章 设计游戏程序实例
10.1 剪刀、石头、布
10.1.1 设计思想
10.1.2 参考程序
10.1.3 运行示范
10.2 迷宫
10.2.1 设计思想
10.2.2 参考程序
10.2.3 运行示范
10.3 空战
10.3.1 设计思想
10.3.2 参考程序
10.4 贪吃蛇
10.4.1 供改造的源程序
10.4.2 运行示范
10.5 停车场
10.5.1 参考程序
10.5.2 运行示范
10.6 画矩形
10.6.1 用C语言编写Windows程序
10.6.2 Windows的程序结构
10.6.3 用C语言编写画矩形程序
10.7 俄罗斯方块
10.7.1 基本游戏规则
10.7.2 基本操作方法
10.7.3 编写游戏交互界面问题
10.7.4 用C语言编写控制台俄罗斯方块游戏
10.7.5 编写Windows俄罗斯方块游戏
10.8 用C语言编写Windows下的贪吃蛇游戏
10.8.1 程序清单
10.8.2 运行示范
附录 7位ASCII码表
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言解惑：指针、数组、函数和多文件编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言教程
前言
第0章　 从零开始 1
0.1　 为什么要用C 1
0.2　 ANSI C标准 2
0.3　 从C到C++ 3
0.4　 从C和C++到Java 3
第1章　 C语言概述 4
1.1　 编程和预备知识 4
1.2　 程序输出 4
1.3　 变量、表达式和赋值 7
1.4　 使用#define和#include 9
1.5　 使用printf()和scanf() 12
1.6　 控制流 14
1.7　　函数 19
1.8　 数组、字符串和指针 24
1.8.1　 数组 24
1.8.2　 字符串 25
1.8.3　 指针 28
1.9　 文件 31
1.10　 与操作系统有关的内容 35
1.10.1　 编写和运行C程序 35
1.10.2　 中断程序 36
1.10.3　 输入文件尾标志 37
1.10.4　 输入和输出的重定向 37
1.11　 总结 38
1.12　 练习 39
第2章　 词法元素、操作符和C系统 45
2.1　 字符和词法元素 46
2.2　 语法规则 48
2.3　 注释 49
2.4　 关键字 50
2.5　 标识符 50
2.6　 常量 51
2.7　 字符串常量 52
2.8　 操作符和标点符号 53
2.9　 操作符的优先级和结合性 53
2.10　 增值操作符和减值操作符 55
2.11　 赋值操作符 56
2.12　 例子：计算2的乘方 57
2.13　 C系统 58
2.13.1　 预处理器 59
2.13.2　 标准函数库 59
2.14　 总结 62
2.15　 练习 63
第3章　 基本数据类型 69
3.1　 声明、表达式和赋值 69
3.2　 基本数据类型 71
3.3　 字符和char数据类型 72
3.4　 int数据类型 75
3.5　 整数类型short、long和unsigned 76
3.6　 浮点类型 77
3.7　 typedef的用法 79
3.8　 sizeof操作符 79
3.9　 使用getchar()和putchar() 80
3.10　 数学函数 82
3.10.1　 使用abs()和fabs() 84
3.10.2　 UNIX和数学函数库 84
3.11　 隐式类型转换和强制类型转换 84
3.11.1　 整型提升 85
3.11.2　 寻常算术转换 85
3.11.3　 强制类型转换 86
3.12　 十六进制和八进制常量 87
3.13　 总结 89
3.14　 练习 89
第4章　 控制流 96
4.1　 关系操作符、相等操作符和逻辑操作符 96
4.2　 关系操作符和表达式 97
4.3　 相等操作符和表达式 99
4.4　 逻辑操作符和表达式 100
4.5　 复合语句 103
4.6　 表达式和空语句 103
4.7　 if和if-else语句 104
4.8　 while语句 106
4.9　 for语句 108
4.10　 例子：布尔变量 110
4.11　 逗号操作符 111
4.12　 do语句 112
4.13　 例子：斐波那契数 113
4.14　 goto语句 115
4.15　 break和continue语句 116
4.16　 switch语句 117
4.17　 条件操作符 118
4.18　 总结 119
4.19　 练习 120
第5章　 函数 128
5.1　 函数定义 128
5.2　 return语句 130
5.3　 函数原型 131
5.4　 例子：创建乘方表 132
5.5　 从编译器的角度观察函数原型 133
5.6　 函数定义顺序的另一种风格 134
5.7　 函数调用和传值调用 134
5.8　 开发大型程序 136
5.9　 使用断言 138
5.10　 作用域规则 139
5.10.1　 平行和嵌套代码块 140
5.10.2　 以调试为目的使用代码块 140
5.11　 存储类型 141
5.11.1　 auto存储类型 141
5.11.2　 extern存储类型 141
5.11.3　 register存储类型 143
5.11.4　 static存储类型 143
5.12　 静态外部变量 144
5.13　 默认初始化 145
5.14　 递归 145
5.15　 例子：汉诺塔 149
5.16　 总结 152
5.17　 练习 153
第6章　 数组、指针和字符串 159
6.1　 一维数组 159
6.1.1　 初始化 160
6.1.2　 下标 160
6.2　 指针 161
6.3　 传引用调用 164
6.4　 数组和指针之间的关系 165
6.5　 指针运算和元素的大小 166
6.6　 数组作为函数的实参 166
6.7　 例子：冒泡排序 167
6.8　 用calloc()和malloc()进行动态内存分配 168
6.9　 例子：归并和归并排序 171
6.10　 字符串 175
6.11　 标准函数库中的字符串处理函数 177
6.12　 多维数组 180
6.12.1　 二维数组 180
6.12.2　 存储映射函数 180
6.12.3　 形式参数声明 181
6.12.4　 三维数组 182
6.12.5　 初始化 182
6.12.6　 使用typedef 183
6.13　 指针数组 184
6.14　 main()函数的参数 188
6.15　 不规则数组 189
6.16　 函数作为参数 190
6.17　 例子：使用二分法寻找函数的根 192
6.18　 函数指针数组 196
6.19　 类型限定符const和volatile 199
6.20　 总结 200
6.21　 练习 202
第7章　 位操作符和枚举类型 214
7.1　 位操作符和表达式 214
7.1.1　 按位求反 215
7.1.2　 补码 215
7.1.3　 位逻辑操作符 216
7.1.4　 左移位和右移位操作符 217
7.2　 掩码 218
7.3　 软件工具：打印int值的二进制形式 219
7.4　 包装和解包 220
7.5　 枚举类型 223
7.6　 例子：“石头、剪刀、布”游戏 225
7.7　 总结 229
7.8　 练习 230
第8章　 预处理器 235
8.1　 #include的使用 235
8.2　 使用#define 236
8.3　 带参数的宏 237
8.4　 stddef.h中的类型定义和宏 239
8.5　 例子：用qsort()进行排序 239
8.6　 例子：带参数的宏 243
8.7　 stdio.h和ctype.h中的宏 246
8.8　 条件编译 247
8.9　 预定义的宏 249
8.10　 “#”和“##”操作符 249
8.11　 assert()宏 250
8.12　 使用#error和#pragma 250
8.13　 行号 251
8.14　 对应的函数 251
8.15　 例子：快速排序 251
8.16　 总结 254
8.17　 练习 254
第9章　 结构和联合 262
9.1　 结构 262
9.2　 访问结构成员 264
9.3　 操作符的优先级和结合性的总结 267
9.4　 在函数中使用结构 268
9.5　 结构的初始化 269
9.6　 例子：玩扑克牌 269
9.7　 联合 273
9.8　 位字段 275
9.9　 例子：访问位和字节 276
9.10　 ADT堆栈 277
9.11　 总结 280
9.12　 练习 281
第10章　 结构和列表处理 288
10.1　 自引用的结构 288
10.2　 线性链表 289
10.3　 链表操作 290
10.4　 一些链表处理函数 293
10.4.1　 插入 294
10.4.2　 删除 295
10.5　 堆栈 296
10.6　 例子：波兰记法和堆栈求值 298
10.7　 队列 303
10.8　 二叉树 306
10.8.1　 二叉树的遍历 307
10.8.2　 创建树 308
10.9　 普通的树 309
10.9.1　 遍历 311
10.9.2　 calloc()的用法以及树的创建 311
10.10　 总结 312
10.11　 练习 313
第11章　 输入/输出和操作系统 318
11.1　 输出函数printf() 318
11.2　 输入函数scanf() 321
11.3　 fprintf()、fscanf()、sprintf()
和sscanf()函数 324
11.4　 fopen()和fclose()函数 325
11.5　 例子：对文件进行空间加倍 327
11.6　 使用临时文件和优雅函数 329
11.7　 随机访问文件 331
11.8　 文件描述符输入/输出 332
11.9　 文件访问权限 333
11.10　 在C程序内部执行命令 334
11.11　 在C程序内部使用管道 335
11.12　 环境变量 336
11.13　 C编译器 337
11.14　 使用性能评估程序 338
11.15　 函数库 339
11.16　 对C代码进行计时 340
11.17　 使用make 343
11.18　 使用touch 347
11.19　 其他有用的工具 348
11.20　 总结 349
11.21　 练习 350
第12章　 高级应用 358
12.1　 用fork()创建并发进程 358
12.2　 进程的叠加：exec...()函数族系 360
12.3　 使用pipe()实现进程间的通信 362
12.4　 信号 363
12.5　 例子：哲学家用餐问题 365
12.6　 矩阵的动态分配 368
12.6.1　 为什么二维数组无法满足要求 368
12.6.2　 用指针数组创建矩阵 369
12.6.3　 调整下标范围 371
12.6.4　 一次分配所有内存 373
12.7　 返回状态 374
12.8　 总结 377
12.9　 练习 378
第13章　 从C到C++ 383
13.1　 输出 383
13.2　 输入 384
13.3　 函数 386
13.4　 类和抽象数据类型 387
13.5　 重载 389
13.6　 构造函数和析构函数 390
13.7　 面向对象编程和继承 392
13.8　 多态 393
13.9　 模板 395
13.10　 C++的异常 396
13.11　 面向对象编程的优点 396
13.12　 总结 397
13.13　 练习 398
第14章　 从C到Java 402
14.1　 输出 402
14.2　 变量和类型 403
14.3　 类和抽象数据类型 404
14.4　 重载 406
14.5　 类的创建和销毁 406
14.6　 面向对象编程和继承 406
14.7　 多态和重写方法 407
14.8　 Applet 408
14.9　 Java的异常 409
14.10　 Java和OOP的优势 410
14.11　 总结 410
14.12　 练习 411
附录A　 标准函数库 413
附录B　 C的语法 441
附录C　 ANSI C与传统C的比较 446
附录D　 ASCII字符码 452
附录E　 操作符的优先级和结合性 454
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
Section I：Agile Development 敏捷开发
Chapter 1：Agile Practices 敏捷实践
The Agile Alliance 敏捷联盟
Individuals and Interactions over Processes and Tools人和交互重于过程和工具
Working Software over Comprehensive Documentation 可以工作的软件重于面面俱到的文档
Customer Collaboration over Contract Negotiation 客户合作重于合同谈判
Responding to Change over Following a Plan 随时应对变化重于遵循计划
Principles 原则
Conclusion 结论
Bibliography 参考文献
Chapter 2：Overview of Extreme Programming 极限编程概述
The Practices of Extreme Programming 极限编程实践
Whole Team 完整团队
User Stories 用户故事
Short Cycles 短交付周期
Acceptance Tests 验收测试
Pair Programming 结对编程
Test．Driven Development(TDD) 测试驱动开发
Collective Ownership 集体所有权
Continuous Integration 持续集成
Sustainable Pace 可持续的开发速度
Open Workspace 开放的工作空间
The Planning Game 计划游戏
Simple Design 简单设计
Refactoring 重构
Metaphor 隐喻
Conclusion 结论
Bibliography 参考文献
Chapter 3：Planning 计划
Initial Exploration 初始探索
Spiking，Splitting，and Velocity 探究、分解和速度
Release Planning 发布计划
Iteration Planning 迭代计划
Defining“Done” 定义“完成”
Tlask Planning 任务计划
Iterating 迭代
Tracking 跟踪
Conclusion 结论
Bibliography 参考文献
Chapter 4：Testing 测试
TIest-Driven Development 测试驱动开发
Example of Test-First Design 测试优先设计的例子
Test Isolation 测试促使模块之间隔离
Serendipitous Decoupling 意外获得的解耦合
Acceptance Tests 验收测试
Serendipitous Architecture 意外获得的构架
Conclusion 结论
Bibliography 参考文献
Chapter 5：Refactoring 重构
A Simple Example of Refactoring：Generating Primes 素数产生程序：一个简单的重构示例
Unit Testing 单元测试
Refactoring 重构
The Final Reread 最后审视
Conclusion 结论
Bibliography 参考文献
Chapter 6：A Programming Episode 一次编程实践
The Bowling Game 保龄球比赛
Conclusion 结论
Overview of the Rules of Bowling 保龄球规则概述
Section II　Agile Design 敏捷设计
Chapter 7：What Is Agile Design 什么是敏捷设计
Design Smells 设计臭味
Design Smells——The Odors of Rotting Software 设计坏味——腐化软件的气味
Rigidity 僵化性
Fragility 脆弱性
Immobility 顽固性
Viscosity 粘滞性
Needless Complexity 不必要的复杂性
NeedLless Repetition 不必要的重复
Opacity 晦涩性
Why Software Rots 软件为何会腐化
The Copy Program Copy 程序
A Familiar Scenario 熟悉的场景
Agile Design of the Copy Program copy 程序的敏捷设计
Conclusion 结论
Bibliography 参考文献
Chapter 8：The Single-Responsibility Principle(SRP)　SRP：单一职责原则
Defining a Responsibility 定义职责
Separating Coupled Responsibilities 分离耦合的职责
Persistence 持久化
Conclusion 结论
Bibliography 参考文献
Chapter 9：The Open/Closed Principle(OCP) OCP：开放-封闭原则
Description 0f OCP　OCP概述
The Shape Application Shape 应用程序
Violating OCP 违反OCP
Conforming to OCP 遵循OCP
Anticipation and“Natural”Structure 预测变化和“贴切的”结构
Putting the“Hooks”In 放置吊钩
Using Abstraction to Gain Explicit Closure使用抽象获得显式封闭
Using a Data-Driven Approach to Achieve Closure 使用“数据驱动"的方法获取封闭性
Conclusion结论
Bibliography参考文献
Chapter 10：The Liskov Substitution Principle(LSP) LSP：Liskov替换原则
Violations 0f LSP 违反LS P的情形
A Simple Example 简单例子
A More Subtle Violation 更微妙的违反情形
A Real-World Example 实际的例子
Factoring Instead of Deriving 用提取公共部分的方法代替继承
Heuristics and Conventions 启发式规则和习惯用法
Conclusion 结论
Bibliography 参考文献
Chapter 11：The Dependency-Inversion Principle(DIP) DIP：依赖倒置原则
Layering 层次化
Ownership Inversion 倒置的接口所有权
Dependence on Abstractions 依赖于抽象
A Simple DIP Example 简单的DIP示例
Finding the Underlying Abstraction 找出潜在的抽象
The Furnace Example 熔炉示例
Conclusion 结论
Bibliography 参考文献
Chapter 12：The Interface Segregation Principle(ISP) ISP：接口隔离原则
Interface Pollution 接口污染
Separate Clients Mean Separate Interfaces 分离客户就是分离接口
Class Interfaces versus Object Interfaces 类接口与对象接口
Separation Through Delegation 使用委托分离接口
Separation Through Multiple Inheritance 使用多重继承分离接口
The ATM User Interface Example　ATM用户界面的例子
Conclusion 结论
Bibliography 参考文献
Chapter 13：Overview of UML for C# Programmers　C#程序员UML概观
Class Diagrams 类图
Object Diagrams 对象图
Sequence Diagrams 顺序图
Collaboration Diagrams 协作图
State Diagrams 状态图
Conclusion 结论
Bibliography 参考文献
Chapter 14：Working with Diagrams 使用UML
Why Model? 为什么建模
Why Build Models of Software? 为什么构建软件模型
Should We Build Comprehensive Designs Before Coding? 编码前应该构建面面俱到的设计吗
Making Effective Use of UML 有效使用UML
Communicating with Others 与他人交流
Road Maps 脉络图
Back-End Documentation 项目结束文档
What to Keep and What to Throw Away 要保留的和要丢弃的
Iterative Refinement 迭代式改进
Behavior First 行为优先
Check the Structure 检查结构
Envisioning the Code 想象代码
Evolution of Diagrams 图的演化
When and How to Draw Diagrams 何时以及如何绘制图示
When to Draw Diagrams and When to Stop 何时要画图，何时不要画图
CASE Tools CASE工具
But What About Documentation? 那么，文档呢
Conclusion 结论
Chapter 15　State Diagrams 状态图
The Basics 基础知识
Special Events 特定事件
Superstates 超状态
Initial and Final Pseudostates 初始伪状态和结束伪状态
Using FSM Diagrams 使用FSM图示
Conclusion 结论
Chapter 16：Object Diagrams 对象图
A Snapshot in Time 即时快照
Active Objects 主动对象
Conclusion 结论
Chapter 17：Use Cases 示例
Writing Use Cases 编写用例
Alternate Courses 备选流程
What Else? 其他东西呢
Diagramming Use Cases 用例图
Conclusion 结论
Bibliography 参考文献
Chapter 18：Sequence Diagrams 顺序图
The Basics 基础知识
Obj ects，Lifelines，Messages，and Other Odds and Ends 对象、生命线、消息及其他
Creation and Destruction 创建和析构
Simple Loops 简单循环
Cases and Scenarios 时机和场合
Advanced Concepts 高级概念
Loops and Conditions 循环和条件
Messages That Take Time 耗费时间的消息
Asynchronous Messages 异步消息
Multiple Threads 多线程
Active Objects 主动对象
Sending Messages to Interfaces 向接口发送消息
Conclusion 结论
Chapter 19：Class Diagrams 类图
The Basics 基础知识
Classes 类
Association 关联
Inheritance 继承
An Example Class Diagram 类图示例
The Details 细节
Class Stereotypes 类衍型
Abstract Classes 抽象类
Properties 属性
Aggregation 聚集
Composition 组合
Multiplicity 多重性
Association Stereotypes 关联衍型
Nested Classes 内嵌类
Association Classes 关联类
Association Qualifiers 关联修饰符
Conclusion 结论
Bibliography 参考文献
Chapter 20　Heuristics and C0ffee 咖啡的启示
The Mark IV Special Coffee Maker　Mark IV型专用咖啡机
Specification 规格说明书　260
A Common but Hideous Solution 常见的丑陋方案
Imaginary Abstraction 虚构的抽象
An Improved Solution 改进方案
Implementing the Abstract Model 实现抽象模型
The Benefits of This Design 这个设计的好处
Ooverkill 面向对象过度设计
Bibliography 参考文献
Section Ⅲ　The Payroll Case Study 薪水支付案例研究
Rudimentary Specification of the Payroll System 薪水支付系统的初步规格说明
Exercise 练习
Use Case 1：Add New Employee 用例1：增加新雇员
Use Case 2：Deleting an Employee 用例2：删除雇员
Use Case 3：Post a Time Card 用例3：登记考勤卡
Use Case 4：Posting a Sales Receipt 用例4：登记销售凭条
Use Case 5：Posting a Union Service Charge 用例5：登记工会服务费
Use Case 6：Changing Employee Details 用例6：更改雇员明细
Use Case 7：Run the Payroll for Today 用例7：现在运行薪水支付系统
Chapter 21：Command and Active Object：Versatility and Multitasking　COMMAND模式和ACTlVE OBJECT模式：多功能与多任务
Simple Commands 简单的Command
Transactions 事务
Physical and Temporal Decoupling 实体上解耦和时间上解耦
Temporal Decoupling 时间上解耦
Undo Method　Undo()方法
Active Object　ACTIVE OBJECT模式
Conclusion 结论
Bibliography 参考文献
Chapter 22：Template Method and Strategy：Inheritance versus Delegation　TEMPLATE METHOD模式和STRATEGY模式：继承和委托
Template Method　TEM PLATE METHOD模式
Pattern Abuse 滥用模式
Bubble Sort 冒泡排序
Strategy　STRATEGY模式
Conclusion 结论
Bibliography 参考文献
Chapter 23：Facade and Mediator　FACAD E模式和MEDIATOR模式
Facade　FACADE模式
Mediator　MEDIATOR模式
Conclusion 结论
Bibliography 参考文献
Chapter 24：Singleton and Monostate　SINGLETON模式和MONOSTATE模式
Singleton　SINGLETON模式
Benefits　SINGLETON模式的好处
Costs　SINGLETON模式的代价
Singleton in Action 运用SINGLETON模式
Monostate　MONOSTATE模式
Benefits　MONOSTATE模式的好处
Costs　MONOSTATE模式的代价
Monostate in Action 运用MONOSTATE模式
Conclusion 结论
Bibliography 参考文献
Chapter 25：Null Object　NULL OBJECT
Description 描述
Conclusion 结论
Bibliography 参考文献
Chapter 26：The Payroll Case Study：Iteration 1　薪水支付案例研究：第一次迭代开始
Rudimentary Specification 初步的规格说明
Analysis by Use Cases 基于用例分析
Adding Employees 增加新雇员
Deleting Employees 删除雇员
Posting Time Cards 登记考勤卡
Posting Sales Receipts 登记销售凭条
Posting a Union Service Charge 登记工会服务费
Changing Employee Details 更改雇员明细
Payday 发薪日
Reflection：Finding the Underlying Abstractions 反思：找出底层的抽象
Employee Payment 雇员支付类别抽象
Payment Schedule 支付时间表抽象
Payment Methods 支付方式
Affiliations 从属关系
Conclusion 结论
Bibliography 参考文献
Chapter 27：The Payroll Case Study：Implementation 薪水支付案例研究：实现
Transactions 事务
Adding Employees 增加雇员
Deleting Employees 删除雇员
Time Cards，Sales Receipts，and Service Charges 考勤卡、销售凭条以及服务费用
Changing EmplOyees 更改雇员属性
What Was I Smoking? 犯了什么晕
Paying Employees 支付雇员薪水
Paying Salaried Employees 支付领月薪的雇员薪水
Paying Hourly Employees 支付钟点工薪水
Main Program 主程序
The Database 数据库
Conclusion 结论
About This Chapter 关于本章
Bibliography 参考文献
Section IV：Packaging the Payroll System 打包薪水支付系统
Chapter 28：Principles of Package and Component Design 包和组件的设计原则
Packages and Components 包和组件
Principles of Component Cohesion：Granularity 组件的内聚性原则：粒度
The Reuse/Release Equivalence Principle(REP) 重用-发布等价原则
The Common Reuse Principle(CRP) 共同重用原则
The Common Closure Principle(CCP) 共同封闭原则
Summary of Component Cohesion 组件内聚性总结
Principles of Component Coupling：Stability 组件的耦合陛原则：稳定性
The Acyclic Dependencies Principle(ADP) 无环依赖原则
The Stable-Dependencies Principle(SDP) 稳定依赖原则
The Stable-Abstractions Principle(SAP) 稳定抽象原则
Conclusion 结论
Chapter 29：Factory FACTORY模式
A Dependency Problem　依赖问题
Static versus Dynamic Typing　静态类型与动态类型
SubStitutable Factories　可替换的工厂
Using Factories for TIest Fixtures　对测试支架使用对象工厂
Importance of Factories　工厂的重要性
Conclusion　结论
Bibliography　参考文献
Chapter 30：The Payroll Case Study：Package Analysis 薪水支付案例研究：包分析
Component Structure and Notation 组件结构和符号
Applying the Common Closure Principle(CCP) 应用CCP
Applying the Reuse/Release Equivalence Principle(REP) 应用REP
Coupling and Encapsulation 耦合和封装
Metrics 度量
Applying the Metrics to the Payroll Application 度量薪水支付应用程序
Object Factories 对象工厂
Rethinking the Cohesion Boundaries　重新思考内聚的边界
The Final Packaging Structure　最终的包结构
Conclusion　结论
Bibliography　参考文献
Chapter 31：Composite 　COMPOSITE模式
Composite Commands　组合命令
Multiplicity or No Multiplicity　多重性还是非多重性
Conclusion　结论
Chapter 32：Observer：Evolving into a Pattern　OBSERVER——演化至模式
The Digital Clock 数字时钟
The Observer Pattern OBSERVER模式
Models 模型
Management of OOD Principles 面向对象设计原则的运用
Conclusion 结论
Bibliography 参考文献
Chapter 33：Abstract Server,Adapter,and Bridge　ABSTRACTSERVER模式、ADAPTER模式和BRIDGE模式
Abstract Server ABSTRACT SERVER模式
Adapter ADAPTER模式
The Class Form of Adapter 类形式ADAPTER模式
The Mode,m Problem，Adapters，and LSP 调制解调器问题、适配器以及LSP
Bridge BRIDGE模式
Conclusion 结论
Bibliography 参考文献
Chapter 34：Proxy and Gateway：Managing Third-Party APIs　PROXY模式和GATEWAY模式：管理第三方API　　Proxy PROXY 模式
Implementing Proxy 实现PROXY模式
Summary 小结
Databases，Middleware，and Other Third．Party Interfaces 数据库、中间件以及其他第三方接口
Table Data Gateway TABLE DATA GATEWAY
Testing and In．Memory TDGs 测试和内存TDG
Testing the DB Gateways 测试DbGateWay
Using Other Patterns with Databases 可以用于数据库的其他模式
Conclusion 结论
Bibliography 参考文献
Chapter 35：Visitor VISITOR模式
VISITOR VISITOR模式
Acyclic Visitor ACYCLIC VISITOR模式
Uses of VISITOR 使用VISITOR模式
Decorator DECORATOR模式
Extension Object EXTENSION OBJECT模式
Conclusion 结论
Bibliography 参考文献
Chapter 36：State STATE模式
Nested Switch/Case Statements 嵌套switch/case语句
The Internal Scope State Variable 内部作用域的状态变量
Testing the Actions 测试动作
Costs and Benefits 代价和收益
Transition Tables 迁移表
Using Table Interpretation 使用表解释
Costs and Benefits 代价和收益
The State Pattern　STATE模式
State versus Strategy　STATE模式和STRATEGY模式
Costs and Benefits 代价和收益
The State Machine Compiler(SMC) 状态机编译器
Turnstile.CS Generated by SMC，and Other Support Files　SMC生成的Turnstile.CS以及其他支持文件　593
Costs and Benefits 代价和收益
Classes of State Machine Application 状态机应用的场合
High-Level Application Policies for GUIs 作为GUI中的高层应用策略
GUI Interaction Controllers　GUI交互控制器
Distributed Processing 分布式处理
Conclusion 结论
Bibliography 参考文献
Chapter 37：The Payroll Case Study：The Database 薪水支付案例研究：数据库
Building the Database 构建数据库
A Flaw in the Code Design 一个代码设计缺陷
Adding an Employee 增加雇员
Transactions 事务
Loading an Employee 加载Employee对象
What Remains? 还有什么工作
Chapter 38：The Payroll User Interface：Model View Presenter 薪水支付系统用户界面：Model-View-Presenter
The Interface 界面
Implementation 实现
Building a Window 构建窗口
The Payroll Window Payroll 窗口
The Unveiling 真面目
Conclusion 结论
Bibliography 参考文献
Appendix A：A Satire of Two Companies 双公司记
Rufus Inc．：Proj ect Kickoff　Rufus公司：“日落”项目　671　Rupert Industries：Project Alpha　Rupert工业公司：“朝晖”项目
Appendix B：What Is Software? 什么是软件
Index索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>敏捷软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计
第1篇  基本知识  第1章  C++的初步知识    1.1  从C到C++    1.2  最简单的C++程序    1.3  C++程序的构成和书写形式    1.4  C++程序的编写和实现    1.5  关于C++上机实践    习题  第2章  数据类型和表达式第2篇  基于过程的程序设计  第3章  程序设计初步  第4章  利用函数实现指定的功能  第5章  利用数组处理批量数据  第6章  善于使用指针与引用  第7章  用户自定义数据类型第3篇  基于对象的程序设计  第8章  类和对象的特性  第9章  怎样使用类和对象  第10章  运算符重载第4篇  面向对象的程序设计  第11章  继承与派生  第12章  多态性与虚函数  第13章  输入输出流  第14章  C++工具参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
前　言
第1章　让自己习惯Objective-C 1
建议1：视Objective-C为一门动态语言 1
建议2：在头文件中尽量减少其他头文件的引用 6
建议3：尽量使用const、enum来替换预处理#define 10
建议4：优先使用对象字面量语法而非等效方法 13
建议5：处理隐藏的返回类型，优先选择实例类型而非id 17
建议6：尽量使用模块方式与多类建立复合关系 19
建议7：明解Objective-C++中的有所为而有所不为 23
第2章　数据类型、集合和控制语句 28
建议8：C语言与Objective-C语言的关系是充分而非必要条件 28
建议9：高度警惕空指针和野指针的袭击 31
建议10：在64位环境下尽可能利用标记指针 35
建议11：谨记兼容32位和64位环境下代码编写事项 38
建议12：清楚常量字符串和一般字符串的区别 43
建议13：在访问集合时要优先考虑使用快速枚举 44
建议14：有序对象适宜存于数组，而无序对象适宜存于集 48
建议15：存在公共键时，字典是在对象之间传递信息的绝佳方式 53
建议16：明智而审慎地使用BOOL类型 55
第3章　内存管理 57
建议17：理解内存和Objective-C内存管理规则 57
建议18：内存管理讲究“好借好还，再借不难” 61
建议19：区别开alloc、init、retain、release和dealloc之间的差异 63
建议20：优先选用存取方法来简化内存管理 66
建议21：对象销毁或者被移除一定考虑所有权的释放 70
建议22：明智而审慎地使用dealloc 73
第4章　设计与声明 75
建议23：编写代码要遵守Cocoa API约定 75
建议24：洞悉实例变量 77
建议25：透彻了解属性的里里外外 81
建议26：存取方法是良好的类接口必要组成部分 85
建议27：明晓类公共领域的方法都是虚方法 87
建议28：初始化还是解码取决于是否支持归档和解档 92
建议29：利用键–值机制访问类的私有成员变量和方法 93
建议30：浅复制适宜指针而深复制适宜数据 101
建议31：明智而审慎地使用NSCopying 103
建议32：使用协议来实现匿名对象的提供 106
第5章　实现 108
建议33：使用类别把类的实现拆分成不同的文件 108
建议34：明智地使用内省可使程序更加高效和健壮 109
建议35：尽量使用不可变性对象而非可变性对象 113
建议36：利用复合能巧妙地把两个类或两个对象融合 115
建议37：使用类扩展来隐藏实现的细节 120
建议38：使用内联块应注意避免循环引用 122
建议39：利用类别把方法添加到现有的类 124
建议40：通过强弱引用来管理对象的所有权 127
第6章　继承与面向对象设计 133
建议41：明确isa在继承上的作用 133
建议42：利用类别和协议实现类似多重继承的机制 136
建议43：类别和类扩展是类继承的延续性拓展 139
建议44：继承基类的实现行为勿忘调用super 141
第7章　设计模式与Cocoa编程 145
建议45：设计模式是特定环境下的特定问题的解决方案 145
建议46：MVC模式是一种复合或聚合模式 147
建议47：对象建模在数据库中也广泛使用 155
建议48：类簇可简化框架的公开架构而又不减少功能的丰富性 160
建议49：委托用于界面控制，而数据源用于数据控制 165
第8章　定制init...和dealloc 171
建议50：了解对象的alloc和init... 171
建议51：直接访问实例变量的init...方法 174
建议52：初始化方法必须以“init”字母开头 176
建议53：从init...方法得到的对象可能是不想要的 177
建议54：实现init...方法的唯一性或者指定性并非“不可能” 179
建议55：init...方法有“轻重级别”之分 181
第9章　Objective-C与Swift的兼容性 184
建议56：Objective-C和Swift的互用性基于映射机制 184
建议57：利用Swift的特性可增强已有的Objective-C代码 191
建议58：洞悉Objective-C 和Swift类型转换的处理机制 194
建议59：C语言的数据类型在Swift中“有所变有所不变” 199
建议60：Swift和Objective-C兼容性是基于混搭机制 204
建议61：利用迁移机制实现Objective-C代码的重生 209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言入门很简单
第1篇 一切从基础开始
第1章 概述
1.1 C语言简介
1.1.1 C语言的位置
1.1.2 C语言的优缺点
1.1.3 C适合什么开发
1.2 C语言的开发环境
1.2.1 编辑器、编译器和链接器
1.2.2 集成开发环境
1.3 Visual Studio使用简介
1.3.1 Visual Studio版本
1.3.2 Visual Studio的安装
1.3.3 新建项目
1.3.4 编写代码
1.3.5 编译链接
1.3.6 运行可执行程序
1.4 如何学好C语言
1.5 小结
1.6 习题
第2章 开始C语言之旅
2.1 为什么要写代码
2.1.1 为什么要写程序
2.1.2 从本书开始学编程
2.1.3 从一个现实的例子开始
2.2 编程的核心——数据
2.2.1 数据从哪里来
2.2.2 数据的表示
2.2.3 数据类型面面观——精度和范围
2.2.4 C语言基本数据类型
2.2.5 数据的变与不变——变量、常量
2.3 使用变量和常量
2.3.1 变量的使用
2.3.2 命名的方式
2.3.3 关键字
2.3.4 常量的使用
2.4 小结
2.5 习题
第2篇 简单程序的构建
第3章 简单数学运算
3.1 什么是赋值
3.1.1 赋值的作用——把数据存起来
3.1.2 赋值运算的形式
3.1.3 赋值表达式
3.1.4 机动灵活的赋值——scanf()
3.1.5 看看我们的劳动成果——printf()
3.1.6 赋值的重要性
3.2 开始赋值——整型赋值
3.2.1 整数在计算机中的表示——二进制
3.2.2 更先进的表示方法——八进制和十六进制
3.2.3 进制之间的转化——以二进制为桥梁
3.2.4 给整型赋值
3.3 浮点型赋值
3.3.1 小数在计算机的表示
3.3.2 给浮点型赋值
3.4 字符型赋值
3.4.1 字符在计算机中的表示——ASCII
3.4.2 给字符赋值
3.5 类型转化
3.5.1 什么是类型转换
3.5.2 类型转换的利弊
3.5.3 隐式类型转化和显示类型转换
3.5.4 赋值中的类型转换
3.6 基本数学运算
3.6.1 数学运算和数学表达式
3.6.2 商与余数
3.6.3 位运算
3.6.4 优先级的奥秘
3.6.5 数学运算中的类型转换
3.7 复合赋值运算
3.7.1 复合赋值运算
3.7.2 自增自减运算——特殊的复合赋值
3.7.3 自增自减的使用
3.8 小结
3.9 习题
第4章 程序结构
4.1 语句和语句块
4.1.1 简单语句
4.1.2 语句块
4.2 变量的作用域
4.2.1 局部变量的声明定义位置规则
4.2.2 局部变量的作用域规则
4.2.3 嵌套语句块的同名变量作用域规则
4.3 最常见的语句执行顺序——顺序结构
4.4 判断结构
4.4.1 判断的基础——逻辑真假
4.4.2 基础的判断——关系运算
4.4.3 复杂的判断——逻辑运算
4.5 if判断结构
4.5.1 基本if结构
4.5.2 if…else…结构
4.5.3 另类的条件判断——?运算符的使用
4.5.4 if…else if…else结构
4.5.5 嵌套的if结构
4.6 switch判断结构
4.6.1 switch基本结构
4.6.2 果断结束——break的使用
4.7 循环结构
4.7.1 while循环结构
4.7.2 for循环结构
4.7.3 goto语句
4.7.4 循环嵌套
4.7.5 break和continue
4.8 真正的程序——三种结构的揉和
4.9 小结
4.10 习题
第3篇 复杂数据的表示
第5章 数组
5.1 数组简介
5.1.1 数组的用途
5.1.2 数组变量的定义
5.2 数组变量初始化和赋值
5.2.1 数组的初始化
5.2.2 数组的下标
5.2.3 给数组赋值
5.2.4 数组元素的引用
5.3 二维数组
5.3.1 数组的维
5.3.2 二维数组表示和含义
5.3.3 二维数组的初始化
5.3.4 二维数组的赋值
5.3.5 二维数组的引用
5.4 多维数组
5.4 小结
5.5 习题
第6章 字符的数组——字符串
6.1 字符数组
6.1.1 字符数组的表示
6.1.2 字符数组的初始化
6.1.3 字符数组的赋值和引用
6.2 字符串
6.2.1 字符串的C语言表示
6.2.2 使用字符串为字符数组初始化
6.2.3 字符串的保存形式
6.3 字符串的输入输出——scanf和printf字符串
6.3.1 输入输出字符串的C语言表示
6.3.2 scanf()函数对字符串的特殊处理
6.4 小结
6.5 习题
第7章 指针
7.1 地址的概念
7.1.1 地址的含义
7.1.2 为什么要用地址
7.1.3 地址的表示与取址运算
7.2 指针和指针变量
7.2.1 指针的含义和用途
7.2.2 指针类型
7.2.3 指针变量的定义和使用
7.2.4 void指针
7.3 指针运算
7.3.1 取指针元素
7.3.2 指针的自加自减
7.3.3 指针的类型转换
7.4 数组和指针
7.4.1 数组名也是指针
7.4.2 数组名是指针常量
7.4.3 使用数组名访问数组元素
7.4.4 三种访问数组元素的方法
7.4.5 数组指针和指针数组
7.5 多重指针和多维数组
7.5.1 多重指针
7.5.2 取多重指针元素运算
7.5.3 多维数组名和各维元素
7.5.4 使用指针访问多维数组
7.6 字符串和指针
7.6.1 字符指针
7.6.2 字符指针和字符串
7.6.3 scanf()、printf()函数和字符指针
7.7 小结
7.8 习题
第8章 结构体
8.1 结构体的含义
8.2 结构体类型的表示
8.2.1 结构体类型的一般格式
8.2.2 结构体的成员变量
8.2.3 复杂的结构体
8.3 结构体变量
8.3.1 结构体变量的声明定义
8.3.2 结构体变量初始化
8.3.3 取结构体成员运算
8.4 结构体数组
8.5 结构体指针
8.5.1 一重结构体指针
8.5.2 使用结构体指针取结构体数据
8.5.3 结构体指针例子
8.6 回到问题
8.7 小结
8.8 习题
第9章 共同体类型
9.1 共同体的含义与表示
9.1.1 共同体的用途
9.1.2 共同体的表示
9.1.3 复杂的共同体
9.2 共同体变量
9.2.1 共同体变量
9.2.2 共同体成员变量的相互覆盖
9.2.3 使用共同体变量
9.3 共同体数组
9.4 共同体的指针
9.4.1 一重共同体指针类型
9.4.2 共同体指针变量
9.4.3 完整的例子
9.5 小结
9.6 习题
第10章 枚举类型
10.1 枚举类型的含义与表示
10.1.1 枚举类型的含义
10.1.2 枚举类型的表示
10.2 枚举常量和枚举变量
10.2.1 枚举常量
10.2.2 枚举变量的定义
10.2.3 枚举变量的使用
10.3 枚举数组和指针
10.3.1 枚举数组
10.3.2 枚举指针
10.3.3 用枚举指针来访问枚举数组
10.4 typedef类型定义符
10.5 小结
10.6 习题
第4篇 复杂功能的实现
第11章 函数
11.1 函数的意义
11.2 函数的形式
11.2.1 函数的一般形式
11.2.2 函数的参数列表
11.2.3 函数的返回值类型
11.3 函数声明和定义
11.3.1 函数的声明
11.3.2 函数的定义形式
11.3.3 函数的形参
11.3.4 return返回值语句
11.4 自己动手写一个函数——加法函数
11.4.1 确定加法函数的样子
11.4.2 实现加法函数体
11.4.3 完整的加法函数定义
11.5 函数调用
11.5.1 函数的调用作用
11.5.2 函数调用表达式
11.5.3 函数的实参
11.5.4 简单函数的调用
11.6 复杂参数
11.6.1 数组参数
11.6.2 指针参数
11.6.3 结构体、共同体和枚举参数
11.7 小结
11.8 习题
第12章 特殊的函数——main()函数
12.1 main()函数的作用
12.2 main()函数的声明定义
12.2.1 main()函数的声明形式
12.2.2 main()函数的参数
12.2.3 main()函数的返回值
12.3 小结
12.4 习题
第13章 局部变量和全局变量
13.1 变量的作用域和生命周期
13.2 函数内的局部变量
13.2.1 局部变量的作用域
13.2.2 局部变量的生命周期
13.2.3 局部变量的覆盖作用
13.3 函数外的全局变量
13.3.1 全局变量的作用域
13.3.2 全局变量的生命周期
13.3.3 局部变量对全局变量的覆盖作用
13.4 变量修饰符
13.4.1 使用修饰符改变变量的作用域和生命周期
13.4.2 C语言中常用变量修饰符的作用
13.5 小结
13.6 习题
第5篇 C语言的高级内容
第14章 预处理命令、文件包含
14.1 预处理命令的作用
14.1.1 程序预处理
14.1.2 预处理命令
14.1.3 C语言的几类预处理命令
14.2 C语言中的宏定义
14.2.1 C语言的宏定义形式
14.2.2 不带参宏定义
14.2.3 带参数的宏定义
14.3 预编译控制
14.3.1 C语言预编译控制
14.3.2 三种预编译控制组合形式
14.3.3 一个简单的例子
14.4 文件包含
14.4.1 头文件和源文件的文件名
14.4.2 头文件和源文件的内容
14.5 include包含头文件
14.5.1 自定义头文件和系统头文件
14.5.2 文件包含的两种形式
14.5.3 完整的circle例子
14.5.4 C语言中的标准头文件
14.6 小结
14.7 习题
第15章 文件操作
15.1 文件
15.1.1 重新认识文件
15.1.2 计算机眼里的文件
15.1.3 开发人员能对文件干些什么
15.2 文件的打开关闭
15.2.1 文件指针
15.2.2 文件打开函数
15.2.3 文件关闭函数
15.3 文件读写
15.3.1 读写一个字符
15.3.2 读写一个字符串
15.3.3 读写一个数据块
15.4 文件的其他操作
15.4.1 随机读写文件
15.4.2 出错检验
15.5 小结
15.6 习题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言入门很简单
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C编译器剖析 - 邹昌伟
第1章 基础知识
1.1 语言、文法与递归
1.2 一个较复杂的文法
1.3 由文法到分析器
1.3.1 表达式
1.3.2 声明
1.3.3 语句
1.4 UCC编译器预览
1.4.1 UCC的使用
1.4.2 UCC驱动器
1.5 结合C语言来学汇编
1.5.1 汇编语言简介
1.5.2 整数运算
1.5.3 浮点数的算术运算
1.5.4 浮点数之间的比较操作
1.5.5 指针、数组和结构体
1.6 C语言的变量名、数组名和函数名
1.7 C语言的变参函数
1.8 本章习题
第2章 UCC编译器的基本模块
2.1 从Makefile走起
2.2 词法分析
2.3 UCC编译器的内存管理
2.4 C语言的类型系统
2.5 UCC编译器的符号表管理
2.6 本章习题
第3章 语法分析
3.1 C语言的表达式
3.1.1 条件表达式和二元表达式
3.1.2 一元表达式、后缀表达式和基本表达式
3.2 C语言的语句
3.3 C语言的外部声明
3.3.1 声明和函数定义
3.3.2 与声明有关的几个非终结符
3.3.3 声明说明符和声明符
3.4 本章习题
第4章 语义检查
4.1 语义检查简介
4.2 表达式的语义检查
4.2.1 表达式的语义检查简介
4.2.2 数组索引的语义检查
4.2.3 基本表达式的语义检查
4.2.4 函数调用的语义检查
4.2.5 成员选择运算符的语义检查
4.2.6 相容类型
4.2.7 一元表达式的语义检查
4.2.8 二元表达式、赋值表达式和条件表达式的语义检查
4.3 语句的语义检查
4.4 声明的语义检查
4.4.1 类型结构的构建
4.4.2 结构体的类型结构
4.4.3 结构体和数组的初始化
4.4.4 内部连接和外部连接
4.4.5 外部声明的语义检查
4.5 本章习题
第5章 中间代码生成及优化
5.1 中间代码生成简介
5.2 表达式的翻译
5.2.1 布尔表达式的翻译
5.2.2 公共子表达式
5.2.3 通过“偏移”访问数组元素和结构体成员
5.2.4 后缀表达式的翻译
5.2.5 赋值表达式的翻译
5.2.6 一元表达式及其他表达式的翻译
5.3 语句的翻译
5.3.1 if语句和复合语句的翻译
5.3.2 switch语句的翻译
5.4 UCC编译器的优化
5.4.1 删除无用的临时变量和优化跳转目标
5.4.2 基本块的合并
5.5 本章习题
第6章 汇编代码生成
6.1 汇编代码生成简介
6.2 寄存器的管理
6.3 中间代码的翻译
6.3.1 由中间代码产生汇编指令的主要流程
6.3.2 为算术运算产生汇编代码
6.3.3 为跳转指令产生汇编代码
6.3.4 为函数调用与返回产生汇编代码
6.3.5 为类型转换产生汇编代码
6.3.6 为取地址产生汇编指令
6.4 本章习题
参考文献
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C编译器剖析 - 邹昌伟
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白话C语言
序  学习编程能够带给你什么  为什么是学习C语言而不是别的  你准备好了吗第1章  基础篇  我们是从零开始的吗  了解一些计算机内幕  程序员的“怪癖”  代数与C语言  本章要点第2章  函数篇  程序的相貌  函数的相貌  如何在函数中“遣词造句”  从main函数开始  为什么要定义多个函数  调用函数时发生了什么  让人头痛的printf和scanf  本章要点第3章  符号篇  标识符  分隔符和结尾符  特殊的常量标识  都是分号惹的祸  为什么它们是最高级的运算符  古怪的运算符和表达式  双胞胎运算符  ＝符号的双重身份  穿上马甲之后  extern的用武之地  static的用武之地  本章要点第4章  数据篇  数据、数值与逻辑值  变量的值什么时候会变化  为什么要定义数组变量  指针的有色眼镜  指针型参数的作用  小心驶得万年船  本章要点第5章  风格与调试篇  程序是写给谁看的  好习惯是一种护身符  调试“三板斧”  调试的雕虫小技  本章要点第6章  其他  C语言中的“潜规则”  问世间“工程”为何物  “工程”是怎样炼成的  好奇心会杀死猫吗  本章要点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>白话C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字音频规范与程序设计
前言
第一章	Windows音频体系与VC++开发基础
1.1	认识声音与音频
1.2	Windows音频体系层次结构
1.2.1	用户模式与内核模式
1.2.2	关于声音的延迟问题及解决方法
1.3	VC++开发基础
1.3.1	区分C、C++和VC++三者的关系
1.3.2	事件驱动与消息处理
1.3.3	开发环境概述
1.3.4	MFC概述
1.3.5	利用向导创建一个简单的对话框程序
第二章	MCI与MMAPI多媒体编程接口
2.1	MCI简介
2.1.1	MCI逻辑结构
2.1.2	MCI接口、函数与命令
2.1.3	MCI消息与宏定义
2.2	MCI编程步骤
2.3	MCI编程实例
2.3.1	播放CD
2.3.2	WAV播放与录音
2.3.3	基于MCIWnd的多媒体播放器
2.4	MMAPI简介
2.4.1	四种多媒体文件IO
2.4.2	波形音频处理
2.4.3	MIDI的流缓冲区与非流缓冲区处理
2.4.4	多媒体定时器
第三章	WAVE格式及播放与录制
3.1	认识WAVE
3.2	WAVE文件结构
3.3	采样点与采样帧的区别
3.4	WAVE中常用的一些块
3.4.1	格式块
3.4.2	数据块
3.4.3	提示块
3.4.4	播放列表块
3.4.5	关联数据块
3.4.6	采样块
3.5	多媒体波形音频函数
3.6	波形音频处理的回调机制
3.7	WAVE播放
3.7.1	WAVE播放基本流程
3.7.2	双缓冲播放机制
3.7.3	关于死锁的问题
3.8	WAVE录音
3.9	程序实例
3.9.1	WAVE文件解析及分离与合并
3.9.2	WAVE播放器
3.9.3	WAVE录音机
第四章	MIDI标准与程序设计
4.1	什么是MIDI
4.1.1	MIDI硬件接口
4.1.2	MIDI设备连接
4.1.3	MIDI通讯方式
4.2	MIDI信息
4.2.1	MIDI音乐制作
4.2.2	通道信息
4.2.3	控制器
4.2.4	系统信息
4.2.5	运行状态
4.3	其他MIDI规范
4.4	GM、GS与XG
4.5	GM2
4.6	MIDI文件格式
3.6.1	头部信息
3.6.2	轨道信息
3.6.3	Meta信息
4.7	MIDI文件示例
4.8	与MIDI相关的时间计算
4.8.1	BPM
4.8.2	PPNQClock
4.8.3	MIDIClock
4.8.4	SMPTE
4.9	程序实例
4.9.1	MIDI设备枚举、播放与录制
4.9.2	MIDI信息发送器
4.9.3	鼓速测试工具
4.9.4	MIDI播放器
4.9.5	截获MIDI信息
4.10	USBMIDI概述
4.11	USBMIDI的实现机制
4.12	USB-MIDI功能器件
4.12.1	MIDI流接口
4.12.2	拓扑结构
4.12.3	USB-MIDI转换器
4.12.4	元件
4.13	USB-MIDI数据格式
4.14	USB-MIDI操作模型
4.14.1	主机到USB-MIDI功能器件的通讯
4.14.2	USB-MIDI功能器件到主机的通讯
4.14.3	高带宽数据传输机制
4.15	USB-MIDI描述符
4.15.1	MIDI流接口描述符
4.15.2	MIDI流端点描述符
4.16	USBMIDI驱动设计
4.16.1	用户模式音频驱动程序
4.16.2	用户模式音频驱动的入口点
4.16.3	用户模式音频驱动入口点消息
4.16.4	用户模式音频驱动通知客户端
4.16.5	用户模式音频驱动的安装
4.17	USB驱动程序
4.17.1	IRP的分层处理
4.17.2	IRP的基本结构与内容
4.17.3	驱动对象与设备对象
4.17.4	核心模式驱动的入口点
4.17.5	USB驱动程序的设计步骤
4.18	户模式音频驱动几个上层接口的实现
第五章	数字音乐合成
5.1	合成器概述
5.2	MIDI的发音原理
5.3	FM合成原理
5.4	波表合成
5.4.1	波表合成器工作原理
5.4.2	波表合成的关键技术
5.4.3	频率变换
5.4.4	循环(LOOP)
5.4.5	波表合成器的衡量指标
5.5	软波表与硬波表
5.6	音色制作
5.6.1	样本准备与分配
5.6.2	样本参数调整
5.6.3	音色参数调整
5.6.4	设置效果参数
5.6.5	保存音色文件
第六章	音频混音器
6.1	混音器原理
6.1.1	声卡硬件模型
6.1.2	音频线路
6.1.3	控件
6.2	混音器编程
6.2.1	MixerAPI函数介绍
6.2.2	枚举系统中的混音器设备
6.2.3	打开混音器设备
6.2.4	枚举音频线路
6.2.5	获取音频线路信息
6.2.6	枚举音频线路的相关控件
6.2.7	获取与线路相关的所有控件信息
6.2.8	通过控件ID获取控件信息
6.2.9	通过控件类型获取控件信息
6.2.10	获取或设置控件之值
6.2.11	多声道控件
6.2.12	多条目控件
6.2.13	混音器专用信息
6.3	程序实例-混音器调节软件
第七章	音频插件设计
7.1	插件的实现原理
7.2	基于动态链接库的方法实现DLL插件
7.2.1	定义插件接口结构
7.2.2	实现插件的功能
7.2.3	插件管理
7.3	实现一个支持三种插件类型的MINI播放器
7.3.1	主程序设计
7.3.2	输入型插件设计
7.3.3	常规型插件设计
7.3.4	输出型插件设计
7.4	给Winamp写一个MIDI键盘插件
7.4.1	确定插件的类型
7.4.2	截获系统API
7.4.3	实现插件功能
7.5	基于ATL的方法实现COM插件
7.6	VST插件概述
7.7	VSTSDK与VST的音频数据处理
7.8	创建一个最简单的VST插件
7.9	设计一个StereoDelay效果的VST插件
7.10	VSTXML文件
7.11	设计一个简单的FM合成器插件
7.11.1	什么是FM合成
7.11.2	用到哪些VST(i)函数
7.11.3	波形产生器
7.11.4	包络发生器
7.11.5	频率比
7.11.6	低频振荡器
7.11.7	合成信号路径
7.11.8	合成实现
7.11.9	音高测试
7.11.10	谐振频率测试
7.12	VSTGUI编程
7.12.1	创建一个最简单GUI的VST插件
7.12.2	几种常用GUI控件的使用方法
7.12.3	监听器与控件标识符
7.13	实现一个自行设计界面的RingModulator插件
7.14	VST宿主程序设计
第八章	基音的时频域检测
8.1	概述
8.2	音乐信号的前期处理
8.2.1	信号数字化
8.2.2	取音框
8.2.3	静音与杂音处理
8.3	时域基频检测方法
8.3.1	自相关函数法
8.3.2	自相关函数法的程序实例
8.3.3	平均振幅差函数法
8.3.4	平均振幅差函数法的程序实例
8.4	频域基频检测方法
8.4.1	傅里叶变换的原理及其物理意义
8.4.2	快速傅里叶变换法
8.4.3	快速傅里叶变换法的程序实例
8.4.4	谐波积频谱法
8.4.5	谐波积频谱法的程序实例
8.4.6	倒谱法
8.4.7	极大似然法
8.5	时频域检测方法
8.5.1	小波变换法
8.5.2	ACF与AMDF结合法
8.5.3	ACF与AMDF相结合的程序实例
8.6	基频检测的后期处理
8.7	软件调音器的设计
第九章	ASIO音频驱动设计
9.1	何为ASIO
9.2	用户层ASIO驱动设计
9.2.1	ASIO的有限状态机
9.2.2	音频数据流的传输
9.2.3	ASIO驱动接口
9.2.4	数据同步
9.2.5	四个重要的回调函数
9.2.6	几个重要的数据结构
9.2.7	输入输出延迟问题
9.3	用户层ASIO驱动的实现
9.3.1	准备工作
9.3.2	添加自注册功能
9.3.3	实现IASIO的所有接口
9.4	在音频软件中使用ASIO驱动
9.4.1	ASIO播放
9.4.2	ASIO录音
第十章	MP3编解码
10.1	MP3简介
10.2	MP3文件格式
10.2.1	TAG_V2（ID3V2）
10.2.1.1	标签头
10.2.1.2	扩展标签头
10.2.1.3	标签帧
10.2.2	帧（Frame）
10.2.2.1	帧头（FRAME_HEADER）
10.2.2.2	音频数据（AUDIO_DATA）
10.2.3	TAG_V1（ID3V1）
10.3	程序实例-MP3文件分析
10.4	MP3编码的基本概念
10.4.1	奈奎斯特定理
10.4.2	非均匀量化
10.4.3	霍夫曼编码
10.4.4	离散余弦变换
10.4.5	心理声学模型
10.4.5.1	静音门槛曲线
10.4.5.2	临界频带
10.4.5.3	屏蔽效应
10.4.5.4	感知熵
10.4.5.5	第二心理声学模型
10.4.5.6	滤波器组
10.4.5.7	比特分配与非均匀量化
10.4.5.8	霍夫曼编码
10.4.5.9	封装成帧
10.5	MP3编码过程
10.5.1	编码框架
10.5.2	心理声学模型
10.5.2.1	汉宁窗快速傅里叶变换FFT
10.5.2.2	非预测值计算
10.5.2.3	计算长块阈值（第一部分）
10.5.2.4	计算感知熵PE
10.5.2.5	长块阈值计算（第二部分）
10.5.2.6	短块阈值计算
10.5.3	分析滤波器组
10.5.4	MDCT
10.5.4.1	窗框选择
10.5.4.2	改进的离散余弦变换
10.5.5	长窗混叠处理
10.5.6	非均匀量化与编码
10.5.6.1	帧循环的准备工作
10.5.6.2	外层循环（失真控制）
10.5.6.3	内层循环（速率控制）
10.5.7	格式化
10.6	MP3解码过程
10.6.1	帧头信息处理
10.6.2	帧边信息处理
10.6.3	解码比例因子信息
10.6.3.1	长块（LongBlock）
10.6.3.2	短块（ShortBlock）
10.6.3.3	混合块（MixBlock）
10.6.4	解码霍夫曼编码
10.6.4.1	解码Zeros区
10.6.4.2	解码Count1区
10.6.4.3	解码BigValues区
10.6.5	非均匀反量化
10.6.6	重新排序
10.6.7	立体声处理
10.6.8	混叠消除
10.6.9	IMDCT反余弦变换
10.6.10	频率反转
10.6.11	多相合成滤波器
10.7	程序实例
10.7.1	MP3文件解析
10.7.2	MP3的实时录制
10.7.2.1	编译LAME
10.7.2.2	Lame-EncDLL接口函数使用与说明
10.7.2.3	录制原始波形音频数据
10.7.2.4	WAVE转MP3
10.7.3	MP3播放器
10.7.4	Libmad源码分析
第十一章	DirectSound开与应用
11.1	DirectX概述
11.2	DirectSound简介
11.2.1	DirectSound的功能组成与组件对象
11.2.2	DirectSound的缓冲区
11.2.3	DirectSound的数据结构
11.3	DirectSound播放
11.3.1	VC++编译环境配置
11.3.2	DirectSound回放的基本过程
11.3.3	枚举系统输出声音设备
11.3.4	创建DirectSound对象
11.3.5	设置声音设备的协作等级
11.3.6	创建声音缓冲区对象
11.3.7	加载WAVE声音数据
11.3.8	声音缓冲区回放
11.3.9	声音缓冲区控制
11.3.10	混音
11.3.11	3D音效和声音效果
11.3.12	DirectSound3D收听者
11.3.13	设置声音特效
11.4	DirectSound录音
11.4.1	枚举系统录音设备
11.4.2	创建设备对象
11.4.3	获取录音设备的性能
11.4.4	创建录音缓冲区
11.4.5	获取录音缓冲区信息
11.4.6	为录音缓冲区对象设置通知机制
11.4.7	开始录音
11.5	使用DirecSound中的效果
11.5.1	在缓冲区中设置效果
11.5.2	混响（Reverb）
11.5.3	合唱（Chorus）
11.5.4	回响（Echo）
11.5.5	镶边（Flanger）
11.5.6	参量均衡（ParametricEQ）
11.5.7	咕噜（Gargle）
11.5.8	失真（Distortion）
11.5.9	压缩（Compression）
11.6	扬声器配置
11.6.1	设置扬声器配置
11.6.2	获取扬声器配置
11.7	程序实例
11.7.1	DirectSound播放
11.7.2	DirectSound录音
11.7.3	DirectSound效果器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字音频规范与程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷5
第0 章  尘埃落定　　1
0.1  渊源　　1
0.2  成功与失败　　 2
0.2.1  观察　　2
0.2.2  状态　　3
0.2.3  处方　　4
0.3  模式定义及解释　　5
0.4  深入理解模式　　11
第一部分  模式剖析
第1 章  问题之解决方案及其他　　15
1.1  问题之解决方案　　15
1.1.1  一个例子（1） 　　15
1.1.2  重现与良好　　16
1.2  流程和物件　　16
1.3  “好”的解决方案　　17
1.4  驱动力：模式之心脏　　19
1.4.1  一个例子（4） 　　19
1.4.2  dysfunctional、bad 还是anti 　　21
1.5  上下文　　22
1.5.1  一个例子（5） 　 23
1.5.2  上下文的一般性　　23
1.5.3  独立上下文　　24
1.5.4  一个例子（6） 　 25
1.6  一般性　　 25
1.7  一图胜（逊）千言　　 27
1.8  模式命名　　29
1.8.1  模式命名的语法分类　　30
1.8.2  字面命名还是隐喻　　 30
1.9  模式是循序渐进的　　 31
1.10  模式既是讲故事，又能发起对话　　33
1.11  模式不能代替思考　　 33
1.12  从“问题—解决方案”到模式　　34
第2 章  多种多样的模式实现　　35
2.1  是否存在一个通用的模型呢　　35
2.1.1  Observer 模式：快速回顾　　36
2.1.2  结构的变化与角色　　36
2.1.3  行为的变化　　37
2.1.4  内部差异　　38
2.1.5  语言及平台的差别　　39
2.1.6  领域、环境相关的变化　40
2.1.7  再论假设　　41
2.2  模式与框架　　42
2.2.1  工具和上下文环境　　44
2.2.2  两个框架的故事　　44
2.3  模式与形式主义　　47
2.4  通用性与特殊性　　48
第3 章  模式格式　　50
3.1  风格与实质　　50
3.2  格式的功能　　52
3.3  格式的元素　　53
3.4  细节　　55
3.4.1  案例　　56
3.4.2  图示　　57
3.4.3  <code>…</code> 　　57
3.5  鸟瞰图　　 58
3.5.1  从金字塔到托盘　　58
3.5.2  模式骨架　　58
3.5.3  总结意图　　60
3.5.4  模式抽象　　60
3.6  不同的格式　　60
3.6.1  演变　　61
3.6.2  选择　　62
3.7  风格与实质（Redux） 　　63
第二部分  模式之间的关系
第4 章  模式孤岛　　 67
4.1  模式的联系　　67
4.2  设计实验：将模式作为孤岛　　68
4.3  第二个设计实验：交织在一起的模式　　72
4.4  模式密度　　73
第5 章  模式的互补性　　 75
5.1  一个问题，多种解决方案　　75
5.2  互相竞争的模式　　76
5.2.1  以状态为例　　76
5.2.2  模式族　　79
5.2.3  迭代开发　　80
5.2.4  适配开发　　83
5.2.5  遵从康威定律　　84
5.2.6  与风格的设计对话　　86
5.3  互相合作的模式　　87
5.3.1  一个关于值的例子　　88
5.3.2  设计上的完善　　 88
5.4  模式结合　　89
5.4.1  再论迭代　　89
5.4.2  再论适配编程　　91
5.5  互补性：竞争、完善、结合　　92
第6 章  模式复合　　93
6.1  常见模式排列　　93
6.2  从元素到复合　　93
6.2.1  Pluggable Factory 　　94
6.2.2  Composite Command 的两种视角　　95
6.2.3  模式复合的格式　　 96
6.3  从补充到复合　　97
6.3.1  重申　　 97
6.3.2  适配　　 99
6.4  是元素还是组合　　100
6.4.1  组合的含义　　100
6.4.2  深入MVC　　101
6.5  复合分析与综合　　102
6.5.1  非设计模式的复合　　102
6.5.2  设计模式复合　　103
第7 章  模式序列　　104
7.1  模式讲述软件工程成功的故事　　104
7.2  模式故事　　105
7.2.1  一个小故事　　105
7.2.2  已经发表的故事　　107
7.3  从故事到序列　　108
7.4  模式的序列　　109
7.4.1  一个早期的例子　　110
7.4.2  模式序列既是流程也是物件　　110
7.4.3  再次回到以前提到的小故事　　111
7.5  回顾模式复合和模式互补　　112
7.5.1  重组　　112
7.5.2  再论Batch Iterator 　　113
7.5.3  再论Interpreter 　　　114
7.5.4  再论Align Architecture andOrganization 　　115
7.6  回到上下文的问题　　 116
7.6.1  定义上下文　　116
7.6.2  专用化与差异化　　118
7.7  模式间的联系　　118
第8 章  模式集合　　120
8.1  模式手册　　120
8.2  组织模式集合　　121
8.3  即时组织　　121
8.4  根据层次组织　　122
8.4.1  设计和架构　　122
8.4.2  惯用法　　 123
8.4.3  混合层次　　124
8.4.4  层次　　124
8.5  根据领域组织　　125
8.6  根据分区组织　　125
8.6.1  阶层架构　　126
8.6.2  分区　　126
8.7  根据意图组织　　126
8.7.1  根据意图划分POSA 的模式　　127
8.7.2  根据意图划分GoF 的模式　　128
8.7.3  根据意图划分DDD 模式　　128
8.7.4  反思模式意图　　128
8.8  组织模式集合（重奏）　　 128
8.9  问题框架　　 129
8.9.1  问题框架　　130
8.9.2  问题框架和模式的对比　　 131
8.9.3  问题框架与模式的组合　　 132
8.10  模式符号学　　132
8.11  模式集合与风格　　134
8.11.1  Unix 接口设计模式　　135
8.11.2  Web 2.0 设计模式　　136
8.11.3  风格与概念一致性　　137
8.12  走向模式语言　　138
第三部分  模式语言
第9 章  语言的元素　　141
9.1  使用模式进行设计　　 141
9.2  从模式故事和模式序列到模式语言　　 142
9.2.1  一个未完成的故事　　143
9.2.2  序列的组合　　145
第10 章  模式网络及其他　　147
10.1  模式网络　　147
10.2  流程与物件　　147
10.2.1  流程的迭代本质　　 148
10.2.2  具体的面向领域的引导　　152
10.3  单项最佳　　153
10.4  驱动力：模式语言之心脏　　155
10.5  模式上下文定义拓扑结构与架构风格　　 158
10.6  模式构成词汇，序列展示语法　　 159
10.7  通用性　　162
10.7.1  不同的模式序列　　162
10.7.2  模式的组合　　163
10.8  完整的语言胜过千幅图　　163
10.9  面向领域的命名帮助忆起模式语言　　164
10.10  模式语言展开对话并讲述很多故事　　165
10.11  路还很长　　165
10.12  模式语言对创造性智慧的回报　　167
10.13  从模式网络到模式语言　　 168
第11 章  亿万种不同的实现　　169
11.1  众口难调　　169
11.2  渐进式成长　　169
11.2.1  面向系统的、进化的设计方法　　170
11.2.2  渐进式成长和敏捷开发　　171
11.3  并没有排斥重构　　172
11.4  一次一个模式　　174
11.4.1  明白手头上的问题的关键　　 174
11.4.2  优先级驱动的设计决策　　175
11.4.3  模式集成先于模式实现　　175
11.5  基于角色的模式集成　　176
11.5.1  选择1：识别并且保持已经实现的角色　　176
11.5.2  选择2：识别并分离已经实现的角色　　177
11.5.3  选择3：将缺失角色分配给既有设计元素　　178
11.5.4  选择4：将缺失角色作为新设计元素来实现　　179
11.5.5  基于角色的模式集成和渐进式成长过程　　180
11.6  模式语言和参考架构　　180
11.7  模式语言与产品线架构　　181
11.8  从十亿个到一个……再到一些　　184
第12 章  模式语言的格式　　185
12.1  风格与本质　　185
12.2  格式的作用　　185
12.3  格式的元素　　186
12.3.1  展示全貌　　187
12.3.2  简洁与细节　　187
12.3.3  模式连接　　189
12.3.4  再说元素　　189
12.4  细节，细节，细节　　 190
12.4.1  模式语言的格式　　 190
12.4.2  鸟瞰图　　 190
12.4.3  展示顺序　　194
12.4.4  示例　　194
12.4.5  细节程度　　195
12.5  再论风格与本质　　 197
第13 章  模式与模式语言　　198
13.1  模式和模式语言：共性　　198
13.1.1  共同的核心属性　　198
13.1.2  共同的根源　　199
13.1.3  一个模式的模式语言　　199
13.2  模式与模式语言：区别　　200
13.2.1  模式和细节　　 200
13.2.2  模式语言和交互　　200
13.2.3  两个独立的世界　　201
13.3  模式“对”模式语言　　201
第14 章  从模式到人　　202
14.1  模式以人为本　　 202
14.1.1  模式价值体系　　 203
14.1.2  人类读者　　 204
14.2  对软件开发者的支持　　204
14.3  对软件使用者的支持　　206
14.3.1  用户界面　　206
14.3.2  用户需求　　206
14.3.3  交到用户手中　　207
14.4  对模式作者的支持　　 207
14.4.1  协同写作　　 207
14.4.2  作者研讨会　　208
14.4.3  牧放　　208
14.5  技术为人　　209
第15 章  模式的过去、现在和未来　　210
15.1  过去的3 年　　210
15.1.1  模式与模式语言　　 210
15.1.2  理论和概念　　212
15.1.3  重构与集成　　212
15.1.4  GoF　　 213
15.2  模式的现状　　213
15.3  模式的明天在哪里　　 214
15.3.1  模式与模式语言　　 214
15.3.2  理论和概念　　216
15.3.3  重构与集成　　216
15.3.4  支持其他的软件开发方法　　 216
15.3.5  对其他学科的影响　　217
15.3.6  其他学科对我们的影响　　217
15.4  简述模式的未来　　218
第16 章  万事如意　　219
模式概念总结　　 221
参考模式　　 225
参考文献　　238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙语短篇
Introduction 前言
1、The Longest Menu in the World
2、Court Case
3、My Friend the Penguin
4、Man at War
5、A Long Silence
6、The Photographer
7、Guilty or Not Guilty
8、Late for Work
9、Speak Your Weight
10、Musical Lions
11、The Witness
12、An Important Friend
13、The Shirt
14、A Present for the Judge
15、Performers
Answer Key 答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙语短篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>消费信用模型
1消费信用和信用评分简介
1.1引言：消费信用的重要性和影响力
1.2违约信用评分的历史背景
1.3贷款机构的目标
1.3.1银行的目标
1.3.2贷款过程
1.4贷款决策的建模工具
1.4.1影响图
1.4.2消费信贷中的申请决策
1.4.3决策树
1.4.4消费信贷决策树
1.4.5策略树
1.5概率、比率和分数
1.5.1概率和比率
1.5.2总体比率和信息比率
1.5.3分数：一个充分统计量
1.5.4对数比率分数
1.5.5对数比率分数的分解
1.5.6朴素Bayes评分卡的构建
1.5.7分数分布
1.6分数的变换
1.6.1缩放自然分数
1.6.2缩放正态分布的分数
1.6.3多级评分卡
1.6.4风险率和时变分数
1.6.5离散时间风险概率
1.7贷款的回报和成本
1.7.1单期贷款的回报率模型
1.7.2单期企业债券的回报率模型
1.7.3消费贷款的利润率和回报率
1.7.4两期回报率模型
1.7.5多期贷款
1.8评分卡构建的基本原理
1.8.1建立评分卡的基本方法
1.8.2拒绝推断
1.8.3行为评分
1.8.4数据样本
1.8.5数据检验和整理
1.8.6样本细分
1.8.7训练和检验样本
1.8.8剔除特征变量
1.8.9特征粗分类
1.8.10卡方和信息统计量
1.8.11粗分类生成新变量
1.8.12评分卡最终形成和检验
1.9逻辑回归评分卡
1.10其他建立评分卡的方法
1.10.1线性回归
1.10.2散度最大化
1.10.3线性规划
1.10.4分类树
2评分系统的评估
2.1评分卡质量的评估
2.1.1交叉验证法
2.1.2自展法
2.2判别能力的测量
2.2.1散度与信息量
2.2.2马氏距离
2.2.3KS统计量
2.2.4D—致性统计量与U统计量
2.3ROC曲线和Gini系数
2.3.1Gini系数和AUROC
2.3.2ROC曲线与D统计量、KS统计量的关系
2.3.3Gini系数的边界
2.3.4ROC曲线和商业决策
2.3.5CAP曲线与准确率
2.4评分卡细分对判别能力的影响
2.4.1样本细分对Gini系数的影响
2.4.2样本细分对KS统计量的影响
2.4.3样本细分对散度的影响
2.5评分卡预测概率的校准
2.5.1二项检验
2.5.2二项检验的正态近似
2.5.3卡方检验
2.6分类预测正确程度的测量
2.6.1混淆矩阵
2.6.2第一类错误和第二类错误，敏感度和特异度
2.6.3交换集合
2.6.4最小错误成本
3基于风险定价
3.1消费信贷中的可变定价
3.1.1可变定价
3.1.2差异化定价
3.1.3响应率和接受率
3.1.4双重定价
3.2无风险利率响应函数和最优定价
3.2.1无风险响应率
3.2.2弹性
3.2.3最大支付意愿
3.2.4常见的响应函数
3.2.5最优定价
3.3风险响应关系，逆向选择和负担能力
3.3.1风险响应关系
3.3.2逆向选择
3.3.3风险响应关系和逆向选择的区别
3.3.4负担能力
3.4基于风险的响应函数和定价
3.4.1基于风险的好人概率
3.4.2基于风险的最优利率
3.4.3无逆向选择的最优利率
3.4.4有逆向选择的最优利率
3.5多种优惠条件下的接受概率
3.5.1贷款的多种优惠条件
3.5.2逻辑接受概率函数
3.5.3线性规划估计最大支付意愿
3.5.4加速生命模型估计最大支付意愿
3.6借贷博弈定价模型
……
4利润评分和动态模型
5组合信用风险和巴塞尔协议
附录
术语表
参考文献
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>消费信用模型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DK儿童动物百科全书•第2版
前言
动物王国
什么是动物？
动物行为
动物的生命周期
全球生境
濒危动物
哺乳动物
什么是哺乳动物？
有袋类动物
“飞翔的”哺乳动物
食虫动物
蝙蝠
蝙蝠的听觉
灵长类动物
新大陆旧大陆
独特的狒狒
类人猿
原猴类灵长动物
啮齿动物
啮齿动物的世界
建筑师河狸
鲸和海豚
鲸目动物的世界
母鲸和仔鲸
海豚的交流
犬科动物
为寒冷而生！
熊科动物
保护大熊猫
猫科动物
狮的群体协作
猫科动物的世界
生存游戏
鼬和它的近亲
海獭的家
灵猫和它的近亲
海豹和海狮
我是海象
象
大象家族
儒艮和海牛
马、驴和斑马
长颈鹿和狓
犀牛
好斗的河马
骆驼和它的近亲
鹿
牛和羚羊
角马大迁徙
鸟类
什么是鸟类？
鸟的世界
鸟以群分
猛禽
白头海雕
安静的猫头鹰
猎禽
海鸟和滨鸟
企鹅
漂泊信天翁
鹈鹕和它的近亲
水禽
迁徙：雪雁
翠鸟和它的近亲
红鹳
鹭和它的近亲
鹦鹉
蜂鸟
啄木鸟和巨嘴鸟
令人惊叹的巢
栖木鸟
椋鸟
鸟蛋的世界
爬行动物
什么是爬行动物？
爬行动物的诞生
陆龟和海龟
蛇
蜥蜴
变色龙
壁虎、石龙子和其他
鬣蜥、巨蜥及其近亲
鳄和短吻鳄
两栖动物
什么是两栖动物？
蝾螈和水螈
蛙和蟾蜍
海蟾蜍
箭毒蛙
蛙和蟾蜍
鱼类
什么是鱼类？
鲨鱼的世界
大头双髻鲨
鲨鱼杀手？
鳐和
硬骨鱼
鱼群
捕猎
鞍带石斑鱼
深海鱼类
产卵期的鲑鱼
无脊椎动物
什么是无脊椎动物？
海绵
海葵
水母
珊瑚
蠕虫
软体动物
蛞蝓和蜗牛
章鱼和乌贼
贝壳的世界
节肢动物
蜻蜓和豆娘
竹节虫和叶
蝗虫和蟋蟀
螳螂
蜚蠊
蝽
角蝉
甲虫的世界
沙螽
蚂蚁
白蚁
蜜蜂和黄蜂
蝇
蝶和蛾
蛾和蝶
蝎
蜘蛛
蛛丝
甲壳动物
蜘蛛蟹
蜈蚣和马陆
棘皮动物
专业词汇解释
索引
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DK儿童动物百科全书•第2版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏设计、原型与开发
第 I部分游戏设计和纸质原型
第 1章像设计师一样思考  2
1.1  你是一名游戏设计师  2
1.2  Bartok：游戏练习  2
1.3  游戏的定义 7
1.4  小结  12
第 2章游戏分析框架  14
2.1  游戏学的常用框架  14
2.2  MDA：机制、动态和美学 14
2.3  规则、戏剧和动态元素 17
2.4  四元法 19
2.5  小结  21
第 3章分层四元法 22
3.1  内嵌层 22
3.2  动态层 23
3.3  文化层 24
3.4  设计师的责任 25
3.5  小结  25
第 4章内嵌层  27
4.1  机制内嵌  27
4.2  美学内嵌  31
4.3  叙事内嵌  33
4.4  技术内嵌  39
4.5  小结  40
5.1  玩家的角色  41
第 5章动态层  41
5.2  涌现  42
5.3  动态机制 42
5.4  动态美学 46
5.5  动态叙事 50
5.6  涌现叙事 51
5.7  动态技术 51
5.8  小结  52
第 6章文化层 53
6.1  游戏之外 53
6.2  文化机制 54
6.3  美学文化 55
6.4  叙事文化 55
6.5  技术文化 56
6.6  授权的跨媒体不属于文化层  57
6.7  游戏的文化影响 58
6.8  小结  58
第 7章像一名设计师一样工作  59
7.1  迭代设计 59
7.2  创新  65
7.3  头脑风暴与构思 66
7.4  改变你的想法  68
7.5  规划作品的范围大小 70
7.6  小结  71
第 8章设计目标  72
8.1  设计目标：一个不完整的清单 72
8.2  以设计为中心的目标 73
8.3  以玩家为中心的目标 75
8.4  小结  87
第 9章纸面原型  88
9.1  纸面原型的优势 88
9.2  纸面原型工具  89
9.3  一个纸面原型的例子 90
9.4  纸面原型的优点 97
9.5  纸面原型的缺点 98
9.6  小结  99
第 10章游戏测试 100
10.1为什么要测试游戏 100
10.2成为出色的试玩者 101
10.3试玩者圈子 101
10.4测试方法  103
10.5其他重要的测试办法 107
10.6小结 109
第 11章数学和游戏平衡  110
11.1游戏平衡的意义  110
11.2安装 OpenOffice Calc 110
11.3用 Calc检查骰子 111
11.4概率 118
11.5桌游中的乱数产生技术  121
11.6加权分布  123
11.7排列 125
11.8正负反馈  126
11.9使用 Calc调整武器平衡性  127
11.10小结  132
第 12章谜题设计 133
12.1谜题无处不在  133
12.2 Scott Kim与谜题设计  133
12.3动作解谜游戏的几种类型  139
12.4小结 140
第 13章指引玩家 142
13.1直接指引  142
13.2间接指引  144
13.3介绍新技能和新概念 149
13.4小结 151
第 14章数字游戏产业  152
14.1关于游戏产业  152
14.2游戏教育  155
14.3走进行业中去  157
14.4等不及开始做游戏了 160
14.5小结 161
第 II部分数字原型
第 15章数字化系统中的思维  164
15.1棋类游戏中的系统思维  164
15.2简单命令练习 165
15.3游戏分析：《拾苹果》 167
15.4小结  171
第 16章  Unity开发环境简介  172
16.1下载 Unity软件 172
16.2开发环境简介 173
16.3首次运行 Unity软件  176
16.4设置 Unity的窗口布局 181
16.5熟悉 Unity界面 184
16.6小结  185
第 17章 C#编程语言简介 186
17.1理解 C#的特性  186
17.2阅读和理解 C#语法  190
17.3小结  193
第 18章  Hello World：你的首个程序  194
18.1创建新项目  194
18.2新建 C#脚本  196
18.3让事情更有趣 200
18.4小结  208
第 19章变量和组件 209
19.1变量  209
19.2 C#中的强类型变量 209
19.3重要的 C#变量类型  210
19.4变量的作用域 213
19.5命名惯例  213
19.6  Unity中的重要变量类型 215
19.7  Unity游戏对象和组件  220
19.8小结  222
第 20章布尔运算和比较运算符  223
20.1布尔值  223
20.2比较运算符 226
20.3条件语句  229
20.4小结 234
第 21章循环语句 235
21.1循环语句的种类  235
21.2创建项目  235
21.3  while循环  236
21.4死循环的危害  236
21.5更实用的 while循环  237
21.6  do…while循环  238
21.7 for循环  239
21.8 foreach循环  240
21.9循环中的跳转语句 241
21.10  小结  243
第 22章 List和数组 244
22.1 C#中的集合 244
22.2 List  245
22.3数组 249
22.4多维数组  252
22.5交错数组  255
22.6应该使用数组还是 List  259
22.7小结 259
第 23章函数与参数  263
23.1创建函数示例的项目 263
23.2函数的定义 263
23.3函数的形式参数和实际参数 266
23.4函数的返回值  267
23.5使用合适的函数名称 269
23.6什么情况下应该使用函数  269
23.7函数重载  270
23.8可选参数  271
23.9 params关键字  272
23.10  递归函数  273
23.11小结  274
第 24章代码调试  276
24.1如何开始调试 276
24.2绑定或移除脚本时出现的错误  278
24.3使用调试器逐语句运行代码 281
24.4小结  287
第 25章类  289
25.1理解类 289
25.2创建 Enemy类示例的项目 290
25.3类的继承  295
25.4小结  298
第 26章面向对象思维  299
26.1面向对象的比喻  299
26.2面向对象的 Boids实现方法  301
26.3小结  310
第 27章敏捷思维  311
27.1敏捷软件开发宣言  311
27.2 Scrum方法论 312
27.3小结  319
第 III部分游戏原型实例和教程
第 28章游戏原型 1：《拾苹果》 322
28.1数字化原型的目的  322
28.2准备工作  323
28.3开始工作：绘图资源. 323
28.4编写《拾苹果》游戏原型的代码  329
28.5图形用户界面（ GUI）和游戏管理  340
28.6小结  347
第 29章游戏原型 2：《爆破任务》 348
29.1准备工作：原型 2  348
29.2游戏原型概念 348
29.3绘图资源  349
29.4编写游戏原型的代码. 354
29.5小结  380
第 30章游戏原型 3：《太空射击》  382
30.1准备工作：原型 3  382
30.2设置场景  384
30.3创建主角飞船  385
30.4添加敌机  397
30.5随机生成敌机  401
30.6设置标签、图层和物理规则 403
30.7使敌机可以消灭主角飞船  405
30.8重新开始游戏  409
30.9射击 410
30.10  添加升级道具 421
30.11解决代码中的竞态条件 428
30.12  让敌机可以掉落升级道具  430
30.13  为其他敌机编程  432
30.14  添加粒子效果和背景  444
30.15  小结  446
第 31章游戏原型 4：《矿工接龙》  449
31.1准备工作：原型 4  449
31.2项目 Build设置 450
31.3将图片导入为 Sprite  451
31.4用 Sprite制作纸牌  453
31.5《矿工接龙》游戏 469
31.6在代码中实现《矿工接龙》游戏  471
31.7为游戏添加得分机制 489
31.8小结 504
第 32章游戏原型 5：Bartok  505
32.1准备工作：原型 5  505
32.2编译设置  507
32.3 Bartok编程 508
32.4小结 536
第 33章游戏原型 6：Word Game  537
33.1准备工作： Word Game原型  537
33.2关于 Word Game  538
33.3解析 Word List  539
33.4创建游戏  544
33.5屏幕布局  549
33.6添加交互  557
33.7添加计分  561
33.8添加动画  564
33.9添加色彩  567
33.10  小结  569
第 34章游戏原型 7：QuickSnap 571
34.1准备工作： QuickSnap原型  571
34.2构建场景  572
34.3游戏编程  579
34.4小结  598
第 35章游戏原型 8：Omega Mage 600
35.1准备工作： Omega Mage原型 600
35.2构建场景  602
35.3法师角色  607
35.4鼠标交互  609
35.5移动  613
35.6物品栏和选择道具  618
35.7施展火场法术 625
35.8切换房间  634
35.9补充敌人  638
35.10  攻击法师 646
35.11抽象敌人接口  651
35.12  创建 EnemyFactory  653
35.13  小结  657
第 IV部分附录
附录 A 项目创建标准流程  660
A.1  建立新项目  660
A.2  场景编码就绪 662
附录 B 实用概念 665
B.1 C#和 Unity代码概念  665
B.2 数学概念 684
B.3 插值  693
B.4 角色扮演游戏  706
B.5 用户接口概念  707
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏设计、原型与开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
第一章 安全面临的威胁
1.1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从毕业生到程序员
第1章  一毕业就面临的问题	1
1.1  高校毕业生就业途径	1
1.2  计算机专业毕业生的就业问题	3
1.3  求职之路	4
1.3.1  抉择	4
1.3.2  兴趣和志向	4
1.3.3  顺趋势者昌，逆趋势者亡	5
1.4  中国软件行业的特点和趋势	6
1.4.1  盗版	7
1.4.2  嵌入式开发	7
1.4.3  移动开发	8
1.4.4  SAAS及云计算	9
1.5  行业应用软件开发	11
1.6  求职战略方向	12
1.7  求职战术手段	12
1.7.1  接触用人企业	12
1.7.2  求职过程	13
第2章  初入职场	15
2.1  从学生期到职场期的变轨	15
2.1.1  人生的节日	16
2.1.2  团队意识	16
2.2  积累与创新	22
2.3  技术之害	24
2.4  关于薪酬	25
2.5  关于买房	26
2.6  关于自信心	28
2.7  小结	28
第3章  商业软件开发基础	29
3.1  学习型软件开发和商业软件开发	29
3.2  项目软件和产品软件	29
3.2.1  合同软件	30
3.2.2  产品软件	30
3.2.3  自营软件	31
3.3  商业软件开发基本概念	31
3.4  商业软件开发的平衡点	31
3.4.1  软件开发时间	32
3.4.2  软件质量	32
3.4.3  软件功能	33
3.5  过程和质量控制	33
3.6  新旧技术的权衡	34
3.7  商业包装	34
3.8  商业软件开发人员的工作环境	36
3.8.1  对于客户	36
3.8.2  对于市场销售人员	37
3.8.3  对于管理层	37
第4章   开发者眼里的Windows	39
4.1  Windows Service	39
4.2  管理Windows Service	40
4.3  事件查看器	42
4.4  远程桌面	44
4.4.1  配置服务器	44
4.4.2  连接远程桌面	45
4.5  任务管理器	47
4.5.1  管理应用程序	48
4.5.2  管理进程	49
4.5.3  查看系统性能	50
4.5.4  查看网络	50
4.5.5  管理正在登录的用户	51
第5章  C#程序开发	52
5.1  C#语言简介	52
5.2  .NET框架简介	53
5.2.1  托管应用程序	54
5.2.2  微软中间语言规范	55
第6章  C#基本语法	57
6.1  C#应用系统模块逻辑框架	57
6.1.1  应用系统	57
6.1.2  程序集	57
6.1.3  命名空间	58
6.1.4  类型	59
6.1.5  类型成员	60
6.1.6  功能语法块	60
6.2  数据类型	61
6.2.1  基础数据类型	61
6.2.2  数组	63
6.2.3  自定义类型	64
6.3  数据类型转换	72
6.3.1  强制类型转换	72
6.3.2  as类型转换	73
6.3.3  is类型判断	74
6.4  可访问级别	74
6.4.1  private私有的	75
6.4.2  protected受保护的	75
6.4.3  internal内部的	75
6.4.4  public 公开的	76
6.5  类型样式	76
6.5.1  static class 静态类	76
6.5.2  abstract class 抽象类	77
6.5.3  sealed class 密封类	78
6.6  类型成员	79
6.6.1  构造函数	80
6.6.2  字段	80
6.6.3  属性	81
6.6.4  方法	81
6.6.5  事件	82
6.6.6  索引器	82
6.6.7  静态成员	84
6.6.8  实例成员	86
6.6.9  常数成员	87
6.7  面向对象编程	87
6.7.1  类	87
6.7.2  封装	87
6.7.3  继承	88
6.7.4  重载	88
6.7.5  重写	89
6.8  表达式	90
6.8.1  数学表达式	90
6.8.2  逻辑表达式	91
6.8.3  位运算表达式	91
6.9  执行结构	92
6.9.1  顺序执行	92
6.9.2  条件判断	92
6.9.3  循环结构	95
6.9.4  异常处理结构	99
6.10  C#转型建议	103
6.10.1  从VB到C#	103
6.10.2  从C/C++到C#	105
6.10.3  从Java到C#	107
第7章  第一次C#体验	108
7.1  第一次使用VS.NET集成开发环境	108
7.1.1  菜单栏	109
7.1.2  工具条	109
7.1.3  工具箱	109
7.1.4  主工作区	109
7.1.5  解决方案资源管理器	109
7.1.6  属性编辑器	110
7.2  C#程序类型	112
7.2.1  Windows应用程序	113
7.2.2  ASP.NET Web应用程序	113
7.2.3  命令行应用程序	113
7.2.4  其他类型的应用程序	114
第8章  开发第一个Windows应用程序	115
8.1  建立C# Windows应用程序项目	115
8.2  WinForm控件工具箱	116
8.3  WinForm窗体设计器	118
8.4  Windows窗体设计概念及原则	122
8.5  Main函数	130
8.6  解决方案资源管理器	132
8.7  解决方案资源树状列表	132
8.7.1  解决方案	132
8.7.2  程序工程	133
8.7.3  引用	135
8.7.4  程序文件	136
8.7.5  文件夹	137
8.8  解决方案资源管理工具条	139
8.8.1  属性按钮	139
8.8.2  添加新解决方案文件夹按钮	142
8.8.3  显示所有文件按钮	142
8.8.4  刷新按钮	143
8.9  控件属性编辑区域	144
8.9.1  控件名称下拉列表	144
8.9.2  属性列表工具条	145
8.9.3  属性项目列表	147
8.10  设计用户界面	150
8.11  用户界面事件处理原理	154
8.11.1  鼠标事件	155
8.11.2  键盘事件	156
8.12  编写事件处理代码	156
8.12.1  读写系统配置	159
8.13  调试	161
8.13.1  执行代码	161
8.13.2  查看和修改变量值	163
8.13.3  命令窗口	165
8.14  测试和运行Windows应用程序	165
8.15  小结	166
第9章  开发第一个ASP.NET应用程序	167
9.1  ASP.NET概念	167
9.1.1  B/S架构	167
9.1.2  HTTP传输协议	169
9.1.3  HTML文档规范	173
9.1.4  ASP.NET服务器端架构	174
9.1.5  ASP.NET Web服务器控件技术	178
9.1.6  ASP.NET客户端开发架构	182
9.2  建立C# ASP.NET应用程序项目	183
9.3  ASP.NET页面设计器	186
9.3.1  ASP.NET页面工具箱	186
9.3.2  Web页面内容编辑器	187
9.4  ASP.NET控件工具箱	188
9.5  设计用户界面	189
9.6  编写后台代码	189
9.6.1  输出JavaScript	192
9.7  测试和运行ASP.NET应用程序	196
9.8  部署ASP.NET应用程序	196
9.8.1  准备运行环境	197
9.8.2  准备应用程序目录	197
9.8.3  创建虚拟目录	197
9.8.4  配置虚拟目录	201
9.9  其他部署相关技术手段	204
9.9.1  Aspnet_regiis.exe	204
9.9.2  IISReset.exe	204
9.9.3  配置ASP.NET账号权限	204
第10章  开发第一个Web Service程序	207
10.1  Web Service原理	207
10.2  软件功能需求	208
10.3  建立C# Web Service应用程序项目	208
10.4  编写Web方法	210
10.5  发布Web Service	216
10.6  使用Web Service	216
10.7  在Windows应用程序中使用Web Service	216
10.7.1  添加Web引用	216
10.7.2  使用Web Service	217
10.8  在ASP.NET应用程序中使用Web Service	222
10.9  Web Service原理	225
第11章  开发第一个ADO.NET数据库应用程序	228
11.1  ADO.NET数据库访问概述	228
11.2  建立C#应用程序项目	229
11.2.1  快速读取数据	229
11.2.2  数据源绑定	233
11.2.3  修改数据	236
11.3  类型使用参考说明	253
11.3.1  System.Data.IDbConnection接口类型	253
11.3.2  System.Data.IDbCommand接口类型	253
11.3.3  System.Data.IDataReader接口类型	254
11.3.4  System.Data.IDataParameter接口类型	255
11.3.5  System.Data.DataTable类型	256
11.3.6  System.Data.DataColumn类型	257
11.3.7  System.Data.DataRow类型	258
第12章  开发第一个JavaScript应用程序	259
12.1  JavaScript基本概念	259
12.2  HTML DOM	261
12.3  JavaScript语法	263
12.3.1  数据类型	263
12.3.2  运算符	264
12.3.3  条件判断语法结构	266
12.3.4  循环语法结构	267
12.3.5  异常处理语法结构	268
12.3.6  其他语法结构	270
12.4  系统预定义对象	271
12.4.1  系统实例对象	272
12.4.2  系统全局对象	274
12.5  JavaScript代码文件	282
12.5.1  文本编码格式	283
12.6  JavaScript调试	285
12.6.1  设置IE	285
12.6.2  插入断点	285
12.6.3  调试	287
12.7  JavaScript应用实例	288
12.7.1  走马灯	288
12.7.2  网页对话框	289
12.7.3  日历对话框	293
12.7.4  数据验证	294
12.8  浏览器兼容性	301
12.9  小结	302
第13章  开发第一个XML应用程序	303
13.1  XML应用框架	303
13.2  XML的发展历史	304
13.3  XML基础知识介绍	305
13.3.1  XML基本语法知识	305
13.3.2  W3C国际标准组织	307
13.3.3  国际标准的意义	307
13.4  微软.NET框架对XML的支持	308
13.4.1  流式处理模型	308
13.4.2  DOM处理模型	308
13.5  输出XML文档	310
13.5.1  PageUseXmlTextWriter.aspx	311
13.5.2  PageUseXmlDocument.aspx	316
13.6  类型使用参考说明	318
13.6.1  System.Xml.XmlTextWriter类型	318
13.6.2  System.Xml.XmlDocument类型	319
13.6.3  System.Xml.XmlElement类型	320
13.7  小结	321
第14章  开发第一个文件系统操作应用程序	322
14.1  文件系统操作概述	322
14.1.1  文件和目录	322
14.1.2  文件路径	322
14.1.3  文本文件和二进制文件	323
14.1.4  .NET的文件系统开发	323
14.2  建立C#应用程序项目	323
14.2.1  设计主窗体	323
14.2.2  浏览目录	325
14.2.3  浏览文件	329
14.2.4  查看、编辑文本内容	331
14.2.5  查看图片内容	339
14.2.6  访问文件内容	342
第15章  关系型数据库开发基础	344
15.1  主流数据库介绍	344
15.1.1  MS Access	344
15.1.2  MS SQL Server	353
15.2  SQL语言	372
15.2.1  查询数据	373
15.2.2  新增数据	377
15.2.3  修改数据	378
15.2.4  删除数据	378
15.2.5  视图	379
15.2.6  存储过程	380
15.2.7  触发器	381
第16章  商业软件开发规范	382
16.1  C#代码书写规范	382
16.1.1  代码缩进	382
16.1.2  空行	383
16.1.3  换行	383
16.1.4  空格	385
16.1.5  定义类型	385
16.1.6  大小写	387
16.1.7  名称	388
16.1.8  名称空间	390
16.1.9  语句	391
16.1.10  注释	391
16.1.11  代码文件目录结构	392
16.2  C#软件开发原则	392
16.2.1  尽晚创建，尽早释放	392
16.2.2  单入口，单出口	394
16.2.3  最小权限原则	395
16.2.4  尽早暴露错误原则	397
第17章  面向对象软件开发方法	401
17.1  发现问题	401
17.2  分析问题	401
17.3  解决问题	402
17.3.1  任务分解	402
17.3.2  过程控制	403
17.3.3  知识重用	403
17.3.4  代码重用	405
17.4  面向对象开发	406
17.4.1  封装	406
17.4.2  继承	407
第18章  团队开发管理	408
18.1  项目管理	408
18.1.1  项目启动	409
18.1.2  需求开发	409
18.1.3  项目计划	410
18.1.4  系统设计	410
18.1.5  开发实施	412
18.1.6  系统测试	412
18.1.7  发布部署	413
18.1.8  试用验收	413
18.1.9  项目结项	413
18.1.10  项目移交	414
18.1.11  项目管理	415
18.1.12  QA	415
18.1.13  CM	415
18.2  源代码管理	416
18.2.1  源代码管理的原理	416
18.2.2  VSS源代码管理软件	419
18.2.3  使用VSS客户端软件	419
18.2.4  在VS.NET中使用VSS	435
附录A  关于企业培训	442
附录B  关于盗版	445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从毕业生到程序员
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#科学计算讲义
引言
第1章 C#程序设计基础
1.1 计算机、程序设计与算法
1.1.1 计算机结构
1.1.2 操作系统
1.1.3 机器语言与高级语言
1.1.4 程序设计与算法
1.2 C#历史与概述
1.2.1 C语言：结构化编程语言的高峰
1.2.2 C++语言: 面向对象与大型程序
1.2.3 Java语言：可移植、安全性与Internet
1.2.4 C#:.NET主打语言
1.3 集成开发环境介绍
1.4 面向对象程序设计
1.4.1 封装
1.4.2 多态
1.4.3 继承
1.5 数据类型与运算符
1.5.1 简单数据类型
1.5.2 数组
1.5.3 运算符
1.5.4 赋值运算符
1.6 程序控制结构
1.6.1 顺序结构
1.6.2 分支结构
1.6.3 循环结构
1.6.4 控制结构的嵌套
1.7 类的设计及对象实现
1.7.1 定义类
1.7.2 创建对象
1.7.3 方法
1.7.4 构造函数
1.7.5 析构函数与垃圾回收
1.8 运算符重载及索引器
1.8.1 运算符重载
1.8.2 索引器
1.8.3 面向对象思想在C#程序设计中的重要性
1.9 GUI编程
1.10 本章小结
第2章 线性方程组迭代解法
2.1 Jacobi 迭代法
2.1.1 基本原理
2.1.2 实验内容与数据
2.1.3 程序源代码
2.1.4 实验结论
2.2 Gauss-Seidel迭代法
2.2.1 基本原理
2.2.2 实验内容与数据
2.2.3 程序源代码
2.2.4 实验结论
2.3 逐次超松弛迭代法
2.3.1 基本原理
2.3.2 实验内容与数据
2.3.3 程序源代码
2.3.4 实验结论
2.4 Richardson迭代法
2.4.1 基本原理
2.4.2 实验内容与数据
2.4.3 程序源代码
2.4.4 实验结论
2.5 广义Richardson迭代法
2.5.1 基本原理
2.5.2 实验内容与数据
2.5.3 程序源代码
2.5.4 实验结论
2.6 Jacobi超松弛迭代法
2.6.1 基本原理
2.6.2 实验内容与数据
2.6.3 程序源代码
2.6.4 实验结论
2.7 最速下降法
2.7.1 基本原理
2.7.2 实验内容与数据
2.7.3 程序源代码
2.7.4 实验结论
2.8 共轭梯度法
2.8.1 基本原理
2.8.2 实验内容与数据
2.8.3 程序源代码
2.8.4 实验结论
2.9 本章小结
第3章 线性方程组的直接解法
3.1 三角方程组
3.1.1 基本原理
3.1.2 实验内容与数据
3.1.3 程序代码
3.1.4 实验结论
3.2 高斯消去法
3.2.1 基本原理
3.2.2 实验内容与数据
3.2.3 程序源代码
3.2.4 实验结论
3.3 选主元消去法
3.3.1 基本原理
3.3.2 实验内容与数据
3.3.3 程序源代码
3.3.4 实验结论
3.4 Crout分解
3.4.1 基本原理
3.4.2 实验内容与数据
3.4.3 程序源代码
3.4.4 实验结论
3.5 Doolittle分解
3.5.1 基本原理
3.5.2 实验内容与数据
3.5.3 程序源代码
3.5.4 实验结论
3.6 追赶法计算三对角方程
3.6.1 基本原理
3.6.2 实验内容与数据
3.6.3 程序源代码
3.6.4 实验结论
3.7 行列式的计算
3.7.1 基本原理
3.7.2 实验内容与数据
3.7.3 程序源代码
3.7.4 实验结论
3.8 本章小结
第4章 正交变换与最小二乘计算方法
4.1 对称正定阵的Cholesky分解
4.1.1 基本原理
4.1.2 实验内容与数据
4.1.3 程序源代码
4.1.4 实验结论
4.2 不开平方的Cholesky分解
4.2.1 基本原理
4.2.2 实验内容与数据
4.2.3 程序源代码
4.2.4 实验结论
4.3 QR分解之Householder镜像变换方法
4.3.1 基本原理
4.3.2 实验内容与数据
4.3.3 程序源代码
4.3.4 实验结论
4.4 修正的Gram-Schimdt正交化方法
4.4.1 基本原理
4.4.2 实验内容与数据
4.4.3 程序源代码
4.4.4 实验结论
4.5 求解法方程计算最小二乘问题
4.5.1 基本原理
4.5.2 实验内容与数据
4.5.3 程序源代码
4.5.4 实验结论
4.6 QR分解法计算最小二乘问题
4.6.1 基本原理
4.6.2 实验内容与数据
4.6.3 程序源代码
4.6.4 实验结论
4.7 加权最小二乘与Gauss-Markov估计
4.7.1 基本原理
4.7.2 实验内容与数据
4.7.3 程序源代码
4.7.4 实验结论
4.8 具有先验信息的贝叶斯估计
4.8.1 基本原理
4.8.2 实验内容与数据
4.8.3 程序源代码
4.8.4 实验结论
4.9 工程应用中最小二乘法的实用方法
4.10 本章小结
第5章 鲁棒估计
5.1 M估计的IGGI方案
5.1.1 基本原理
5.1.2 实验内容与数据
5.1.3 程序源代码
5.1.4 实验结论
5.2 Hampel函数作标准等价权
5.2.1 基本原理
5.2.2 实验内容与数据
5.2.3 程序源代码
5.2.4 实验结论
5.3 Huber估计
5.3.1 基本原理
5.3.2 实验内容与数据
5.3.3 程序源代码
5.3.4 实验结论
5.4 本章小结
第6章 随机数
6.1 乘同余法均匀分布随机数发生器
6.1.1 基本原理
6.1.2 实验内容与数据
6.1.3 程序源代码
6.1.4 实验结论
6.2 混合同余法均匀分布随机数发生器
6.2.1 基本原理
6.2.2 实验内容与数据
6.2.3 程序源代码
6.2.4 实验结论
6.3 正态分布随机数
6.3.1 基本原理
6.3.2 实验内容与数据
6.3.3 程序源代码
6.3.4 实验结论
6.4 蒙特卡罗方法介绍
6.4.1 基本原理
6.4.2 实验内容与数据
6.4.3 程序源代码
6.4.4 实验结论
6.5 本章小结
第7章 插值法
7.1 拉格朗日插值
7.1.1 基本原理
7.1.2 实验内容与数据
7.1.3 程序源代码
7.1.4 实验结论
7.2 牛顿插值法
7.2.1 基本原理
7.2.2 实验内容与数据
7.2.3 程序源代码
7.2.4 实验结论
7.3 Hermite插值法
7.3.1 基本原理
7.3.2 实验内容与数据
7.3.3 程序源代码
7.3.4 实验结论
7.4 本章小结
第8章 非线性方程数值解法
8.1 Picard迭代法
8.1.1 基本原理
8.1.2 实验内容与数据
8.1.3 程序源代码
8.1.4 实验结论
8.2 牛顿迭代法
8.2.1 基本原理
8.2.2 实验内容与数据
8.2.3 程序源代码
8.2.4 实验结论
8.3 割线法
8.3.1 基本原理
8.3.2 实验内容与数据
8.3.3 程序源代码
8.3.4 实验结论
8.4 重根时的迭代改进
8.4.1 基本原理
8.4.2 实验内容与数据
8.4.3 程序源代码
8.4.4 实验结论
8.5 应用范例：债券到期收益率的计算
8.5.1 基本原理
8.5.2 实验内容与数据
8.5.3 程序源代码
8.5.4 实验结论
8.6 本章小结
第9章 非线性最优化
9.1 一维搜索之黄金分割法
9.1.1 基本原理
9.1.2 实验内容与数据
9.1.3 程序源代码
9.1.4 实验结论
9.2 连续抛物线插值法
9.2.1 基本原理
9.2.2 实验内容与数据
9.2.3 程序源代码
9.2.4 实验结论
9.3 多维非线性最优化牛顿下山法
9.3.1 基本原理
9.3.2 实验内容与数据
9.3.3 程序源代码
9.3.4 实验结论
9.4 最速下降法
9.4.1 基本原理
9.4.2 实验内容与数据
9.4.3 程序源代码
9.4.4 实验结论
9.5 变尺度之DFP方法
9.5.1 基本原理
9.5.2 实验内容与数据
9.5.3 程序源代码
9.5.4 实验结论
9.6 拟牛顿之BFGS方法
9.6.1 基本原理
9.6.2 实验内容与数据
9.6.3 程序源代码
9.6.4 实验结论
9.7 本章小结
第10章 常微分方程(组)的数值方法
10.1 经典Rung-Kutta方法
10.1.1 基本原理
10.1.2 实验内容与数据
10.1.3 程序源代码
10.1.4 实验结论
10.2 Gill方法
10.2.1 基本原理
10.2.2 实验内容与数据
10.2.3 程序源代码
10.2.4 实验结论
10.3 Rung-Kutta方法计算微分方程组
10.3.1 基本原理
10.3.2 实验内容与数据
10.3.3 程序源代码
10.3.4 实验结论
10.4 Adams-Bashforth三步三阶方法
10.4.1 基本原理
10.4.2 实验内容与数据
10.4.3 程序源代码
10.4.4 实验结论
10.5 Adams-Bashforth四步四阶方法
10.5.1 基本原理
10.5.2 实验内容与数据
10.5.3 程序源代码
10.5.4 实验结论
10.6 三阶Adams预测校正方法(PECE)
10.6.1 基本原理
10.6.2 实验内容与数据
10.6.3 程序源代码
10.6.4 实验结论
10.7 四阶Adams预测校正方法(PECE)
10.7.1 基本原理
10.7.2 实验内容与数据
10.7.3 程序源代码
10.7.4 实验结论
10.8 辛结构与哈密顿系统的辛算法介绍
10.8.1 基本原理
10.8.2 实验内容与数据
10.8.3 程序源代码
10.8.4 实验结论
10.9 本章小结
附录A C# 数值代数类的抽象与设计
附录B 动态链接库与混合编程
B.1 静态链接库与动态链接库
B.2 C#调用Fortran动态链接库范例
B.3 调用可执行函数
附录C Linux下C#开发与跨平台编程介绍
C.1 Mono简介
C.2 Linux下C#IDE开发范例
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#科学计算讲义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻松学C语言
基  础  篇
第1章  第一个C语言程序	2
1.1  C语言开发概述	2
1.1.1  C语言的发展	2
1.1.2  C语言的特点	3
1.2  构建开发环境	3
1.2.1  Visual C++ 6.0的软硬件需求	3
1.2.2  安装Visual C++ 6.0	4
1.3  第一个C语言程序	5
1.3.1  C程序的结构	6
1.3.2  编写源程序	6
1.3.3  编译调试程序	7
1.3.4  运行程序	8
1.3.5  查看源文件	8
1.4  小结	8
1.5  习题	8
语  法  篇
第2章  数据的表示	12
2.1  数	12
2.1.1  十进制	12
2.1.2  二进制	13
2.1.3  八进制	15
2.1.4  十六进制	16
2.2  数据的描述	18
2.2.1  C的构词方式——标识符	18
2.2.2  特殊的标识符	19
2.2.3  整数类型	20
2.2.4  浮点类型	21
2.2.5  字符类型	22
2.3  变量	23
2.3.1  变量的声明和定义	23
2.3.2  不变的变量——常量	25
2.4  小结	27
2.5  习题	27
第3章  程序的基本单位——语句	31
3.1  语句的构成	31
3.2  运算符	32
3.2.1  赋值运算	32
3.2.2  数据类型的转换	35
3.3  常用的其他运算符	37
3.3.1  位运算符	37
3.3.2  算术运算符	39
3.3.3  自增、自减运算符	40
3.3.4  逗号运算符	41
3.3.5  复合赋值运算符	41
3.3.6  sizeof运算符	43
3.3.7  分隔符	43
3.3.8  运算符的优先级	44
3.4  语句块	45
3.4.1  语句块的构成	45
3.4.2  作用域	45
3.5  小结	46
3.6  习题	47
第4章  程序控制结构	51
4.1  语句块的执行方式—— 顺序结构	51
4.2  条件的表达	52
4.2.1  单一条件的表达—— 关系运算符	52
4.2.2  多条件的表达—— 逻辑运算符	53
4.3  选择结构	54
4.3.1  最简单的选择—— 条件运算符	54
4.3.2  if语句单分支形式	55
4.3.3  if else语句双分支形式	56
4.3.4  else if形式语句	57
4.3.5  嵌套if形式语句	58
4.3.6  switch语句	60
4.3.7  选择结构典型实例—— 两数计算器	63
4.4  循环结构	64
4.4.1  for语句	65
4.4.2  while语句	66
4.4.3  do while语句	66
4.4.4  循环语句的区别	67
4.5  意外情况的表达—— 转向语句	68
4.5.1  continue语句	68
4.5.2  break语句	68
4.5.3  goto语句	69
4.6  小结	70
4.7  习题	70
第5章  数组	73
5.1  数组简介	73
5.2  数组的来源	73
5.3  一维数组	74
5.3.1  一维数组的声明和定义	74
5.3.2  一维数组的初始化	74
5.3.3  一维数组的引用	75
5.3.4  一维数组程序举例	76
5.4  二维数组	76
5.4.1  二维数组的声明和定义	77
5.4.2  二维数组的初始化	77
5.4.3  二维数组的引用	77
5.4.4  二维数组程序举例	78
5.5  字符数组	79
5.5.1  字符数组的声明和定义	79
5.5.2  字符数组的初始化	79
5.5.3  字符数组的引用	80
5.5.4  字符数组的输入/输出	81
5.6  综合实例—— 杨辉三角	82
5.7  小结	84
5.8  习题	84
第6章  函数	91
6.1  函数概述	91
6.2  函数的声明与定义	92
6.2.1  无参函数的声明和定义的一般形式	92
6.2.2  有参函数的声明和定义的一般形式	93
6.2.3  空函数	94
6.3  函数的形式参数和函数的返回值	94
6.3.1  形式参数	94
6.3.2  函数的返回值	94
6.4  函数调用	95
6.4.1  函数调用的方式	96
6.4.2  函数的参数传递	97
6.5  函数的嵌套和递归	97
6.5.1  函数的嵌套	98
6.5.2  函数的递归	98
6.6  数组作为函数参数	100
6.6.1  数组元素作函数实参	100
6.6.2  数组名作函数实参	100
6.7  字符数组相关的输入/输出函数	101
6.7.1  逐个字符的输入和输出	101
6.7.2  字符串的输入和输出	103
6.8  函数应用举例——猴子吃桃问题	103
6.9  小结	105
6.10  习题	105
第7章  指针	111
7.1  地址和指针的概念	111
7.2  变量的指针和指向变量的指针变量	112
7.2.1  变量的指针与指针变量	112
7.2.2  指针变量的赋值与引用	112
7.2.3  指针变量作为函数的参数	113
7.3  指针与数组	114
7.3.1  指向数组元素的指针	114
7.3.2  通过指针引用数组元素	114
7.3.3  数组名作为函数参数	115
7.4  指针与字符串	117
7.5  函数指针与指针函数	118
7.5.1  用函数指针调用函数	118
7.5.2  使用函数指针作函数参数	119
7.5.3  指针函数——返回指针的函数	120
7.6  指针数组与二级指针	121
7.6.1  指针数组	121
7.6.2  二级指针——指向指针的指针	122
7.6.3  指针数组作为main()函数的参数	123
7.7  有关指针的数据类型和指针运算	125
7.7.1  有关指针的数据类型	125
7.7.2  指针运算	126
7.7.3  void指针类型	126
7.8  小结	126
7.9  习题	126
第8章  结构体与共用体	131
8.1  结构体的概念及结构体类型的定义	131
8.1.1  为什么使用结构体	131
8.1.2  定义结构体类型	132
8.2  结构体变量	133
8.2.1  结构体变量的定义	133
8.2.2  结构体变量的引用	133
8.2.3  结构体变量的初始化	134
8.2.4  结构体变量作为函数参数	135
8.3  结构体数组	136
8.3.1  结构体数组的定义	137
8.3.2  结构体数组的引用以及初始化	137
8.3.3  结构体数组作为函数的参数	139
8.4  结构体指针	140
8.4.1  指向结构体变量的指针	140
8.4.2  指向结构体数组的指针	141
8.4.3  指向结构体的指针作函数参数	142
8.5  位域	143
8.5.1  定义位域结构	143
8.5.2  位域的声明	144
8.5.3  位域的使用	144
8.6  共用体	145
8.6.1  共用体的概念	145
8.6.2  共用体变量的定义及引用	147
8.6.3  共用体与结构体的嵌套	149
8.7  枚举类型	149
8.7.1  枚举类型及其变量的定义	149
8.7.2  枚举类型应用举例	151
8.8  typedef自定义类型	151
8.9  小结	153
8.10  习题	153
第9章  编译预处理	157
9.1  宏定义	157
9.1.1  不带参数的宏定义	158
9.1.2  带参数的宏定义	159
9.1.3  宏的取消	160
9.1.4  标准宏对象	161
9.2 “文件包含”处理	161
9.3  条件编译	163
9.3.1  #ifdef命令	163
9.3.2  #ifndef	163
9.3.3  #if命令	164
9.4  小结	165
9.5  习题	165
应  用  篇
第10章  文件和目录操作运算	170
10.1  C文件概述	170
10.2  文件的处理形式	171
10.3  文件型指针	172
10.4  文件打开与关闭	173
10.4.1  打开文件—— fopen()函数	173
10.4.2  打开文件是否成功	174
10.4.3  关闭文件—— fclose()函数	174
10.5  文件读写函数	174
10.5.1  字符读写函数—— fputc()函数和fgetc()函数	175
10.5.2  块读写函数—— fread函数和fwrite函数	177
10.5.3  格式化文件输入输出—— fprintf函数和fscanf函数	178
10.6  文件的定位	179
10.6.1  是否到文件末尾—— feof()函数	179
10.6.2  移到开头—— rewind函数	179
10.6.3  fseek()函数和ftell()函数	180
10.7  出错检测	181
10.7.1  ferror()函数	181
10.7.2  clearerr()函数	181
10.8  目录基本操作	182
10.9  文件存储路径操作	183
10.10  保存文件信息的结构	184
10.11  文件管理	184
10.11.1  文件重命名	184
10.11.2  删除文件	185
10.11.3  使用临时文件	186
10.12  小结	187
10.13  习题	188
第11章  数值处理运算	193
11.1  绝对值运算	193
11.2  指数与对数运算	194
11.3  三角形运算函数	194
11.3.1  正余弦与反正余弦函数	194
11.3.2  正切与反正切函数	195
11.3.3  直角三角形斜边运算	196
11.4  比较运算	197
11.5  双精度分解运算	197
11.6  随机数运算	198
11.7  小结	199
11.8  习题	199
第12章  字符串处理运算	203
12.1  字符串的输入	203
12.1.1  逐个字符输入	203
12.1.2  整个字符串输入	203
12.2  将其他数据类型转换成字符串的运算	204
12.3  字符串的操作	206
12.3.1  字符串的复制	206
12.3.2  字符串的比较	207
12.3.3  字符串大小写转换	209
12.3.4  字符串的字符个数相关运算	209
12.4  字符串的输出	211
12.4.1  逐个字符的输出	211
12.4.2  整个字符串的输出	211
12.4.3  字符串输入输出小结	212
12.5  小结	212
12.6  习题	212
第13章  动态内存管理及变量的存储类别	217
13.1  动态内存管理的来源	217
13.2  动态内存管理	218
13.2.1  动态存储区域分配空间	219
13.2.2  释放动态分配的存储空间	220
13.2.3  重新分配内存空间	221
13.2.4  sizeof—— 判断数据类型长度符	222
13.3  变量的存储类别	223
13.3.1  静态存储方式与动态存储方式	223
13.3.2  static—— 声明静态局部变量	224
13.3.3  自动变量	225
13.3.4  register—— 寄存器变量	226
13.3.5  extern声明外部变量	227
13.3.6  static的使用	229
13.4  小结	229
13.5  习题	230
第14章  简单数据结构	234
14.1  线性表	234
14.1.1  线性表的基本概念	234
14.1.2  线性表的基本操作	235
14.1.3  线性表的顺序存储结构	236
14.1.4  顺序表的基本操作	237
14.1.5  顺序表的插入	238
14.1.6  顺序表的查找	240
14.1.7  顺序表的删除	241
14.1.8  顺序表操作的算法典型案例	242
14.1.9  线性表的链式存储结构	242
14.1.10  单链表的基本操作	243
14.1.11  单链表的插入结点运算	245
14.1.12  单链表的删除结点运算	247
14.1.13  单链表的查找结点运算	248
14.2  栈	249
14.2.1  栈的定义和基本运算	249
14.2.2  栈的顺序存储	250
14.2.3  栈的链式存储	254
14.3  队列	256
14.3.1  队列的定义和基本运算	257
14.3.2  非循环队列的顺序存储	257
14.3.3  循环队列的顺序存储	260
14.3.4  队列的链式存储	262
14.4  小结	264
14.5  习题	265
第15章  排序	269
15.1  冒泡排序	269
15.1.1  冒泡排序算法描述	269
15.1.2  冒泡排序算法实现	270
15.1.3  冒泡排序算法实例	270
15.2  快速排序	271
15.2.1  快速排序算法描述	271
15.2.2  快速排序算法实现	272
15.2.3  快速排序算法实例	273
15.3  简单选择排序	273
15.3.1  简单选择排序算法描述	273
15.3.2  选择排序算法实现	274
15.3.3  选择排序算法实例	274
15.4  堆排序	275
15.4.1  堆排序算法描述	275
15.4.2  堆排序算法实现	277
15.4.3  堆排序算法实例	277
15.5  直接插入排序	278
15.5.1  直接插入排序算法描述	278
15.5.2  直接插入排序算法实现	278
15.5.3  直接插入排序算法示例	278
15.6  希尔排序	278
15.6.1  希尔（Shell）排序算法描述	278
15.6.2  希尔排序算法实现	281
15.6.3  希尔排序算法实例	281
15.7  合并排序	282
15.7.1  合并排序算法描述	282
15.7.2  合并排序算法实现	283
15.7.3  合并排序算法实例	284
15.8  基数排序	284
15.8.1  基数排序的算法描述	284
15.8.2  基数排序算法实现	286
15.9  小结	286
15.10  习题	286
第16章  经典例题分析	292
16.1  八皇后问题	292
16.1.1  八皇后的问题分析	292
16.1.2  八皇后的算法设计	293
16.2  汉洛塔问题	294
16.2.1  汉洛塔问题分析	294
16.2.2  汉洛塔的算法设计	295
16.3  猴子选大王	296
16.3.1  猴子选大王问题分析	296
16.3.2  猴子选大王的算法设计	297
16.4  三个数的最小公倍数	298
16.4.1  三个数的最小公倍数的问题分析	298
16.4.2  三个数的最小公倍数的算法设计	299
16.5  背包问题	300
16.5.1  背包问题分析	300
16.5.2  背包问题的算法设计	301
16.6  循环赛问题	302
16.6.1  循环赛问题分析图	302
16.6.2  循环赛问题的算法设计	303
16.7  马遍历问题	304
16.7.1  马遍历问题分析图	304
16.7.2  马遍历算法设计	305
16.8  魔术方阵	307
16.8.1  魔术方阵的分析图	307
16.8.2  魔术方阵的算法设计	307
16.9  三色旗	309
16.9.1  三色旗的分析图	309
16.9.2  三色旗的算法设计	309
16.10  迷宫问题	312
16.10.1  迷宫的问题分析图	312
16.10.2  迷宫的算法实现	312
16.11  小结	315
16.12  习题	315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻松学C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与分布式系统
出版者的话
中文版序
序
前言
第一部分系统建模、集群化和虚拟化
第1章分布式系统模型和关键技术
1.1互联网之上的可扩展计算
1.1.1互联网计算的时代
1.1.2可扩展性计算趋势和新的范式
1.1.3物联网和CPS
1.2基于网络的系统技术
1.2.1多核CPU和多线程技术
1.2.2大规模和超大规模GPU计算
1.2.3内存、外部存储和广域网
1.2.4虚拟机和虚拟化中间件
1.2.5云计算的数据中心虚拟化
1.3分布式和云计算系统模型
1.3.1协同计算机集群
1.3.2网格计算的基础设施
1.3.3对等网络家族
1.3.4互联网上的云计算
1.4分布式系统和云计算软件环境
1.4.1面向服务的体系结构（SOA）
1.4.2分布式操作系统趋势
1.4.3并行和分布式编程模型
1.5性能、安全和节能
1.5.1性能度量和可扩展性分析
1.5.2容错和系统可用性
1.5.3网络威胁与数据完整性
1.5.4分布式计算中的节能
1.6参考文献和习题
第2章可扩展并行计算集群
2.1大规模并行集群
2.1.1集群发展趋势
2.1.2计算机集群的设计宗旨
2.1.3基础集群设计问题
2.1.4Top500超级计算机分析
2.2计算机集群和MPP体系结构
2.2.1集群组织和资源共享
2.2.2节点结构和MPP封装
2.2.3集群系统互连
2.2.4硬件、软件和中间件支持
2.2.5大规模并行GPU集群
2.3计算机集群的设计原则
2.3.1单系统镜像特征
2.3.2冗余高可用性
2.3.3容错集群配置
2.3.4检查点和恢复技术
2.4集群作业和资源管理
2.4.1集群作业调度方法
2.4.2集群作业管理系统
2.4.3集群计算的负载共享设备(LSF)
2.4.4MOSIX: Linux集群和云的操作系统
2.5顶尖超级计算机系统的个案研究
2.5.1Tianhe1A：2010年的世界最快超级计算机
2.5.2Gray XT5 Jaguar：2009年的领先超级计算机
2.5.3IBM Roadrunner：2008年的领先超级计算机
2.6参考文献和习题
第3章虚拟机和集群与数据中心虚拟化
3.1虚拟化的实现层次
3.1.1虚拟化实现的层次
3.1.2VMM的设计需求和提供商
3.1.3操作系统级的虚拟化支持
3.1.4虚拟化的中间件支持
3.2虚拟化的结构/工具与机制
3.2.1hypervisor与Xen体系结构
3.2.2全虚拟化的二进制翻译
3.2.3编译器支持的半虚拟化技术
3.3CPU、内存和I/O设备的虚拟化
3.3.1虚拟化的硬件支持
3.3.2CPU虚拟化
3.3.3内存虚拟化
3.3.4I/O虚拟化
3.3.5多核处理器的虚拟化
3.4虚拟集群和资源管理
3.4.1物理集群与虚拟集群
3.4.2在线迁移虚拟机的步骤与性能影响
3.4.3内存、文件与网络资源的迁移
3.4.4虚拟集群的动态部署
3.5数据中心的自动化与虚拟化
3.5.1数据中心服务器合并
3.5.2虚拟存储管理
3.5.3虚拟化数据中心的云操作系统
3.5.4虚拟化数据中心的可信管理
3.6参考文献与习题
第二部分云平台、面向服务的体系结构和云编程
第4章构建在虚拟化数据中心上的云平台体系结构
4.1云计算和服务模型
4.1.1公有云、私有云和混合云
4.1.2云生态系统和关键技术
4.1.3基础设施即服务(IaaS)
4.1.4平台即服务 (PaaS) 和软件即服务(SaaS)
4.2数据中心设计与互连网络
4.2.1仓库规模的数据中心设计
4.2.2数据中心互连网络
4.2.3运送集装器的模块化数据中心
4.2.4模块化数据中心的互连
4.2.5数据中心管理问题
4.3计算与存储云的体系结构设计
4.3.1通用的云体系结构设计
4.3.2层次化的云体系结构开发
4.3.3虚拟化支持和灾难恢复
4.3.4体系结构设计挑战
4.4公有云平台：GAE、AWS和Azure
4.4.1公有云及其服务选项
4.4.2谷歌应用引擎（GAE）
4.4.3亚马逊的Web服务（AWS）
4.4.4微软的Windows Azure
4.5云间的资源管理
4.5.1扩展的云计算服务
4.5.2资源配置和平台部署
4.5.3虚拟机创建和管理
4.5.4云资源的全球交易
4.6云安全与信任管理
4.6.1云安全的防御策略
4.6.2分布式入侵/异常检测
4.6.3数据和软件保护技术
4.6.4数据中心的信誉指导保护
4.7参考文献与习题
第5章面向服务的分布式体系结构
5.1服务和面向服务的体系结构
5.1.1REST和系统的系统
5.1.2服务和Web服务
5.1.3企业多层体系结构
5.1.4网格服务和OGSA
5.1.5其他的面向服务的体系结构和系统
5.2面向消息的中间件
5.2.1企业总线
5.2.2发布-订阅模型和通知
5.2.3队列和消息传递系统
5.2.4云或网格中间件应用
5.3门户和科学网关
5.3.1科学网关样例
5.3.2科学协作的HUBzero平台
5.3.3开放网关计算环境（OGCE）
5.4发现、注册表、元数据和数据库
5.4.1UDDI和服务注册表
5.4.2数据库和订阅-发布
5.4.3元数据目录
5.4.4语义Web和网格
5.4.5作业执行环境和监控
5.5面向服务的体系结构中的工作流
5.5.1工作流的基本概念
5.5.2工作流标准
5.5.3工作流体系结构和规范
5.5.4工作流运行引擎
5.5.5脚本工作流系统Swift
5.6参考文献与习题
第6章云编程和软件环境
6.1云和网格平台的特性
6.1.1云的功能和平台的特性
6.1.2网格和云的公共传统特性
6.1.3数据特性和数据库
6.1.4编程和运行时支持
6.2并行和分布式编程范式
6.2.1并行计算和编程范式
6.2.2MapReduce、Twister和迭代MapReduce
6.2.3来自Apache的Hadoop软件库
6.2.4微软的Dryad和DryadLINQ
6.2.5Sawzall和Pig Latin高级语言
6.2.6并行和分布式系统的映射应用
6.3GAE的编程支持
6.3.1GAE编程
6.3.2谷歌文件系统（GFS）
6.3.3BigTable——谷歌的NOSQL系统
6.3.4Chubby——谷歌的分布式锁服务
6.4亚马逊AWS与微软Azure中的编程
6.4.1亚马逊EC2上的编程
6.4.2亚马逊简单存储服务（S3）
6.4.3亚马逊弹性数据块存储服务（EBS）和SimpleDB
6.4.4微软Azure编程支持
6.5新兴云软件环境
6.5.1开源的Eucalyptus和Nimbus
6.5.2OpenNebula、Sector/Sphere和Open Stack
6.5.3Manjrasoft Aneka云和工具机
6.6参考文献与习题
第三部分网格、P2P和未来互联网
第7章网格计算系统和资源管理
7.1网格体系结构和服务建模
7.1.1网格历史与服务类别
7.1.2CPU清除和虚拟超级计算机
7.1.3开放网格服务体系结构（OGSA）
7.1.4数据密集型网格服务模型
7.2网格项目和网格系统创建
7.2.1国家网格和国际项目
7.2.2美国的NSF TeraGrid
7.2.3欧盟的DataGrid
7.2.4ChinaGrid设计经验
7.3网格资源管理和资源中介
7.3.1资源管理和作业调度
7.3.2CGSP的网格资源监控
7.3.3服务记账和经济模型
7.3.4Gridbus的资源中介
7.4网格计算的软件与中间件
7.4.1开源网格中间件包
7.4.2Globus Tookit体系结构（GT4）
7.4.3集装器和资源/数据管理
7.4.4ChinaGrid支持平台（CGSP）
7.5网格应用趋势和安全措施
7.5.1网格应用技术融合
7.5.2网格负载与性能预测
7.5.3网格安全执行的信任模型
7.5.4认证与授权方法
7.5.5网格安全基础设施（GSI）
7.6参考文献与习题
第8章对等计算和覆盖网络
8.1P2P计算系统
8.1.1P2P计算系统的基本概念
8.1.2P2P计算面临的基础挑战
8.1.3P2P网络系统分类
8.2P2P覆盖网络及其性质
8.2.1无结构P2P覆盖网络
8.2.2分布式哈希表（DHT）
8.2.3结构化P2P覆盖网络
8.2.4混合式覆盖网络
8.3路由、邻近性和容错
8.3.1P2P覆盖网络的路由
8.3.2P2P覆盖网络中的网络邻近性
8.3.3容错和失效恢复
8.3.4抗扰动与失效
8.4信任、信誉和安全管理
8.4.1节点信任和信誉系统
8.4.2信任覆盖网络和DHT实现
8.4.3PowerTrust：可扩展的信誉系统
8.4.4加强覆盖网络安全，抵御DDoS攻击
8.5P2P文件共享和版权保护
8.5.1快速搜索、副本和一致性
8.5.2P2P内容分发网络
8.5.3版权保护问题和解决方案
8.5.4P2P网络中的共谋盗版预防
8.6参考文献与习题
第9章普适云计算、物联网与社会网络
9.1支持普适计算的云趋势
9.1.1云计算在HPC/HTC和普适计算中的应用
9.1.2NASA和CERN的大规模私有云
9.1.3灵活和可扩展的云混搭系统
9.1.4移动云计算平台Cloudlet
9.2分布式系统和云的性能
9.2.1科研云综述
9.2.2数据密集型扩展计算（DISC）
9.2.3HPC/HTC系统的性能指标
9.2.4云计算的服务质量
9.2.5MPI、Azure、EC2、MapReduce、Hadoop的基准测试
9.3物联网关键技术
9.3.1实现普适计算的物联网
9.3.2射频标识（RFID）
9.3.3传感器网络和ZigBee技术
9.3.4全球定位系统（GPS）
9.4物联网创新应用
9.4.1物联网应用
9.4.2零售和供应链管理
9.4.3智能电网和智能建筑
9.4.4信息物理系统（CPS）
9.5在线社会网络和专业网络
9.5.1在线社会网络特征
9.5.2基于图论的社会网络分析
9.5.3社会网络社区和应用
9.5.4Facebook：世界上最大的社会网络
9.5.5Twitter：微博、新闻和提醒服务平台
9.6参考文献与习题
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与分布式系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Rcpp：R与C++的无缝整合
第一部分 简介
第1章 Rcpp简介
第2章 工具与设置
第二部分 核心数据类型
第3章 数据结构：第一部分
第4章 数据结构：第二部分
第三部分 进阶话题
第5章 在扩展包中使用Rcpp
第6章 扩展Rcpp
第7章 Modules
第8章 Suger
第四部分 应用
第9章 RInside
第10章 RcppArmadillo
第11章 RcppGSL
第12章 RcppEigen
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Rcpp：R与C++的无缝整合
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>说话心理学：渗透潜意识的语言说服力
第1部分　与潜意识对话　// 1
意识就像暴露在阳光下的喷泉，落下来的水花会流向巨大的隐藏在地下的潜意识水池，而喷泉就是来自这里。
第1章　在语言中植入建议和暗示　// 3
第2部分　有说服力的语言模式　// 31
14种语言模式源自全球公认的说服力大师，对他们的沟通技巧进行提炼，将沟通风格公式化。勤加练习后，它们将帮助你形成自己独有的语言模式。
第2章　重新定义：轻松解决分歧，引导对话走向你的目标　// 33
第3章　同意框架：增加亲和力、消除抵触心理并应对异议　// 43
第4章　语言运算：添加和删除潜意识里的想法，给他人创造积极情绪　// 53
第５章　融洽关系：立即产生共鸣　// 67
第6章　因果逻辑：加强你的说服力　// 77
第7章　意识模式：让别人无条件地接受你说的一切　// 85
第8章　铺路石与领头羊式语言：快速避开批评和获得认同　// 95
第9章　理解—同感—引用：奇迹般地消除异议　// 105
第10章　内在表征：悄悄引导他人的思维方式　// 111
第11章　动机方向：发现客户做出购买决策的内在驱动力　// 121
第12章　测试真假：破解客户眼中的隐藏信息　// 131
第13章　部分理论：将反对意见分成两部分，分而化 　　　之　// 147
第14章　引用模式：引用他人的话说服他人　// 157
第15章　肢体动作：用肢体语言引起他人的注意　// 163
第3部分　有说服力的提问技巧　// 179
准确地提出问题和清晰地表达你的看法，能帮你积极地将自己的建议和观点植入对方的潜意识，悄悄地影响他们的看法，促进他们做出决定。
第16章　预设问题：将预设信息融入你的问题中　// 183
第17章　附加疑问：获得客户自发的认同　// 193
第18章　功能强大式问题：打开客户的心扉，悄悄植入建议　// 201
第19章　未来测试式问题：让客户渴望你的产品或服 　　　务　// 217
第20章　标准问题：理解客户看重什么，满足客户的需求　// 225
第4部分　准备好说服他人　// 235
准备好说服他人了吗？当几种语言模式恰当地排列组合，并用你与对方熟悉的风格沟通后，你会发现自己的技巧所向披靡。
第21章　向自己提问：准备好应对可能出现的结果　// 237
第22章　建立自信：用自信的态度说服他人　// 245
第23章　如何练习：熟能生巧　// 253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>说话心理学：渗透潜意识的语言说服力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>TMS320C54x DSP结构、原理及应用
诸论第1章  TMS320C54x的结构原理  1.1  TMS320系列DSP芯片概述    1.1.1  TMS320系列DSP的分类及应用    1.1.2  TMS320C5000 DSP平台  1.2  TMS320C54x DSP    1.2.1  TMS320C54x的主要特性    1.2.2  TMS320C54x的组成框图  1.3  总线结构  1.4  存储器    1.4.1  存储器空间分配    1.4.2  程序存储器    1.4.3  数据存储器  1.5  户央处理单元    1.5.1  算术逻辑运算单元    1.5.2  累加器A和B    1.5.3  桶形移位器    1.5.4  乘法器/加法器单元    1.5.5  比较、选择和存储单元    1.5.6  指数编码器    1.5.7  CPU状态和控制寄存器  1.6  数据寻址方式    1.6.1  立即寻址    1.6.2  绝对寻址    1.6.3  累加器寻址    1.6.4  直接寻址    1.6.5  间接寻址    1.6.6  存储器映像寄存器寻址    1.6.7  堆栈寻址  1.7  程序存储器地址生成方式    1.7.1  程序计数器    1.7.2  分支转移    1.7.3  调用与返回    1.7.4  条件操作    1.7.5  重复操作    1.7.6  复位操作    1.7.7  中断    1.7.8  省电方式  1.8  流水线    1.8.1  流水线操作    1.8.2  延迟分支转移    1.8.3  条件执行    1.8.4  双寻址存储器与流水线    1.8.5  单寻址存储器与流水线    1.8.6  流水线冲突和插入等待周期  1.9  在片外围电路    1.9.1  并行I/O口及通用I/O引脚    1.9.2  定时器    1.9.3  时钟发生器    1.9.4  主机接口  1.10  串行口    1.10.1  串行口概述    1.10.2  标准串行口  1.11  DMA控制器    1.11.1  DMA控制器的基本特性    1.11.2  子地址寻址方式    1.11.3  DMA通道优先级和使能控制寄存器    1.11.4  DMA通道现场寄存器    1.11.5  DMA编程举例  1.12  外部总线    1.12.1  外部总线接口    1.12.2  外部总线操作的优先级别    1.12.3  等待状态发生器    1.12.4  分区切换逻辑    1.12.5  外部总线接口定时图    1.12.6  复位和IDLE3省电工作方式  1.13  TMS320C54x引脚信号说明第2章  指令系统  2.1  指令的表示方法    2.1.1  指令系统中的符号和略语    2.1.2  指令系统中的记号和运算符  2.2  指令系统    2.2.1  指令系统概述    2.2.2  指令系统分类第3章  汇编语言程序开发工具  3.1  TMS320C54x软件开发过程  3.2  汇编语言程序的编写方法  3.3  汇编语言程序的编辑、汇编和链接过程  3.4  COFF的一般概念    3.4.1  COFF文件中的段    3.4.2  汇编器对段的处理    3.4.3  链接器对段的处理    3.4.4  COFF.文件中的符号  3.5  汇编    3.5.1  运行汇编程序    3.5.2  列表文件    3.5.3  汇编命令    3.5.4  宏定义和宏调用   3.6  链接    3.6.1  运行链接程序    3.6.2  链接器选项    3.6.3  链接器命令文件    3.6.4  多个文件的链接第4章  Simulator和CCS集成开发工具的使用方法  4.1  Simulator的使用方法    4.1.1  软件仿真器概述    4.1.2  仿真命令    4.1.3  仿真器初始化命令文件    4.1.4  仿真外部中断  4.2  什么是CCS  4.3  如何安装和设置CCS    4.3.1  CCS对计算机系统的配置要求    4.3.2  CCS的安装与设置  4.4  CCS窗口介绍    4.4.1  (2CS窗口示例    4.4.2  CCS的菜单栏和快捷菜单    4.4.3  CCS的常用工具栏  4.5  如何建立工程文件    4.5.1  工程文件的建立、打开和关闭    4.5.2  在工程文件中添加或删除文件    4.5.3  编辑源文件    4.5.4  工程的构建  4.6  如何调试程序    4.6.1  加载可执行文件    4.6.2  程序的运行和复位    4.6.3  断点设置    4.6.4  内存、寄存器和变量操作  4.7  如何与外部文件交换数据    4.7.1  外部数据文件的格式    4.7.2  利用探针从/向外部文件载入/保存数据    4.7.3  利用I/O端口与外部文件传送数据  4.8  如何仿真外部中断和测试程序的执行时间    4.8.1  仿真外部中断    4.8.2  测试一段程序的执行时间  4.9  如何利用图形窗口观察和分析数据    4.9.1  CCS的画图功能    4.9.2  CCS图形功能应用举例  4.10  通用扩展语言    4.10.1  GEL函数    4.10.2  在GEL菜单中添加GEL函数    4.10.3  GEL文件的加载和卸载  4.11  CCS应用举例    4.11.1  汇编语言源程序    4.11.2  C语言源程序第5章  汇编语言程序设计  5.1  程序的控制与转移  5.2  堆栈的使用方法  5.3  加、减法和乘法运算  5.4  重复操作  5.5  数据块传送  5.6  双操作数乘法  5.7  长字运算和并行运算  5.8  小数运算  5.9  除法运算  5.10  浮点运算第6章  TMS320C54x的软硬件应用  6.1  TMS320C54x与存储器及外围设备接口  6.2  TMS320C54x与慢速器件接口  6.3  FIR滤波器的C54x实现方法  6.4  IIR滤波器的C54x实现方法  6.5  快速傅里叶变换(FFT)的C54X实现方法  6.6  正弦和余弦信号发生器  6.7  自举加载器  6.8  DMA与McBSP相结合的数据采集系统附录A  TMS320系列芯片DSP的命名方法附录B  TMS320C5402引脚图和引脚分配表附录C  TMS320C54x DSP的中断向量表和硬件中断优先权附录D  等待周期表附录E  TMS320C54x指令系统一览表(按指令功能排列)附录F  TMS320C54x指令系统一览表(按指令字母顺序排列)附录G  TMS320CS4x汇编命令一览表附录H  FFT正弦、余弦系数表参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>TMS320C54x DSP结构、原理及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南
第0章 导读
第1章 Boost程序库总论
第2章 时间与日期
第3章 内存管理
第4章 实用工具
第5章 字符串与文本处理
第6章 正确性与测试
第7章 容器与数据结构
第8章 算法
第9章 数学与数字
第10章 操作系统相关
第11章 函数与回调
第12章 并发编程
第13章 编程语言支持
第14章 其他Boost组件
第15章 Boost与设计模式
第16章 结束语
附录A 推荐书目
附录B 网络资源
附录C C++标准简述
附录D STL简述
附录E ref_array实现代码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Boost程序库完全开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C函数库参考手册
第1章  字符测试函数
isalnum 测试字符是否为英文字母或数字
isalpha 测试字符是否为英文字母
isascii 测试字符是否为ASCII码字符
isblank 测试字符是否为空格字符
i

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C函数库参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>8位单片机C语言编程
第1章　PIC微控制器系统        1
1.1　PIC 16 微控制器        1
1.1.1　MCU特性        2
1.1.2　程序执行        3
1.1.3　RAM文件寄存器        4
1.1.4　其他PIC芯片        5
1.2　PIC MCU配置        5
1.2.1　时钟选择        5
1.2.2　配置选项        6
1.2.3　在C语言中的配置        7
1.3　PIC16 MCU 外围设备        7
1.3.1　定时器        8
1.3.2　A/D转换器        9
1.3.3　比较器        10
1.3.4　并行从端口        10
1.3.5　中断        11
1.4　PIC16 串行接口        12
1.4.1　USART        12
1.4.2　SPI 总线        13
1.4.3　I2C总线        14
1.5　PIC16 MPLAB 项目        15
1.5.1　MPLAB C 项目        15
1.5.2　项目文件        16
1.6　PIC16 编程与调试        17
1.6.1　编程        18
1.6.2　调试        18
1.6.3　设计包        20
练习        20
作业        21
第2章　C编程精华        22
2.1　PIC16 C入门        22
2.1.1　简单程序        22
2.1.2　程序创建        22
2.1.3　程序测试        23
2.1.4　程序分析        24
2.2　PIC16 C程序基础        25
2.2.1　变量        25
2.2.2　循环        26
2.2.3　决策        27
2.2.4　循环控制        28
2.2.5　FOR循环        28
2.2.6　SIREN程序        29
2.2.7　空程序        30
2.3　PIC16 数据操作        31
2.3.1　变量类型        31
2.3.2　赋值运算        34
2.3.3　条件运算        35
2.4　PIC16 C顺序控制        35
2.4.1　while循环        36
2.4.2　break、continue和goto        37
2.4.3　if..else和switch..case        38
2.5　PIC16 C函数和结构        39
2.5.1　基本函数        40
2.5.2　全局变量和局部变量        41
2.6　PIC16 C输入和输出        42
2.6.1　串行LCD        42
2.6.2　键盘和计算器        45
2.7　PIC16 Ｃ更多的数据类型        48
2.7.1　数组        48
2.7.2　间接寻址操作符        49
2.7.3　枚举类型        50
2.8　PIC16 C编译器伪指令        51
2.8.1　程序伪指令        51
2.8.2　头文件        51
2.9　PIC16 C汇编子程序        56
2.9.1　程序编译        57
2.9.2　汇编程序块        57
2.9.3　PIC汇编语言        60
练习        61
作业        63
第3章　C外围接口编程        64
3.1　PIC16 C模拟输入        64
3.1.1　模拟信号设置        64
3.1.2　电压测量        65
3.2　PIC16 C中断        67
3.2.1　C中断        67
3.2.2　中断举例        68
3.2.3　中断语句        69
3.3　PIC16 C 硬件定时器        70
3.3.1　计数器/定时器操作        70
3.3.2　PWM模式        70
3.3.3　比较模式        71
3.3.4　捕捉模式        72
3.4　PIC16 C URAT串行链路        73
3.5　PIC16 C SPI 串行总线        74
3.6　PIC16 C I2 C串行总线        77
3.7　PIC16 C并行与串行接口        78
3.7.1　并行从端口        78
3.7.2　通信链路比较        80
3.8　PIC16 C EEPROM接口        81
3.9　PIC16 C模拟输出        82
练习        85
作业        86
第4章　C语言在机械电子电路板中的应用        88
4.1　PICDEM机械电子板概述        88
4.1.1　PICDEM 硬件        88
4.1.2　电机驱动        91
4.1.3　测试程序        92
4.1.4　调试        93
4.2　PICDEM 液晶显示器        94
4.2.1　LCD连接        94
4.2.2　LCD测试程序        96
4.2.3　BCD 计数程序        98
4.3　PICDEM 直流电机测试程序        98
4.3.1　基本控制        99
4.3.2　转数计数器        99
4.4　PICDEM 步进电机控制        101
4.4.1　结构        101
4.4.2　步进电机的测试        102
4.4.3　方向控制        103
4.5　PICDEM 模拟传感器        104
4.5.1　光传感器        105
4.5.2　温度测量        106
4.6　PICDEM 温度控制器        107
4.6.1　规格        108
4.6.2　I/O分配        108
4.6.3　实现        108
4.7　PICDEM板仿真        110
4.7.1　电路描述        112
4.7.2　演示应用        113
练习        113
作业        114
第5章　PIC16 C应用与系统        116
5.1　PIC16 C应用设计        116
5.1.1　硬件设计        116
5.1.2　软件设计        116
5.1.3　应用调试和测试        117
5.2　PIC16 C温度控制器        118
5.2.1　系统操作        118
5.2.2　软件设计和实现        119
5.3　PIC16 C数据记录系统        120
5.3.1　BASE板        120
5.3.2　程序纲要        122
5.4　PIC16 C操作系统        123
5.4.1　轮询I/O口        123
5.4.2　中断        123
5.4.3　PC 操作系统        124
5.4.4　实时操作系统        125
5.5　PIC16 C系统设计        126
5.5.1　硬件选择        126
5.5.2　微控制器        127
5.5.3　硬件设计        128
5.5.4　软件设计        129
练习        129
作业        130
附录A　使用ISIS Schematic Capture
进行硬件设计        131
附录B　使用CCS C进行软件设计        134
附录C　使用Proteus VSM进行系统
测试        141
附录D　C编译器比较        145
附录E　CCS C编程语法小结        153
附录F　CCS C编程函数参考        156
答案        163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>8位单片机C语言编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>光阴似箭
第1部分  历史与经济学引言：万变不离其宗  1.躁动的计量史学：经济史学家对经济学历史的评价  2.熊彼特的理性历史之辩  3.康德拉季耶夫：历史和统计学新方法  4.潮汐和波浪的神奇吸引力  第1部分结论：理性历史理论第2部分  连续发生的工业革命引言：技术变化与经济发展的长波。  5.英国工业革命：棉花、铁和水力时代  6.第二次康德拉季耶夫长波：铁路，蒸汽力和机械化时代  7.第三次康德拉季耶夫长波：钢铁、重工业和电气化时代  8.第四次康德拉季耶夫长波：大萧条与石油、汽车、动力化及大规模生产时代  9.新技术经济范式的出现：信息通讯技术(ICT)时代  第2部分结论：资本主义发展长波的周期现象参考文献索引后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>光阴似箭
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言软件开发教程
译者序
前言
第1章  软件开发
1. 1  开发活动
1. 2  规格说明
1. 3  设计
1. 4  模块化
1. 5  选择编程

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言软件开发教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构C语言版
第1章 C语言与数据结构
第2章 数组与字符串
第3章 基本链表
第4章 复杂链表
第5章 栈与队列
第6章 递归函数
第7章 二叉树
第8章 图
第9章 查找方法
第10章 内部排序法
第11章 外部排序法
第12章 OOP与数据结构
附录A 常用字符与ASCII代码对照表
附录B 习题解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构C语言版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
第一章  C程序设计基础知识
第二章  基本数据类型与常用库函数
第三章  运算符和表达式
第四章  控制结构与语句
第五章  数组
第六章  函数
第七章  编译预处理
第八章  指针
第九章  结构体
第十章  位运算
第十一章  文件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙语短篇C2
Introduction 前言 1. The Longest Menu in the World 2. Court Case 3. My Friend the Penguin 4, Man at War 5, A Long Silence 6. The Photographer 7. Guilty or Not Guilty 8. Late for Work 9. Speak Your Weight10. Musical Lions11. The Witness12. An Important Friend13. The Shirt14. A Present for the Judge15. PerformersAnswer Key 答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙语短篇C2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>先有爛點子，才有好點子
前言
你可曾腦袋一片空白，完全想不出點子？
第1章　為什麼頭腦會想不出點子？
「想不出點子」的原因
原來頭腦不會完全想不出點子
想出爛點子是件壞事嗎？
第2章　培養頭腦想出點子的方法
該怎麼做才能想出點子？
構思點子的三大原則
原則一：A×B＝C的創意公式
原則二：點子「重量不重質」
原則三：從爛點子想出好點子
新奇有趣的玩具是怎麼想出來的？
第3章　從聯想生出點子的「A×B＝C」公式
所有的構思來自「聯想」
「A×B」的「×」是什麼？
進行「×」所需要的聯想力
運用聯想力簡單構思一百個點子
活用在其他工作領域的點子
強化聯想力的要訣
第4章　從「重量不重質」的原則，選出最妙的點子
想出大量點子後的「挑選法」
單打獨鬥想不出好點子
第5章　讓點子通過審核，加以實現的方法
讓點子通過審核的祕訣
行不通的點子不會通過
行得通的點子就會順利通過
如果有心通過審核，辦法多的是
第6章　培養頭腦不斷湧現點子的方法
如何欣賞被埋沒的點子？
再怎麼被埋沒的點子都有價值
撰寫爛點子日記
制定計劃蒐集能成為點子的資料
編纂自己專屬的「題材新聞」
編纂「人人都○○的筆記本」
每週六早上進行一小時思考遊戲
讓「嘴巴」思考而非頭腦
附錄 與腦科學家的精采對談
訪問茂木健一郎先生，暢談點子與創造性
後記
讓自己開心想出世上獨一無二的點子
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>先有爛點子，才有好點子
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>功利教育批判
中文版序 / 1
教育应当培养有批判力、有想象力、有同情心的民主公民

英文版序 / 1
教育不是为经济增长服务的工具

新版前言 / 5
放任人文学科萎缩，我们将付出沉重代价

第一章　无声的危机 / 1
各国的教育制度都在拼命追求国家的利润，都在轻率地抛弃民主制度生存所
必需的技能。这种倾向若是发展下去，世界各国很快就会产出一代代有用的
机器，而不能造就完整的公民——他们能独立思考，能批判传统，能理解他
人苦难和成就的意义。

第二章　为赢利的教育，为民主的教育 / 15
在繁荣的民主制度下，很难找到为经济增长服务的教育的纯粹实例，因为民
主建立在对每个人的尊重上，而为经济增长服务的教育模式却只看重集体，
鼓励学生将自己看做一个正在发展的大集体的成员，而不是看做享有各自权
利的单独个人。

第三章　教育公民：道德的（与反道德的）情感 / 33
是什么力量使强势群体热衷统治和主宰？是什么力量使多数者人群设法贬
低、诬蔑少数者人群？无论这些力量是什么，培养负责任的国家公民和世界
公民素质的真正教育，最终都必须反对这些力量。

第四章　苏格拉底教学法：辩论的重要性 / 59
传统教育方式的核心弊病，就是鼓励学生的被动性。学校被看做了听课和吸
收之地，重视听讲甚于重视分析、考察和积极地解决问题。学生拿起书本，
却毫无求知渴望，毫无警醒之心，毫无质疑态度。这种顺从态度，不但对他
们的人生不利，更是对民主的威胁。

第五章　世界公民 / 101
世界上的学校、学院和大学面临着一项重要而紧迫的任务：培养学生的一种
能力，那就是能将自己看做由多元文化构成的国家的成员，进一步说，能将
自己看做由多元文化构成的世界的成员，而且能大致地了解世界上各种人群
的历史与特点。

第六章　培养想象力：文学和艺术 / 121
对学生从学校毕业后的生活来说，艺术的最重要贡献就是丰富他们个人的情
感资源和想象资源，让他们获得理解自己、理解他人的能力，而没有艺术教
育，他们很难获得这种能力。他们不会自动地认为他人具有广阔的内心、各
种心灵渴望和各种情感。

第七章　岌岌可危的民主教育 / 155
我们声称喜欢民主，喜欢言论自由、尊重差异、理解他人。我们在嘴上谈论
这些价值观，却极少思考：要将这些价值观传给下一代人并确保其存在，我
们需要做什么。追求财富分散了我们的注意力，我们越来越要求我们的学校
生产出有用的赚钱者，而不是培养出有思想的公民。

后 记 / 183
人文学科的未来

致 谢 / 197
注 释 / 201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>功利教育批判
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>为什么速度越快，时间越少
目录

致谢

导言 速度的陷阱
1对速度的迷恋
2看不见的手
3时间至上
4网络购物
5网络化
6无效市场假说
7被连接分割
8*限金融
9生活的再程序化——心灵的去程序化
10大崩溃
附录
注释
索引

《雅理译丛》编后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>为什么速度越快，时间越少
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>狄奥提玛的孩子们
导论 重估审美理性主义
一、一处辉煌的遗迹？
二、审美判断理论
三、理性主义美学
四、规则的意义
五、康德不足取的论争
六、狄奥提玛对狄奥尼索斯
七、非理性主义的挑战
八、伽达默尔和理性主义传统
第一章 莱布尼茨与审美理性主义的根源
一、祖父的悬案
二、美的理论
三、关于感觉的分析
四、古典的三位一体
第二章 沃尔夫与审美理性主义的诞生
一、沃尔夫与美学传统
二、艺术理论
三、心理学
四、美的理论
五、新古典主义的基础
第三章 高特谢德和理性主义的正午
一、高特谢德教授先生的假发
二、趣味的重要性
三、为悲剧辩护
四、趣味理论
五、诗学
六、规则
七、哲基尔博士和海德先生
第四章 诗人们的战争
一、莱比锡对苏黎世
二、对争论的误读
三、争论的焦点
第五章 鲍姆加登的美学
一、美学之父？
二、哲学诗学
三、美的科学
四、感觉理论
五、对美的分析
六、美学的地位
七、一份含混的遗产
第六章 温克尔曼与新古典主义
一、作为哲学家的温克尔曼
二、历史影响
三、模仿古人
四、一种新古典主义美学
五、古今之争
六、美学理论
七、绘画与寓言
八、爱若斯与狄奥尼索斯
第7章 门德尔松对理性的辩护
一、启蒙运动的保护者
二、关于感性的分析
三、西勒诺斯的狂笑
四、重新思考
五、驯服崇高
六、应对伯克
七、遭遇让-雅克
八、关于天才的声明
九、与哈曼的第一次冲突
十、阿波拉特和富尔伯特的短暂争吵
十一、三功能理论
第八章 莱辛与审美理性主义的变革
一、莱辛与理性主义传统
二、天才与规则
三、天才的非理性？
四、莱辛伦理学中的理性主义与感性主义
五、《拉奥孔》：主题与归纳式论证
六、《拉奥孔》：演绎式论证
七、《拉奥孔》：隐藏的议程
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>狄奥提玛的孩子们
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>80後再看時代曲
002. 陀飛輪
004.春光乍洩
006.唱歌
008.年度之歌
010.樂天女孩
........
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>80後再看時代曲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统下C程序开发详解
第一部分 Linux基础篇第1章 Linux编程平台第2章 文本编辑器的使用第二部分 Shell编程篇第3章 Linux常用命令第4章 Shell编程第三部分 C程序基础篇第5章 编译与调试第6章 C语言基础第7章 C程序的常用语句第四部分 指针与函数篇第8章 数组与指针第9章 函数第10章 字符与字符串处理第11章 结构体第12章 时间函数第五部分 文件与目录篇第13章 目录与文件第14章 文件I/O第六部分 网络编程篇第15章 网络编程第16章 无连接的套接字通信第17章 面向连接的套接字通信第七部分 图形界面开发篇第18章 Linux图形界面开发基础第19章 图形界面编程第20章 界面布局第21章 信号与事件第22章 Glade设计程序界面第23章 Qt编程入门第24章 使用Qt Designer开发Qt程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统下C程序开发详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你必须知道的495个C语言问题
第1章　声明和初始化　1
基本类型　1
1．1　我该如何决定使用哪种整数类型？　1
1．2　为什么不精确定义标准类型的大小？　2
1．3　因为C语言没有精确定义类型的大小，所以我一般都用typedef定义int16和int32。然后根据实际的机器环境把它们定义为int、short、long等类型。这样看来，所有的问题都解决了，是吗？　2
1．4　新的64位机上的64位类型是什么样的？　3
指针声明　3
1．5　这样的声明有什么问题？char *p1， p2; 我在使用p2的时候报错了。　3
1．6　我想声明一个指针，并为它分配一些空间，但却不行。这样的代码有什么问题？char *p; *p=malloc(10);　4
声明风格　4
1．7　怎样声明和定义全局变量和函数最好？　4
1．8　如何在C中实现不透明(抽象)数据类型？　5
1．9　如何生成“半全局变量”，就是那种只能被部分源文件中的部分函数访问的变量？　5
存储类型　6
1．10　同一个静态(static)函数或变量的所有声明都必须包含static存储类型吗？　6
1．11　extern在函数声明中是什么意思？　6
1．12　关键字auto到底有什么用途？　7
类型定义(typedef)　7
1．13　对于用户定义类型，typedef 和#define有什么区别？　7
1．14　我似乎不能成功定义一个链表。我试过typedef struct{char *item; NODEPTR next;}* NODEPTR; 但是编译器报了错误信息。难道在C语言中结构不能包含指向自己的指针吗？　7
1．15　如何定义一对相互引用的结构？　9
1．16　Struct{　} x1;和typedef struct{　} x2; 这两个声明有什么区别？　10
1．17　“typedef int(*funcptr)();”是什么意思？　10
const 限定词　10
1．18　我有这样一组声明：typedef char *charp; const charp p; 为什么是p而不是它指向的字符为const?　10
1．19　为什么不能像下面这样在初始式和数组维度值中使用const值？const int n=5; int a[n];　10
1．20　const char *p、char const *p和char *const p有什么区别？　10
复杂的声明　 11
1．21　怎样建立和理解非常复杂的声明？例如定义一个包含N个指向返回指向字符的指针的函数的指针的数组？　11
1．22　如何声明返回指向同类型函数的指针的函数?我在设计一个状态机，用函数表示每种状态，每个函数都会返回一个指向下一个状态的函数的指针。可我找不到任何方法来声明这样的函数——感觉我需要一个返回指针的函数，返回的指针指向的又是返回指针的函数……，如此往复，以至无穷。　12
数组大小　13
1．23　能否声明和传入数组大小一致的局部数组，或者由其他参数指定大小的参数数组？　13
1．24　我在一个文件中定义了一个extern数组，然后在另一个文件中使用，为什么sizeof取不到数组的大小？　13
声明问题　14
1．25　函数只定义了一次，调用了一次，但编译器提示非法重声明了。　14
*1．26　main的正确定义是什么？void main正确吗？　15
1．27　我的编译器总在报函数原型不匹配的错误，可我觉得没什么问题。这是为什么？　15
1．28　文件中的第一个声明就报出奇怪的语法错误，可我看没什么问题。这是为什么？　15
1．29　为什么我的编译器不允许我定义大数组，如double array[256][256]?　15
命名空间　15
1．30 如何判断哪些标识符可以使用，哪些被保留了？　15
初始化　18
1．31　对于没有显式初始化的变量的初始值可以作怎样的假定？如果一个全局变量初始值为“零”，它可否作为空指针或浮点零？　18
1．32　下面的代码为什么不能编译? intf(){char a[]="Hello， world!";}　18
*1．33　下面的初始化有什么问题？编译器提示“invalid initializers ”或其他信息。char *p=malloc(10);　19
1．34　char a[]= "string literal";和char *p="string literal"; 初始化有什么区别？当我向p[i] 赋值的时候，我的程序崩溃了。　19
1．35　char a{[3]}= "abc"; 是否合法？　20
1．36　我总算弄清楚函数指针的声明方法了，但怎样才能初始化呢？　20
1．37　能够初始化联合吗？　20
第2章　结构、联合和枚举　21
结构声明　21
2．1　struct x1{　};和typedef struct{　}x2; 有什么不同？　21
2．2　这样的代码为什么不对？struct x{　}; x thestruct;　22
2．3　结构可以包含指向自己的指针吗？　22
2．4　在C语言中用什么方法实现抽象数据类型最好?　22
*2．5　在C语言中是否有模拟继承等面向对象程序设计特性的好方法？　22
2．6　为什么声明extern f(struct x *p); 给我报了一个晦涩难懂的警告信息？　23
2．7　我遇到这样声明结构的代码：struct name {int namelen; char namestr[1];};然后又使用一些内存分配技巧使namestr数组用起来好像有多个元素，namelen记录了元素个数。它是怎样工作的？这样是合法的和可移植的吗？　23
2．8　我听说结构可以赋给变量也可以对函数传入和传出。为什么K&R1却明确说明不能这样做？　25
2．9　为什么不能用内建的==和!=操作符比较结构？　 26
2．10 结构传递和返回是如何实现的？　26
2．11　如何向接受结构参数的函数传入常量值？怎样创建无名的中间的常量结构值？　26
2．12　怎样从/向数据文件读/写结构？　27
结构填充　27
2．13　为什么我的编译器在结构中留下了空洞？这导致空间浪费而且无法与外部数据文件进行“二进制”读写。能否关掉填充，或者控制结构域的对齐方式？　27
2．14　为什么sizeof返回的值大于结构大小的期望值，是不是尾部有填充？　28
2．15　如何确定域在结构中的字节偏移量？　28
2．16　怎样在运行时用名字访问结构中的域？　29
2．17　C语言中有和Pascal的with等价的语句吗？　 29
2．18　既然数组名可以用作数组的基地址，为什么对结构不能这样？　29
2．19　程序运行正确，但退出时却“core dump ”(核心转储)了，怎么回事？　29
联合　30
2．20　结构和联合有什么区别？　30
2．21　有办法初始化联合吗？　30
2．22　有没有一种自动方法来跟踪联合的哪个域在使用？　30
枚举　31
2．23　枚举和一组预处理的#define有什么不同？　 31
2．24　枚举可移植吗？　31
2．25　有什么显示枚举值符号的容易方法吗？　31
位域　31
2．26　一些结构声明中的这些冒号和数字是什么意思？　31
2．27　为什么人们那么喜欢用显式的掩码和位操作而不直接声明位域？　32
第3章　表达式　 33
求值顺序　33
3．1　为什么这样的代码不行？a[i]= i++;　33
3．2　使用我的编译器，下面的代码int i= 7; printf("%d\n"， i++ * i++); 打印出49。不管按什么顺序计算，难道不该是56吗？　33
3．3　对于代码int i=3; i=i++; 不同编译器给出不同的i值，有的为3，有的为4，哪个是正确的？　34
*3．4　有这样一个巧妙的表达式：a^= b^= a^= b; 它不需要临时变量就可以交换a和b的值。　34
3．5　可否用显式括号来强制执行我所需要的计算顺序并控制相关的副作用？就算括号不行，操作符优先级是否能够控制计算顺序呢？　35
3．6　可是&&和||操作符呢？我看到过类似while((c = getchar()) != EOF && c != '\n')的代码……　35
3．7　是否可以安全地认为，一旦&&和||左边的表达式已经决定了整个表达式的结果，则右边的表达式不会被求值？　36
3．8　为什么表达式printf("%d %d"， f1()， f2()); 先调用了f2？我觉得逗号表达式应该确保从左到右的求值顺序。　36
3．9　怎样才能理解复杂表达式并避免写出未定义的表达式？“序列点”是什么？　36
3．10 在a[i] = i++;中，如果不关心a[]的哪一个分量会被写入，这段代码就没有问题，i也的确会增加1，对吗？　38
3．11　人们总是说i=i++的行为是未定义的。可我刚刚在一个ANSI编译器上尝试过，其结果正如我所期望的。　38
3．12　我不想学习那些复杂的规则，怎样才能避免这些未定义的求值顺序问题呢？　38
其他的表达式问题　39
*3．13　++i和i++有什么区别？　39
3．14　如果我不使用表达式的值，那我应该用i++还是++i来做自增呢？　39
3．15　我要检查一个数是不是在另外两个数之间，为什么if(a b c)不行？　40
3．16　为什么如下的代码不对？int a=1000， b=1000; long int c=a * b;　40
3．17　为什么下面的代码总是给出0？double degC， degF; degC= 5．0 / 9 * (degF - 32);　40
3．18　需要根据条件把一个复杂的表达式赋给两个变量中的一个。可以用下面这样的代码吗？((condition) ? a ： b)= complicated_expression;　41
3．19　我有些代码包含这样的表达式。a ? b=c ： d 有些编译器可以接受，有些却不能。为什么？　41
保护规则　42
3．20　“semantics of‘’change in ANSI C”的警告是什么意思？　42
3．21　“无符号保护”和“值保护”规则的区别在哪里？　42
第4章　指针　45
基本的指针应用　45
4．1　指针到底有什么好处？　45
4．2　我想声明一个指针并为它分配一些空间，但却不行。这些代码有什么问题呢？char *p; *p =malloc(10);　45
4．3　*p++自增p还是p所指向的变量？　46
指针操作　46
4．4　我用指针操作int数组的时候遇到了麻烦。　46
4．5　我有一个char *型指针碰巧指向一些int型变量，我想跳过它们。为什么((int *)p)++; 这样的代码不行？　47
4．6　为什么不能对void *指针进行算术操作？　47
4．7　我有些解析外部结构的代码，但是它却崩溃了，显示出了“unaligned access”(未对齐的访问)的信息。这是什么意思？　47
作为函数参数的指针　47
4．8　我有个函数，它应该接受并初始化一个指针：void f(int *ip){ static int dummy = 5; ip = &dummy;}但是当我如下调用时：int *ip; f(ip); 调用者的指针没有任何变化。　47
4．9　能否用void ** 通用指针作为参数，使函数模拟按引用传递参数?　 48
4．10　我有一个函数extern intf(int *); ，它接受指向int型的指针。我怎样用引用方式传入一个常数？调用f(&5);似乎不行。　49
4．11　C语言可以“按引用传参”吗？　50
其他指针问题　50
4．12　我看到了用指针调用函数的不同语法形式。到底怎么回事？　50
4．13　通用指针类型是什么？当我把函数指针赋向void *类型的时候，编译通不过。　51
4．14　怎样在整型和指针之间进行转换？能否暂时把整数放入指针变量中，或者相反？　51
*4．15　我怎样把一个int变量转换为char *型？我试了类型转换，但是不行。　52
第5章　空指针　 53
空指针和空指针常量　53
5．1　臭名昭著的空指针到底是什么？　53
5．2　怎样在程序里获得一个空指针？　54
5．3　用缩写的指针比较“if(p)”检查空指针是否有效？如果空指针的内部表达不是0会怎样？　55
NULL 宏　56
5．4　NULL是什么，它是怎么定义的？　56
5．5　在使用非零位模式作为空指针的内部表示的机器上，NULL 是如何定义的？　56
5．6　如果NULL定义成#define NULL((char *)0) ，不就可以向函数传入不加转换的NULL 了吗？　57
5．7　我的编译器提供的头文件中定义的NULL为0L。为什么？　57
5．8　NULL可以合法地用作函数指针吗？　57
5．9　如果NULL和0作为空指针常量是等价的，那我到底该用哪一个呢？　58
5．10 但是如果NULL的值改变了，比如在使用非零内部空指针的机器上，用NULL(而不是0)
不是更好吗？　58
5．11　我曾经使用过一个编译器，不使用NULL就不能编译。　58
5．12　我用预处理宏#define Nullptr(type)(type *)0帮助创建正确类型的空指针。　59
回顾　59
5．13　这有点奇怪：NULL可以确保是0，但空(null)指针却不一定？　59
5．14　为什么有那么多关于空指针的疑惑？为什么这些问题如此频繁地出现？　60
5．15　有没有什么简单点儿的办法理解所有这些与空指针有关的东西呢？　60
5．16　考虑到有关空指针的所有这些困惑，要求它们的内部表示都必须为0不是更简单吗？　60
5．17　说真的，真有机器用非零空指针吗，或者不同类型用不同的表示？　61
地址0 上到底有什么？　61
5．18　运行时的整数值0转换为指针以后一定是空指针吗？　61
5．19　如何访问位于机器地址0处的中断向量？如果我将指针值设为0，编译器可能会自动将它转换为非零的空指针内部表示。　62
5．20 运行时的“null pointer assignment”错误是什么意思？应该怎样捕捉它？　62
第6章　数组和指针　63
数组和指针的基本关系　63
6．1　我在一个源文件中定义了char a[6]，在另一个源文件中声明了extern char *a。为什么不行？　63
6．2　可是我听说char a[]和char *a是等价的。是这样的吗？　63
6．3　那么，在C语言中“指针和数组等价”到底是什么意思？　64
6．4　既然它们这么不同，那为什么作为函数形参的数组和指针声明可以互换呢？　65
数组不能被赋值　66
6．5　为什么不能这样向数组赋值？extern char *getpass(); char str[10]; str=getpass("Enter password：");　66
6．6　既然不能向数组赋值，那这段代码为什么可以呢？int f(char str[]){ if(str[0] == '\0') str="none";…}　66
6．7　如果你不能给它赋值，那么数组如何能成为左值呢？　66
回顾　67
6．8　现实地讲，数组和指针的区别是什么？　67
6．9　有人跟我讲，数组不过是常指针。这样讲准确吗？　67
6．10　我还是很困惑。到底指针是一种数组，还是数组是一种指针？　67
6．11　我看到一些“搞笑”的代码，包含5["abcdef"]这样的“表达式”。这为什么是合法的C语言表达式呢？　68
数组的指针　 68
6．12　既然数组引用会退化为指针，如果array是数组，那么array和&array又有什么区别呢？　68
6．13　如何声明一个数组的指针？　69
动态数组分配　70
6．14　如何在运行时设定数组的大小？怎样才能避免固定大小的数组？　70
6．15　我如何声明大小和传入的数组一样的局部数组？　70
6．16　如何动态分配多维数组？　71
6．17　有个很好的窍门，如果我这样写：int realarray[10]; int *array = &realarray[-1]; 我就可以把“array”当作下标从1　开始的数组。　72
函数和多维数组　73
6．18　当我向一个接受指针的指针的函数传入二维数组的时候，编译器报错了。　73
6．19　我怎样编写接受编译时宽度未知的二维数组的函数？　74
6．20　我怎样在函数参数传递时混用静态和动态多维数组？　74
数组的大小　 75
6．21　当数组是函数的参数时，为什么sizeof不能正确报告数组的大小？　76
6．22　如何在一个文件中判断声明为extern的数组的大小(例如，数组定义和大小在另一个文件中)？sizeof操作符似乎不行。　76
6．23　sizeof返回的大小是以字节计算的，怎样才能判断数组中有多少个元素呢？　76
第7 章　内存分配　77
基本的内存分配问题　77
7．1　为什么这段代码不行？char *answer; printf("Type something：\n"); gets(answer); printf("You typed \"%s\"\n"， answer);　77
7．2　我的strcat() 不行。我试了下面的代码：char *s1= "Hello，"; char *s2= "world!"; char *s3= strcat(s1， s2);但是我得到了奇怪的结果。　78
7．3　但是strcat的文档说它接受两个char *型参数。我怎么知道(空间)分配的事情呢？　78
*7．4　我刚才试了这样的代码：char *p; strcpy(p， "abc");它运行正常。怎么回事？为什么它没有出错？　79
*7．5　一个指针变量分配多少内存？　79
7．6　我使用fgets将文件的所有行读入一个数组，为什么读入的每一行都是最后一行的内容呢？　79
7．7　我有个函数，本该返回一个字符串，但当它返回调用者的时候，返回的字符串却是垃圾信息。
为什么？　 80
*7．8　那么返回字符串或其他聚集的正确方法是什么呢？　81
调用malloc　81
7．9　为什么在调用malloc()时报出了“waring： assignment of pointer from integer lacks a cast”？　81
7．10 为什么有些代码小心翼翼地把malloc返回的值转换为分配的指针类型？　81
*7．11　在调用malloc()的时候，错误“不能把void * 转换为int * ”是什么意思？　82
7．12　我看到下面这样的代码：char *p = malloc(strlen(s) + 1); strcpy(p，s); 难道不应该是malloc ((strlen(s) + 1) * sizeof(char)) 吗？　82
7．13　我为malloc写了一个小小的封装函数。它为什么不行？　82
7．14　我想声明一个指针并向它分配一些内存，但是不行。这样的代码有什么问题？char *p; *p = malloc(10);　82
7．15　我如何动态分配数组？　83
7．16　怎样判断还有多少内存？　83
7．17　malloc(0)是返回空指针还是指向0个字节的指针？　83
7．18　我听说有的操作系统在程序使用的时候才真正分配malloc申请的内存。这合法吗？　83
有关malloc 的问题　83
7．19　为什么malloc返回了离谱的指针值？我的确读过问题7．9，而且也在调用之前包含了extern void *malloc();声明。　 83
7．20　我用一行这样的代码分配一个巨大的数组，用于数值运算：double *array = malloc (256　*256　*sizeof(double));malloc()并没有返回空指针，但是程序运行得有些奇怪，好像改写了某些内存，或者malloc()并没有分配我申请的那么多内存。为什么？　84
7．21　我的PC机有8兆内存。为什么我只能分配640K左右的内存？　84
7．22　我的应用程序非常依赖数据结构的节点的动态分配，而malloc/free的代价成了瓶颈。我该怎么做？　84
7．23　我的程序总是崩溃，显然发生在malloc内部的某个地方。但是我看不出哪里有问题。是malloc有bug吗？　84
释放内存　85
7．24　动态分配的内存一旦释放之后就不能再使用，是吧？　85
7．25　为什么在调用free()之后指针没有变空？使用(赋值、比较)释放之后的指针有多么不安全？　86
7．26　当我调用malloc()为一个函数的局部指针分配内存时，我还需要用free()显式地释放吗？　86
7．27　我在分配一些结构，它们包含指向其他动态分配的对象的指针。我在释放结构的时候，还需要释放每一个下级指针吗？　86
7．28　我必须在程序退出之前释放分配的所有内存吗？　86
7．29　我有个程序分配了大量的内存，然后又释放了。但是从操作系统看，内存的占用率却并没有变回去。　87
分配内存块的大小　87
7．30　free()怎么知道有多少字节需要释放？　87
7．31　那么我能否查询malloc包，以查明可分配的最大块是多大？　87
7．32　为什么sizeof不能告诉我它所指的内存块的大小？　87
其他分配函数　88
7．33　(像问题6．14中那样)动态分配数组之后，还能改变它的大小吗？　88
7．34　向realloc()的第一个参数传入空指针合法吗？你为什么要这样做？　89
7．35　calloc()和malloc()有什么区别？应该用哪一个？利用calloc 的零填充功能安全吗？free()可以释放calloc()分配的内存吗，还是需要一个cfree()？　 90
7．36　alloca是什么？为什么不提倡使用它？　91
第8章　字符和字符串　92
8．1　为什么strcat(string， '!'); 不行？　92
8．2　我想检查一个字符串是否跟某个值匹配。为什么这样不行？if(string == "value")　92
8．3　如果我可以写char a[] = "Hello， world!"; 那为什么不能写char a[14]; a = "Hello， world!";　93
8．4　为什么我的strcat 不行？我试了char *s1="Hello，"; char *s2="world!"; char *s3　=strcat(s1， s2);可得到的结果很奇怪。　93
8．5　char a[]= "string literal"; 和char *p= "string literal"; 初始化有什么区别？当我对p[i]赋值的时候，程序崩溃了。　93
8．6　我怎么得到与字符相对应的数字(即ASCII 或其他字符集下的)值？反过来又该怎么做？　94
8．7　C语言有类似其他语言的"substr"(提取子串)这样的函数吗？　94
8．8　我将用户键入的字符串读入数组，然后再显示出来。当用户键入\n这样的序列时，为什么不能正确处理呢？　94
8．9　我注意到sizeof('a')是2而不是1(即不是sizeof(char))，是不是我的编译器有问题？　94
8．10　我正开始考虑多语言字符集的问题。是否有必要担心sizeof(char)会被定义为2，以便表达16位的字符集呢？　95
第9章　布尔表达式和变量　96
9．1　C语言中布尔值该用什么类型？为什么它不是一个标准类型？我应该用#define或enum定义真值和假值吗？　96
9．2　既然在C 语言中所有的非零值都被看作“真”，那是不是把TRUE 定义为1很危险？如果某个内建的函数或关系操作符“返回”不是1的其他值怎么办？　 97
9．3　当p是指针时，if(p)是合法的条件表达式吗？　98
9．4　我该使用像TRUE和FALSE这样的符号名称还是直接用1和0来作布尔常量？　98
9．5　我准备使用的一个第三方头文件定义了自己的TRUE和FALSE，它们跟我已经开发的部分不兼容。我该怎么办？　98
第10章　C预处理器　99
宏定义　99
10．1　我想定义一些函数式的宏，例如：#define square(x)x * x但它们并不总是正确的。为什么？　99
10．2　这里有一些的预处理宏，使用它们，我可以写出更像Pascal的C代码。你觉得怎么样？　100
10．3　怎么写一个交换两个值的通用宏？　 101
10．4　书写多语句宏的最好方法是什么？　 101
10．5　用typdef和预处理宏生成用户定义类型有什么区别？　102
头文件　102
10．6　我第一次把一个程序分成多个源文件，我不知道该把什么放到．c文件，把什么放到．h文件。(“．h”到底是什么意思？)　102
10．7　可以在一个头文件中包含另一头文件吗？　103
10．8　完整的头文件搜索规则是怎样的？　 104
10．9　我在文件的第一个声明就遇到奇怪的语法错误，但是看上去没什么问题。　104
10．10　我使用了来自两个不同的第三方库的头文件，它们都定义了相同的宏，如TRUE、FALSE、Min()和Max()等，但是它们的定义相互冲突，而且跟我在自己的头文件中的定义也有冲突。我该怎么办？　104
10．11　我在编译一个程序，看起来我好像缺少需要的一个或多个头文件。谁能发给我一份？　105
条件编译　 105
10．12　怎样构造比较字符串的#if预处理表达式？　105
10．13　sizeof操作符可以用在#if预处理指令中吗？　106
10．14　我可以像这样在#define行里使用#ifdef来定义两个不同的东西吗？　106
10．15　对typedef的类型定义有没有类似#ifdef的东西？　106
10．16　我如何用#if表达式来判断机器是高字节在前还是低字节在前？　107
10．17　为什么在我用#ifdef关掉的代码行中报出了奇怪的语法错误？　107
10．18　我拿到了一些代码，里边有太多的#ifdef。我不想使用预处理器把所有的#include 和#ifdef都扩展开，有什么办法只保留一种条件的代码呢？　107
10．19　如何列出所有的预定义宏？　107
奇异的处理　108
10．20　我有些旧代码，试图用这样的宏来构造标识符：#define Paste(a， b) a/**/b 但是现在不行了。为什么？　108
10．21　我有一个旧宏：#define CTRL(c) ('c' & 037)现在不能用了。为什么？　108
10．22　为什么宏#define TRACE(n) printf("TRACE： \%d\n"， n) 报出警告“macro replacement within a string literal ”？它似乎把TRACE(count);扩展成了printf("TRACE： \%d\count"， count);　109
10．23　如何在宏扩展的字符串字面量中使用宏参数？　109
10．24　我想用ANSI 的“字符串化”预处理操作符#将符号常量的值放入消息中，但它总是对宏名称而不是它的值进行字符串化。这是什么原因？　109
10．25　我想用预处理器做某件事情，但却不知道如何下手。　110
可变参数列表的宏　110
10．26　怎样写可变参数宏？如何用预处理器“关掉”具有可变参数的函数调用？　110
10．27　如何在通用的调试宏中包含__FILE__和__LINE__宏？　111
第11章　ANSI/ISO标准C　113
标准　113
11．1　什么是“ANSI C标准”？　113
11．2　如何得到一份标准的副本？　114
*11．3　我在哪里可以找到标准的更新？　115
函数原型　 115
11．4　为什么我的ANSI编译器对用float声明的参数会警告类型不匹配？　115
11．5　能否混用旧式的和新型的函数语法？　116
*11．6　为什么下述声明报出了一个奇怪的警告信息“Struct X declared inside parameter list”？ extern int f(struct x *p);　116
11．7　有个问题一直困扰着我，它是由这一行printf ("%d"， n); 导致的，因为n是个long int型。难道 ANSI 的函数原型不能检查这种函数的参数不匹配问题吗？　116
11．8　我听说必须在调用printf之前包含stdio．h。为什么？　117
const 限定词　117
11．9　为什么不能在初始化和数组维度中使用const值？例如const int n = 5; int a[n];　117
11．10 “const char *p”、“char const *p ”和“char * const p ”有何区别？　117
11．11　为什么不能向接受const char ** 的函数传入char **？　118
11．12　我这样声明：typedef char * charp; const charp p; 为什么是p而不是它所指向的字符为const？　 118
main()函数的使用　119
11．13　能否通过将main声明为void来关掉“main没有返回值”的警告？　119
11．14　main()的第3个参数envp是怎么回事？　 120
11．15　我觉得把main()声明为void也不会失败，因为我调用了exit()而不是return，况且我的操作系统也忽略了程序的退出/返回状态。　120
*11．16　那么到底会出什么问题？真的有什么系统不支持void main()吗？　120
11．17　为什么以前流行的那些C 语言书总是使用void main()？　 120
11．18　在main()中调用exit(status)和返回同样的status真的等价吗？　121
预处理功能　121
11．19　我试图用ANSI“字符串化”预处理操作符'#'向信息中插入符号常量的值，但它字符串化的总是宏的名字而不是它的值。为什么？　121
11．20　警告信息“warning： macro replacement within a string literal”是什么意思？　121
11．21　为什么在我用#ifdef去掉的代码里出现了奇怪的语法错误？　122
11．22　#pragma是什么，有什么用？　122
11．23　“#pragma once”什么意思？我在一些头文件中看到了它。　122
其他的ANSI C 问题　123
11．24　char a[3] = "abc";合法吗？它是什么意思？　123
11．25　既然对数组的引用会退化为指针，那么，如果array是数组，array和&array之间有什么区别呢？　123
11．26　为什么我不能对void *指针进行算术运算？　123
11．27　memcpy()和memmove() 有什么区别？　124
11．28　malloc(0)有什么用？返回一个空指针还是指向0字节的指针？　124
11．29　为什么ANSI 标准规定了外部标识符的长度和大小写限制？　125
11．30　noalias是怎么回事？在它身上发生了什么？　125
老的或非标准的编译器　125
11．31　为什么我的编译器对最简单的测试程序都报出了一大堆的语法错误？对这段代码的第一行就报错了：main(int argc． char **argv) { return0; }　125
11．32　为什么有些 ASNI/ISO 标准库函数未定义？我明明使用的就是ANSI 编译器。　126
11．33　谁有可以在旧的C 程序和ANSI C 之间相互转换的工具，或者自动生成原型的工具？　127
11．34　为什么声称兼容ANSI 的编译器不能编译这些代码？我知道这些代码是 ANSI 的，因为gcc 可以编译。　127
兼容性　127
11．35　人们好像有些在意实现定义的(implementation-defined)、不确定的(unspecified)和未定义的(undefined) 行为的区别。它们的区别到底在哪里？　128
*11．36　一个程序“合法(legal)”、“有效(valid)”或“符合标准的”(conforming )到底是什么意思？　128
11．37　我很吃惊，ANSI 标准竟然有那么多未定义的东西。标准的唯一任务不就是让这些东西标准化吗？　129
11．38　有人说i=i++的行为是未定义的，但是我刚在一个兼容ANSI 的编译器上测试，得到了我希望的结果。它真的是未定义的吗？　129
第12章　标准输入输出库　130
基本输入输出　130
12．1　这样的代码有什么问题？char c; while((c = getchar()) != EOF)　130
12．2　我有个读取直到EOF的简单程序，但是我如何才能在键盘上输入那个“\EOF”呢？我看stdio．h 中定义的EOF 是-1，是不是说我该输入-1？　　131
12．3　为什么这些代码把最后一行复制了两遍？while(!feof(infp)){fgets(buf， MAXLINE， infp); fputs(buf， outfp);}　131
12．4　我用fgets将文件的每行内容读入指针数组。为什么结果所有的行都是最后一行的内容呢？　132
12．5　我的程序的屏幕提示和中间输出有时没有在屏幕上显示，尤其是当我用管道通过另一个程序输出的时候。为什么？　132
12．6　我怎样才能不等待回车键而一次输入一个字符？　132
printf格式　132
12．7　如何在printf 的格式串中输出一个'%'字符？我试过\%，但是不行。　132
12．8　为什么这么写不对？long int n = 123456; printf("%d\n"， n);　133
12．9　有人告诉我不能在printf 中使用%lf。为什么printf() 用%f输出double 型，而scanf 却用%lf 呢？　133
*12．10　对于size_t 那样的类型定义，当我不知道它到底是long 还是其他类型的时候，我应该使用什么样的printf格式呢？　134
12．11　如何用printf 实现可变的域宽度？就是说，我想在运行时确定宽度而不是使用%8d？　134
12．12　如何输出在千位上用逗号隔开的数字？货币格式的数字呢？　135
12．13　为什么scanf("%d"， i) 调用不行？　136
*12．14　为什么char s[30]; scamf("%s"， s); 不用&也可以？我原以为传给scanf的每个变量都要带&。　136
12．15　为什么这些代码不行？double d; scanf("%f"， &d);　136
12．16　为什么这段代码不行？short int s; scanf("%d"， &s);　136
12．17　怎样在scanf 格式串中指定可变的宽度？　 136
12．18　怎样从特定格式的数据文件中读取数据？怎样读入10个float 而不用使用包含10次%f的奇怪格式？如何将一行的任意多个域读入一个数组中？　137
scanf问题　138
12．19　我像这样用"%d\n"调用scanf 从键盘读取数字：int n; scanf("%d\n"，&n); printf("you typed %d\ n"， n);好像要多输入一行才返回。为什么？　138
12．20　我用scanf 和%d读取一个数字，然后再用gets() 读取字符串，但是编译器好像跳过了gets() 调用！　 139
12．21　我发现如果坚持检查返回值以确保用户输入的是我期待的数值，则scanf 的使用会安全很多。但有的时候好像会陷入无限循环。为什么？　139
12．22　为什么大家都说不要使用scanf？那我该用什么来代替呢？　140
其他stdio 函数　141
12．23　我怎样才知道对于任意的sprintf 调用需要多大的目标缓冲区？怎样才能避免sprintf 目标缓冲区溢出？　141
12．24　sprintf的返回值是什么？是int 还是char *？　142
12．25　为什么大家都说不要使用gets？　　142
12．26　我觉得我应该在一长串的printf 调用之后检查errno ，以确定是否有失败的调用。为什么当我将输出重定向到文件的时候会输出奇怪的“printf failed： Not a typewriter ”信息？　142
12．27　fgetops/fsetops和ftell/fseek之间有什么区别？fgetops和fsetops 到底有什么用处？　143
12．28　如何清除用户的多余输入，以防止在下一个提示符下读入？用fflush(stdin) 可以吗？　143
打开和操作文件　144
12．29　我写了一个函数用来打开文件：myfopen(char *filename， FILE *fp){fp = fopen(filename， "r");}可我这样调用的时候：FILE *infp; myfopen("filename．dat"， infp);，infp 指针并
没有正确设置。为什么？　144
12．30　连一个最简单的fopen调用都不成功！这个调用有什么问题？FILE *fp = fopen(filename， 'r');　145
12．31　为什么我不能用完整路径名打开一个文件？这个调用总是失败：fopen("c：\newdir\ file． dat"， "r");　145
12．32　我想用fopen模式"r+"打开一个文件，读出一个字符串，修改之后再写入，从而就地更新一个文件。可是这样不行。为什么？　145
12．33　如何在文件中间插入或删除一行(一条记录)？　145
12．34　怎样从打开的流中恢复文件名？　145
重定向stdin 和stdout　 146
12．35　怎样在程序里把stdin或stdout重定向到文件？　146
12．36　一旦使用freopen之后，怎样才能恢复原来的stdout (或stdin)？　146
12．37　如何判断标准输入或输出是否经过了重定向，即是否在命令行上使用了“”或“”？　147
12．38　我想写个像"more"那样的程序。怎样才能在stdin 被重定向之后再回到交互键盘？　147
*12．39　怎样同时向两个地方输出，如同时输出到屏幕和文件？　147
“二进制”输入输出　148
12．40　我希望按字节在内存和文件之间直接读写数字，而不像fprintf和fscanf进行格式化。我该怎么办？　148
12．41　怎样正确地读取二进制文件？有时看到0x0a和0x0d容易混淆，而且如果数据中包含0x1a的话，我好像会提前遇到EOF。　148
12．42　我在写一个二进制文件的“过滤器”，但是stdin和stdout却被作为文本流打开了。怎样才能把它们的模式改为二进制？　148
12．43　文本和二进制输入输出有什么区别？　149
12．44　如何在数据文件中读写结构？　149
12．45　怎样编写符合旧的二进制数据格式的代码？　149
第13章　库函数　151
字符串函数　151
13．1　怎样把数字转为字符串(与atoi相反)？有itoa函数吗？　151
13．2　为什么strncpy不能总在目标串放上终止符'\0'？　152
13．3　C 语言有类似于其他语言中的“substr ”(取出子串)的例程吗？　152
13．4　怎样把一个字符串中所有字符转换成大写或小写？　153
13．5　为什么有些版本的toupper对大写字符会有奇怪的反应？为什么有的代码在调用toupper 前先调用islower？　153
13．6　怎样将字符串分割成用空白分隔的字段？怎样实现类似main 处理argc和argv的过程？　153
13．7　哪里可以找到处理正则表达式或通配符匹配的代码？　155
排序　156
13．8　我想用strcmp作为比较函数，调用qsort对一个字符串数组排序，但是不行。为什么？　156
13．9　我想用qsort()对一个结构数组排序。我的比较函数接受结构指针，但是编译器认为这个函数不是qsort需要的类型。我要怎样转换这个函数指针才能避免这样的警告？　156
13．10　怎样对一个链表排序？　158
13．11　怎样对大于内存容量的数据排序？　158
日期和时间　159
13．12　怎样在C 程序中取得当前日期或时间？　159
13．13　我知道库函数localtime可以把time_t转换成结构struct tm，而ctime可以把time_t转换成为可打印的字符串。怎样才能进行反向操作，把struct tm或一个字符串转换成time_t？　 159
13．14　怎样在日期上加n天？怎样取得两个日期的时间间隔？　160
随机数　162
13．15　怎么生成一个随机数？　162
13．16　怎样获得某一范围内的随机整数？　163
13．17　每次执行程序，rand都返回相同的数字序列。为什么？　164
13．18　我需要随机的真/假值，所以我就直接用rand()%2，可是我得到交替的0， 1， 0， 1， 0 …。为什么？　164
13．19　如何获取根本不重复的随机数？　165
13．20　怎样产生正态分布或高斯分布的随机数？　 165
13．21　我在移植一个程序，里边调用了一个函数drand48　，而我的库又没有这个。这是个什么函数？　167
其他库函数　168
13．22　exit(status)是否真的跟从main 函数返回status 等价？　168
13．23　memcpy和memmove 有什么区别？　168
13．24　我想移植这个旧程序。为什么报出这些“undefined external”错误：index? 、rindex?、bcopy?、bcmp?、bzero?？　 168
13．25　我不断得到库函数未定义错误，但是我已经包含了所有用到的头文件了。　168
13．26　虽然我在连接时明确地指定了正确的函数库，我还是得到库函数未定义错误。　168
13．27　一个最简单的程序，不过在一个窗口里打印出“Hello，World”，为什么会编译出巨大的可执行代码(数百K)？我该少包含一些头文件吗？　169
13．28　连接器报告_end未定义代表什么意思？　169
*13．29　我的编译器提示printf未定义！这怎么可能？　169
第14章　浮点运算　170
14．1　一个float变量赋值为3．1时，为什么printf输出的值为3．0999999？　170
14．2　我想计算一些平方根，我把程序简化成这样：main(){printf ("%f\h"， sqrt(144．)); 可得到的结果却是疯狂的数字。为什么？　170
14．3　我想做一些简单的三角函数运算，也包含了math．h ，但连接器总是提示sin、cos这样的函数未定义。为什么？　171
14．4　我的浮点数计算程序表现得很奇怪，在不同的机器上给出了不同的结果。为什么？　171
14．5　有什么好的方法来检查浮点数在“足够接近”情况下的相等？　171
14．6　怎样取整？　172
14．7　为什么C语言不提供乘幂的操作符？　173
14．8　为什么我机器上的math．h没有预定义常量M_PI？　173
14．9　怎样将变量置为IEEE NaN(“Not a Number”)或检测变量是否为NaN及其他特殊值？　173
14．10　如何简洁地处理浮点异常？　174
14．11　在C语言中如何很好地实现复数？　174
14．12　我要寻找一些实现以下功能的程序源代码：快速傅立叶变换(FFT)、矩阵算术(乘法、求逆等函数)、复数算术。　175
14．13　Turbo C的程序崩溃，显示错误为“floating point formats not linked”(浮点格式未连接)。我还缺点儿什么呢？　175
第15章　可变参数列表　176
调用变参函数　176
15．1　为什么调用printf前必须要包含stdio．h？　 176
15．2　为什么%f可以在printf参数中同时表示float和double？它们难道不是不同类型吗？　177
15．3　我遇到了一个令人十分受挫的问题，后来发现是这行代码造成的：printf("%d"， n);原来n 是longint型。难道ANSI的函数原型不就是用来防止这类的参数类型不匹配吗？　177
15．4　怎样写一个接受可变参数的函数？　 177
15．5　怎样写一个函数，像printf那样接受一个格式串和可变参数，然后再把参数传给printf去完成大部分工作？　180
15．6　怎样写类似scanf的函数，再把参数传给scanf去完成大部分工作？　180
15．7　我用的是ANSI前的编译器，没有stdarg．h文件。我该怎么办？　181
提取可变参数　182
15．8　怎样知道实际上有多少个参数传入函数？　182
15．9　为什么编译器不允许我定义一个没有固定参数项的可变参数函数？　182
15．10　我有个接受float型的变参函数，为什么va_arg(argp， float)却不行？　183
15．11　为什么va_arg不能得到类型为函数指针的参数？　183
困难的问题　184
15．12　怎样实现一个可变参数函数，它把参数再传给另一个可变参数函数？　184
15．13　怎样调用一个在运行时才构建参数列表的函数？　186
第16　章 奇怪的问题　187
16．1　为什么这个循环只执行了一次？for(i=start;i end ; i ++);{printf("%d\n"，i);}　187
*16．2　遇到不可理解的不合理语法错误，似乎大段的程序没有编译。　187
*16．3　为什么过程调用不起作用？编译器似乎直接跳过去了。　187
16．4　程序在执行之前就崩溃了！(用调试器单步跟踪，在main函数的第一个语句之前就死了。)为什么？　188
16．5　程序执行正确，但退出时在main函数的最后一个语句之后崩溃了。为什么会这样？　188
16．6　程序在一台机器上运行完美，但在另一台上却得到怪异的结果。更奇怪的是，增加或去除调试的打印语句，就改变了症状……　188
16．7　为什么下面的代码会崩溃？char *p = "hello， world!"; p[0] = 'H';　189
16．8　我有些代码是用来解析外部结构的，但它却崩溃了，报了“unaligned access ”(未对齐的访问)错误。这是什么意思？　190
16．9　“Segmentation violation”、“Bus error”和“General protection fault”是什么意思？　191
第17章　风格　 192
17．1　什么是C最好的代码布局风格？　192
17．2　如何在源文件中合理分配函数？　193
17．3　用if(!strcmp(s1， s2))比较两个字符串是否相等是个好风格吗？　193
17．4　为什么有的人用if(0== x)而不是if(x== 0)？　193
17．5　为什么有些代码在每次调用printf 前增加了类型转换(void)？　194
17．6　既然NULL和0都是空指针常量，我到底该用哪一个？　194
17．7　是该用TRUE和FALSE这样的符号名称还是直接用1和0来作布尔常量？　194
17．8　什么是“匈牙利表示法”(Hungarian Notation )？是否值得一试？　194
17．9　哪里可以找到“Indian Hill Style Guide ”及其他编码标准？　194
17．10　有人说goto是邪恶的，永远都不该用它。这是否太极端了？　195
17．11　人们总是说良好的风格很重要，但当他们使用良好的风格写出清晰易读的程序后，又发现程序的效率似乎降低了。既然效率那么重要，是否可以为了效率牺牲一些风格和可读性呢？　196
第18章　工具和资源　197
18．1　能否列一个常用工具列表？　197
18．2　怎样捕获棘手的malloc问题？　198
18．3　有什么免费或便宜的编译器可以使用？　198
lint　198
18．4　刚刚输入完一个程序，但它表现得很奇怪。你能发现有什么错误的地方吗？　199
18．5　如何关掉lint对每个malloc调用报出的“warning： possible pointer alignment problem”警告消息？　199
18．6　哪里可以找到兼容ANSI的lint？　199
18．7　难道ANSI函数原型说明没有使lint过时吗？　199
资源　200
18．8　网上有哪些C语言的教程或其他资源？　200
*18．9　哪里可以找到好的源代码实例，以供研究和学习？　201
18．10　有什么好的学习C语言的书？有哪些高级的书和参考？　201
18．11　哪里能找到K&R的练习答案？　201
18．12　哪里能找到Numerical Recipes in C 、Plauger的The Standard C Library或Kernighan和Pike的The UNIX Programming Enviroment等书里的源码？　201
18．13　哪里可以找到标准C函数库的源代码？　202
18．14　是否有一个在线的C参考指南？　202
18．15　我需要分析和评估表达式的代码。从哪里可以找到？　202
18．16　哪里可以找到C的BNF或YACC语法？　 202
*18．17　谁有C编译器的测试套件？　203
*18．18　哪里有一些有用的源代码片段和例子的收集？　203
*18．19　我需要执行多精度算术的代码。　203
18．20　在哪里和怎样取得这些可自由发布的程序？　203
第19章　系统依赖　205
键盘和屏幕I/O　205
19．1　怎样从键盘直接读入字符而不用等回车键？怎样防止字符输入时的回显？　205
19．2　怎样知道有未读的字符(如果有，有多少)？另外，如何在没有字符的时候不阻塞读入？　209
19．3　怎样显示一个在原地更新自己的百分比或“旋转棒”的进度指示器？　209
19．4　怎样清屏？怎样反色输出？怎样把光标移动到指定的x， y位置？　210
19．5　怎样读入方向键、功能键？　210
其他I/O　211
19．6　怎样读入鼠标输入？　211
19．7　怎样做串口(“comm”)的输入输出？　211
19．8　怎样直接输出到打印机？　211
19．9　怎样发送转义字符序列控制终端或其他设备？　211
19．10　怎样做图形？　212
*19．11　怎样显示GIF和JPEG图像？　212
文件和目录　212
19．12　怎样检验一个文件是否存在？如果请求的输入文件不存在，我希望向用户提出警告。　212
19．13　怎样在读入文件前，知道文件大小？　213
*19．14　怎样得到文件的修改日期和时间？　213
19．15　怎样原地缩短一个文件而不用清除或重写？　213
19．16　怎样在文件中插入或删除一行(或一条记录)？　214
19．17　怎样从一个打开的流或文件描述符得到文件名？　214
19．18　怎样删除一个文件？　214
*19．19　怎样复制文件？　215
19．20　为什么用了详尽的路径还不能打开文件？下面的代码会返回错误。Fopen("c：\newdir\file．dat"， "r")　215
*19．21　fopen不让我打开文件"$HOME/．profile"和"~/．myrcfile"。　215
*19．22　怎样制止MS-DOS下令人恐怖的“Abort，Retry，Ignore? ”信息？　215
19．23　遇到“Too many open files(打开文件太多)”的错误，怎样增加同时打开文件的允许数目？　215
19．24　如何得到磁盘的可用空间大小？　216
19．25　怎样在C语言中读入目录？　216
19．26　如何创建目录？如何删除目录(及其内容)？　217
访问原始内存　217
19．27　怎样找出系统还有多少内存可用？　217
19．28　怎样分配大于64K的数组或结构？　217
19．29　错误信息“DGROUP data allocation exceeds 64K(DGROUP 数据分配内存超过64K)”什么意思？我应该怎么做？我以为使用了大内存模型，就可以使用大于64K的数据！　217
19．30　怎样访问位于某特定地址的内存(内存映射的设备或图形显示内存)？　218
19．31　如何访问机器地址0处的中断向量？如果将指针设为0，编译器可能把它转成一个非零的内部空指针值。　218
“系统”命令　219
19．32　怎样在一个C程序中调用另一个程序(独立可执行的程序或系统命令)？　219
19．33　如果运行时才知道要执行的命令的参数(文件名等)，应该如何调用system？　219
19．34　在MS-DOS上如何得到system返回的准确错误状态？　220
19．35　怎样调用另一个程序或命令，然后获取它的输出？　220
进程环境　 220
19．36　怎样才能发现程序自己的执行文件的全路径？　220
19．37　怎样找出和执行文件在同一目录的配置文件？　221
19．38　进程如何改变它的调用者的环境变量？　221
19．39　如何打开命令行给出的文件并解析选项？　 221
19．40　exit(status)是否真的和从main函数返回同样的status等价？　221
19．41　怎样读入一个对象文件并跳跃到其中的函数？　221
其他系统相关的操作　222
19．42　怎样以小于1秒的精度延时或计算用户响应时间？　222
19．43　怎样捕获或忽略control-C这样的键盘中断？　222
19．44　怎样简洁地处理浮点异常？　223
19．45　怎样使用socket？如何联网？如何写客户/服务器程序？　223
*19．46　怎样调用BIOS函数？如何写ISR？如何创建TSR？　 224
*19．47　什么是“near”和“far”指针？　224
回顾　224
19．48　我不能使用这些非标准、依赖系统的函数，程序需要兼容ANSI!　224
19．49　为什么这些内容没有在C语言中进行标准化？任何现实程序都会用到这些东西。　224
第20章　杂项　226
20．1　怎样从函数返回多个值？　226
20．2　用什么数据结构存储文本行最好？我开始用固定大小的char型数组的数组，但是有很多局限。　227
20．3　怎样打开命令行提到的文件并处理参数？　229
20．4　如何正确地使用errno？　231
20．5　怎样写数据文件，使之可以在不同字大小、字节顺序或浮点格式的机器上读入？　232
20．6　怎样用char *指针指向的函数名调用函数？　232
位和字节　 233
20．7　如何操作各个位？　233
20．8　怎样实现位数组或集合？　234
20．9　怎样判断机器的字节顺序是高字节在前还是低字节在前？　235
*20．10　怎样调换字节？　236
20．11　怎样将整数转换到二进制或十六进制？　237
20．12　可以使用二进制常数(类似0b101010这样的东西)吗？printf有二进制的格式说明符吗？　237
效率　238
20．13　用什么方法计算整数中为1的位的个数最高效？　238
20．14　怎样提高程序的效率？　238
20．15　指针真的比数组快吗？函数调用会拖慢程序多少？++i比i=i+1快吗？　240
20．16　用移位操作符替换乘法和除法是否有价值？　240
*20．17　人们说编译器优化得很好，我们不再需要为速度而写汇编了，但我的编译器连用移位代替i/=2都做不到。　240
*20．18　怎样不用临时变量而交换两个值？　241
switch 语句　241
20．19　switch语句和if/else链哪个更高效？　241
20．20　是否有根据字符串进行条件切换的方法？　241
20．21　是否有使用非常量case行标的方法(如范围或任意的表达式)？　242
各种语言功能　243
20．22　return语句外层的括号是否真的可选择？　 243
20．23　为什么C语言的注释不能嵌套？怎样注释掉含有注释的代码？引号包含的字符串内的注释是否合法？　243
20．24　为什么C语言的操作符不设计得更全面一些？好像还缺了一些^^、&&=和-=这样的操作符。　244
*20．25　C语言有循环移位操作符吗？　244
*20．26　C是个伟大的语言还是别的什么东西？哪个其他语言可以写出像a+++++b这样的代码？　244
20．27　如果赋值操作符是：=，是不是就不容易意外地写出if(a=b)了？　245
20．28　C语言有和Pascal 的with等价的语句吗？　245
20．29　为什么C语言没有嵌套函数？　245
*20．30　assert是什么？如何使用？　246
其他语言　 246
20．31　怎样从C中调用FORTRAN(C++、BASIC、Pascal、Ada、LISP)的函数？反之如何？　246
20．32　有什么程序可以将Pascal或FORTRAN(或LISP、Ada、awk、“老”C)程序转化为C程序？　246
20．33　C++是C的超集吗？可以用C++编译器来编译C代码吗？　247
20．34　我需要用到“近似”的strcmp例程，比较两个字符串的近似度，并不需要完全一样。有什么好办法？　247
20．35　什么是散列法？　248
20．36　如何生成正态或高斯分布的随机数？　248
20．37　如何知道某个日期是星期几？　249
20．38　(year % 4== 0)是否足以判断闰年？2000年是闰年吗？　250
20．39　为什么tm结构中的tm_sec的范围是0到61，暗示一分钟有62秒？　250
琐事　250
20．40　一个难题：怎样写一个输出自己源代码的程序？　250
20．41　什么是“达夫设备”(Duff’s Device)？　 251
20．42　下届国际C语言混乱代码竞赛(International Obfuscated C Code Contest，IOCCC)什么时候进行？哪里可以找到当前和以前的获胜代码？　251
20．43　K&R1提到的关键字entry是什么？　252
20．44　C的名字从何而来？　252
20．45　“char”如何发音？　252
*20．46　“lvalue”和“rvalue”代表什么意思？　252
20．47　哪里可以获得本书的在线版？　252
术语表　253
参考文献　261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你必须知道的495个C语言问题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言解惑
第1章　操作符　1
谜题1．1　基本算术操作符　1
谜题1．2　赋值操作符　6
谜题1．3　逻辑操作符和增量操作符　10
谜题1．4　二进制位操作符　16
谜题1．5　关系操作符和条件操作符　23
谜题1．6　操作符的优先级和求值顺序　27
第2章　基本类型　33
谜题2．1　字符、字符串和整数类型　33
谜题2．2　整数和浮点数的转换　37
谜题2．3　其他类型的转换　43
第3章　头文件　49
第4章　控制流　51
谜题4．1　if语句　51
谜题4．2　while和for语句　57
谜题4．3　语句的嵌套　62
谜题4．4　switch、break和continue语句　67
第5章　编程风格　73
谜题5．1　选用正确的条件　73
谜题5．2　选用正确的结构　76
第6章　存储类　81
谜题6．1　块　81
谜题6．2　函数　85
谜题6．3　更多的函数　89
谜题6．4　文件　94
第7章　指针和数组　99
谜题7．1　简单的指针和数组　99
谜题7．2　指针数组　105
谜题7．3　多维数组　110
谜题7．4　难解的指针　113
第8章　结构　119
谜题8．1　简单的结构、嵌套结构　119
谜题8．2　结构数组　124
谜题8．3　结构指针数组　131
第9章　预处理器　139
谜题9．1　C语言的预处理器的宏命令替换功能　139
谜题9．2　宏的副作用　145
附录　149
附录A　操作符优先级表　149
附录B　操作符汇总表　150
附录C　ASCII字符表　153
附录D　类型转换表　154
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言解惑
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言编程新手自学手册
丛书序前言    第一篇  基础篇第1章  C语言概述  1.1  C语言发展史  1.2  C语言的特点  1.3  C语言编译器  1.4  安装Turbo C 3.0  1.5  Turbo C/C++ 3.0集成开发环境介绍    1.5.1  文件菜单（File）    1.5.2  编辑菜单（Edit）    1.5.3  运行菜单（Run）    1.5.4  编译菜单（Compile）    1.5.5  项目菜单（Project）    1.5.6  调试菜单（Debug）  1.6  进行C语言程序开发的步骤    1.6.1  编辑源代码    1.6.2  编译    1.6.3  链接    1.6.4  运行  1.7  一个简单的C语言程序  1.8  C语言程序的结构    1.8.1  C程序组成部分    1.8.2  C程序格式总结  1.9  疑难问题解析  职场点拨——C语言的地位第2章  算法和数据类型第3章  运算符和表达式第4章  C语句和数据的输入/输出第5章  流程控制第6章  数组和字符串第7章  函数第8章  指针    第二篇  核心技术篇第9章  结构体、共用体和枚举第10章  链表第11章  位运算第12章  预编译处理    第三篇  提高篇第13章  文件操作处理第14章  错误和程序调试第15章  C语言高级编程技术    第四篇  综合实战篇第16章  俄罗斯方块游戏第17章  Ping网络项目设计第18章  学生成绩管理系统参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言编程新手自学手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>阿尔法经济学
第1章 市场的魔力/ 1
1.1 市场的社会价值/ 1
1.2 联合均衡问题/ 4
1.3 市场有效性意味着什么？/ 6
1.4 市场有效性的一个形象类比/ 11
1.5 均衡条件下存在错误定价吗？/ 12
1.6 有成本的信息套利/ 16
1.7 对市场有效性“近似成立”的辩护/ 17
1.8 小结/ 22
第2章 噪声交易者模型： 能否替代有效市场假说/ 25
2.1 综述/ 26
2.2 席勒模型/ 29
2.3 金融市场的噪声交易者模型/ 34
2.4 对金融市场研究的启示/ 39
2.5 研究设计/ 43
2.6 小结/ 46
第3章 噪声交易与投资者情绪/ 49
3.1 投资者情绪与套利成本/ 52
3.2 什么驱动了股票价格？/ 53
3.3 关于投资者情绪的早期研究/ 56
3.4 行为学基础： 投资者情绪的来源/ 60
3.5 资本流动与股票收益/ 65
3.6 投资者群体与系统性噪声/ 69
3.7 度量投资者情绪/ 75
3.8 公司层面情绪/ 78
3.9 投资者的心情与情感/ 80
3.10 小结/ 84
附录 当市场存在噪声下管理层的决策/ 85
第4章 度量公司价值： 基本面分析的作用/ 87
4.1 综述/ 87
4.2 量化投资者——本杰明·格雷厄姆/ 89
4.3 简单的理论模型/ 93
4.4 价值投资的两个要素/ 98
4.5 来自业界的启示/ 99
4.6 学术研究中的实证证据/ 102
4.7 价值投资为何持续有效？/ 111
4.8 小结/ 119
附录 乔尔·格林布拉特的神奇公式/ 120
第5章 套利成本/ 123
5.1 精明投资者眼中的市场/ 127
5.2 制定交易策略/ 130
5.3 复杂度对错误定价的影响/ 136
5.4 策略的执行与实施成本/ 146
5.5 筹资和融资限制/ 150
5.6 小结/ 156
第6章 研究方法论： 资产收益的可预测性/ 159
6.1 对风险因子的暴露/ 160
6.2 区分风险补偿和错误定价/ 164
6.3 短窗口期收益/ 167
6.4 其他非收益率指标/ 169
6.5 分期间和分样本/ 170
6.6 退市偏差和幸存者偏差/ 172
6.7 规模、流动性与策略可行性/ 173
6.8 评估经济显著性/ 175
6.9 检验统计显著性/ 177
6.10 长窗口期收益/ 179
6.11 对学术研究的增量贡献/ 181
6.12 小结/ 183
参考文献/ 185
术语中英对照/ 217
致谢/ 223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>阿尔法经济学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++面向对象程序设计
第1章  面向对象编程原理第2章  C++入门第3章  符号、表达式和控制结构第4章  C++中的函数第5章  类和对象第6章  构造函数和析构函数第7章  运算符重载和类型转换第8章  继承：类的扩展第9章  指针、虚函数和多态第10章  控制台的输入输出操作第11章  文件操作第12章  模板第13章  异常处理第14章  标准模板库介绍第15章  操作字符串第16章  标准C++的新特性第17章  面向对象系统的开发附录A  项目程序附录B  使用Turbo C++附录C  Windows环境下执行C++附录D  标准C++的关键词列表附录E  C++运算符的优先级附录F  C++和面向对象编程重要术语附录G  C++自测参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++面向对象程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ 程序设计教程
第一部分 C++过程化语言基础
第1章 C++入门
第2章 基本数据类型与输入输出
第3章 表达式和语句
第4章 过程化语句
第5章 函数
第6章 程序结构
第7章 数组
第8章 指针
第9章 引用
第10章 结构
第二部分 面向对象程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++ 程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C与C++ 一线开发实践
第1章  Linux概述 1
1.1  什么是Linux 1
1.2  Linux的简史 2
1.3  Linux和Windows的比较 4
1.4  Linux主要应用领域 4
1.5  Linux的版本 5
1.6  使用哪个版本的Linux进行学习 5
1.7  Linux的特点 5
1.8  如何学习Linux 6
1.9  命令行还是图形界面 6
1.10  计算机启动的基本过程 6
1.10.1  按下电源 7
第1章  Linux概述 1
1.1  什么是Linux 1
1.2  Linux的简史 2
1.3  Linux和Windows的比较 4
1.4  Linux主要应用领域 4
1.5  Linux的版本 5
1.6  使用哪个版本的Linux进行学习 5
1.7  Linux的特点 5
1.8  如何学习Linux 6
1.9  命令行还是图形界面 6
1.10  计算机启动的基本过程 6
1.10.1  按下电源 7
1.10.2  BIOS自检 7
1.10.3  系统引导 8
1.10.4  实模式和保护模式 10
1.11  启动内核 11
1.12  认识Shell 11
1.13  常见的Shell 11
1.14  图形界面和字符界面的切换 12
1.14.1  在不退出X-Window的情况下切换到字符界面 12
1.14.2  强行退出X-Window进入文本模式 12
1.14.3  设置每次开机进入字符界面 13
1.14.4  从字符界面进入图形界面 14
1.15  Shell命令概述 14
1.16  环境变量 14
第2章  搭建Linux C 开发环境 16
2.1  准备Linux虚拟机 16
2.2  连接Linux虚拟机 20
2.2.1  通过桥接模式连接虚拟机 21
2.2.2  主机模式 24
2.2.3  通过NAT模式连接虚拟机 25
2.3  通过终端工具连接Linux虚拟机 27
2.4  搭建Linux下的C 开发环境 30
2.4.1  非集成开发方式 30
2.4.2  集成开发方式 31
2.5  搭建Windows下的Linux C 开发环境 37
2.5.1  搭建非集成式的Windows下的Linux C 开发环境 37
2.5.2  搭建集成式的Windows下的Linux C 开发环境 39
2.6  需要掌握的开发工具 49
2.7  vi编辑器的使用 50
2.7.1  vi编辑器概述 50
2.7.2  vi编辑器的工作模式 50
2.7.3  vi的基本操作 51
2.7.4  命令行模式下的基本操作 51
2.7.5  插入模式 55
2.7.6  末行模式操作 55
2.8  gcc编译器的使用 57
2.8.1  gcc对C语言的编译过程 57
2.8.2  gcc所支持的后缀名文件 62
2.8.3  gcc的语法格式 62
2.8.4  gcc常见选项 64
2.9  g 的基本使用 75
2.10  gdb调试器的使用 77
2.10.1  为何要学习gdb调试器 77
2.10.2  gdb简介 77
2.10.3  重要准备 77
2.10.4  启动gdb 77
2.10.5  退出gdb 78
2.10.6  gdb的常用命令概述 79
2.10.7  file命令加载程序 80
2.10.8  list命令显示源代码 80
2.10.9  run命令运行程序 83
2.10.10  break命令设置断点 85
第3章  C 语言基础 89
3.1  C 基础知识 89
3.1.1  C 程序结构 89
3.1.2  注释 91
3.1.3  变量和数据类型 92
3.1.4  标识 92
3.1.5  基本数据类型 93
3.1.6  变量的定义和C 11中的auto 94
3.1.7  变量的范围 98
3.1.8  变量初始化 98
3.1.9  常量 99
3.1.10  操作符/运算符 103
3.1.11  控制台交互 110
3.2  控制结构 115
3.2.1  条件结构 115
3.2.2  循环结构 116
3.2.3  分支控制和跳转 120
3.2.4  选择结构语句switch 122
3.3  函数 123
3.4  函数高级话题 127
3.4.1  参数按数值传递和按地址传递 127
3.4.2  函数重载 130
3.4.3  内联函数 131
3.4.4  递归 132
3.4.5  函数的声明 133
3.5  高级数据类型 134
3.5.1  数组 134
3.5.2  指针 145
3.5.3  动态分配内存 155
3.5.4  结构体 159
3.5.5  自定义数据类型 165
3.6  面向对象编程 168
3.6.1  类 168
3.6.2  构造函数和析构函数 171
3.6.3  构造函数重载 173
3.6.4  类的指针 175
3.6.5  由关键字struct和union定义的类 176
3.6.6  操作符重载 176
3.6.7  关键字 this 179
3.6.8  静态成员 180
3.6.9  类之间的关系 182
3.6.10  多态 189
3.7  C 面向对象小结 195
3.8  C 高级知识 199
3.8.1  模板 199
3.8.2  命名空间 205
3.8.3  异常处理 209
3.8.4  预处理指令 213
3.8.5  预定义宏 215
3.8.6  C 11中的预定义宏 216
3.9  字符串 218
3.9.1  字符串基础 218
3.9.2  搜索与查找 227
3.10  再论异常处理 233
3.10.1  基本概念 233
3.10.2  抛出异常 234
3.10.3  捕获异常 234
3.10.4  C 标准异常 235
3.10.5  定义新的异常 236
3.11  再论函数模板 237
3.12  字符集 239
3.12.1  计算机上的3种字符集 239
3.12.2  查看Linux系统的字符集 241
3.12.3  修改Linux系统的字符集 242
3.12.4  Unicode编码的实现 242
3.12.5  C运行时库对Unicode的支持 246
3.12.6  C 标准库对Unicode的支持 247
3.12.7  字符集相关实例 248
第4章  Linux文件编程 249
4.1  文件系统 249
4.1.1  基本概念 249
4.1.2  文件系统层次结构标准 249
4.2  文件的属性信息 250
4.3  i节点 251
4.3.1  基本概念 251
4.3.2  i节点的内容 251
4.3.3  i节点的使用状况 253
4.4  文件类型 254
4.4.1  普通文件 255
4.4.2  目录 255
4.4.3  块设备文件 256
4.4.4  字符设备文件 257
4.4.5  链接文件 257
4.5  文件权限 259
4.6  Linux文件I/O编程的基本方式 260
4.7  什么是I/O 260
4.8  Linux系统调用下的文件I/O编程 261
4.8.1  文件描述符 261
4.8.2  打开或创建文件 262
4.8.3  创建文件 263
4.8.4  关闭文件 264
4.8.5  读取文件中的数据 266
4.8.6  向文件写入数据 268
4.8.7  设定文件偏移量 269
4.8.8  获取文件状态 271
4.8.9  文件锁定 272
4.8.10  建立文件和内存映射 276
4.8.11  mmap和共享内存对比 279
4.9  C 方式下的文件I/O编程 280
4.9.1  流的概念 280
4.9.2  流的类库 280
4.9.3  打开文件 281
4.9.4  关闭文件 283
4.9.5  写入文件 283
4.9.6  读取文件 283
4.9.7  文件位置指针 285
4.9.8  状态标志符的验证 287
4.9.9  读写文件数据块 288
4.10  文件编程中的其他操作 290
4.10.1  获取文件有关信息 290
4.10.2  创建和删除文件目录项 293
第5章  多进程编程 296
5.1  进程的基本概念 296
5.2  进程的描述 296
5.2.1  进程的标识符 299
5.2.2  PID文件 301
5.3  进程的创建 303
5.3.1  使用fork创建进程 303
5.3.2  使用exec创建进程 305
5.3.3  使用system创建进程 311
5.4  进程调度 312
5.5  进程的分类 315
5.5.1  前台进程 315
5.5.2  后台进程 315
5.6  守护进程 316
5.6.1  守护进程的概念 316
5.6.2  守护进程的特点 317
5.6.3  查看守护进程 317
5.6.4  守护进程的分类 318
5.6.5  守护进程的启动方式 319
5.6.6  编写守护进程的步骤 319
第6章  Linux进程间的通信 323
6.1  信号 323
6.1.1  信号的基本概念 323
6.1.2  与信号相关的系统调用 328
6.2  管道 336
6.2.1  管道的基本概念 336
6.2.2  管道读写的特点 337
6.2.3  管道的局限性 337
6.2.4  创建管道函数pipe 338
6.2.5  读写管道函数read/write 338
6.2.6  等待子进程中断或结束的函数wait 338
6.2.7  使用管道的特殊情况 342
6.3  消息队列 342
6.3.1  创建和打开消息队列函数msgget 343
6.3.2  获取和设置消息队列的属性函数msgctl 343
6.3.3  将消息送入消息队列的函数msgsnd 344
6.3.4  从消息队列中读取一条新消息的函数msgrcv 345
6.3.5  生成键值函数ftok 346
第7章  C Web编程 354
7.1  CGI程序的工作方式 354
7.2  架设Web服务器Apache 354
第8章  多线程基本编程 358
8.1  使用多线程的好处 358
8.2  多线程编程的基本概念 359
8.2.1  操作系统和多线程 359
8.2.2  线程的基本概念 359
8.2.3  线程的状态 360
8.2.4  线程函数 361
8.2.5  线程标识 361
8.2.6  C 多线程开发的两种方式 361
8.3  利用POSIX多线程API函数进行多线程开发 362
8.3.1  线程的创建 362
8.3.2  线程的属性 367
8.3.3  线程的结束 379
8.3.4  线程退出时的清理机会 387
8.4  C 11中的线程类 392
8.4.1  线程的创建 393
8.4.2  线程的标识符 401
8.4.3  当前线程this_thread 402
第9章  多线程高级编程 406
9.1  多线程的同步和异步 406
9.2  线程同步 406
9.3  利用POSIX多线程API函数进行线程同步 411
9.3.1  互斥锁 411
9.3.2  读写锁 417
9.3.3  条件变量 424
9.4  C 11/14中的线程同步 431
9.5  线程池 434
9.5.1  线程池的定义 434
9.5.2  使用线程池的原因 435
9.5.3  用C 实现一个简单的线程池 435
第10章  Linux下的库 441
10.1  库的基本概念 441
10.2  库的分类 441
10.3  静态库 442
10.3.1  静态库的基本概念 442
10.3.2  静态库的创建和使用 442
10.4  动态库 445
10.4.1  动态库的基本概念 445
10.4.2  动态库的创建和使用 445
第11章  TCP/IP协议基础 450
11.1  什么是TCP/IP 450
11.2  TCP/IP协议的分层结构 450
11.3  应用层 453
11.3.1  DNS 454
11.3.2  端口的概念 454
11.4  传输层 455
11.4.1  TCP协议 455
11.4.2  UDP协议 456
11.5  网络层 456
11.5.1  IP协议 456
11.5.2  ARP协议 462
11.5.3  RARP协议 464
11.5.4  ICMP协议 465
11.6  数据链路层 474
11.6.1  数据链路层的基本概念 474
11.6.2  数据链路层的主要功能 474
第12章  套接字基础 476
12.1  网络程序的架构 477
12.2  套接字的类型 478
12.3  套接字的地址结构 478
12.4  主机字节序和网络字节序 479
12.5  出错信息的获取 481
第13章  TCP套接字编程 483
13.1  TCP套接字编程的基本步骤 483
13.2  协议簇和地址簇 484
13.3  socket地址 487
13.3.1  通用socket地址 487
13.3.2  专用socket地址 488
13.3.3  IP地址的转换 489
13.4  TCP套接字编程的相关函数 491
13.4.1  socket函数 491
13.4.2  bind函数 492
13.4.3  listen函数 494
13.4.4  accept函数 494
13.4.5  connect函数 495
13.4.6  write函数 497
13.4.7  read函数 498
13.4.8  send函数 498
13.4.9  recv函数 499
13.4.10  close函数 499
13.4.11  获得套接字地址 499
13.4.12  阻塞套接字的使用 504
13.4.13  非阻塞套接字的使用 511
第14章  UDP套接字编程 525
14.1  UDP套接字编程的基本步骤 525
14.2  TCP套接字编程的相关函数 526
14.2.1  消息发送函数sendto和sendmsg 526
14.2.2  消息接收函数recvfrom和recvmsg 527
14.3  实战UDP套接字 529
14.4  UDP丢包及无序问题 538
第15章  原始套接字编程 539
15.1  原始套接字概述 539
15.2  与标准套接字的区别 539
15.3  原始套接字的编程方法 540
15.4  面向链路层的原始套接字编程函数 540
15.4.1  创建原始套接字函数 540
15.4.2  接收函数recvfrom 541
15.4.3  发送函数sendto 542
15.5  以太网帧格式 545
15.6  获取网络接口的信息 547
15.7  实战链路层的原始套接字 550
15.7.1  常见的应用场景 550
15.7.2  混杂模式 577
15.7.3  链路层原始套接字开发注意事项 596
15.8  面向IP层的原始套接字编程 597
第16章  C 网络性能测试工具iPerf的简析 605
16.1  iPerf概述 605
16.2  iPerf的特点 605
16.3  iPerf的工作原理 605
16.4  iPerf的主要功能 606
16.5  在Linux下安装iPerf 607
16.6  iPerf的简单使用 608
16.7  iPerf源代码概述 609
16.8  Thread类 610
16.8.1  数据成员说明 611
16.8.2  主要函数成员 611
16.9  SocketAddr类 615
16.10  Socket 类 617
16.10.1  Listen 函数 618
16.10.2  Accept函数 620
16.10.3  Connect函数 620
第17章  版本控制和SVN工具 623
17.1  SVN简介 623
17.1.1  什么是SVN 623
17.1.2  使用SVN的好处 624
17.1.3  使用SVN的基本流程 624
17.2  SVN服务器的安装和配置 624
17.2.1  VisualSVN 服务器的安装和配置 624
17.2.2  SVN客户端在Windows上的使用 629
第18章  C 跨平台开发 634
18.1  什么是跨平台 634
18.2  C 的可移植性 634
18.2.1  可移植性的概念 634
18.2.2  影响C 语言可移植性的因素 635
18.3  设计跨平台软件的原则 638
18.3.1  避免语言的扩展特性 638
18.3.2  实现动态的处理 638
18.3.3  使用脚本文件进行管理 639
18.3.4  使用安全的数据串行化 640
18.3.5  跨平台开发中的编译及测试 641
18.3.6  实现抽象 641
18.4  建立跨平台的开发环境 642
18.4.1  跨平台开发编译器的选择 642
18.4.2  建立跨平台的Make系统 643
18.5  C 语言跨平台软件开发的实现 648
18.6  C 语言跨平台的开发策略 649
18.7  建立统一的工程包 650
18.8  建立跨平台的代码库 650
18.9  工厂模式与单例模式的实现 651
18.10  利用平台依赖库封装平台相关代码 651
18.11  处理器的差异控制 652
18.11.1  内存对齐 652
18.11.2  字节顺序 653
18.11.3  类型的大小 654
18.11.4  使用预编译处理类型差异 654
18.12  编译器的差异控制 655
18.12.1  实现平台无关的代码 655
18.12.2  内存管理 657
18.12.3  容错性的影响 657
18.12.4  利用日志管理异常 657
18.13  操作系统和接口库 658
18.13.1  文件描述符的限制 659
18.13.2  进程和线程的限制 659
18.13.3  操作系统抽象层 659
18.14  用户界面 660
18.14.1  跨平台软件图形界面的设计 660
18.14.2  wxWidgets 简介 661
18.14.3  使用wxWidgets开发跨平台软件的界面 661
第19章  Linux下的安全编程 663
19.1  本章概述 663
19.2  密码学基础知识 665
19.2.1  密码学概述 665
19.2.2  对称密钥加密技术 665
19.2.3  公开密钥加密技术 666
19.2.4  单向散列函数算法 667
19.2.5  数字签名基础知识 667
19.3  身份认证基础知识 668
19.3.1  身份认证概述 668
19.3.2  身份认证的方式 669
19.4  密码编程的两个重要库 670
19.5  OpenSSL的简介 671
19.6  OpenSSL模块分析 671
19.6.1  OpenSSL源代码模块结构 671
19.6.2  OpenSSL加密库调用方式 672
19.6.3  OpenSSL支持的对称加密算法 673
19.6.4  OpenSSL支持的非对称加密算法 673
19.6.5  OpenSSL支持的信息摘要算法 673
19.6.6  OpenSSL密钥和证书管理 673
19.7  面向对象与OpenSSL 674
19.7.1  BIO接口 675
19.7.2  EVP接口 676
19.8  OpenSSL的下载、编译和升级安装 677
19.9  对称加解密算法的分类 680
19.9.1  流对称算法 680
19.9.2  分组对称算法 680
19.9.3  了解库和头文件 684
19.10  利用OpenSSL进行对称加解密 686
19.10.1  一些基本概念 686
19.10.2  对称加解密相关函数 687
19.11  Crypto 的简介 695
19.12  Crypto 的编译 696
19.13  Crypto 进行AES加解密 696
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C与C++ 一线开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++ 2013入门经典（第7版）
第1章  使用Visual C++编程	1
1.1  使用Visual C++学习	1
1.2  编写C++应用程序	2
1.3  学习桌面应用程序的编程	2
1.3.1  学习C++	3
1.3.2  C++概念	3
1.3.3  控制台应用程序	4
1.3.4  Windows编程概念	4
1.4  集成开发环境简介	6
1.4.1  编辑器	6
1.4.2  编译器	6
1.4.3  链接器	6
1.4.4  库	7
1.4.5  标准C++库	7
1.4.6  Microsoft库	7
1.5  使用IDE	7
1.5.1  工具栏选项	8
1.5.2  可停靠的工具栏	9
1.5.3  文档	9
1.5.4  项目和解决方案	9
1.5.5  设置Visual C++的选项	16
1.5.6  创建和执行Windows应用程序	17
1.6  小结	19
1.7  本章主要内容	19
第2章  数据、变量和计算	21
2.1  C++程序结构	21
2.1.1  main()函数	28
2.1.2  程序语句	28
2.1.3  空白	30
2.1.4  语句块	30
2.1.5  自动生成的控制台程序	30
2.2  定义变量	32
2.2.1  命名变量	32
2.2.2  关键字	32
2.2.3  声明变量	33
2.2.4  变量的初始值	33
2.3  基本数据类型	34
2.3.1  整型变量	34
2.3.2  字符数据类型	35
2.3.3  整型修饰符	36
2.3.4  布尔类型	36
2.3.5  浮点类型	37
2.3.6  C++中的基本类型	37
2.3.7  字面值	38
2.3.8  定义类型的别名	39
2.4  基本的输入/输出操作	40
2.4.1  从键盘输入	40
2.4.2  到命令行的输出	40
2.4.3  格式化输出	41
2.4.4  转义序列	42
2.5  C++中的计算	44
2.5.1  赋值语句	44
2.5.2  算术运算	44
2.5.3  计算余数	49
2.5.4  修改变量	49
2.5.5  增量和减量运算符	50
2.5.6  计算的顺序	52
2.6  类型转换和类型强制转换	53
2.6.1  赋值语句中的类型转换	54
2.6.2  显式类型转换	54
2.6.3  老式的类型强制转换	55
2.7  auto关键字	55
2.8  类型的确定	56
2.9  按位运算符	56
2.9.1  按位AND运算符	57
2.9.2  按位OR运算符	58
2.9.3  按位XOR运算符	59
2.9.4  按位NOT运算符	60
2.9.5  移位运算符	60
2.10  lvalue和rvalue	61
2.11  了解存储时间和作用域	62
2.11.1  自动变量	62
2.11.2  决定变量声明的位置	65
2.11.3  全局变量	65
2.11.4  静态变量	68
2.12  具有特定值集的变量	68
2.12.1  旧枚举	68
2.12.2  类型安全的枚举	70
2.13  名称空间	72
2.13.1  声明名称空间	73
2.13.2  多个名称空间	74
2.14  小结	75
2.15  练习	75
2.16  本章主要内容	76
第3章  判断和循环	79
3.1  比较数据值	79
3.1.1  if语句	80
3.1.2  嵌套的if语句	81
3.1.3  嵌套的if-else语句	85
3.1.4  逻辑运算符和表达式	87
3.1.5  条件运算符	89
3.1.6  switch语句	91
3.1.7  无条件转移	94
3.2  重复执行语句块	95
3.2.1  循环的概念	95
3.2.2  for循环的变体	98
3.2.3  while循环	105
3.2.4  do-while循环	107
3.2.5  基于范围的循环	108
3.2.6  嵌套的循环	108
3.3  小结	111
3.4  练习	111
3.5  本章主要内容	111
第4章  数组、字符串和指针	113
4.1  处理多个相同类型的数据值	113
4.1.1  数组	114
4.1.2  声明数组	114
4.1.3  初始化数组	117
4.1.4  使用基于范围的for循环	118
4.1.5  多维数组	119
4.2  处理C样式的字符串	123
4.2.1  字符串输入	124
4.2.2  字符串字面量	125
4.2.3  给字符串使用基于范围的for循环	126
4.3  间接数据访问	128
4.3.1  指针的概念	128
4.3.2  声明指针	128
4.3.3  使用指针	129
4.3.4  初始化指针	130
4.3.5  指向char类型的指针	132
4.3.6  sizeof操作符	136
4.3.7  常量指针和指向常量的指针	136
4.3.8  指针和数组	138
4.4  动态内存分配	144
4.4.1  堆的别名—— 空闲存储器	144
4.4.2  new和delete操作符	145
4.4.3  为数组动态分配内存	146
4.4.4  多维数组的动态分配	148
4.5  使用引用	149
4.5.1  引用的概念	149
4.5.2  声明并初始化lvalue引用	149
4.5.3  在基于范围的for循环中
使用引用	150
4.5.4  创建rvalue引用	151
4.6  字符串的库函数	151
4.6.1  确定以空字符结尾的字符串的长度	152
4.6.2  连接以空字符结尾的字符串	152
4.6.3  复制以空字符结尾的字符串	153
4.6.4  比较以空字符结尾的字符串	154
4.6.5  搜索以空字符结尾的字符串	154
4.7  小结	156
4.8  练习	156
4.9  本章主要内容	157
第5章  程序结构(1)	159
5.1  理解函数	159
5.1.1  需要函数的原因	160
5.1.2  函数的结构	161
5.1.3  替代的函数语法	163
5.1.4  使用函数	163
5.2  给函数传递实参	166
5.2.1  按值传递机制	167
5.2.2  给函数传递指针实参	168
5.2.3  给函数传递数组	169
5.2.4  给函数传递引用实参	173
5.2.5  使用const修饰符	175
5.2.6  rvalue引用形参	176
5.2.7  main()函数的实参	178
5.2.8  接受数量不定的函数实参	179
5.3  从函数返回值	181
5.3.1  返回指针	181
5.3.2  返回引用	184
5.3.3  函数中的静态变量	186
5.4  递归函数调用	188
5.5  小结	191
5.6  练习	191
5.7  本章主要内容	192
第6章  程序结构(2)	193
6.1  函数指针	193
6.1.1  声明函数指针	194
6.1.2  函数指针作为实参	196
6.1.3  函数指针的数组	198
6.2  初始化函数形参	198
6.3  异常	200
6.3.1  抛出异常	202
6.3.2  捕获异常	202
6.3.3  重新抛出异常	204
6.3.4  MFC中的异常处理	204
6.4  处理内存分配错误	205
6.5  函数重载	206
6.5.1  函数重载的概念	207
6.5.2  引用类型和重载选择	209
6.5.3  何时重载函数	210
6.6  函数模板	210
6.7  使用decltype操作符	212
6.8  使用函数的示例	215
6.8.1  实现计算器	215
6.8.2  从字符串中删除空格	217
6.8.3  计算表达式的值	218
6.8.4  获得项值	220
6.8.5  分析数	221
6.8.6  整合程序	224
6.8.7  扩展程序	225
6.8.8  提取子字符串	227
6.8.9  运行修改过的程序	229
6.9  小结	229
6.10  练习	229
6.11  本章主要内容	230
第7章  自定义数据类型	233
7.1  C++中的结构	233
7.1.1  结构的概念	234
7.1.2  定义结构	234
7.1.3  初始化结构	234
7.1.4  访问结构的成员	235
7.1.5  伴随结构的智能感知帮助	238
7.1.6  RECT结构	239
7.1.7  使用指针处理结构	240
7.2  数据类型、对象、类和实例	241
7.2.1  类的起源	243
7.2.2  类的操作	243
7.2.3  术语	244
7.3  理解类	244
7.3.1  定义类	244
7.3.2  声明类的对象	245
7.3.3  访问类的数据成员	245
7.3.4 对象成员的初始化	247
7.3.5  初始化类成员	248
7.3.6  类的成员函数	248
7.3.7  在类的外部定义成员函数	250
7.3.8  内联函数	251
7.4  类构造函数	252
7.4.1  构造函数的概念	252
7.4.2  默认的构造函数	254
7.4.3  默认的形参值	256
7.4.4  在构造函数中使用初始化列表	258
7.4.5  声明显式的构造函数	259
7.4.6  委托构造函数	260
7.5  类的私有成员	260
7.5.1  访问私有类成员	263
7.5.2  类的友元函数	263
7.5.3  默认复制构造函数	266
7.6  this指针	267
7.7  类的const对象	269
7.7.1  类的const成员函数	270
7.7.2  类外部的成员函数定义	271
7.8  类对象的数组	271
7.9  类的静态成员	273
7.9.1  类的静态数据成员	273
7.9.2  类的静态函数成员	276
7.10  类对象的指针和引用	277
7.10.1  类对象的指针	277
7.10.2  类对象的引用	279
7.11  小结	280
7.12  练习	280
7.13  本章主要内容	281
第8章  深入理解类	283
8.1  类析构函数	283
8.1.1  析构函数的概念	284
8.1.2  默认的析构函数	284
8.1.3  析构函数与动态内存分配	286
8.2  实现复制构造函数	289
8.3  运算符重载	291
8.3.1  实现重载的运算符	291
8.3.2  实现对比较运算符的完全支持	294
8.3.3  重载赋值运算符	298
8.3.4  重载加法运算符	303
8.3.5  重载递增和递减运算符	307
8.3.6  重载函数调用操作符	308
8.4  对象复制问题	309
8.4.1  避免不必要的复制操作	309
8.4.2  应用rvalue引用形参	312
8.4.3  命名的对象是lvalue	314
8.5  默认的类成员	319
8.6  类模板	320
8.6.1  定义类模板	320
8.6.2  根据类模板创建对象	323
8.6.3  有多个形参的类模板	326
8.6.4  函数对象模板	328
8.7  完美转发	329
8.8  模板形参的默认实参	332
8.8.1  函数模板的默认实参	332
8.8.2  类模板的默认实参	333
8.9  类模板的别名	337
8.10  模板特例	337
8.11  使用类	341
8.11.1  类接口的概念	341
8.11.2  定义问题	341
8.11.3  实现CBox类	341
8.12  组织程序代码	358
8.13  字符串的库类	359
8.13.1  创建字符串对象	359
8.13.2  连接字符串	361
8.13.3  访问与修改字符串	364
8.13.4  比较字符串	367
8.13.5  搜索字符串	370
8.14  小结	378
8.15  练习	378
8.16  本章主要内容	379
第9章  类继承和虚函数	381
9.1  面向对象编程的基本思想	381
9.2  类的继承	382
9.2.1  基类的概念	383
9.2.2  基类的派生类	383
9.3  继承机制下的访问控制	386
9.3.1  派生类中构造函数的操作	389
9.3.2  声明类的保护成员	392
9.3.3  继承类成员的访问级别	395
9.4  派生类中的复制构造函数	396
9.5  禁止派生类	399
9.6  友元类成员	399
9.6.1  友元类	401
9.6.2  对类友元关系的限制	401
9.7  虚函数	401
9.7.1  虚函数的概念	403
9.7.2  确保虚函数的正确执行	405
9.7.3  禁止重写函数	406
9.7.4  使用指向类对象的指针	406
9.7.5  使用引用处理虚函数	408
9.7.6  纯虚函数	408
9.7.7  抽象类	409
9.7.8  间接基类	411
9.7.9  虚析构函数	413
9.8  类类型之间的强制转换	416
9.8.1  定义转换运算符	417
9.8.2  显式类型转换运算符	417
9.9  嵌套类	417
9.10  小结	421
9.11  练习	421
9.12  本章主要内容	423
第10章  标准模板库	425
10.1  标准模板库的定义	425
10.1.1  容器	426
10.1.2  容器适配器	428
10.1.3   迭代器	428
10.2  智能指针	430
10.3  算法	433
10.4  STL中的函数对象	433
10.5  STL容器范围	434
10.6  序列容器	434
10.6.1  创建矢量容器	435
10.6.2  矢量容器的容量和大小	438
10.6.3  访问矢量中的元素	442
10.6.4  在矢量中插入和删除元素	443
10.6.5  在矢量中存储类对象	446
10.6.6  矢量元素的排序	451
10.6.7  存储矢量中的指针	452
10.6.8  双端队列容器	457
10.6.9  使用列表容器	460
10.6.10  使用forward_list容器	469
10.6.11  使用其他序列容器	471
10.6.12  tuple< >类模板	480
10.7  关联容器	483
10.7.1  使用映射容器	483
10.7.2  使用多重映射容器	494
10.8  关于迭代器的更多内容	495
10.8.1  使用输入流迭代器	495
10.8.2  使用插入迭代器	498
10.8.3  使用输出流迭代器	500
10.9  关于函数对象的更多内容	502
10.10  关于算法的更多内容	503
10.11  类型特质和静态断言	505
10.12  λ表达式	506
10.12.1  capture子句	507
10.12.2  捕获特定的变量	508
10.12.3  模板和λ表达式	508
10.12.4  命名λ表达式	512
10.13  小结	514
10.14  练习	515
10.15  本章主要内容	515
第11章  Windows编程的概念	517
11.1  Windows编程基础	517
11.1.1  窗口的元素	518
11.1.2  Windows程序与操作系统	519
11.1.3  事件驱动型程序	519
11.1.4  Windows消息	520
11.1.5  Windows API	520
11.1.6  Windows数据类型	521
11.1.7  Windows程序中的符号	521
11.2  Windows程序的结构	522
11.2.1  WinMain()函数	523
11.2.2  处理Windows消息	533
11.3  MFC	538
11.3.1  MFC表示法	539
11.3.2  MFC程序的组织方式	539
11.4  小结	543
11.5  本章主要内容	543
第12章  使用MFC编写Windows程序	545
12.1  MFC的文档/视图概念	545
12.1.1  文档的概念	545
12.1.2  文档界面	546
12.1.3  视图的概念	546
12.1.4  链接文档和视图	547
12.1.5  应用程序和MFC	548
12.2  创建MFC应用程序	549
12.2.1  创建SDI应用程序	550
12.2.2  MFC Application Wizard 的输出	554
12.2.3  创建MDI应用程序	563
12.3  小结	565
12.4  练习	565
12.5  本章主要内容	565
第13章  处理菜单和工具栏	567
13.1  与Windows通信	567
13.1.1  了解消息映射	568
13.1.2  消息类别	570
13.1.3  处理程序中的消息	570
13.2  扩展Sketcher程序	571
13.3  菜单的元素	572
13.4  为菜单消息添加处理程序	575
13.4.1  选择处理菜单消息的类	576
13.4.2  创建菜单消息函数	576
13.4.3  编写菜单消息函数的代码	578
13.4.4  添加更新菜单消息的处理程序	581
13.5  添加工具栏按钮	584
13.5.1  编辑工具栏按钮的属性	585
13.5.2  练习使用工具栏按钮	586
13.5.3  添加工具提示	586
13.6  小结	587
13.7  练习	587
13.8  本章主要内容	587
第14章  在窗口中绘图	589
14.1  窗口绘图的基础知识	589
14.1.1  窗口客户区	589
14.1.2  Windows图形设备界面	590
14.2  MFC的绘图机制	592
14.2.1  应用程序中的视图类	592
14.2.2  CDC类	593
14.3  实际绘制图形	601
14.4  对鼠标进行编程	603
14.4.1  鼠标发出的消息	603
14.4.2  鼠标消息处理程序	604
14.4.3  使用鼠标绘图	606
14.5  绘制草图	627
14.5.1  运行示例	628
14.5.2  捕获鼠标消息	629
14.6  小结	630
14.7  练习题	630
14.8  本章主要内容	631
第15章  改进视图	633
15.1  Sketcher应用程序的缺陷	633
15.2  改进视图	634
15.2.1  更新多个视图	634
15.2.2  滚动视图	635
15.2.3  使用MM_LOENGLISH 映射模式	640
15.3  删除和移动元素	640
15.4  实现上下文菜单	641
15.4.1  关联菜单和类	642
15.4.2  选中上下文菜单项	643
15.5  标识位于光标下的元素	644
15.5.1  练习弹出菜单	645
15.5.2  突出显示元素	645
15.5.3  实现移动和删除功能	649
15.6  处理屏蔽的元素	655
15.7  小结	657
15.8  练习	657
15.9  本章主要内容	657
第16章  使用对话框和控件	659
16.1  理解对话框	659
16.2  理解控件	660
16.3  创建对话框资源	660
16.3.1  给对话框添加控件	661
16.3.2  测试对话框	662
16.4  对话框的编程	662
16.4.1  添加对话框类	662
16.4.2  模态和非模态对话框	664
16.4.3  显示对话框	664
16.5  支持对话框控件	666
16.5.1  初始化对话框控件	667
16.5.2  处理单选按钮消息	668
16.6  完成对话框的操作	668
16.6.1  给文档添加线宽	669
16.6.2  给元素添加线宽	669
16.6.3  在视图中创建元素	671
16.6.4  练习使用对话框	672
16.7  使用微调按钮控件	673
16.7.1  添加Scale菜单项和
工具栏按钮	673
16.7.2  创建微调按钮	673
16.7.3  生成比例对话框类	674
16.7.4  显示微调按钮	677
16.8  使用缩放比例	678
16.8.1  可缩放的映射模式	678
16.8.2  设置文档的大小	679
16.8.3  设置映射模式	680
16.8.4  同时实现滚动与缩放	681
16.9  使用状态栏	683
16.9.1  给框架窗口添加状态栏	683
16.9.2  CString类	687
16.10  使用编辑框控件	688
16.10.1  创建编辑框资源	688
16.10.2  创建对话框类	689
16.10.3  添加Text菜单项	690
16.10.4  定义文本元素	691
16.10.5  实现CText类	691
16.11  小结	696
16.12  练习	696
16.13  本章主要内容	696
第17章  存储和打印文档	697
17.1  了解序列化	697
17.2  序列化文档	698
17.2.1  文档类定义中的序列化	698
17.2.2  文档类实现中的序列化	699
17.2.3  基于CObject的类的
功能	701
17.2.4  序列化的工作方式	702
17.2.5  如何实现类的序列化	703
17.3  应用序列化	704
17.3.1  记录文档修改	704
17.3.2  序列化文档	706
17.3.3  序列化元素类	707
17.4  练习序列化	711
17.5  打印文档	713
17.6  实现多页打印	716
17.6.1  获取文档的总尺寸	716
17.6.2  存储打印数据	717
17.6.3  准备打印	718
17.6.4  打印后的清除	719
17.6.5  准备设备上下文	719
17.6.6  打印文档	720
17.6.7  获得文档的打印输出	724
17.7  小结	724
17.8  练习	724
17.9  本章主要内容	725
第18章  编写Windows 8应用程序	727
18.1  Windows Store应用程序	727
18.2  开发Windows Store应用程序	728
18.3  Windows Runtime的概念	729
18.3.1  WinRT名称空间	729
18.3.2  WinRT对象	730
18.4  C++/CX	730
18.4.1  C++/CX名称空间	730
18.4.2  定义WinRT类类型	731
18.4.3  ref类类型的变量	733
18.4.4  访问ref类对象的成员	734
18.4.5  事件处理程序	734
18.4.6  转换ref类引用的类型	735
18.5  XAML	735
18.5.1  XAML元素	735
18.5.2  XAML中的UI元素	737
18.5.3  附加属性	739
18.5.4  父元素和子元素	740
18.5.5  控件元素	740
18.5.6  布局元素	740
18.5.7  处理UI元素的事件	741
18.6  创建Windows Store应用程序	742
18.6.1  应用程序文件	742
18.6.2  定义用户界面	742
18.6.3  创建标题	745
18.6.4  添加游戏控件	746
18.6.5  创建包含纸牌的网格	748
18.6.6  实现游戏的操作	752
18.6.7  初始化MainPage对象	755
18.6.8  初始化一副纸牌	756
18.6.9  建立cardGrid的子元素	757
18.6.10  初始化游戏	758
18.6.11  洗牌	760
18.6.12  突出显示UI纸牌	761
18.6.13  处理翻牌事件	762
18.6.14  处理图形事件	764
18.6.15  确认赢家	765
18.6.16  处理游戏控件的按钮事件	766
18.7  缩放UI元素	768
18.8  平移	770
18.8.1  应用程序的启动动画	770
18.8.2  故事板动画	771
18.9  小结	773
18.10  本章主要内容	773
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++ 2013入门经典（第7版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图像加密算法与实践
前言
第Ⅰ部分 准备
第1章 图像加密概论
1.1 图像加密的发展和特点
1.1.1 图像加密的发展
1.1.2 图像加密的特点
1.2 图像加密的分类
1.2.1 图像加密分类(一)
1.2.2 图像加密分类(二)
1.3 图像加密分析
1.3.1 攻击类型
1.3.2 Kerchoffs原理
1.4 图像加密原理
1.4.1 图像置乱加密原理
1.4.2 图像序列加密原理
1.5 本书内容安排
1.5.1 关于编程与运行环境
1.5.2 关于本书程序的结构与组成
参考文献
第2章 算法基础
2.1 Arnold变换
2.1.1 二维Arnold变换
2.1.2 广义Arnold变换
2.1.3 三维Arnold变换
2.1.4 n维Arnold变换
2.2 模运算
2.2.1 模运算的性质
2.2.2 模算术运算
2.2.3 模算术的性质
2.3 混沌变换
2.3.1 Logistic映射
2.3.2 Chebyshev映射
2.3.3 Baker映射
2.3.4 Henon映射
2.3.5 Lorenz映射
2.3.6 Chen超混沌系统
2.4 图像像素的重排
2.4.1 n维图像的一维序列表示
2.4.2 n维图像与k维图像之间的转换
2.5 图像时频变换
2.5.1 DCT变换
2.5.2 提升Haar小波变换
参考文献
第Ⅱ部分 空域图像加密
第3章 置乱加密
3.1 RGB平移置乱加密
3.1.1 加密思想
3.1.2 加密算法
3.1.3 算法实现与实践
3.1.4 相关研究
3.2 Henon混沌置乱加密
3.2.1 加密思想
3.2.2 加密算法
3.2.3 算法实现与实践
3.2.4 相关研究
3.3 SCAN模式加密
3.3.1 SCAN模式
3.3.2 SCAN加密方案
3.3.3 算法实现与实践
3.3.4 相关研究
3.4 二值图像修正SCAN加密
3.4.1 二值图像四叉树表示与修正SCAN语言
3.4.2 加密方案
3.4.3 算法实现与实践
参考文献
第4章 灰度加密
4.1 灰度DES加密
4.1.1 DES算法
4.1.2 算法实现与实践
4.1.3 相关研究
4.2 Hill矩阵加密
4.2.1 Hill加密算法
4.2.2 自可逆矩阵
4.2.3 自可逆矩阵Hill加密方案
4.2.4 算法实现与实践
4.2.5 相关研究
4.3 混沌序列加密
4.3.1 混沌映射序列加密方案
4.3.2 算法实现与实践
4.3.3 相关研究
4.4 细胞自动机方法
4.4.1 细胞自动机简介
4.4.2 基本细胞自动机
4.4.3 图像加密算法
4.4.4 算法实现与实践
4.4.5 相关研究
4.5 随机格加密
4.5.1 随机格
4.5.2 二值图像随机格加密
4.5.3 灰度图像随机格加密算法
4.5.4 算法实现与实践
4.5.5 相关研究
4.6 基于遗传算法和混沌的图像加密
4.6.1 遗传算法的基本概念和思想
4.6.2 加密方案
4.6.3 算法实现与实践
4.6.4 相关研究
参考文献
第5章 混合加密
5.1 Arnold-Chen混沌序列加密
5.1.1 Arnold映射和Chen混沌系统
5.1.2 Arnold-Chen混沌序列加密方案
5.1.3 算法实现与实践
5.1.4 相关研究
5.2 复合混沌加密
5.2.1 复合混沌
5.2.2 加密方案
5.2.3 算法实现与实践
5.2.4 相关研究
5.3 Baker序列加密
5.3.1 离散化Baker映射
5.3.2 加密方案
5.3.3 算法实现与实践
5.3.4 相关研究
5.4 位平面置乱加密
5.4.1 位平面置乱
5.4.2 加密方案
5.4.3 算法实现与实践
5.4.4 相关研究
5.5 三维Arnold混沌映射加密
5.5.1 三维Arnold映射
5.5.2 三维混沌映射加密方案
5.5.3 算法实现与实践
5.5.4 评注和相关研究
5.6 基于DNA的加密
5.6.1 DNA序列
5.6.2 基于DNA的加密方案
5.6.3 算法实现与实践
5.6.4 相关研究
参考文献
第Ⅲ部分 频域图像加密
第6章 频域置乱与数据加密
6.1 Haar域置乱加密
6.1.1 二维混沌映射和离散小波变换
6.1.2 加密方法
6.1.3 算法实现与实践
6.1.4 相关研究
6.2 基于Fibonacci p-编码的图像置乱
6.2.1 P-Fibonacci和P-Lucas变换
6.2.2 颜色空间及其转换
6.2.3 频域置乱算法
6.2.4 算法实现与实践
6.2.5 相关研究
6.3 矩阵变换加密
6.3.1 正交基和可逆矩阵
6.3.2 加密方案
6.3.3 安全性分析
6.3.4 算法实现与实践
6.3.5 相关研究
6.4 Haar域序列加密
6.4.1 密钥的生成
6.4.2 小波域图像表示
6.4.3 加密方案
6.4.4 算法实现与实践
6.4.5 相关研究
参考文献
第7章 频域混合加密
7.1 选择加密与流加密
7.1.1 选择加密与RC4算法
7.1.2 加密方案
7.1.3 算法实现与实践
7.1.4 相关研究
7.2 DCT域多层块置乱加密
7.2.1 多层块置乱
7.2.2 多层块置乱加密方案
7.2.3 算法实现与实践
7.2.4 相关研究
参考文献
第Ⅳ部分 图像加密分析与测试
第8章 图像加密分析与攻击
8.1 对二值压缩图像的已知明文攻击
8.1.1 对2DRE压缩算法与加密算法的分析
8.1.2 模拟攻击算法实现与实践
8.2 对Arnold-Chen加密方案的攻击
8.2.1 选择明文攻击方案
8.2.2 已知明文攻击方案
8.2.3 关于仿真攻击方案
8.2.4 选择明文攻击算法实现与实践
8.2.5 已知明文攻击算法实现与实践
8.3 对复合混沌加密方案的攻击
8.3.1 差分选择明文攻击
8.3.2 差分选择明文攻击算法实现与实践
8.4 对Baker序列加密方案的攻击
8.4.1 选择密文攻击方案
8.4.2 仿真攻击的实现
8.4.3 仿真攻击算法设计与实现
参考文献
第9章 图像加密评估与测试
9.1 密钥空间分析
9.1.1 加密密钥数量分析
9.1.2 密钥灵敏度测试
9.2 统计分析
9.2.1 加密图像的直方图分析
9.2.2 相邻像素的相关性分析
9.2.3 信息熵测试
9.3 扩散性测试
9.3.1 像素改变率
9.3.2 一致平均改变强度
9.3.3 雪崩效应
9.4 其他测试
9.4.1 置乱程度评估
9.4.2 混乱和扩散程度评估
9.4.3 加密质量的测试
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图像加密算法与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>与尼采一起生活
导言　与尼采一起生活…………001
我们将如何理解尼采？…………007
令人不快的尼采…………010
尼采的美德…………017
我们应当如何解读尼采？…………020
尼采会怎样塑造我们？—一种“生存论的”路径…………024
透彻地思考尼采…………030
第1章　针对个人的尼采…………033
针对个人的哲学：典型的美德（与恶习）…………034
尼采的风格与尼采的哲学…………039
为人身攻击论证辩护…………048
《瞧，这个人》：“尼采是个疯子，不是吗？”…………057
尼采的视角主义与关于道德的诸多视角…………068
忏悔录与回忆录：哲学中的个人申辩…………081
第2章　尼采的道德视角主义…………084
尼采的道德视角主义…………088
作为人身攻击论证的谱系学：作为道德诊断的怨恨…………097
谱系学是一种起源谬误吗？…………103
关于责任的诸多视角：尼采的“谴责性”视角…………114
第3章　尼采的激情…………121
尼采论“深层的”情感…………125
作为意义的情感真理…………130
为激情辩护：尼采论人的本性…………136
尼采的生理心理学…………143
尼采论作为策略的情感…………154
提升生命的激情与愚钝生命的激情…………159
强力意志与热情的生命…………165
第4章　尼采论怨恨、爱与同情…………174
怨恨有什么错？…………179
尼采论爱与同情…………182
对怨恨的重新考察…………197
老鹰与羔羊：强与弱的隐喻…………205
主人、奴隶与正义的根源…………215
第5章　尼采的肯定的伦理学…………226
在传统语境下的尼采：虚无主义所支持与反对的…………229
尼采、康德与亚里士多德…………236
道德的意义…………243
美德伦理学：尼采与亚里士多德…………252
亚里士多德的城邦，尼采的问题…………261
第6章　尼采的美德：他会怎样塑造我们？…………269
追寻美德（“价值的重估”）…………275
通过范例展示的美德…………280
我们怎样具备美德？让我来数数道路…………284
尼采的亚里士多德式的美德…………290
尼采特有的美德…………310
尼采的隐秘美德…………325
超人：一幅立体主义的画像…………337
第7章　尼采的存在主义…………341
尼采的宿命论、决定论与命运…………345
尼采论自由与宿命论：悖论还是视角？…………353
尼采的古典宿命论…………358
“成为你自己”…………365
合理地理解宿命论…………370
什么是“自我创造”？（它需要“自由意志”吗？）…………375
尼采论责任…………387
存在主义式的肯定生命与再论永恒复归…………392
结论：尼采是一位存在主义者吗？…………403
参考文献…………406
参考说明…………421
译后记…………423
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>与尼采一起生活
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C安全编码标准(原书第2版)
译者序
前言
贡献者简介
第1章　预处理器（PRE）
1.1　PRE30-C. 不要通过连接创建通用字符名称
1.2　PRE31-C. 避免不安全宏参数的副作用
1.3　PRE32-C. 不要在类函数的宏调用中使用预处理器指令
第2章　声明和初始化（DCL）
2.1　DCL30-C. 声明具有正确存储持续期的对象
2.2　DCL31-C. 在使用前声明标识符
2.3　DCL36-C. 不要声明具有冲突链接类别的标识符
2.4　DCL37-C. 不要声明或者定义保留标识符
2.5　DCL38-C. 使用正确语法声明灵活数组成员
2.6　DCL39-C. 避免在结构填充中泄露信息
2.7　DCL40-C. 不要创建相同函数或者对象的不兼容声明
2.8　DCL41-C. 不要在switch语句第一个条件标签之前声明变量
第3章　表达式（EXP）
3.1　EXP30-C. 不要依赖求值顺序以避免副作用
3.2　EXP32-C. 不要通过非易失性引用访问易失性对象
3.3　EXP33-C. 不要读取未初始化的内存
3.4　EXP34-C. 不要对null指针进行解引用
3.5　EXP35-C. 不要修改具有临时生命期的对象
3.6　EXP36-C. 不要将指针转换为更严格对齐的指针类型
3.7　EXP37-C. 用正确数量和类型的参数调用函数
3.8　EXP39-C. 不要通过不兼容类型的指针访问变量
3.9　EXP40-C. 不要修改常量对象
3.10　EXP42-C. 不要比较填充数据
3.11　EXP43-C. 使用restrict限定的指针时避免未定义行为
3.12　EXP44-C. 不要向sizeof、_Alignof或者_Generic传递有副作用的操作数
3.13　EXP45-C. 不要在选择语句中执行赋值
第4章　整数（INT）
4.1　INT30-C. 确保无符号整数运算不产生回绕
4.2　INT31-C. 确保整数转换不会造成数据丢失或者错误解释
4.3　INT32-C. 确保有符号整数的运算不造成溢出
4.4　INT33-C. 确保除法和余数运算不会造成0除数错误
4.5　INT34-C. 不要用负数或者不小于操作数位数的位数对表达式进行移位
4.6　INT35-C. 使用正确的整数精度
4.7　INT36-C. 将指针转换为整数或者将整数转换为指针
第5章　浮点数（FLP）
5.1　FLP30-C. 不要使用浮点变量作为循环计数器
5.2　FLP32-C. 避免或者检测数学函数中的定义域和值域错误
5.3　FLP34-C. 确保浮点数转换在新类型的范围内
5.4　FLP36-C. 将整数值转换为浮点指针类型时保持精度
第6章　数组（ARR）
6.1　ARR30-C. 不要形成或者使用超限的指针或者数组下标
6.2　ARR32-C. 确保变长数组的大小参数在有效范围内
6.3　ARR36-C. 不要进行两个不引用相同数组的指针之间的减法或者比较
6.4　ARR37-C. 不要在指向非数组对象的指针上加或者减一个整数
6.5　ARR38-C. 保证库函数不形成无效指针
6.6　ARR39-C. 不要在指针上加或者减一个按比例调整的整数
第7章　字符和字符串（STR）
7.1　STR30-C. 不要企图修改字符串字面量
7.2　STR31-C. 保证字符串存储有足够的空间容纳字符数据和null结束符
7.3　STR32-C. 不要向要求字符串参数的库函数传递非null结束字符序列
7.4　STR34-C. 在转换为更大的整数尺寸之前将字符转换为unsigned char类型
7.5　STR37-C. 字符串处理函数的实参必须可以表示为unsigned char
7.6　STR38-C. 不要混淆窄和宽字符串及函数
第8章　内存管理（MEM）
8.1　MEM30-C. 不要访问已释放内存
8.2　MEM31-C. 在不再需要时释放动态分配的内存
8.3　MEM33-C. 动态分配和复制包含灵活数组成员的结构
8.4　MEM34-C. 只释放动态分配的内存
8.5　MEM35-C. 为对象分配足够的内存
8.6　MEM36-C. 不要通过调用realloc()修改对象的对齐方式
第9章　输入/输出（FIO）
9.1　FIO30-C. 从格式字符串中排除用户输入
9.2　FIO31-C. 不要打开已经打开的文件
9.3　FIO32-C. 不要在只适合文件的设备上执行操作
9.4　FIO34-C. 区分从文件读入的字符和EOF/WEOF
9.5　FIO37-C. 不要假定fgets()或者fgetws()在成功时返回非空字符串
9.6　FIO38-C. 不要复制FILE对象
9.7　FIO39-C. 不要在没有中间刷新或者定位调用的情况下在一个流中交替输入和输出
9.8　FIO40-C. 在fgets()或者fgetws()失败时重置字符串
9.9　FIO41-C. 不要用有副作用的流作为实参调用getc()、putc()、getwc()或者putwc()
9.10　FIO42-C. 在不再需要时关闭文件
9.11　FIO44-C. 对fsetpos()只使用fgetpos()返回的值
9.12　FIO45-C. 避免访问文件时出现TOCTOU竞争条件
9.13　FIO46-C. 不要访问已关闭文件
9.14　FIO47-C. 使用有效格式字符串
第10章　环境（ENV）
10.1　ENV30-C. 不要修改某些函数返回值引用的对象
10.2　ENV31-C. 在可能使某个环境指针无效的操作之后不要依赖该指针
10.3　ENV32-C. 所有退出处理程序必须正常返回
10.4　ENV33-C. 不要调用system()
10.5　ENV34-C. 不要保存某些函数返回的指针
第11章　信号（SIG）
11.1　SIG30-C. 在信号处理程序中只调用异步安全函数
11.2　SIG31-C. 不在信号处理程序中访问共享对象
11.3　SIG34-C. 不在可中断的信号处理程序中调用signal()
11.4　SIG35-C. 不从计算性异常信号处理程序中返回
第12章　错误处理（ERR）
12.1　ERR30-C. 在调用已知设置errno的库函数之前，将errno设置为0，只在函数返回表示故障的值之后才检查errno
12.2　ERR32-C. 不要依赖不确定的errno值
12.3　ERR33-C. 检测并处理标准库错误
第13章　并发性（CON）
13.1　CON30-C. 清理线程特定存储
13.2　CON31-C. 不要在互斥体被锁定时删除它们
13.3　CON32-C. 从多个线程访问位域时避免数据竞争
13.4　CON33-C. 使用库函数时避免竞争条件
13.5　CON34-C. 用正确的存储持续期声明线程间共享的对象
13.6　CON35-C. 以预定义顺序加锁，避免死锁
13.7　CON36-C. 将可能不合逻辑地唤醒的函数包装在一个循环中
13.8　CON37-C. 不要在多线程程序中调用signal()
13.9　CON38-C. 使用条件变量时保持线程安全性和活性
13.10　CON39-C. 不要加入或者断开之前已经加入或者断开的线程
13.11　CON40-C. 不要在一个表达式中两次引用同一个原子变量
13.12　CON41-C. 将可能不合逻辑地失败的函数包装在一个循环中
第14章　杂项（MSC）
14.1　MSC30-C. 不要使用rand()函数生成伪随机数
14.2　MSC32-C. 正确地设置伪随机数生成器的种子
14.3　MSC33-C. 不要向asctime()函数传递无效的数据
14.4　MSC37-C. 确保控制永远不会到达非void函数的结束位置
14.5　MSC38-C. 如果预定义标识符只能以宏的形式实现，不要将其当作对象处理
14.6　MSC39-C. 不要在va_list的值不确定时调用va_arg()
14.7　MSC40-C. 不要违反约束
附录A　词汇表
附录B　未定义行为
附录C　未指定行为
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C安全编码标准(原书第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言从入门到精通
第1篇  基 础 知 识
第1章  初识C语言	3
视频讲解：26分钟
1.1  C语言简介	4
1.1.1  编程语言的发展	4
1.1.2  什么是C语言	4
1.1.3  C语言的特点	5
1.2  认识C程序	6
1.2.1  简单的C程序	6
1.2.2  C程序的开发环境	8
1.2.3  编程原则	16
1.2.4  编译出错提示	18
范例1  输出一个正方形	27
范例2  用TC 2.0打开文本文件	27
1.3  经典范例	28
1.3.1  经典范例1  十进制转换为十六进制	28
1.3.2  经典范例2  三个数由小到大排序	28
1.4  小结	29
1.5  实践与练习	29
第2章  C语言基础	31
视频讲解：1小时28分钟
2.1  数据类型	32
2.2  常量	33
2.2.1  整型常量	33
2.2.2  实型常量	34
2.2.3  字符型常量	35
2.2.4  符号常量	37
范例1  计算学生平均身高	38
范例2  求圆的周长	38
2.3  变量	39
2.3.1  整型变量	39
2.3.2  实型变量	42
2.3.3  字符型变量	44
范例3  实型数据的存储	45
范例4  字符型数据进行算术运算	45
2.4  运算符与表达式	46
2.4.1  赋值运算符与表达式	47
2.4.2  算术运算符与表达式	51
2.4.3  关系运算符与表达式	53
2.4.4  逻辑运算符与表达式	54
2.4.5  逗号运算符与表达式	55
2.4.6  三目运算符与表达式	56
范例5  判断闰年	57
范例6  判断整数倍	58
2.5  经典范例	58
2.5.1  经典范例1  混合运算	58
2.5.2  经典范例2  检查字符类型	59
2.5.3  经典范例3  判断三角形的类型	60
2.6  小结	61
2.7  实践与练习	61
第3章  顺序与选择结构程序设计	63
视频讲解：1小时39分钟
3.1  C语句及赋值语句	64
3.1.1  C语句的概述	64
3.1.2  赋值语句	66
范例1  判断回文数	67
范例2  阶梯问题	68
3.2  字符数据输入/输出	69
3.2.1  字符数据输出	69
3.2.2  字符数据输入	70
范例3  将输入的小写字母转换为
大写字母	71
范例4  使用字符函数输入/输出字符	72
3.3  格式输入/输出函数	73
3.3.1  格式输出函数	73
3.3.2  格式输入函数	77
范例5  求一元二次方程的根	79
范例6  求直角三角形的斜边	80
3.4  if语句	81
3.4.1  if语句的基本形式	81
3.4.2  if语句的其他形式	82
3.4.3  if语句的嵌套形式	84
范例7  判断偶数	85
范例8  平方和值判断	86
3.5  switch语句	87
范例9  评定成绩等级	89
范例10  加油站加油	90
3.6  经典范例	91
3.6.1  经典范例1  计算运输公司的计费	91
3.6.2  经典范例2  一年的日期情况	93
3.6.3  经典范例3  模拟自动售货机	94
3.7  小结	95
3.8  实践与练习	95

第4章  循环控制	97
视频讲解：1小时6分钟
4.1  while及do while语句	98
4.1.1  while语句	98
4.1.2  do while语句	100
范例1  从键盘中输入一个数n，求n！	101
范例2  买苹果问题	102
4.2  for语句	102
4.2.1  for循环的变体	103
4.2.2  循环嵌套	106
范例3  统计不及格人数	109
范例4  一元钱兑换方案	110
4.3  转移语句	110
4.3.1  goto语句	110
4.3.2  break语句	112
4.3.3  continue语句	114
范例5  求出给定数值内的所有正整数的和	115
范例6  偶数拆分	115
4.4  经典范例	116
4.4.1  经典范例1  灯塔数量	116
4.4.2  经典范例2  平方和运算	117
4.4.3  经典范例3  打印乘法口诀表	118
4.5  小结	119
4.6  实践与练习	119
第2篇  核 心 技 术
第5章  数组	123
视频讲解：1小时4分钟
5.1  一维数组	124
5.1.1  一维数组的定义和引用	124
5.1.2  一维数组的初始化	126
范例1  判断一个数是否存储在数组中	128
范例2  选票统计	128
5.2  二维数组	129
5.2.1  二维数组的定义和引用	130
5.2.2  二维数组的初始化	131
范例3  求二维数组对角线之和	133
范例4  打印杨辉三角	134
5.3  字符数组	135
5.3.1  字符数组的定义和引用	135
5.3.2  字符数组的初始化	136
5.3.3  字符数组的结束标志	137
5.3.4  字符数组的输入/输出	138
5.3.5  字符串处理函数	141
范例5  统计各种字符的个数	148
范例6  字符升序排列	149
5.4  多维数组	150
5.5  经典范例	150
5.5.1  经典范例1  模拟比赛打分	150
5.5.2  经典范例2  打印5阶幻方	152
5.5.3  经典范例3  找出排在后面的国家名	153
5.6  小结	154
5.7  实践与练习	154
第6章  函数	155
视频讲解：1小时48分钟
6.1  函数的简介	156
6.1.1  概述	156
6.1.2  函数的定义与声明	158
范例1  计算任意两个整数的积	161
范例2  求最大公约数与最小公倍数	162
6.2  返回语句	163
6.2.1  函数返回	163
6.2.2  返回值	165
范例3  求任意两个数的平均数	167
范例4  判断素数	167
6.3  函数参数	168
6.3.1  形式参数和实际参数	168
6.3.2  数组作函数参数	170
范例5  求字符串中字符个数	174
范例6  求学生的平均身高	175
6.4  函数的调用	176
6.4.1  函数的调用方式	176
6.4.2  嵌套调用	178
6.4.3  递归调用	180
范例7  分数计算器	182
范例8  递归解分鱼问题	184
6.5  局部变量和全局变量	185
6.5.1  局部变量	185
6.5.2  全局变量	188
6.6  变量的存储类别	190
6.6.1  静态存储与动态存储	190
6.6.2  auto变量	191
6.6.3  static变量	193
6.6.4  register变量	195
6.6.5  extern变量	195
6.7  内部函数和外部函数	197
6.7.1  内部函数	197
6.7.2  外部函数	198
范例9  最大值与最小值对调	199
范例10  使用register定义局部变量	200
6.8  库函数	201
6.8.1  数学函数	202
6.8.2  字符和字符串函数	204
范例11  小数分离	207
范例12  求任意数n次幂	208
6.9  经典范例	209
6.9.1  经典范例1  某日是该年的第几天	209
6.9.2  经典范例2  递归解决年龄问题	210
6.9.3  经典范例3  一数三平方	211
6.10  小结	212
6.11  实践与练习	213
第7章  指针	215
视频讲解：50分钟
7.1  指针相关概念	216
7.1.1  地址与指针	216
7.1.2  指针变量	217
7.1.3  “&”和“*”运算符	220
7.1.4  指针的算术运算	221
范例1  转向的指针	223
范例2  数值的运算	224
7.2  一维数组与指针	225
7.2.1  指向数组元素的指针	225
7.2.2  使用指针访问数组	226
范例3  查找数列中的最值	230
范例4  逆序存放数组元素	231
7.3  二维数组与指针	232
范例5  输出二维数组有关值	234
范例6  输出二维数组的任一行、任一列	235
7.4  字符串与指针	236
7.4.1  字符型指针	237
7.4.2  字符串数组	238
范例7  字符串的匹配	239
范例8  将若干字符串按照字母顺序输出	240
7.5  指针作函数参数	241
7.5.1  指针变量作函数的参数	242
7.5.2  数组指针作函数的参数	245
7.6  指向指针的指针	250
范例9  使用指针的指针输出字符串	252
范例10  输入月份号输出英文月份名	253
7.7  函数型指针	254
7.8  main函数的参数	256
范例11  用函数指针实现求两个数据的和
与差	257
范例12  用指向函数的指针比较大小	258
7.9  经典范例	259
7.9.1  经典范例1  字符串插入	259
7.9.2  经典范例2  删除数组中的连续
元素	260
7.9.3  经典范例3  输出销售额	261
7.10  小结	262
7.11  实践与练习	263
第8章  结构体与共用体	265
视频讲解：1小时2分钟
8.1  结构体	266
8.1.1  结构体类型的概念	266
8.1.2  结构体变量的定义和引用	267
8.1.3  结构体变量的初始化	271
8.2  结构体数组	273
8.2.1  定义结构体数组	273
8.2.2  初始化结构体数组	274
范例1  比较计数	276
范例2  找出最高分	277
范例3  信息查询	278
8.3  结构体指针	280
8.3.1  结构体指针变量的声明	280
8.3.2  结构体指针的引用	281
8.3.3  结构体数组指针	283
8.3.4  结构体作函数的参数	284
范例4  统计分钟数	287
范例5  指向数组元素的结构体指针运算	288
8.4  包含结构的结构	289
8.5  链表	290
8.5.1  链表概述	290
8.5.2  单链表的建立	292
8.5.3  链表的输出	294
8.5.4  链表相关操作	296
范例6  合并两个链表	302
范例7  创建循环链表	303
范例8  创建双向链表	304
8.6  共用体	307
8.6.1  共用体的概念	307
8.6.2  共用体变量的定义和引用	308
8.6.3  共用体变量的初始化	310
范例9  取出整型数据的高字节数据	311
范例10  共用体处理任意类型数据	311
8.7  枚举类型	312
范例11  选择颜色	314
范例12  输出星期几	315
8.8  用typedef定义类型	316
8.9  经典范例	318
8.9.1  经典范例1  候选人选票程序	318
8.9.2  经典范例2  使用共用体存放学生和
老师信息	319
8.9.3  经典范例3  约瑟夫环	320
8.10  小结	322
8.11  实践与练习	322
第9章  算法	323
视频讲解：1小时8分钟
9.1  算法基础	324
9.1.1  算法的概念	324
9.1.2  流程图	324
9.1.3  三种基本结构	326
9.1.4  N-S流程图	327
范例1  判断偶数	328
范例2  求整数和	328
9.2  排序算法	329
9.2.1  选择排序	330
9.2.2  冒泡排序	331
9.2.3  插入排序	334
9.2.4  希尔排序	335
9.2.5  快速排序	337
9.3  查找算法	339
9.3.1  顺序查找	339
9.3.2  折半查找	340
9.3.3  分块查找	342
9.3.4  哈希查找	344
9.4  经典范例	348
9.4.1  经典范例1  百钱百鸡问题	348
9.4.2  经典范例2  斐波那契数列	349
9.4.3  经典范例3  尼科彻斯定理	350
9.5  小结	351
9.6  实践与练习	351

第3篇  高 级 应 用
第10章  位运算	355
视频讲解：44分钟
10.1  位运算操作符	356
10.1.1  “或”运算符	356
10.1.2  “与”运算符	357
10.1.3  “取反”运算符	359
10.1.4  “异或”运算符	360
10.1.5  “左移”运算符	362
10.1.6  “右移”运算符	364
范例1  取一个整数的后4位	365
范例2  取出给定16位二进制数的奇数位	365
10.2  循环移位	366
10.3  位段	368
10.3.1  位段的概念与定义	369
10.3.2  位段相关说明	370
范例3  输出各个位段的值	371
范例4  位段变量的内存分配	372
10.4  经典范例	373
10.4.1  经典范例1  求一个数的补码	373
10.4.2  经典范例2  使二进制数特定位翻转	373
10.4.3  经典范例3  RSA加密算法的实现	374
10.5  小结	376
10.6  实践与练习	376
第11章  预处理	377
视频讲解：44分钟
11.1  宏定义	378
11.1.1  不带参数的宏定义	378
11.1.2  带参数的宏定义	379
范例1  不带参数的宏定义的简单应用	381
范例2  利用宏定义求偶数和	381
11.2  “文件包含”处理	382
11.3  条件编译	383
11.3.1  #if相关命令	384
11.3.2  #ifdef及#ifndef命令	386
11.3.3  #undef命令	388
11.3.4  #line及#pragma命令	388
范例3  编写头文件包含圆面积的计算公式	389
范例4  使用条件编译将字符转换为大写	390
11.4  经典范例	391
11.4.1  经典范例1  找最小数	391
11.4.2  经典范例2  利用文件包含设计
输出模式	392
11.4.3  经典范例3  使用条件编译隐藏密码	392
11.5  小结	393
11.6  实践与练习	393
第12章  文件	395
视频讲解：1小时23分钟
12.1  文件概述	396
12.2  文件基本操作	396
12.2.1  文件的打开	396
12.2.2  文件的关闭	398
范例1  关闭打开的所有文件	398
范例2  同时显示两个文件的内容	400
12.3  文件的读写	401
12.3.1  字符形式读写文件	402
12.3.2  字符串形式读写文件	404
12.3.3  成块读写文件	406
12.3.4  格式化读写函数	409
范例3  以行为单位读写文件	411
范例4  重命名文件	412
12.4  文件的定位	413
12.4.1  fseek函数	413
12.4.2  rewind函数	415
12.4.3  ftell函数	416
12.5  经典范例	419
12.5.1  经典范例1  合并两个文件信息	419
12.5.2  经典范例2  文件替换时的错误处理	420
12.5.3  经典范例3  文件分割	422
12.6  小结	424
12.7  实践与练习	424
第13章  图形图像	425
视频讲解：38分钟
13.1  字符屏幕	426
13.1.1  定义文本窗口	426
13.1.2  颜色设置	426

13.1.3  文本的输入和输出	427
13.1.4  屏幕操作函数	428
13.2  图形显示	431
13.2.1  图形模式初始化	431
13.2.2  屏幕颜色设置	434
13.2.3  基本图形函数	436
13.2.4  封闭图形的填充	443
范例1  颜色变换	445
范例2  彩色扇形	446
13.3  图形屏幕	447
13.4  图形模式下文本输出	448
13.4.1  文本输出函数	449
13.4.2  文本属性设置	450
范例3  跳动的小球	452
范例4  变化的同心圆	453
13.5  经典范例	454
13.5.1  经典范例1  绘制正弦曲线	454
13.5.2  经典范例2  绘制彩带	455
13.5.3  经典范例3  绘制五角星	456
13.6  小结	457
13.7  实践与练习	457
第4篇  项 目 实 战
第14章  商品信息管理系统  	461
视频讲解：21分钟
14.1  需求分析	462
14.2  预处理技术	462
14.3  结构体的使用	463
14.4  函数声明技术	463
14.5  功能选择界面	464

14.6  录入商品信息	466
14.7  查询商品信息	469
14.8  删除商品信息	471
14.9  修改商品信息	473
14.10  插入商品信息	475
14.11  统计商品数	478
14.12  小结	479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C/C++图形图像与游戏编程典型实例解析
目录
丛书序
前言
第1章 图形图像、游戏编程基础与应用实例
实例1 Visual C图像读写的编程实现
实例2 Visual C图像显示的编辑实现
实例3 Visual C图像增强的编程实现
实例4 Visual C傅立叶变换的编程实现
实例5 Visual C图像快速傅立叶变换篇
实例6 Visual C图像界面设计的编程实现
实例7 Visual C图像边缘检测的编程实现
实例8 图像的数字化艺术
实例9 图库管理系统的设计
实例10 三维地形实时动态显示的核心技术研究
实例11 在Visual C中定制DIB类
实例12 图论的两个实用算法的编程
实例13 在GDI+中双缓存的使用
实例14 基于CMYK图像的格式分析与读取实现
第2章 图形图像编程实例
第3章 游戏编程实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C/C++图形图像与游戏编程典型实例解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>世界英文歌曲经典
1.WeAreTheWorld（我们是世界）
2.DoThey KnowIt’sChristmas（他们是否知道今天是圣诞）
3.Thriller（恶魔）
4.BillieJean（比莉・珍）
5.BalyBeMine（陪伴我）
6.ThGirlIsMine（这女孩属于我）
7.HumanNature（人之天性）
8.Bad（真棒）
9.BeatIt（逃避）
10.P Y.T.（PrettyYoungThing）（可爱的小东西）
11.LadyInMy Life（我生命中的爱人）
12.Say SaySat（说说说）
13.Hello（喂）
14.SayYouSayMe（说你说我）
15.StuckOnYou（迷恋上你）
16.A11Night Long（Al1Night）（一整夜）
17.EndlessLove（不尽的爱）
18.Nightshift（夜班）
19.LikeAVirgin（像处女一般）
20.MaterialGirl（追求物质的女郎）
21.Crazy ForYou（为你着迷）
22.Holiday（节日）
23.Lucky Star（幸运之星）
24.Borderline（边界）
25.LaIslaBonita（美丽的海岛）
26.LiveToTell（倾诉）
27.Against Al1Odds（渺然梦里）
28.Sussudio（苏苏迪奥）
29.OneM0reNight（再给我一个夜晚）
30.InTheAir Tonight（从天而降）
31.TakeMeHome（带我回家）
32.HowDeepIsYourLove（你的爱有多深）
33.M0reThan AWoman（不仅仅是一个女人）
34.Faith（信义）
35.CarelessWhisper（无心耳语）
36.EverythingSheWants（她需要的一切）
37.Freedom（自由）
38.WakeMeUp BeforeYouGo－go（走前唤醒我）
39.BornInThe U.S A.（生于美国）
40.ThisLittleGirl（这个小女孩）
41.GimmeGimmeGimne（AMan After Midnight）（午夜的烦恼）
42.TakeAChanceOnMe（给我一个时机）
43.MoneyMoneyMoney（钞票，钞票）
44.DancingQueen（舞会皇后）
45.DoesYourMotherKnow（你妈妈是否知道）
46.Chiqu1tlta（齐格帝塔）
47.TheNameOfTheGame（奥秘）
48.SuperTrouper（超级演员）
49.OnAndOnAndOn（坚持下去）
50.A11OutOfLove（失去的爱）
51.HereIAm（在这里）
52.sweet Dreams（美梦）
53.Lost In Love（深深地爱上你）
54.Just AsIAm（就像我这样）
55.TimeAfterTime（一次又一次）
56.MoneyChanges Everything（金钱改变一切）
57.GirlsJust WantT HaveFun（女孩们就爱寻开心）
58.TrueColors（本色）
59.AllThruThe Night（通宵达旦）
60.EveryBreathYouTake（你的每一次呼吸）
61.IfYouLoveSomebody SetThem Free（如果你爱一个人就给他以自由）
62.Sunny（阳光）
63.Rasputin（拉斯普汀）
64.Yesterday（昨天）
65.LetItBe（随它去）
66.HeyJude（嗨，裘德）
67.Ob－1a－di Ob－la－da（奥勃拉第，奥勃拉达）
68.ADay InThe Life（生活中的一天）
69.TheLongAnd WindingRoad（漫长而崎岖的道路）
70.Help（帮帮我）
71.Imagine（设想）
72.NoMoreLonelyNights（夜不再孤寂）
73.TooLateForGoodbyes（无法说再见）
74.Valotte（瓦洛特）
75.WhyWorry（为何忧虑）
76.BrotlersInArmS（并肩兄弟）
77.So FarAWay（这样遥远）
78.ScarboroughFair（canticle）〔创伤之镇（赞美诗）〕
79.HomewardBound（回家路上）
80.Mrs Robmson（鲁滨逊夫人）
81.TheBoXer（拳击手）
82.FakingIt（装装样子）
83.ForEmilyWheneverIMay Find Her（致爱米丽）
84.LeavesThat AreGreen（绿叶）
85.BridgeOverTroubledWater（祸水上的桥）
86.FeelingGroovy（The59thStreetBridgSong）（这样美妙）
87.OH Friends（老年朋友）
88.TheGreatest LoveOfAll（最伟大的爱）
89.YouGiveGoodLove（你给了我深情的爱）
90.Heaven（天堂）
91.Straight FromTheHeart（敞开心扉）
92.TheGreatest GiftOffAll1（最美好的礼物）
93.IslandsInThe Stream（河中岛屿）
94.WhereTheStreetsHaveNoName（无名的街道）
95.IStillHaven’tFoundWhatI’mLookingFor（我还没有找到我的目的）
96.Nothing’sGonnaChangeMy LoveForYou（一切都无法改变我对你的爱）
97.Luka（鲁卡）
98 SometlmesWhenWeTouch（我们接触的时刻）
99.St.Elmo’sFire（圣爱尔默之火）
100.IWantTo KnowWhatLoveIs（我想知道什么是爱）
101.EverytimeYouGo Away（每次你离我而去）
102.OutOfTouch（孤立无援）
103.NeutronDance（中子舞）
104.ILikeChopin（我爱肖邦）
105.Woman In Love（爱河中的女人）
106.Handy Man（热心人）
……

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>世界英文歌曲经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 4高级编程
第1章 应用程序和页面架构 1  1.1 应用程序的位置选项 1    1.1.1 内置的Web服务器 2    1.1.2 IIS 3    1.1.3 FTP 3    1.1.4 Web站点需要Frontpage Extensions 4  1.2 ASP.NET页面结构选项 5    1.2.1 内联编码 6    1.2.2 隐藏代码模型 8  1.3 ASP.NET 4的page指令 10    1.3.1 @Page指令 11    1.3.2 @Master指令 13    1.3.3 @Control指令 14    1.3.4 @Import指令 15    1.3.5 @Implements指令 17    1.3.6 @Register指令 17    1.3.7 @Assembly指令 18    1.3.8 @Previouspagetype指令 18    1.3.9 @Mastertype指令 18    1.3.10 @Outputcache指令 19    1.3.11 @Reference指令 19  1.4 ASP.NET的页面事件 19  1.5 处理回送 21  1.6 跨页面的传送 22  1.7 ASP.NET应用程序文件夹 27    1.7.1 App_code文件夹 28    1.7.2 App_data文件夹 32    1.7.3 App_themes文件夹 32    1.7.4 App_globalresources文件夹 32    1.7.5 App_localresources文件夹 32    1.7.6 App_Webreferences文件夹 33    1.7.7 App_browsers文件夹 33  1.8 编译 33  1.9 Build Provider 33    1.9.1 使用内置的Build Provider 38    1.9.2 使用自己的Build Provider 38  1.10 Global.Asax 43  1.11 通过Visual Studio 2010使用类 47  1.12 本章小结 50第2章 ASP.NET服务器控件和客户端脚本 51第3章 ASP.NET Web服务器控件 87第4章 验证服务器控件 161第5章 使用母版页 189第6章 主题和外观 219第7章 ASP.NET 4中的数据绑定 237第8章 使用ADO.NETt管理数据 311第9章 使用LINQ查询 375第10章 使用XML和LINQ to XML 409第11章 提供程序模型概述 463第12章 扩展提供程序模型 497第13章 站点导航 525第14章 个性化 575第15章 成员和角色管理 605第16章 Portal Framework和Web Part 651第17章 使用ASP.NET进行HTML和CSS设计 691第18章 ASP.NET Ajax 719第19章 ASP.NET Ajax控件工具集 757第20章 安全性 817第21章 状态管理 847第22章 高速缓存 879第23章 调试和错误处理技术 909第24章 文件I/O和流 941第25章 用户控件和服务器控件 997第26章 模块和处理程序 1067第27章 ASP.NET MVC 1081第28章 使用业务对象 1105第29章 ADO.NETt Entity Framework 1129第30章 ASP.NET Dynamic Data 1155第31章 使用服务 1179第32章 应用程序的国际化 1245第33章 配置 1267第34章 测试 1315第35章 管理 1347第36章 打包和部署ASP.NET应用程序 1369附录A 迁移ASP.NET旧项目 1399附录B ASP.NET终极工具 1411附录C Silverlight 3和ASP.NET 1429附录D 动态类型与语言 1451附录E ASP.NET联机资源 1459
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 4高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新编C语言习题与解析
第1章  概述	1
知识点：C语言的基本概念	1
要点归纳	1
例题解析	4
第2章  数据类型及其运算	8
2.1  知识点1：数据类型	8
2.1.1  要点归纳	8
2.1.2  例题解析	22
2.2  知识点2：数据输入与输出	36
2.2.1  要点归纳	36
2.2.2  例题解析	40
第3章  选择语句和循环语句	47
3.1  知识点1：选择语句	47
3.1.1  要点归纳	47
3.1.2  例题解析	49
3.2  知识点2：循环语句	59
3.2.1  要点归纳	59
3.2.2  例题解析	61
3.3  知识点3：穷举法	80
3.3.1  要点归纳	80
3.3.2  例题解析	82
第4章  数  组	87
4.1  知识点1：数组的基本概念	87
4.1.1  要点归纳	87
4.1.2  例题解析	90
4.2  知识点2：字符数组和字符串数组	101
4.2.1  要点归纳	101
4.2.2  例题解析	104
4.3  知识点3：数组的排序	114
4.3.1  要点归纳	114
4.3.2  例题解析	119
4.4  知识点4：数组的查找	124
4.4.1  要点归纳	124
4.4.2  例题解析	125
第5章  指  针	127
5.1  知识点1：指针的概念	127
5.1.1  要点归纳	127
5.1.2  例题解析	129
5.2  知识点2：指针和数组	133
5.2.1  要点归纳	133
5.2.2  例题解析	139
5.3  知识点3：指针数组和多级指针	157
5.3.1  要点归纳	157
5.3.2  例题解析	158
第6章  函  数	167
6.1  知识点1：函数的基本概念	167
6.1.1  要点归纳	167
6.1.2  例题解析	168
6.2  知识点2：函数和变量的存储类别	175
6.2.1  要点归纳	175
6.2.2  例题解析	178
6.3  知识点3：函数的数据传递	184
6.3.1  要点归纳	184
6.3.2  例题解析	186
6.4  知识点4：指针型函数	203
6.4.1  要点归纳	203
6.4.2  例题解析	203
6.5  知识点5：指向函数的指针	207
6.5.1  要点归纳	207
6.5.2  例题解析	208
6.6  知识点6：递归函数	210
6.6.1  要点归纳	210
6.6.2  例题解析	212
6.7  知识点7：命令行参数	215
6.7.1  要点归纳	215
6.7.2  例题解析	215
第7章  结构体与共用体	218
7.1  知识点1：结构体类型和结构体变量	218
7.1.1  要点归纳	218
7.1.2  例题解析	221
7.2  知识点2：结构体数组和结构体指针	226
7.2.1  要点归纳	226
7.2.2  例题解析	228
7.3  知识点3：函数之间结构体变量的数据传递	237
7.3.1  要点归纳	237
7.3.2  例题解析	237
7.4  知识点4：结构体的应用——链表	242
7.4.1  要点归纳	242
7.4.2  例题解析	244
7.5  知识点5：共用体	254
7.5.1  要点归纳	254
7.5.2  例题解析	255
7.6  知识点6：枚举类型	261
7.6.1  要点归纳	261
7.6.2  例题解析	262
7.7  知识点7：用户定义类型	264
7.7.1  要点归纳	264
7.7.2  例题解析	264
第8章  预编译处理和位段	268
8.1  知识点1：宏	268
8.1.1  要点归纳	268
8.1.2  例题解析	269
8.2  知识点2：条件编译	277
8.2.1  要点归纳	277
8.2.2  例题解析	278
8.3  知识点3：文件包含	280
8.3.1  要点归纳	280
8.3.2  例题解析	280
8.4  知识点4：位段	281
8.4.1  要点归纳	281
8.4.2  例题解析	282
第9章  文件	284
9.1  知识点1：文件概述	284
9.1.1  要点归纳	284
9.1.2  例题解析	286
9.2  知识点2：文件的操作	289
9.2.1  要点归纳	289
9.2.2  例题解析	292
9.3  知识点3：文件的定位和随机读/写操作	308
9.3.1  要点归纳	308
9.3.2  例题解析	309
附录A  C语言常见错误	323
附录B  近几年全国计算机等级考试二级C试题	328
参考文献	338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新编C语言习题与解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>The Art of Death
Introduction
The Object of Commemoration
Rites of Passage
Dying, A Process
Dances of Death
Examples of Virtue
Death, A Bad Business
Two Bodies
Body Language
The Natural Body and its Fate
Funerals: The Declaration of Difference
Heraldic Displays
Funereal Paraphernalia
Liturgies
Worn Out and In
Objects of Mourning
The Monumental Body
Kinds of Monument
Image Theory
Epilogue
References
Select Bibliography
List of Illustrations
Acknowledgements
Index
Distributed by Syndetic Solutions, Inc.
简介
纪念活动的对象
仪式通行
临终，这个过程
死亡之舞
美德示例
死亡，令人沮丧的职责
两个机构
身体语言
自然的身体和它的命运
葬礼：宣言的差
纹章显示
葬礼的形式
礼仪
循环往复（轮回）
莫宁的宗旨
不朽的身体
种纪念碑
意象理论
尾声
参考文献
选择书目
插图名单
致谢
指数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>The Art of Death
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字图像处理与机器视觉
第0章　初识数字图像处理与机器视觉　1
0．1　数字图像　1
0．1．1　什么是数字图像　1
0．1．2　数字图像的显示　1
0．1．3　数字图像的分类　2
0．1．4　数字图像的实质　3
0．1．5　数字图像的表示　4
0．1．6　图像的空间和灰度级分辨率　4
0．2　数字图像处理与机器视觉　5
0．2．1　从图像处理到图像识别　5
0．2．2　什么是机器视觉　6
0．2．3　数字图像处理和识别的应用实例　7
0．3　数字图像处理的预备知识　8
0．3．1　邻接性、连通性、区域和边界　8
0．3．2　距离度量的几种方法　9
0．3．3　基本的图像操作　10
第1章　MATLAB数字图像处理编程基础　11
1．1　MATLAB R2011a简介　11
1．1．1　MATLAB软件环境　11
1．1．2　文件操作　12
1．1．3　在线帮助的使用　13
1．1．4　变量的使用　15
1．1．5　矩阵的使用　17
1．1．6　细胞数组(Cell Array)和结构体(Structure)　19
1．1．7　关系运算与逻辑运算　20
1．1．8　常用图像处理数学函数　21
1．1．9　MATLAB程序流程控制　22
1．1．10　M文件编写　25
1．1．11　MATLAB函数编写　26
1．2　MATLAB图像类型及其存储方式　28
1．3　MATLAB的图像转换　30
1．4　读取和写入图像文件　32
1．5　图像的显示　34
第2章　Visual C++图像处理编程基础　37
2．1　位图文件及其C++操作　37
2．1．1　设备无关位图　37
2．1．2　BMP图像文件数据结构　37
2．2　认识CImg类　40
2．2．1　主要成员函数列表　40
2．2．2　公有成员　41
2．3　CImg类基础操作　41
2．3．1　加载和写入图像　41
2．3．2　获得图像基本信息　44
2．3．3　检验有效性　45
2．3．4　按像素操作　45
2．3．5　改变图像大小　47
2．3．6　重载的运算符　47
2．3．7　在屏幕上绘制位图图像　48
2．3．8　新建图像　48
2．3．9　图像类型的判断与转化　50
2．4　DIPDemo工程　51
2．4．1　DIPDemo主界面　51
2．4．2　图像操作和处理类——CImg和CImgProcess　52
2．4．3　文档类——CDIPDemoDoc　53
2．4．4　视图类——CDIPDemoView　53
2．5　CImg应用示例　54
2．5．1　打开图像　54
2．5．2　清空图像　55
2．5．3　像素初始化方法　56
2．5．4　保存图像　57
第3章　图像的点运算　58
3．1　灰度直方图　58
3．1．1　理论基础　58
3．1．2　MATLAB实现　59
3．1．3　Visual C++实现　62
3．2　灰度的线性变换　63
3．2．1　理论基础　63
3．2．2　MATLAB程序的实现　64
3．2．3　Visual C++实现　66
3．3　灰度对数变换　67
3．3．1　理论基础　67
3．3．2　MATLAB实现　68
3．3．3　Visual C++实现　69
3．4　伽玛变换　70
3．4．1　理论基础　70
3．4．2　MATLAB编程实现　70
3．4．3　Visual C++实现　72
3．5　灰度阈值变换　73
3．5．1　理论基础　73
3．5．2　MATLAB编程实现　74
3．5．3　Visual C++实现　75
3．6　分段线性变换　76
3．6．1　理论基础　76
3．6．2　MATLAB编程实现　77
3．6．3　Visual C++编程实现　81
3．7　直方图均衡化　82
3．7．1　理论基础　82
3．7．2　MATLAB编程实现　83
3．7．3　Visual C++实现　85
3．8　直方图规定化(匹配)　86
3．8．1　理论基础　86
3．8．2　MATLAB编程实现　87
3．8．3　Visual C++实现　89
第4章　图像的几何变换　92
4．1　解决几何变换的一般思路　92
4．2　图像平移　94
4．2．1　图像平移的变换公式　94
4．2．2　图像平移的实现　94
4．3　图像镜像　96
4．3．1　图像镜像的变换公式　96
4．3．2　图像镜像的实现　97
4．4　图像转置　99
4．4．1　图像转置的变换公式　99
4．4．2　图像转置的实现　99
4．5　图像缩放　101
4．5．1　图像缩放的变换公式　101
4．5．2　图像缩放的实现　101
4．6　图像旋转　103
4．6．1　以原点为中心的图像旋转　103
4．6．2　以任意点为中心的图像旋转　104
4．6．3　图像旋转的实现　105
4．7　插值算法　106
4．7．1　最近邻插值　106
4．7．2　双线性插值　107
4．7．3　高阶插值　109
4．8　图像配准简介　111
4．8．1　图像配准　112
4．8．2　人脸图像配准的MATLAB实现　112
4．9　Visual C++高级应用实例——汽车牌照的投影失真校正　115
4．9．1　系统分析与设计　116
4．9．2　系统实现　117
4．9．3　功能测试　122
第5章　空间域图像增强　126
5．1　图像增强基础　126
5．2　空间域滤波　127
5．3　图像平滑　133
5．3．1　平均模板及其实现　133
5．3．2　高斯平滑及其实现　134
5．3．3　通用平滑滤波的Visual C++实现　138
5．3．4　自适应平滑滤波　139
5．4　中值滤波　140
5．4．1　性能比较　140
5．4．2　一种改进的中值滤波策略　144
5．4．3　中值滤波的工作原理　145
5．5　图像锐化　145
5．5．1　理论基础　145
5．5．2　基于一阶导数的图像增强——梯度算子　145
5．5．3　基于二阶微分的图像增强——拉普拉斯算子　149
5．5．4　基于一阶与二阶导数的锐化算子的比较　151
5．5．5　高提升滤波及其实现　152
5．5．6　高斯-拉普拉斯变换(Laplacian of a Gaussian，LoG)　156
第6章　频率域图像增强　159
6．1　频率域滤波——与空间域滤波殊途同归　159
6．2　傅里叶变换基础知识　159
6．2．1　傅里叶级数　159
6．2．2　傅里叶变换　161
6．2．3　幅度谱、相位谱和功率谱　163
6．2．4　傅里叶变换的实质——基的转换　165
6．3　快速傅里叶变换及实现　166
6．3．1　FFT变换的必要性　167
6．3．2　常见的FFT算法　167
6．3．3　按时间抽取的基-2 FFT算法　168
6．3．4　离散反傅里叶变换的快速算法　171
6．3．5　N维快速傅里叶变换　171
6．3．6　MATLAB实现　171
6．3．7　Visual C++实现　175
6．4　频域滤波基础　183
6．4．1　频域滤波与空域滤波的关系　183
6．4．2　频域滤波的基本步骤　184
6．4．3　频域滤波的MATLAB实现　184
6．4．4　频域滤波的Visual C++实现　185
6．5　频率域低通滤波器　187
6．5．1　理想低通滤波器及其实现　187
6．5．2　高斯低通滤波器及其实现　191
6．6　频率域高通滤波器　195
6．6．1　高斯高通滤波器及其实现　195
6．6．2　频域拉普拉斯滤波器及其实现　198
6．7　MATLAB综合案例——利用频域滤波消除周期噪声　201
6．7．1　频域带阻滤波器　201
6．7．2　带阻滤波器消除周期噪声　202
6．8　频域滤波器与空域滤波器之间的内在联系　204
附录　205
第7章　小波变换　207
7．1　多分辨率分析　207
7．1．1　多分辨率框架　207
7．1．2　分解与重构的实现　213
7．1．3　图像处理中分解与重构的实现　214
7．2　Gabor多分辨率分析　220
7．3　常见小波分析　223
7．3．1　Haar小波　223
7．3．2　Daubechies小波　225
7．4　高维小波　227
第8章　图像复原　230
8．1　图像复原的理论模型　230
8．1．1　图像复原的基本概念　230
8．1．2　图像复原的一般模型　232
8．2　噪声模型　232
8．2．1　噪声种类　233
8．2．2　MATLAB实现　237
8．2．3　Visual C++实现　239
8．3　空间滤波　244
8．3．1　空域滤波原理　244
8．3．2　MATLAB实现　245
8．3．3　Visual C++实现　247
8．4　逆滤波复原　250
8．4．1　逆滤波原理　250
8．4．2　MATLAB实现　251
8．4．3　Visual C++实现　253
8．5　维纳滤波复原　256
8．5．1　维纳滤波原理　256
8．5．2　MATLAB实现　257
8．5．3　Visual C++实现　260
8．6　有约束最小二乘复原　262
8．7　Lucky-Richardson复原　265
8．8　盲去卷积图像复原　266
8．9　MATLAB图像复原综合案例——去除照片的运动模糊　268
第9章　彩色图像处理　270
9．1　彩色基础　270
9．2　彩色模型　272
9．2．1　RGB模型　272
9．2．2　CMY、CMYK模型　274
9．2．3　HSI模型　276
9．2．4　HSV模型　282
9．2．5　YUV模型　287
9．2．6　YIQ模型　292
9．2．7　Lab模型简介　296
9．3　全彩色图像处理基础　296
9．3．1　彩色补偿及其MATLAB实现　296
9．3．2　彩色平衡及其MATLAB实现　298
第10章　图像压缩　300
10．1　图像压缩理论　300
10．1．1　图像冗余　300
10．1．2　香农定理　303
10．1．3　保真度评价　304
10．2　DCT变换与量化　304
10．2．1　DCT变换原理　304
10．2．2　量化　306
10．2．3　DCT变换和量化的Visual C++实现　307
10．3　预测编码　312
10．4　霍夫曼编码　313
10．4．1　霍夫曼编码原理　313
10．4．2　霍夫曼编码的Visual C++实现　316
10．5　算术编码　324
10．5．1　算术编码原理　324
10．5．2　算术编码的Visual C++实现　327
10．6　游程编码　330
10．7　JPEG和JPEG2000压缩标准　331
10．8　Visual C++综合案例——类似JPEG的图像压缩　332
第11章　形态学图像处理　341
11．1　预备知识　341
11．2　二值图像中的基本形态学运算　342
11．2．1　腐蚀及其实现　343
11．2．2　膨胀及其实现　350
11．2．3　开运算及其实现　353
11．2．4　闭运算及其实现　356
11．3　二值图像中的形态学应用　357
11．3．1　击中与击不中变换及其实现　357
11．3．2　边界提取与跟踪及其实现　359
11．3．3　区域填充及其Visual C++实现　363
11．3．4　连通分量提取及其实现　365
11．3．5　细化算法及其Visual C++实现　370
11．3．6　像素化算法及其Visual C++实现　374
11．3．7　凸壳及其Visual C++实现　379
11．3．8　bwmorph()函数　382
11．4　灰度图像中的基本形态学运算　383
11．4．1　灰度膨胀及其实现　383
11．4．2　灰度腐蚀及其实现　386
11．4．3　灰度开、闭运算及其实现　389
11．4．4　顶帽变换(top-hat)及其实现　392
小结　394
第12章　图像分割　395
12．1　图像分割概述　395
12．2　边缘检测　396
12．2．1　边缘检测概述　396
12．2．2　常用的边缘检测算子　397
12．2．3　MATLAB实现　400
12．2．4　Visual C++实现　402
12．3　霍夫变换　409
12．3．1　直线检测　409
12．3．2　曲线检测　411
12．3．3　任意形状的检测　411
12．3．4　Hough变换直线检测的MATLAB实现　412
12．3．5　Hough变换直线检测的Visual C++实现　415
12．4　阈值分割　418
12．4．1　阈值分割方法　419
12．4．2　MATLAB实现　422
12．4．3　Visual C++实现　423
12．5　区域分割　425
12．5．1　区域生长及其实现　425
12．5．2　区域分裂与合并及其MATLAB实现　429
12．6　小结　433
第13章　特征提取　434
13．1　图像特征概述　434
13．2　基本统计特征　436
13．2．1　简单的区域描绘子及其MATLAB实现　436
13．2．2　直方图及其统计特征　437
13．2．3　灰度共现矩阵及其Visual C++实现　439
13．3　特征降维　442
13．3．1　维度灾难　442
13．3．2　特征选择简介　443
13．3．3　主成分分析　444
13．3．4　快速PCA及其实现　450
13．4　综合案例——基于PCA的人脸特征抽取　451
13．4．1　数据集简介　452
13．4．2　生成样本矩阵　452
13．4．3　主成分分析　453
13．4．4　主成分脸可视化分析　454
13．4．5　基于主分量的人脸重建　456
13．5　局部二进制模式　457
13．5．1　基本LBP　457
13．5．2　圆形邻域的LBPP，R算子　458
13．5．3　统一化LBP算子——Uniform LBP及其MATLAB实现　459
13．5．4　MB-LBP及其MATLAB实现　462
13．5．5　图像分区及其MATLAB实现　467
第14章　图像识别初步　470
14．1　模式识别概述　470
14．2　模式识别方法分类　474
14．3　最小距离分类器和模板匹配　476
14．3．1　最小距离分类器及其MATLAB实现　476
14．3．2　基于相关的模板匹配　477
14．3．3　相关匹配的计算效率　482
第15章　人工神经网络　484
15．1　人工神经网络简介　484
15．1．1　仿生学动机　484
15．1．2　人工神经网络的应用实例　486
15．2　人工神经网络的理论基础　487
15．2．1　训练线性单元的梯度下降算法　487
15．2．2　多层人工神经网络　492
15．2．3　Sigmoid单元　492
15．2．4　反向传播(Back Propagation，BP)算法　493
15．2．5　训练中的问题　496
15．3　基于ANN的数字字符识别系统DigitRec——分析与设计　498
15．3．1　任务描述　498
15．3．2　数据集简介　498
15．3．3　设计要点　498
15．4　基于ANN的数字字符识别系统——DigitRec的实现　500
15．4．1　构建神经元结构——SNeuron　500
15．4．2　构建神经网络网络层——SNeuronLayer　501
15．4．3　神经网络信息头——NeuralNet_Header　502
15．4．4　神经网络类——CNeuralNet　502
15．4．5　神经网络的训练数据类——CNeuralData　513
15．4．6　误差跟踪类——CValueTrack　518
15．4．7　训练对话框类——CTrainDlg　520
15．4．8　测试对话框类——CTestDlg　523
15．5　基于ANN的数字字符识别系统——DigitRec的测试　526
15．5．1　训练　526
15．5．2　测试　526
15．6　改进的DigitRec　527
15．6．1　数字字符图像的预处理类——COCRImageProcess　527
15．6．2　输入图像的预处理——实现　528
15．6．3　输入图像的预处理——测试　539
15．7　神经网络参数对训练和识别的影响　540
15．7．1　隐藏层单元数目的影响　540
15．7．2　学习率的影响　541
15．7．3　训练时代数目的影响　542
第16章　支持向量机　544
16．1　支持向量机的分类思想　544
16．2　支持向量机的理论基础　545
16．2．1　线性可分情况下的SVM　545
16．2．2　非线性可分情况下的C-SVM　548
16．2．3　需要核函数映射情况下的SVM　550
16．2．4　推广到多类问题　553
16．3　SVM的MATLAB实现　554
16．3．1　训练——svmtrain　555
16．3．2　分类——svmclassify　556
16．3．3　应用实例　557
16．4　综合案例——基于PCA和SVM的人脸识别系统　557
16．4．1　人脸识别简介　558
16．4．2　前期处理　558
16．4．3　数据规格化　558
16．4．4　核函数的选择　561
16．4．5　参数选择　562
16．4．6　构建多类SVM分类器　564
16．4．7　实验结果　566
16．5　SVM在线资源　571
16．5．1　MATLAB的SVM工具箱　572
16．5．2　LibSVM的简介　572
第17章　AdaBoost　573
17．1　AdaBoost分类思想　573
17．2　AdaBoost理论基础　575
17．3　构建AdaBoost的MATLAB工具箱　577
17．4　MATLAB综合案例——基于AdaBoost的面部图像男女性别分类　580
17．4．1　关于数据集　580
17．4．2　数据的预处理　581
17．4．3　算法流程实现　581
参考文献　583
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数字图像处理与机器视觉
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++代码整洁之道：C++17可持续软件开发模式实践
译者序
关于作者
关于技术审校
致谢
第1章　简介1
1.1　软件熵2
1.2　整洁的代码4
1.3　为什么使用C 4
1.4　C 11—新时代的开始5
1.5　适合本书的读者5
1.6　本书使用的约定6
1.6.1　扩展阅读6
1.6.2　说明、提示和警告6
1.6.3　示例代码7
1.6.4　编码风格7
1.7　相关网站和代码库7
1.8　UML图8
第2章　构建安全体系9
2.1　测试的必要性9
2.2　测试入门11
2.3　单元测试13
2.4　关于QA15
2.5　良好的单元测试原则16
2.5.1　单元测试的代码的质量16
2.5.2　单元测试的命名16
2.5.3　单元测试的独立性17
2.5.4　一个测试一个断言18
2.5.5　单元测试环境的独立初始化19
2.5.6　不对getters和setters做单元测试19
2.5.7　不对第三方代码做单元测试20
2.5.8　不对外部系统做单元测试20
2.5.9　如何处理数据库的访问20
2.5.10　不要混淆测试代码和产品代码21
2.5.11　测试必须快速执行23
2.5.12　测试替身24
第3章　原则27
3.1　什么是原则27
3.2　保持简单和直接原则（KISS）28
3.3　不需要原则（YAGNI）29
3.4　避免复制原则（DRY）29
3.5　信息隐藏原则30
3.6　高内聚原则33
3.7　松耦合原则35
3.8　小心优化原则38
3.9　最少惊讶原则（PLA）39
3.10　童子军原则39
第4章　C 代码整洁的基本规范41
4.1　良好的命名42
4.1.1　名称应该自解释43
4.1.2　使用域中的名称45
4.1.3　选择适当抽象层次的名称45
4.1.4　避免冗余的名称46
4.1.5　避免晦涩难懂的缩写47
4.1.6　避免匈牙利命名和命名前缀47
4.1.7　避免相同的名称用于不同的目的48
4.2　注释49
4.2.1　让写代码像讲故事一样49
4.2.2　不要为易懂的代码写注释50
4.2.3　不要通过注释禁用代码50
4.2.4　不要写块注释51
4.2.5　特殊情况的注释是有用的53
4.3　函数56
4.3.1　只做一件事情59
4.3.2　让函数尽可能小59
4.3.3　函数命名61
4.3.4　使用容易理解的名称61
4.3.5　函数的参数和返回值62
4.4　C 工程中的C风格代码72
4.4.1　使用C 的string和stream替代C风格的char*73
4.4.2　避免使用printf()、sprintf()和gets()等74
4.4.3　使用标准库的容器而不是C风格的数组77
4.4.4　用C 类型转换代替C风格的强制转换80
4.4.5　避免使用宏81
第5章　现代C 的高级概念83
5.1　资源管理84
5.1.1　资源申请即初始化85
5.1.2　智能指针86
5.1.3　避免显式的new和delete92
5.1.4　管理特有资源92
5.2　Move语义94
5.2.1　什么是Move语义94
5.2.2　左值和右值的关系95
5.2.3　右值引用96
5.2.4　不要滥用Move97
5.2.5　零原则98
5.3　编译器是你的搭档102
5.3.1　自动类型推导102
5.3.2　编译时计算105
5.3.3　模板变量107
5.4　不允许未定义的行为108
5.5　Type-Rich编程110
5.6　了解你使用的库116
5.6.1　熟练使用116
5.6.2　熟练使用Boost121
5.6.3　应该了解的一些库121
5.7　恰当的异常和错误处理机制122
5.7.1　防患于未然123
5.7.2　异常即异常—字面上的意思126
5.7.3　如果不能恢复则尽快退出128
5.7.4　用户自定义异常128
5.7.5　值类型抛出，常量引用类型捕获130
5.7.6　注意catch的正确顺序130
第6章　面向对象131
6.1　面向对象思想132
6.2　抽象—解决复杂问题的关键因素133
6.3　类的设计原则134
6.3.1　让类尽可能小134
6.3.2　单一职责原则（SRP）135
6.3.3　开闭原则（OCP）135
6.3.4　里氏替换原则(LSP)136
6.3.5　接口隔离原则（ISP）146
6.3.6　无环依赖原则148
6.3.7　依赖倒置原则（DIP）151
6.3.8　不要和陌生人说话（迪米特法则）156
6.3.9　避免“贫血类”160
6.3.10　只说不问160
6.3.11　避免类的静态成员162
第7章　函数式编程164
7.1　什么是函数式编程165
7.1.1　什么是函数166
7.2.2　pure函数和impure函数167
7.2　现代C 中的函数式编程168
7.2.1　C 模板函数编程168
7.2.2　仿函数170
7.2.3　绑定和函数包装176
7.2.4　Lambda表达式178
7.2.5　通用Lambda表达式（C 14）180
7.3　高阶函数181
7.4　整洁的函数式编程代码186
第8章　测试驱动开发188
8.1　普通的旧单元测试的缺点189
8.2　测试驱动开发作为颠覆者190
8.2.1　TDD的流程190
8.2.2　TDD的一个小例子：Code Kata193
8.3　TDD的优势210
8.4　什么时候不应该使用TDD212
第9章　设计模式和习惯用法213
9.1　设计原则与设计模式214
9.2　常见的设计模式及应用场景214
9.2.1　依赖注入模式215
9.2.2　Adapter模式226
9.2.3　Strategy模式227
9.2.4　Command模式231
9.2.5　Command处理器模式235
9.2.6　Composite模式238
9.2.7　Observer模式241
9.2.8　Factory模式245
9.2.9　Facade模式248
9.2.10　Money Class模式249
9.2.11　特例模式252
9.3　什么是习惯用法255
附录A　UML简要指南266
参考文献275
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++代码整洁之道：C++17可持续软件开发模式实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言大学实用教程
版权信息
致本书读者
前言
第1章 程序设计ABC
1.1 计算机与人
1.2 计算机与程序设计语言
1.3 程序设计语言的故事
1.4 C语言的故事
1.5 程序设计语言的工作原理
1.5.1 运行
1.5.2 内存
1.6 本章小结
习题1
第2章 数据类型、运算符与表达式
2.1 一个简单的C程序例子
2.2 C程序常见符号分类
2.3 数据类型
2.3.1 为什么引入数据类型
2.3.2 从基本数据类型到抽象数据类型
2.3.3 类型修饰符
2.3.4 标识符命名
2.4 常量
2.4.1 整型常量
2.4.2 实型常量
2.4.3 字符常量
2.4.4 字符串常量
2.4.5 宏常量
2.4.6 枚举常量
2.5 变量
2.5.1 变量的定义与初始化
2.5.2 const类型修饰符
2.5.3 使用变量时的注意事项
2.6 常用运算符及表达式
2.6.1 运算符的优先级与结合性
2.6.2 算术运算符
2.6.3 关系运算符
2.6.4 逻辑运算符
2.6.5 赋值运算符
2.6.6 增1和减1运算符
2.6.7 类型强制转换运算符
2.6.8 位运算符
2.6.9 逗号运算符
2.7 赋值和表达式中的类型转换
2.8 本章小结
习题2
第3章 键盘输入与屏幕输出
3.1 C语句分类
3.2 表达式语句
3.3 复合语句和空语句
3.4 基本的输入/输出操作
3.4.1 字符输入/输出
3.4.2 格式输入/输出
*3.4.3 使用函数scanf（）时需要注意的问题
3.5 本章小结
习题3
第4章 程序的控制结构
4.1 算法及其描述方法
4.1.1 算法的概念
4.1.2 算法的描述方法
4.2 顺序结构
4.2.1 顺序结构的流程图表示
4.2.2 应用程序举例
4.3 选择结构
4.3.1 应用场合
4.3.2 选择结构的流程图表示
4.3.3 条件语句
4.3.4 开关语句
4.4 循环结构
4.4.1 应用场合
4.4.2 循环结构的流程图表示
4.4.3 循环语句
4.4.4 单重循环程序实例
4.4.5 嵌套循环及其程序实例
4.5 流程转移控制语句
4.5.1 goto语句
4.5.2 break与continue语句
4.5.3 程序实例
*4.6 程序调试与排错
4.6.1 程序中常见的出错原因
4.6.2 程序调试与排错的基本方法
4.6.3 使用getchar（）需要注意的问题
*4.7 结构化程序设计方法简介
4.7.1 关于goto论战
4.7.2 结构化程序设计的核心思想
4.7.3“自顶向下、逐步求精”的程序设计方法
4.8 本章小结
习题4
第5章 函数
5.1 程序设计的艺术
5.2 函数的定义与使用
5.2.1 函数的分类
5.2.2 函数的定义
5.2.3 函数的调用、参数传递和返回值
5.2.4 函数原型
5.2.5 主函数main（）的特殊性
5.3 变量的作用域和存储类型
5.3.1 变量的作用域
5.3.2 全局变量
5.3.3 变量的存储类型
5.4 函数封装
5.5 预处理指令
5.5.1＃include
5.5.2＃define和＃undef
5.5.3 条件编译
5.6 使用assert（）查错
5.7 模块和链接
*5.8 模块化程序设计方法简介
5.8.1 模块划分的原则
5.8.2 应用实例——“猜数”游戏
*5.9 递归
5.9.1 递归问题的提出
5.9.2 递归函数
5.10 本章小结
习题5
第6章 数组
6.1 数组类型的应用场合
6.2 数组的定义、引用和初始化
6.2.1 数组的定义
6.2.2 数组的引用
6.2.3 数组的初始化
6.2.4 程序实例
6.3 向函数传递一维数组
6.4 向函数传递二维数组
6.5 字符数组
6.5.1 字符数组与字符串的关系
6.5.2 字符数组的输入/输出
6.5.3 字符串处理函数
6.5.4 应用实例
6.6 本章小结
习题6
第7章 指针
7.1 指针概述
7.1.1 指针的概念
7.1.2 为什么引入指针的概念
7.1.3 指针变量作函数参数
7.1.4 字符指针作函数参数
7.2 指针和数组间的关系
7.2.1 一维数组的地址和指针
7.2.2 二维数组的地址和指针
7.3 指针数组
*7.4 函数指针
*7.5 带参数的main（）函数
*7.6 动态数组的实现
7.6.1 C程序的内存映像
7.6.2 动态内存分配函数
7.6.3 一维动态数组的实现
7.6.4 二维动态数组的实现
*7.7 使用const修饰指针变量
*7.8 代码风格
7.8.1 程序版式
7.8.2 命名规则
7.8.3 函数设计
7.8.4 防御性程序设计
7.9 本章小结
习题7
第8章 结构体与共用体
8.1 结构体的应用场合
8.2 结构体类型与结构体变量
8.2.1 结构体类型的声明
8.2.2 用typedef定义结构体类型
8.2.3 结构体变量的定义
8.2.4 指向结构体变量的指针
8.2.5 结构体变量的引用和初始化
8.3 结构体数组
8.3.1 结构体数组的定义
8.3.2 结构体数组程序实例
8.3.3 指向结构体数组的指针
8.4 向函数传递结构体
*8.5 动态数据结构
8.5.1 问题的提出
8.5.2 链表的定义
8.5.3 链表的特点及操作原理
8.5.4 链表的建立
8.5.5 链表的删除操作
8.5.6 链表的插入操作
8.6 共用体
8.7 本章小结
习题8
第9章 文件操作
9.1 计算机中的流
9.2 文件
9.2.1 存储设备的使用
9.2.2 目录
9.2.3 文件格式
9.3 基本文件操作
9.3.1 基本文件操作函数
9.3.2 错误处理
9.3.3 程序示例
9.3.4 基本文件操作的意义
9.4 高级文件操作
9.4.1 文件的打开与关闭
9.4.2 文件的读/写
9.4.3 程序实例
9.4.4 标准输入与标准输出
9.5 本章小结
习题9
第10章 C程序设计常见错误及解决方案
条款1：使用未初始化和未赋值的变量
条款2：不考虑数值溢出的可能
条款3：不用sizeof（）获得类型或变量的字长
条款4：假定类型取值范围
条款5：期望两个整数的运算自动得出浮点数的结果
条款6：不预先判断除数是否为0
条款7：混淆“＆，|”与“＆＆，||”
条款8：使用依赖编译器求值顺序的语句
条款9：使用依靠算符优先级的表达式
条款10：表达式过于复杂
条款11：用“==”时误用“=”
条款12：用“==”比较两个浮点数
条款13：使用幻数
条款14：printf（）和scanf（）中格式控制字符串与参数类型不匹配
条款15：循环或判断语句以“；”结尾
条款16：在循环体内改变循环结束条件
条款17：case分支不用break结束
条款18：switch-case语句没有default分支
条款19：不声明函数原型
条款20：不定义函数参数或返回值的类型
条款21：有返回值的函数不用return指明返回值
条款22：调用函数后，不检查函数是否正确执行
条款23：变量、函数和模块功能不单一
条款24：函数过长
条款25：函数的参数过于复杂
条款26：返回指向局部变量的指针
条款27：随意修改全局变量的值
条款28：数组下标越界
条款29：字符串没有'\0'终结符
条款30：使用不限制最大处理长度的字符串处理函数
条款31：用malloc（）申请的内存不用free（）
条款32：使用已经被free（）的指针
条款33：文件打开后不主动关闭
条款34：成对函数不在同一个模块或函数内调用
条款35：头文件不加宏定义锁
条款36：忽略编译器警告
条款37：用“复制+粘贴”的方式复用代码
条款38：在字符串和注释以外的地方使用全角字符
条款39：代码风格不佳
条款40：代码与注释不一致
附录A 常用基本概念、名词、语句、运算符、数据类型和算法索引表
附录B C关键字
附录C Visual C++下各数据类型所占字节数和取值范围
附录D C运算符的优先级与结合性
附录E ASCII码的字符编码
附录F ASCII码和ASCII扩展码字符表
附录G 常用的ANSI C标准库函数
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言大学实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大卖
第一章置业顾问入门
认识中国房地产业// 003
我适合做这一行吗// 008
房地产入门基础知识// 009
常用计算与书写// 021
新置业顾问入门考核试卷// 026
第二章从置业顾问到销售冠军
卖房子的4个阶段// 031
销售冠军是怎样炼成的// 034
梦想、目标、规划、执行// 035
销售的基本理念// 036
新进项目要做的10件事// 049
成交五步// 058
技能技巧// 104
售楼处里可能发生的事// 125
第三章从销售冠军到销售主管
销售主管是什么// 131
销售主管做些什么事// 134
什么样的人才能当销售主管// 137
销售主管的日常工作// 139
如何带领团队成为销售冠军团队// 142
如何当好销售主管// 146
销售主管常见问题及解决方案// 146
第四章从销售主管到销售经理
职称梳理// 155
销售经理的角色// 156
操盘流程// 157
销售经理要做哪些事// 167
什么样的人才可以成为销售经理// 213
我的秘密武器// 214
第五章从销售经理到营销总监
营销总监做些什么事// 229
什么样的人才能当营销总监// 230
什么样的项目才是好项目// 231
售楼处布置的门道// 232
团队文化与企业文化// 237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大卖
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WINDOWS C程序设计入门与提高
目录
引言
第1章 VisualC十十6.0概述
1.1VisualC十十的发展历史
1.2VisualC十十6.0的安装
1.3VisualC十十6.0的特性
1.4本章小结
第2章 VisualC十十6.0基本操作
2.1集成开发环境的外观及基本操作
2.1.1VisualC十十集成开发环境的组成元素
2.1.2正文窗口及其操作
2.1.3项目工作台窗口及其操作
2.1.4输出窗口及其操作
2.2利用VisualC十十6.0编写应用程序的一般过程
2.2.1新建项目
2.2.2添加代码
2.2.3添加资源
2.2.4编译连接与调试
2.3本章小结
第3章 VisualC十十6.0编辑器的使用
3.1文本编辑器的使用
3.1.1文本编辑器的基本操作
3.1.2文本的查找
3.1.3替换文本
3.1.4Bookmark命令的用法
3.1.5语句自动生成功能
3.1.6文本编辑器的设置
3.2标识符的概念
3.2.1基本概念及取值规则
3.2.2标识符浏览器的概念和功能
3.2.3新建标识符
3.2.4删除未使用的标识符
3.2.5改变标识符的名称
3.2.6快速打开某标识符对应的资源编辑器窗口
3.2.7使用只读标识符或可计算的标识符
3.3资源及资源编辑器的概况
3.3.1资源的概念
3.3.2资源编辑器
3.4菜单编辑器的使用
3.4.1创建菜单和菜单项
3.4.2菜单及菜单项的移动或复制
3.4.3创建快捷菜单
3.4.4定义菜单项的快捷键
3.4.5定义状态栏提示
3.5对话框编辑器的使用
3.5.1对话框编辑器所使用的工具
3.5.2对话框的创建
3.5.3在对话框内添加控件
3.5.4对话框内控件的移动、删除及复制
3.5.5对话框内各控件的布局及尺寸控制
3.5.6对话框的测试
3.6图形编辑器
3.6.1位图资源的创建
3.6.2图形编辑器的外观
3.6.3图形资源属性的设置
3.6.4图形资源的基本操作
3.6.5图标或光标的创建
3.7其他编辑器的使用
3.7.1工具栏编辑器
3.7.2快捷键表编辑器
3.7.3字符串表编辑器
3.7.4二进制数据编辑器
3.7.5版本信息资源编辑器
3.8本章小结
第4章 VisualC十十6.0调试器的使用
4.1调试器的工具
4.1.1菜单命令概述
4.1.2调试窗口
4.1.3调试对话框
4.2控制程序运行的命令及其使用
4.2.1控制程序运行的命令
4.2.2程序跟踪
4.3断点的设置与使用
4.3.1Breakpoints对话框的使用
4.3.2断点的设置语法
4.4查看和修改变量的值
4.4.1QuickWatch窗口的使用
4.4.2Watch窗口的使用
4.4.3变量显示的格式化
4.4.4Variables窗口的使用
4.5其他调试窗口的使用
4.5.1CallStack窗口的使用
4.5.2Registers窗口的使用
4.5.3Memory窗口的使用
4.5.4Disassembly窗口的使用
4.6调试方法
4.6.1调试编译器及连接器的错误
4.6.2调试异常
4.6.3调试线程
4.6.4调试DLLs
4.6.5调试OLE应用程序
4.6.6调试远程应用程序
4.7本章小结
第5章 Windows编程基础
5.1Windows95/98和Wind0wsNT4.0/5.0新的界面特性
5.2一个Windows示范程序
5.3Windows事件和消息概述
5.3.1消息和消息处理
5.3.2窗口过程
5.4Simpwin程序的工作过程
5.4.1WinMain（）函数
5.4.2定义和注册窗口类
5.4.3创建和显示窗口
5.4.4消息循环
5.5基本的数据类型
5.6常用的宏
5.7本章小结
第6章 使用基本资源
6.1图标
6.2菜单
6.2.1创建菜单
6.2.2处理菜单消息
6.2.3菜单项的位置和状态
6.2.4消息框
6.3快捷键
6.3.1创建快捷键表
6.3.2把快捷键与菜单项联系起来
6.3.3在应用程序中装入快捷键表
6.3.4示范程序
6.4对话框
6.4.1对话框概述
6.4.2创建模式对话框
6.4.3创建无模式对话框
6.4.4对话框中的简单控件
6.4.5对话框示范程序
6.5光标
6.6字符串
6.7位图
6.8本章小结
第7章 键盘、鼠标和计时器
7.1键盘
7.1.1几个基本概念
7.1.2键盘消息
7.1.3字符消息
7.1.4键盘输入示例
7.2鼠标
7.2.1鼠标消息
7.2.2鼠标消息的处理
7.2.3捕捉鼠标
7.2.4鼠标输入示范程序
7.3计时器
7.4本章小结
第8章 绘图工具和图形设备接口
8.1设备描述表
8.2画点
8.3画直线
8.4画折线和曲线
8.4.1画折线
8.4.2画弧线
8.4.3画贝塞尔曲线
8.5画笔
8.5.1画笔的属性
8.5.2使用库存画笔
8.5.3创建画笔
8.6画封闭曲线
8.6.1矩形
8.6.2椭圆形
8.6.3圆角矩形
8.6.4弦形
8.6.5扇形
8.6.6多边形
8.6.7多个多边形
8.6.8示范程序
8.7字体选择和文字输出
8.7.1字体
8.7.2逻辑字体
8.7.3枚举安装字体
8.7.4文字输出
8.7.5文字格式化
8.7.6示范程序
8.8高级菜单技术
8.8.1浮动的弹出式菜单
8.8.2位图菜单项
8.8.3自定义菜单项选中标志
8.8.4自画菜单项
8.8.5示范程序
8.9本章小结
第9章 常用控件
9.1控件概述
9.1.1控件和公共控件
9.1.2消息
9.1.3通知消息
9.1.4控件风格
9.2静态控件和按钮控件
9.2.1静态控件
9.2.2按钮
9.3滚动条
9.3.1创建滚动条
9.3.2设置滚动条的滚动范围
9.3.3设置滚动块的位置
9.3.4接收滚动条消息
9.3.5示范程序
9.4列表框
9.4.1列表框的风格
9.4.2发送消息给列表框
9.4.3列表框发出的通知消息
9.4.4列表框示范程序
9.5编辑控件
9.5.1创建编辑控件
9.5.2对编辑框的基本操作
9.5.3编辑控件发出的通知消息
9.5.4编辑控件示范程序
9.6组合框
9.6.1组合框的风格与类型
9.6.2发送消息给组合框
9.6.3组合框发出的通知消息
9.6.4示范程序
9.7状态窗口
9.7.1创建状态窗口
9.7.2状态窗口的分区
9.7.3显示状态信息文字
9.7.4示范程序
9.8本章小结
第10章 MDI多文档界面编程
10.1MDI的组成
10.2MDI程序设计
10.2.1主函数WinMain（）
10.2.2主窗口过程：FrameWinProc（）
10.2.3MDI子窗口过程
10.2.4MDI应用程序设计的关键问题
10.3MDI函数介绍
10.3.1DefFrameProc（）
10.3.2DefMDIChildProc（）
10.3.3TranslateMDISysAccel（）
10.4MDI应用程序例程
10.5本章小结
第11章 多进程和多线程应用程序设计
11.1基本概念
11.1.1多任务、多进程和多线程
11.1.2Win16多任务和Win32多任务的区别
11.2多进程应用程序设计
11.3多线程应用程序的设计
11.3.1线程的建立
11.3.2线程的同步
11.4多进程和多线程程序实例
11.5本章小结

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WINDOWS C程序设计入门与提高
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言高级实例解析
目录
第1章 C语言回顾
1.1 程序设计概述
1.2 Turbo C集成环境介绍
1.2.1 启动Turbo C
1.2.2 File菜单（文件操作）
1.2.3 Run菜单（各种程序运行方式）
1.2.4 Compile菜单（编译、连接）
1.2.5 Project菜单（工程管理）
1.2.6 Options菜单（开发环境定制）
1.2.7 Debug菜单（调试）
1.2.8 Break／watch菜单（断点管理）
1.3 C语言概述
1.3.1 数据类型、运算符与表达式
1.3.2 逻辑运算和判断选取控制
1.3.3 循环控制
1.3.4 数组
1.3.5 编译预处理
1.3.6 指针
1.4 本章小结
第2章 内存模式
2.1 PC机存储器结构及基本的堆管理函数
2.1.1 PC机存储器结构
2.1.2 CPU地址线宽度
2.1.3 微机常用操作系统的内存管理方式
2.1.4 实地址下的内存编译模式
2.1.5 堆概念和结构
2.1.6 堆管理函数
2.2 内存管理实例
2.2.1 实例简介
2.2.2 高速内存分配程序
2.3 高速内存分配程序剖析
2.3.1 程序分析
2.3.2 更有效率的使用内存分配程序
2.4 本章小结
第3章 文件、I／O操作
3.1 文件系统
3.1.1 文件系统的基本概念
3.1.2 FAT12
3.1.3 FAT16
3.1.4 FAT32
3.1.5 NTFS
3.1.6 Ext和Swap
3.2 文件
3.2.1 文件的基本概念
3.2.2 文件类型指针
3.2.3 文件的打开与关闭
3.2.4 文件的读／写操作
3.2.5 非缓冲文件系统
3.2.6 出错的检测
3.3 通讯录实例
3.3.1 实例简介
3.3.2 实例代码
3.4 通讯录程序剖析
3.5 本章小结
第4章 C语言的做图
4.1 VGA显示系统
4.1.1 显示硬件基础
4.1.2 显示缓冲区与颜色定义
4.1.3 视频BIOS ROM
4.2 图形函数
4.2.1 图形模式的初始化
4.2.2 独立图形运行程序的建立
4.2.3 屏幕颜色的设置和清屏函数
4.2.4 基本图形函数
4.2.5 封闭图形的填充
4.2.6 有关图形窗口和图形屏幕操作函数
4.2.7 图形模式下的文本输出
4.3 实例程序
4.3.1 菜单制作程序
4.3.2 主函数和主要数据结构
4.3.3 处理输入
4.3.4 图形显示函数
4.3.5 鼠标操作函数
4.4 本章小结
第5章 鼠标编程
5.1 中断的基本概念
5.1.1 BIOS
5.1.2 中断和异常
5.1.3 BIOS功能调用
5.1.4 鼠标器的INT 33H功能调用
5.2 鼠标编程实例
5.2.1 实例简介
5.2.2 实例代码
5.3 程序剖析
5.3.1 程序分析
5.3.2 程序改进方向
5.4 本章小结
第6章 并口和串口编程
6.1 并行通信
6.1.1 通信、并行通信
6.1.2 并行接口
6.1.3 并口针脚功能
6.2 串行通信
6.2.1 概念
6.2.2 串行接口
6.2.3 串行通信方式及异步通信协议
6.2.4 串口针脚功能
6.3 联机线的连接方法
6.4 I／O接口的输儿输出函数
6.4.1 接口输入函数
6.4.2 接口输出函数
6.5 双机并口通信实例
6.5.1 PPORT.H
6.5.2 PPORT.C
6.5.3 SERVER.C
6.5.4 CLIENT.C
6.6 本章小结
第7章 综合实例——小型CAD系统
7.1 小型CAD系统——MICROCAD
7.1.1 系统简介
7.1.2 运行MICROCAD命令
7.1.3 鼠标
7.1.4 主命令
7.1.5 MCPRINT工具集
7.1.6 字符字体
7.1.7 做图文件的格式
7.1.8 其他注意事项
7.2 MICROCAD实例
7.2.1 程序头
7.2.2 主函数
7.2.3 分发文件操作命令
7.2.4 插入图形函数
7.2.5 绘制图形函数
7.2.6 撤销编辑函数
7.2.7 删除、移动、复制对象函数
7.2.8 绘制对象函数
7.2.9 文件指针转移对象函数
7.2.10 对象选择函数
7.2.11 find_vector（）函数
7.2.12 底层图像绘制函数
7.2.13 缓存和文件操作函数
7.2.14 设备相关函数
7.3 内嵌汇编指令的C程序编译连接方法
7.4 本章小结
第8章 综合实例——编译器
8.1 编译器简介
8.1.1 编译器基本概念
8.1.2 与编译器相关的程序
8.1.3 翻译步骤
8.1.4 编译器中的主要数据结构
8.2 实例简介
8.2.1 语言介绍
8.2.2 程序结构
8.3 词法分析
8.3.1 词法分析简介
8.3.2 扫描处理
8.3.3 为样本语言TINY实现一个扫描程序
8.3.4 SCAN.H
8.3.5 SCAN.C
8.4 语法分析
8.4.1 语法分析简介
8.4.2 上下文无关文法
8.4.3 TINY的上下文无关文法
8.4.4 TINY编译器的语法树结构
8.4.5 自顶向下的分析
8.4.6 PARSE.H
8.4.7 PARSE.C
8.5 语义分析
8.5.1 语义分析简介
8.5.2 属性和属性文法
8.5.3 符号表
8.5.4 数据类型和类型检查
8.5.5 TINY语言的语义分析
8.5.6 ANALYZE.H
8.5.7 ANALYZE.C
8.6 本章小结
第9章 综合实例——网络通信编程
9.1 概述
9.2 Winsock1.1编程技术
9.2.1 Winsock的基本概念
9.2.2 Winsock的编程特点
9.2.3 Winsock基本的API
9.2.4 关于Winsock的异步模式
9.3 Winsock2.0编程技术
9.3.1 Winsock2.0技术细节
9.3.2 Winsock2.0新增的函数
9.4 CSocket编程技术
9.5 TCP面向连接的流的Socket程序
9.5.1 程序介绍
9.5.2 TCP Stream Socket Server
9.5.3 TCP Stream Socket Client
9.6 本章小结
第10章 综合实例——压缩程序
10.1 数据压缩简史
10.1.1 通用无损数据压缩
10.1.2 多媒体信息的压缩
10.2 压缩算法基本知识
10.2.1 熵
10.2.2 模型
10.2.3 编码
10.3 Huffman编码
10.3.1 二叉树
10.3.2 Huffman编码
10.3.3 范式Huffman编码
10.4 字典模型
10.4.1 基本思想
10.4.2 LZ77算法
10.4.3 LZ77算法优化
10.5 典型LZ77算法实例
10.5.1 实例简介
10.5.2 算法实例
10.6 本章小结
第11章 综合实例——多文本编辑器
11.1 文本编辑器——EDITOR
11.1.1 系统简介
11. 1.2 运行EDITOR命令
11.2 EDITOR命令列表
11.2.1 命令综述
11.2.2 文件操作命令
11.2.3 宏命令
11.2.4 查找、替换命令
11.2.5 比较命令
11.2.6 窗口命令
11.2.7 块命令
11.2.8 字处理命令
11.2.9 Tab键
11.2.10 开关命令
11.2.11 其他命令
11.3 程序剖析
11.3.1 结构性函数
11.3.2 文件操作函数
11.3.3 宏命令
11.3.4 查找替换函数
11.3.5 窗口函数
11.3.6 块函数
11.4 本章小结
第12章 综合实例——病毒防火墙
12.1 病毒防火墙——CRCSET
12.1.1 系统简介
12.1.2 CRC简介
12.2 CRC算法
12.2.1 快速算法基本思想
12.2.2 多字节序列运算规律
12.2.3 三字节序列计算
12.3 CRCSET工作原理
12.4 程序实例
12.4.1 CRCSET使用说明
12.4.2 VIRUSCRC.H
12.4.3 VALIDCRC.C
12.4.4 VIRUSDAT.C
12.4.5 TESTCRC.C
12.5 本章小结
第13章 综合实例——排序演示
13.1 排序演示——CSORT
13.1.1 系统简介
13.1.2 系统的使用
13.2 排序算法简介
13.2.1 排序基本概念
13.2.2 排序的分类
13.2.3 排序算法分析
13.2.4 各种内部排序方法
13.3 典型排序算法
13.3.1 冒泡排序
13.3.2 希尔排序
13.3.3 快速排序
13.3.4 直接插入排序
13.4 程序实例
13.4.1 主函数
13.4.2 界面和类型产生函数
13.4.3 排序函数
13.5 本章小结
第14章 综合实例——海底大战
14.1 系统简介
14.2 BMP图像格式
14.2.1 简介
14.2.2 文件结构
14.2.3 构件详解
14.3 TC环境下256色显示
14.3.1 VGA的DAC色彩寄存器知识
14.3.2 置256色图形模式
14.3.3 访问显存
14.3.4 显示卡换页
14.3.5 硬件无关屏幕初始化
14.4 海底大战程序实例
14.4.1 流程控制函数和主要结构
14.4.2 BMP格式相关定义和函数
14.4.3 对象读入、创建、绘制函数
14.4.4 时钟控制方式的定义和函数
14.5 本章小结
第15章 数学建模
15.1 建模一
15.1.1 模型分析
15.1.2 程序实现
15.2 建模二
15.3 建模三
15.3.1 问题的重述
15.3.2 模型的假设
15.3.3 问题的分析
15.3.4 符号定义
15.3.5 模型的建立
15.3.6 模型的改进和比较
15.3.7 模型的评价
15.3.8 定理1的证明
15.3.9 程序实现
15.4 本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言高级实例解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++入门经典(第4版)
第1章  基本概念	1
1.1  现代C++	1
1.2  C++程序概念	2
1.2.1  注释和空白	2
1.2.2  预处理指令和头文件	3
1.2.3  函数	3
1.2.4  语句	4
1.2.5  数据输入输出	4
1.2.6  return语句	5
1.2.7  名称空间	5
1.2.8  名称和关键字	6
1.3  类和对象	6
1.4  模板	7
1.5  程序文件	7
1.6  标准库	7
1.7  代码的表示样式	7
1.8  创建可执行文件	8
1.9  表示数字	9
1.9.1  二进制数	9
1.9.2  十六进制数	11
1.9.3  负的二进制数	12
1.9.4  八进制数	14
1.9.5  Big-Endian和Little-Endian系统	14
1.9.6  浮点数	15
1.10  表示字符	16
1.10.1  ASCII 码	16
1.10.2  UCS和Unicode	17
1.11  C++源字符	17
1.11.1  三字符序列	18
1.11.2  转义序列	18
1.12  过程化编程方法和面向
对象编程方法	20
1.13  本章小结	21
1.14  练习	22
第2章  基本数据类型	23
2.1  变量、数据和数据类型	23
2.1.1  定义整型变量	24
2.1.2  定义有固定值的变量	26
2.2  整型字面量	26
2.2.1  十进制整型字面量	27
2.2.2  十六进制的整型字面量	27
2.2.3  八进制的整型字面量	27
2.2.4  二进制的整型字面量	28
2.3  整数的计算	28
2.4  op=赋值运算符	33
2.5  using声明和指令	34
2.6  sizeof运算符	34
2.7  整数的递增和递减	35
2.8  定义浮点变量	37
2.8.1  浮点字面量	38
2.8.2  浮点数的计算	38
2.8.3  缺点	38
2.8.4  无效的浮点结果	39
2.9  数值函数	40
2.10  流输出的格式化	43
2.11  混合的表达式和类型转换	45
2.11.1  显式类型转换	46
2.11.2  老式的强制转换	48
2.12  确定数值的上下限	49
2.13  使用字符变量	50
2.13.1  使用Unicode字符	51
2.13.2  auto关键字	52
2.13.3  lvalue和rvalue	52
2.14  本章小结	53
2.15  练习	54
第3章  处理基本数据类型	55
3.1  运算符的优先级和相关性	55
3.2  按位运算符	57
3.2.1  移位运算符	58
3.2.2  使用按位与运算符	60
3.2.3  使用按位或运算符	61
3.2.4  使用按位异或运算符	63
3.3  枚举数据类型	67
3.4  数据类型的同义词	70
3.5  变量的生存期	70
3.5.1  定位变量的定义	71
3.5.2  全局变量	71
3.5.3  静态变量	74
3.5.4  外部变量	75
3.6  本章小结	75
3.7  练习	76
第4章  决策	77
4.1  比较数据值	77
4.1.1  应用比较运算符	78
4.1.2  比较浮点数值	79
4.2  if语句	80
4.2.1  嵌套的if语句	82
4.2.2  不依赖编码的字符处理	84
4.3  if-else语句	85
4.3.1  嵌套的if-else语句	87
4.3.2  理解嵌套的if语句	88
4.4  逻辑运算符	89
4.4.1  逻辑与运算符	90
4.4.2  逻辑或运算符	90
4.4.3  逻辑非运算符	91
4.5  条件运算符	92
4.6  switch语句	94
4.7  无条件分支	98
4.8  语句块和变量作用域	99
4.9  本章小结	100
4.10  练习	100
第5章  数组和循环	103
5.1  数据数组	103
5.2  理解循环	105
5.3  for循环	106
5.3.1  避免幻数	107
5.3.2  用初始化列表定义数组的大小	109
5.3.3  确定数组的大小	109
5.3.4  用浮点数值控制for循环	110
5.3.5  使用更复杂的循环控制表达式	112
5.3.6  逗号运算符	113
5.3.7  基于区域的for循环	114
5.4  while循环	115
5.5  do-while循环	119
5.6  嵌套的循环	120
5.7  跳过循环迭代	123
5.8  循环的中断	125
5.9  字符数组	128
5.10  多维数组	131
5.10.1  初始化多维数组	134
5.10.2  在默认情况下设置维数	135
5.10.3  多维字符数组	136
5.11  数组的替代品	137
5.11.1  使用array<T,N>容器	138
5.11.2  使用std::vector<T>容器	142
5.11.3  矢量的容量和大小	143
5.11.4  删除矢量容器中的元素	145
5.12  本章小结	145
5.13  练习	146
第6章  指针和引用	149
6.1  什么是指针	149
6.1.1  地址运算符	151
6.1.2  间接运算符	152
6.1.3  为什么使用指针	153
6.2  char类型的指针	154
6.3  常量指针和指向常量的指针	158
6.4  指针和数组	159
6.4.1  指针的算术运算	160
6.4.2  计算两个指针之间的差	162
6.4.3  使用数组名的指针表示法	162
6.5  动态内存分配	165
6.5.1  栈和堆	165
6.5.2  运算符new和delete	166
6.5.3  数组的动态内存分配	167
6.5.4  通过指针选择成员	169
6.6  动态内存分配的危险	169
6.6.1  内存泄漏	169
6.6.2  自由存储区的碎片	170
6.7  原指针和智能指针	170
6.7.1  使用unique_ptr<T>指针	172
6.7.2  使用shared_ptr<T>指针	173
6.7.3  比较shared_ptr<T>对象	177
6.7.4  weak_ptr<T>指针	177
6.8  理解引用	178
6.8.1  定义左值引用	179
6.8.2  在基于区域的for循环中使用引用变量	180
6.8.3  定义右值引用	180
6.9  本章小结	181
6.10  练习	181
第7章  操作字符串	183
7.1  更好的string类型	183
7.1.1  定义string对象	184
7.1.2  string对象的操作	186
7.1.3  访问字符串中的字符	188
7.1.4  访问子字符串	190
7.1.5  比较字符串	191
7.1.6  搜索字符串	196
7.1.7  修改字符串	203
7.2  国际字符串	207
7.3  包含Unicode字符串的对象	208
7.4  原字符串字面量	208
7.5  本章小结	209
7.6  练习	210
第8章  定义函数	211
8.1  程序的分解	211
8.1.1  类中的函数	212
8.1.2  函数的特征	212
8.2  定义函数	212
8.2.1  函数体	213
8.2.2  函数声明	215
8.3  给函数传送参数	217
8.3.1  按值传送机制	217
8.3.2  按引用传送	223
8.3.3  main()的参数	227
8.4  默认的参数值	228
8.5  从函数中返回值	231
8.5.1  返回指针	231
8.5.2  返回引用	235
8.6  内联函数	236
8.7  静态变量	237
8.8  函数的重载	239
8.8.1  重载和指针参数	241
8.8.2  重载和引用参数	241
8.8.3  重载和const参数	243
8.8.4  重载和默认参数值	244
8.9  函数模板	245
8.9.1  创建函数模板的实例	246
8.9.2  显式指定模板参数	247
8.9.3  函数模板的特例	248
8.9.4  函数模板和重载	249
8.9.5  带有多个参数的函数模板	250
8.9.6  非类型的模板参数	251
8.10  拖尾返回类型	252
8.11  函数指针	253
8.12  递归	256
8.12.1  应用递归	259
8.12.2  Quicksort算法	259
8.12.3  main()函数	260
8.12.4  extract_words()函数	261
8.12.5  swap()函数	262
8.12.6  sort()函数	262
8.12.7  max_word_length()函数	263
8.12.8  show_words()函数	264
8.13  本章小结	265
8.14  练习	266
第9章  lambda表达式	269
9.1  lambda表达式简介	269
9.2  定义lambda表达式	269
9.3  lambda表达式的命名	270
9.4  把lambda表达式传递给函数	272
9.4.1  接受lambda表达式变元的函数模板	272
9.4.2  lambda变元的函数参数类型	273
9.4.3  使用std::function模板类型	274
9.5  捕获子句	277
9.6  在模板中使用lambda表达式	279
9.7  lambda表达式中的递归	281
9.8  本章小结	283
9.9  练习	283
第10章  程序文件和预处理指令	285
10.1  理解转换单元	285
10.1.1 “一个定义”规则	286
10.1.2  程序文件和链接	286
10.1.3  确定名称的链接属性	286
10.1.4  外部名称	287
10.1.5  具有外部链接属性的
const变量	287
10.2  预处理源代码	288
10.3  定义预处理标识符	289
10.4  包含头文件	290
10.5  名称空间	292
10.5.1  全局名称空间	293
10.5.2  定义名称空间	293
10.5.3  应用using声明	296
10.5.4  函数和名称空间	296
10.5.5  未命名的名称空间	299
10.5.6  名称空间的别名	299
10.5.7  嵌套的名称空间	300
10.6  逻辑预处理指令	301
10.6.1  逻辑#if指令	301
10.6.2  测试指定标识符的值	302
10.6.3  多个代码选择	302
10.6.4  标准的预处理宏	303
10.7  调试方法	304
10.7.1  集成调试器	304
10.7.2  调试中的预处理指令	305
10.7.3  使用assert宏	309
10.7.4  关闭断言机制	310
10.8  静态断言	310
10.9  本章小结	312
10.10  练习	313
第11章  定义自己的数据类型	315
11.1  类和面向对象编程	315
11.1.1  封装	316
11.1.2  继承	318
11.1.3  多态性	318
11.1.4  术语	319
11.2  定义类	320
11.3  构造函数	322
11.3.1  在类的外部定义构造函数	324
11.3.2  默认构造函数的参数值	326
11.3.3  在构造函数中使用初始化列表	326
11.3.4  使用explicit关键字	327
11.3.5  委托构造函数	329
11.3.6  默认的副本构造函数	331
11.4  访问私有类成员	332
11.5  友元	333
11.5.1  类的友元函数	334
11.5.2  友元类	336
11.6  this指针	337
11.7  const对象和const函数成员	338
11.8  类的对象数组	340
11.9  类对象的大小	342
11.10  类的静态成员	342
11.10.1  静态数据成员	342
11.10.2  类的静态函数成员	347
11.11  析构函数	347
11.12  类对象的指针和引用	350
11.13  将指针作为类的成员	351
11.13.1  定义Package类	353
11.13.2  定义TruckLoad类	354
11.13.3  实现TruckLoad类	355
11.14  嵌套类	360
11.15  本章小结	363
11.16  练习	363
第12章  运算符重载	365
12.1  为类实现运算符	365
12.1.1  运算符重载	366
12.1.2  可以重载的运算符	366
12.1.3  实现重载运算符	366
12.1.4  全局运算符函数	369
12.1.5  提供对运算符的全部支持	369
12.1.6  在类中实现所有的比较运算符	371
12.2  运算符函数术语	373
12.3  默认的类成员	374
12.3.1  定义析构函数	375
12.3.2  何时定义副本构造函数	377
12.3.3  实现赋值运算符	377
12.3.4  实现移动操作	379
12.4  重载算术运算符	380
12.4.1  改进输出操作	384
12.4.2  根据一个运算符实现另一个运算符	386
12.5  重载下标运算符	387
12.6  重载类型转换	394
12.7  重载递增和递减运算符	395
12.8  函数对象	396
12.9  本章小结	397
12.10  练习	398
第13章  继承	399
13.1  类和面向对象编程	399
13.2  类的继承	401
13.2.1  继承和聚合	401
13.2.2  派生类	402
13.3  把类的成员声明为protected	405
13.4  派生类成员的访问级别	405
13.4.1  在类层次结构中使用访问指定符	406
13.4.2  改变继承成员的访问指定符	408
13.5  派生类中的构造函数操作	408
13.5.1  派生类中的副本构造函数	412
13.5.2  派生类中的默认构造函数	414
13.5.3  继承构造函数	414
13.6  继承中的析构函数	415
13.7  重复的成员名	417
13.8  重复的函数成员名	418
13.9  多重继承	419
13.9.1  多个基类	419
13.9.2  继承成员的模糊性	420
13.9.3  重复的继承	424
13.9.4  虚基类	425
13.10  在相关的类类型之间转换	425
13.11  本章小结	426
13.12  练习	426
第14章  多态性	429
14.1  理解多态性	429
14.1.1  使用基类指针	429
14.1.2  调用继承的函数	431
14.1.3  虚函数	434
14.1.4  虚函数中的默认参数值	442
14.1.5  通过智能指针调用虚函数	443
14.1.6  通过引用调用虚函数	444
14.1.7  调用虚函数的基类版本	445
14.1.8  在指针和类对象之间转换	446
14.1.9  动态强制转换	447
14.1.10  转换引用	449
14.1.11  确定多态类型	449
14.2  多态性的成本	450
14.3  纯虚函数	451
14.3.1  抽象类	452
14.3.2  间接的抽象基类	454
14.4  通过指针释放对象	457
14.5  本章小结	458
14.6  练习	459
第15章  运行时错误和异常	461
15.1  处理错误	461
15.2  理解异常	462
15.2.1  抛出异常	463
15.2.2  异常处理过程	465
15.2.3  未处理的异常	466
15.2.4  导致抛出异常的代码	467
15.2.5  嵌套的try块	468
15.3  用类对象作为异常	472
15.3.1  匹配Catch处理程序和异常	473
15.3.2  用基类处理程序捕获派生类异常	476
15.3.3  重新抛出异常	478
15.3.4  捕获所有的异常	481
15.4  抛出异常的函数	482
15.4.1  函数try块	483
15.4.2  不抛出异常的函数	483
15.4.3  构造函数try块	484
15.4.4  异常和析构函数	484
15.5  标准库异常	485
15.5.1  异常类的定义	486
15.5.2  使用标准异常	487
15.6  本章小结	490
15.7  练习	491
第16章  类模板	493
16.1  理解类模板	493
16.2  定义类模板	494
16.2.1  模板参数	495
16.2.2  简单的类模板	495
16.2.3  定义类模板的函数成员	497
16.3  创建类模板的实例	501
16.4  类模板的静态成员	506
16.5  非类型的类模板参数	507
16.5.1  带有非类型参数的函数成员的模板	510
16.5.2  非类型参数的变元	514
16.5.3  把指针和数组用作非类型参数	514
16.6  模板参数的默认值	515
16.7  模板的显式实例化	516
16.8  特殊情形	516
16.8.1  在类模板中使用
static_assert()	517
16.8.2  定义类模板特化	518
16.8.3  部分模板特化	519
16.8.4  从多个部分特化中选择	519
16.9  类模板的友元	520
16.10  带有嵌套类的类模板	521
16.11  本章小结	528
16.12  练习	528
第17章  文件输入与输出	531
17.1  C++中的输入输出	531
17.1.1  理解流	531
17.1.2  使用流的优点	533
17.2  流类	534
17.2.1  标准流对象	535
17.2.2  流的插入和提取操作	535
17.2.3  流操纵程序	537
17.3  文件流	540
17.3.1  在文本模式下写入文件	540
17.3.2  在文本模式下读取文件	543
17.4  设置流打开模式	546
17.5  未格式化的流操作	554
17.5.1  未格式化的流输入函数	554
17.5.2  未格式化的流输出函数	557
17.6  流输入输出中的错误	557
17.7  二进制模式中的流操作	559
17.8  文件的读写操作	570
17.9  字符串流	577
17.10  对象和流	578
17.10.1  给对象使用插入运算符	579
17.10.2  给对象使用提取运算符	579
17.10.3  二进制模式中的对象I/O	582
17.10.4  流中更复杂的对象	585
17.11  本章小结	590
17.12  练习	590
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++入门经典(第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>LINUX上的C编程
第一章 C语言与Linux系统
1．1 Linux系统简介
1．2 C语言概述
1．3 Linux系统中的C语言
第二章 GCC编译器
2．1 GCC的安装
2．2 GCC的使用
2．3 其它编译调试工具
第三章 C语言的调试工具
3．1 gdb符号调试器
3．2 gdb命令详解及简单应用举例
3．3 其他调试工具
第四章 使用make
4．1 make的简单使用
4．2 控制make的属性
4．3 使用宏（macro）
4．4 内部规则
4．5 使用库
第五章 文件系统的操作
5．1 文件系统简介
5．2 顺序文件操作
5．3 随机文件操作
5．4 文件共享
5．5 索引节点
5．6 文件层次结构
5．7 改变文件属性
5．8 文件链接
5．9 设备文件
第六章 标准输入输出
6．1 简介
6．2 标准输入输出的基本操作
6．3 非格式化输入输出操作
6．4 斗格式化输入输出操作
6．5 临时文件的有关操作
第六章 进程的控制
7．1 进程概述
7．2 进程的基本操作
7．3 进程之间的关系
第八章 信号及其处理
8．1 简介
8．2 信号与信号处理函数
8．3 信号集及其处理
8．4 作业控制信号
第九章 进程间的通信
9．1 简介
9．2 管道
9．3 命名管道
9．4 System V的进程间通讯机制
第十章 守护进程的编制
10．1 守护进程简介
10．2 守护进程的编码
10．3 守护进程的输出
第十一章 网络编程
11．1 预备知识
11．2 流式套接口的基本操作
11．3 客户/服务器机制
11．4 数据报套接口的操作
11．5 高级技巧：select（）和Poll（）
第十二章 设备编程
12．1 对声音设备编程
12．2 对鼠标端口编程
12．3 对调制解调器编程
12．4 对打印机端口编程
12．5 对控制台终端编程
第13章 一个实例――自己的Shell
13．1 头文件head．h：
13．2 主过程main．c
13．3 初始化模块init．c:
13．4 语法分析get simcom．c
13．5 得到下一标识符get_word．c
13．6 得到当前命令行get_comln．c
13．7 执行简单命令Run_com．c
13．8 执行输入的命令Execute．c
13．9 分析简单命令Get_simarg．c
13．10 字符串匹配Check．c
附录 Linux系统调用一览表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>LINUX上的C编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言从入门到精通
第1篇  基 础 知 识
第1章  C语言概述	3
视频讲解：29分钟
1.1  C语言的发展史	4
1.1.1  程序语言简述	4
1.1.2  C语言的历史	4
1.2  C语言的特点	5
1.3  一个简单的C程序	6
1.4  一个完整的C程序	8
1.5  C语言程序的格式	12
1.6  开发环境	13
1.6.1  Turbo C 2.0	13
1.6.2  Visual C++ 6.0	17
1.7  小结	22
第2章  算法	23
视频讲解：22分钟
2.1  算法的基本概念	24
2.1.1  算法的特性	24
2.1.2  算法的优劣	25
2.2  算法的描述	25
2.2.1  自然语言	25
2.2.2  流程图	26
2.2.3  N-S流程图	29
2.3  小结	32
第3章  数据类型	33
视频讲解：39分钟
3.1  编程规范	34
3.2  关键字	35
3.3  标识符	35
3.4  数据类型	36
3.5  常量	37
3.5.1  整型常量	38
3.5.2  实型常量	40
3.5.3  字符型常量	41
3.5.4  转义字符	43
3.5.5  符号常量	44
3.6  变量	45
3.6.1  整型变量	45
3.6.2  实型变量	47
3.6.3  字符型变量	50
3.7  变量的存储类别	51
3.7.1  动态存储与静态存储	51
3.7.2  auto变量	52
3.7.3  static变量	52
3.7.4  register变量	53
3.7.5  extern变量	54
3.8  混合运算	55
3.9  小结	56
3.10  实践与练习	56
第4章  运算符与表达式	57
视频讲解：29分钟
4.1  表达式	58
4.2  赋值运算符与赋值表达式	60
4.2.1  变量赋初值	60
4.2.2  自动类型转换	62
4.2.3  强制类型转换	62
4.3  算术运算符与算术表达式	63
4.3.1  算术运算符	63
4.3.2  算术表达式	64
4.3.3  优先级与结合性	65
4.3.4  自增/自减运算符	67
4.4  关系运算符与关系表达式	69
4.4.1  关系运算符	69
4.4.2  关系表达式	69
4.4.3  优先级与结合性	70
4.5  逻辑运算符与逻辑表达式	71
4.5.1  逻辑运算符	72
4.5.2  逻辑表达式	72
4.5.3  优先级与结合性	72
4.6  位逻辑运算符与位逻辑表达式	73
4.6.1  位逻辑运算符	74
4.6.2  位逻辑表达式	74
4.7  逗号运算符与逗号表达式	74
4.8  复合赋值运算符	76
4.9  小结	77
4.10  实践与练习	77
第5章  常用的数据输入/输出函数	79
视频讲解：40分钟
5.1  语句	80
5.2  字符数据输入/输出	80
5.2.1  字符数据输出	80
5.2.2  字符数据输入	81
5.3  字符串输入/输出	83
5.3.1  字符串输出函数	83
5.3.2  字符串输入函数	85
5.4  格式输出函数	85
5.5  格式输入函数	88
5.6  顺序程序设计应用	92
5.7  小结	93
5.8  实践与练习	94
第6章  选择结构程序设计	95
视频讲解：44分钟
6.1  if语句	96
6.2  if语句的基本形式	96
6.2.1  if语句形式	96
6.2.2  if…else语句形式	99
6.2.3  else if语句形式	103
6.3  if的嵌套形式	106
6.4  条件运算符	109
6.5  switch语句	110
6.5.1  switch语句的基本形式	111
6.5.2  多路开关模式的switch语句	114
6.6  if…else语句和switch语句的区别	116
6.7  选择结构程序应用	118
6.8  小结	120
6.9  实践与练习	120
第7章  循环控制	121
视频讲解：41分钟
7.1  循环语句	122
7.2  while语句	122
7.3  do-while语句	125
7.4  for语句	127
7.4.1  for语句使用	127
7.4.2  for循环的变体	130
7.4.3  for语句中的逗号应用	132
7.5  3种循环语句的比较	133
7.6  循环嵌套	134
7.6.1  循环嵌套的结构	134
7.6.2  循环嵌套实例	135
7.7  转移语句	137
7.7.1  goto语句	137
7.7.2  break语句	139
7.7.3  continue语句	140
7.8  小结	141
7.9  实践与练习	141

第2篇  核 心 技 术
第8章  数组	145
视频讲解：1小时7分钟
8.1  一维数组	146
8.1.1  一维数组的定义和引用	146
8.1.2  一维数组初始化	148
8.1.3  一维数组应用	150
8.2  二维数组	151
8.2.1  二维数组的定义和引用	151
8.2.2  二维数组初始化	152
8.2.3  二维数组应用	155
8.3  字符数组	156
8.3.1  字符数组的定义和引用	157
8.3.2  字符数组初始化	157
8.3.3  字符数组的结束标志	159
8.3.4  字符数组的输入和输出	160
8.3.5  字符数组应用	161
8.4  多维数组	162
8.5  数组的排序算法	163
8.5.1  选择法排序	163
8.5.2  冒泡法排序	165
8.5.3  交换法排序	167
8.5.4  插入法排序	169
8.5.5  折半法排序	171
8.5.6  排序算法的比较	174
8.6  字符串处理函数	174
8.6.1  字符串复制	174
8.6.2  字符串连接	176
8.6.3  字符串比较	177
8.6.4  字符串大小写转换	179
8.6.5  获得字符串长度	180
8.7  数组应用	181
8.7.1  反转输出字符串	181
8.7.2  输出系统日期和时间	183
8.7.3  字符串的加密和解密	184
8.8  小结	186
8.9  实践与练习	186
第9章  函数	187
视频讲解：55分钟
9.1  函数概述	188
9.2  函数的定义	190
9.2.1  函数定义的形式	191
9.2.2  定义与声明	192
9.3  返回语句	194
9.3.1  从函数返回	194
9.3.2  返回值	195
9.4  函数参数	197
9.4.1  形式参数与实际参数	197
9.4.2  数组作函数参数	199
9.4.3  main函数的参数	205
9.5  函数的调用	206
9.5.1  函数的调用方式	206
9.5.2  嵌套调用	209
9.5.3  递归调用	211
9.6  内部函数和外部函数	214
9.6.1  内部函数	214
9.6.2  外部函数	215
9.7  局部变量和全局变量	216
9.7.1  局部变量	217
9.7.2  全局变量	220
9.8  函数应用	221
9.9  小结	227
9.10  实践与练习	228
第10章  指针	229
视频讲解：1小时2分钟
10.1  指针相关概念	230
10.1.1  地址与指针	230
10.1.2  变量与指针	231
10.1.3  指针变量	231
10.1.4  指针自加自减运算	235
10.2  数组与指针	237
10.2.1  一维数组与指针	237
10.2.2  二维数组与指针	241
10.2.3  字符串与指针	244
10.2.4  字符串数组	246
10.3  指向指针的指针	247
10.4  指针变量作函数参数	250
10.5  返回指针值的函数	258
10.6  指针数组作main函数的参数	260
10.7  小结	262
10.8  实践与练习	262

第3篇  高 级 应 用
第11章  结构体和共用体	265
视频讲解：40分钟
11.1  结构体	266
11.1.1  结构体类型的概念	266
11.1.2  结构体变量的定义	267
11.1.3  结构体变量的引用	269
11.1.4  结构体类型的初始化	271
11.2  结构体数组	273
11.2.1  定义结构体数组	273
11.2.2  初始化结构体数组	275
11.3  结构体指针	277
11.3.1  指向结构体变量的指针	277
11.3.2  指向结构体数组的指针	280
11.3.3  结构体作为函数参数	282
11.4  包含结构的结构	284
11.5  链表	286
11.5.1  链表概述	286
11.5.2  创建动态链表	287
11.5.3  输出链表	290
11.6  链表相关操作	292
11.6.1  链表的插入操作	292
11.6.2  链表的删除操作	294
11.7  共用体	298
11.7.1  共用体的概念	298
11.7.2  共用体变量的引用	299
11.7.3  共用体变量的初始化	300
11.7.4  共用体类型的数据特点	301
11.8  枚举类型	301
11.9  小结	302
11.10  实践与练习	303
第12章  位运算	305
视频讲解：35分钟
12.1  位与字节	306
12.2  位运算操作符	306
12.2.1  “与”运算符	306
12.2.2  “或”运算符	308
12.2.3  “取反”运算符	309
12.2.4  “异或”运算符	310
12.2.5  “左移”运算符	312
12.2.6  “右移”运算符	313
12.3  循环移位	315
12.4  位段	317
12.4.1  位段的概念与定义	317
12.4.2  位段相关说明	319
12.5  小结	320
12.6  实践与练习	320
第13章  预处理	321
视频讲解：39分钟
13.1  宏定义	322
13.1.1  不带参数的宏定义	322
13.1.2  带参数的宏定义	323
13.2  #include指令	325
13.3  条件编译	327
13.3.1  #if命令	327
13.3.2  #ifdef及#ifndef命令	329
13.3.3  #undef命令	331
13.3.4  #line命令	331
13.3.5  #pragma命令	332
13.4  小结	333
13.5  实践与练习	333
第14章  文件	335
视频讲解：55分钟
14.1  文件概述	336
14.2  文件基本操作	336
14.2.1  文件指针	336
14.2.2  文件的打开	337
14.2.3  文件的关闭	338
14.3  文件的读写	338
14.3.1  fputc函数	338
14.3.2  fgetc函数	339
14.3.3  fputs函数	340
14.3.4  fgets函数	341
14.3.5  fprintf函数	342
14.3.6  fscanf函数	343
14.3.7  fread和fwrite函数	344
14.4  文件的定位	346
14.4.1  fseek函数	346
14.4.2  rewind函数	348
14.4.3  ftell函数	349
14.5  小结	352
14.6  实践与练习	352
第15章  存储管理	353
视频讲解：22分钟
15.1  内存组织方式	354
15.1.1  内存的组织方式	354
15.1.2  堆与栈	354

15.2  动态管理	356
15.2.1  malloc函数	356
15.2.2  calloc函数	357
15.2.3  realloc函数	358
15.2.4  free函数	359
15.3  内存丢失	360
15.4  小结	361
15.5  实践与练习	361
第16章  网络套接字编程	363
视频讲解：39分钟
16.1  计算机网络基础	364
16.1.1  IP地址	364
16.1.2  OSI七层参考模型	364
16.1.3  地址解析	365
16.1.4  域名系统	366
16.1.5  TCP/IP协议	366
16.1.6  端口	368
16.1.7  套接字的引入	368
16.1.8  网络字节顺序	369
16.2  套接字概述	369
16.2.1  套接字概述	369
16.2.2  TCP的套接字的socket编程	369
16.2.3  UDP的套接字的socket编程	370
16.3  套接字函数	371
16.3.1  套接字函数介绍	371
16.3.2  基于TCP的网络聊天程序	376
16.4  小结	382
16.5  实践与练习	382
第4篇  项 目 实 战
第17章  学生成绩管理系统	385
视频讲解：40分钟
17.1  需求分析	386
17.2  系统设计	386
17.3  功能设计	387
17.3.1  功能选择界面	387
17.3.2  录入学生成绩信息	388
17.3.3  查询学生成绩信息	391
17.3.4  删除学生成绩信息	392
17.3.5  修改学生成绩信息	393
17.3.6  插入学生成绩信息	395
17.3.7  统计学生人数	397
17.4  小结	397
附录A  ASCII表	399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计（原书第3版）
出版者的话
译者序
前言
致读者
第一部分　编程基础
第1章　计算机、程序和C++语言简介 2
1.1　引言 2
1.2　什么是计算机 3
1.2.1　CPU 4
1.2.2　位和字节 4
1.2.3　内存 5
1.2.4　存储设备 5
1.2.5　输入输出设备 6
1.2.6　通信设备 7
1.3　编程语言 8
1.3.1　机器语言 8
1.3.2　汇编语言 9
1.3.3　高级语言 9
1.4　操作系统 10
1.4.1　控制和监视系统活动 11
1.4.2　分配和指派系统资源 11
1.4.3　任务调度 11
1.5　C++语言的历史 11
1.6　一个简单的C++程序 12
1.7　C++程序开发周期 16
1.8　程序风格和文档 18
1.8.1　适当的注释和注释风格 18
1.8.2　正确的缩进和间距 18
1.9　编程错误 19
1.9.1　语法错误 19
1.9.2　运行时错误 19
1.9.3　逻辑错误 20
1.9.4　常见错误 20
关键术语 22
本章小结 22
在线测验 23
程序设计练习 23
第2章　程序设计基础 25
2.1　引言 25
2.2　编写简单的程序 25
2.3　从键盘读取输入 28
2.4　标识符 30
2.5　变量 30
2.6　赋值语句和赋值表达式 32
2.7　命名常量 33
2.8　数值数据类型及其运算 34
2.8.1　数值类型 34
2.8.2　数值文字常量 37
2.8.3　数值运算符 37
2.8.4　指数运算符 38
2.9　算术表达式和运算符优先级 39
2.10　实例研究：显示当前时间 41
2.11　简写运算符 43
2.12　自增、自减运算符 43
2.13　数值类型转换 45
2.14　软件开发流程 47
2.15　实例研究：计算给定金额的货币数量 51
2.16　常见错误 53
关键术语 54
本章小结 55
在线测验 55
程序设计练习 55
第3章　分支语句 60
3.1　引言 60
3.2　bool数据类型 61
3.3　if语句 62
3.4　双分支的if-else语句 64
3.5　嵌套的if语句和多分支的if-else语句 65
3.6　常见错误和陷阱 67
3.7　实例研究：计算身体质量指数 71
3.8　实例研究：计算税款 73
3.9　生成随机数 75
3.10　逻辑运算符 77
3.11　实例研究：确定闰年 81
3.12　实例研究：彩票 82
3.13　switch语句 83
3.14　条件表达式 86
3.15　运算符优先级和结合律 88
3.16　调试 89
关键术语 89
本章小结 90
在线测验 90
程序设计练习 90
第4章　数学函数、字符和字符串 99
4.1　引言 99
4.2　数学函数 100
4.2.1　三角函数 100
4.2.2　指数函数 100
4.2.3　近似函数 101
4.2.4　min、max和abs函数 101
4.2.5　实例研究：计算三角形的角 101
4.3　字符数据类型和操作符 103
4.3.1　ASCII码 103
4.3.2　从键盘读取一个字符 104
4.3.3　特殊字符的转义序列 104
4.3.4　数值类型和字符类型之间的相互转换 105
4.3.5　比较和测试字符 106
4.4　实例研究：生成随机字符 107
4.5　实例研究：猜生日 109
4.6　字符函数 112
4.7　实例研究：十六进制转换为十进制 113
4.8　字符串类型 114
4.8.1　字符串索引和下标操作符 115
4.8.2　连接字符串 116
4.8.3　比较字符串 116
4.8.4　读字符串 116
4.9　实例研究：使用字符串修改彩票程序 118
4.10　格式化控制台输出 119
4.10.1　setprecision(n)操作 120
4.10.2　修改操作 121
4.10.3　showpoint操作 121
4.10.4　setw(width)操作 122
4.10.5　left和right操作 122
4.11　简单的文件输入输出 123
4.11.1　写入文件 124
4.11.2　读取一个文件 125
关键术语 126
本章小结 126
在线测验 127
程序设计练习 127
第5章　循环 132
5.1　引言 132
5.2　while循环 133
5.2.1　实例研究：猜数字 135
5.2.2　循环设计策略 138
5.2.3　实例研究：多道减法测试 138
5.2.4　使用用户的确认控制循环 140
5.2.5　使用标记值控制循环 140
5.2.6　输入和输出重定向 141
5.2.7　从一个文件中读取所有的数据 142
5.3　do-while循环 144
5.4　for循环 145
5.5　使用哪种循环 149
5.6　嵌套循环 150
5.7　最小化数字错误 152
5.8　实例研究 153
5.8.1　求最大公约数 153
5.8.2　预测未来的学费 155
5.8.3　蒙特卡罗模拟 156
5.8.4　十进制转换为十六进制 156
5.9　关键字break和continue 158
5.10　实例研究：检查回文 161
5.11　实例研究：输出素数 163
关键术语 165
本章小结 165
在线测验 166
程序设计练习 166
第6章　函数 176
6.1　引言 176
6.2　函数定义 177
6.3　函数调用 178
6.4　无返回值函数 180
6.5　以传值方式传递参数 183
6.6　模块化代码 184
6.7　函数的重载 186
6.8　函数原型 189
6.9　缺省参数 190
6.10　内联函数 191
6.11　局部、全局和静态局部变量 192
6.11.1　for循环中变量的作用域 194
6.11.2　静态局部变量 194
6.12　以引用方式传递参数 197
6.13　常量引用参数 205
6.14　实例研究：十六进制转换为十进制 205
6.15　函数抽象和逐步求精 207
6.15.1　自顶向下设计 208
6.15.2　自顶向下或自底向上实现 209
6.15.3　实现细节 210
6.15.4　逐步求精的好处 214
关键术语 214
本章小结 215
在线测验 215
程序设计练习 215
第7章　一维数组和C字符串 225
7.1　引言 225
7.2　数组基础 226
7.2.1　声明数组 226
7.2.2　访问数组元素 227
7.2.3　数组初始化语句 228
7.2.4　处理数组 229
7.3　问题：彩票号码 232
7.4　问题：一副纸牌 235
7.5　数组作为函数参数 237
7.6　防止函数修改传递参数的数组 238
7.7　数组作为函数值返回 240
7.8　问题：计算每个字符的出现次数 241
7.9　搜索数组 244
7.9.1　顺序搜索方法 244
7.9.2　二分搜索方法 245
7.10　排序数组 247
7.11　C字符串 249
7.11.1　输入和输出C字符串 249
7.11.2　C字符串函数 250
7.11.3　使用strcpy和strncpy函数复制字符串 251
7.11.4　使用strcat和strncat函数拼接字符串 251
7.11.5　使用strcmp函数比较字符串 252
7.11.6　字符串和数字之间的转换 252
关键术语 253
本章小结 254
在线测验 254
程序设计练习 254
第8章　多维数组 263
8.1　引言 263
8.2　声明二维数组 263
8.3　操作二维数组 264
8.4　二维数组作为函数参数 267
8.5　问题：评定多项选择测试的成绩 268
8.6　问题：找最近邻点对 269
8.7　问题：数独 271
8.8　多维数组 274
8.8.1　问题：每日温度与湿度 275
8.8.2　问题：猜生日 277
本章小结 278
在线测验 278
程序设计练习 278
第二部分　面向对象编程
第9章　对象和类 292
9.1　引言 292
9.2　声明类 292
9.3　例：定义类和创建对象 294
9.4　构造函数 297
9.5　创建及使用对象 298
9.6　类定义和类实现的分离 301
9.7　避免多次包含 303
9.8　类中的内联函数 305
9.9　数据域封装 305
9.10　变量作用域 308
9.11　类抽象和封装 310
关键术语 314
本章小结 314
在线测验 315
程序设计练习 315
第10章　面向对象思想 318
10.1　引言 318
10.2　string类 318
10.2.1　构造一个字符串 319
10.2.2　追加字符串 319
10.2.3　字符串赋值 319
10.2.4　函数at、clear、erase及empty 320
10.2.5　函数length、size、capacity和c_str() 320
10.2.6　字符串比较 321
10.2.7　获取子串 321
10.2.8　字符串搜索 322
10.2.9　字符串插入和替换 322
10.2.10　字符串运算符 323
10.2.11　把数字转换为字符串 324
10.2.12　字符串分割 324
10.2.13　实例研究：字符串替换 324
10.3　对象作为函数参数 327
10.4　对象数组 329
10.5　实例成员和静态成员 331
10.6　只读成员函数 335
10.7　从对象的角度思考 337
10.8　对象合成 342
10.9　实例研究：StackOfIntegers类 344
10.10　类设计准则 346
10.10.1　内聚 346
10.10.2　一致 346
10.10.3　封装 347
10.10.4　清晰 347
10.10.5　完整 347
10.10.6　实例与静态 347
关键术语 348
本章小结 348
在线测验 348
程序设计练习 348
第11章　指针及动态内存管理 353
11.1　引言 353
11.2　指针基础 353
11.3　用typedef定义同义类型 359
11.4　常量指针 359
11.5　数组和指针 360
11.6　函数调用时传递指针参数 363
11.7　从函数中返回指针 367
11.8　有用的数组函数 368
11.9　动态持久内存分配 369
11.10　创建及访问动态对象 373
11.11　this指针 375
11.12　析构函数 376
11.13　实例研究：Course类 379
11.14　拷贝构造函数 382
11.15　自定义拷贝构造函数 384
关键术语 387
本章小结 387
在线测验 388
程序设计练习 388
第12章　模板、向量和栈 393
12.1　引言 393
12.2　模板基础 393
12.3　例：一个通用排序函数 397
12.4　模板类 399
12.5　改进Stack类 405
12.6　C++向量类 407
12.7　用vector类替换数组 410
12.8　实例研究：表达式计算 413
关键术语 417
本章小结 417
在线测验 417
程序设计练习 418
第13章　文件输入输出 424
13.1　引言 424
13.2　文本输入输出 425
13.2.1　向文件中写入数据 425
13.2.2　从文件中读取数据 426
13.2.3　检测文件是否存在 427
13.2.4　检测文件结束 427
13.2.5　让用户输入文件名 429
13.3　格式化输出 430
13.4　函数：getline、get和put 431
13.5　fstream和文件打开模式 434
13.6　检测流状态 435
13.7　二进制输入输出 437
13.7.1　write函数 438
13.7.2　read函数 439
13.7.3　例：二进制数组I/O 440
13.7.4　例：二进制对象I/O 440
13.8　随机访问文件 444
13.9　更新文件 447
关键术语 448
本章小结 448
在线测验 448
程序设计练习 449
第14章　运算符重载 452
14.1　引言 452
14.2　Rational类 453
14.3　运算符函数 458
14.4　重载[]运算符 460
14.5　重载简写运算符 462
14.6　重载一元运算符 462
14.7　重载++和--运算符 463
14.8　友元函数和友元类 464
14.9　重载]运算符 466
14.10　自动类型转换 468
14.10.1　转换为基本数据类型 468
14.10.2　转换为对象类型 469
14.11　定义重载运算符的非成员函数 469
14.12　带有重载运算符函数的Rational类 470
14.13　重载赋值运算符 477
关键术语 481
本章小结 481
在线测验 481
程序设计练习 481
第15章　继承和多态 484
15.1　引言 484
15.2　基类和派生类 484
15.3　泛型程序设计 492
15.4　构造函数和析构函数 493
15.4.1　调用基类构造函数 493
15.4.2　构造函数链和析构函数链 494
15.5　函数重定义 497
15.6　多态 499
15.7　虚函数和动态绑定 500
15.8　关键字protected 503
15.9　抽象类和纯虚函数 504
15.10　类型转换：static_cast 和 dynamic_cast 512
关键术语 515
本章小结 516
在线测验 516
程序设计练习 517
第16章　异常处理 518
16.1　引言 518
16.2　异常处理概述 518
16.3　异常处理机制的优点 522
16.4　异常类 523
16.5　自定义异常类 527
16.6　多重异常捕获 531
16.7　异常的传播 535
16.8　重抛出异常 537
16.9　异常说明 538
16.10　何时使用异常机制 539
关键术语 540
本章小结 540
在线测验 540
程序设计练习 541
第三部分　算法和数据结构
第17章　递归 544
17.1　引言 544
17.2　例：阶乘 545
17.3　实例研究：斐波那契数 548
17.4　用递归方法求解问题 550
17.5　递归辅助函数 552
17.5.1　选择排序 553
17.5.2　二分搜索 555
17.6　汉诺塔 556
17.7　八皇后问题 559
17.8　递归与循环 561
17.9　尾递归 562
关键术语 563
本章小结 563
在线测验 563
程序设计练习 563
第18章　开发高效的算法
第19章　排序
第20章　链表、队列和优先队列
第21章　二分搜索树
第22章　STL容器
第23章　STL算法
第24章　图及其应用
第25章　加权图及其应用
第26章　平衡二叉树和伸展树
附录
附录A　C++关键字 568
附录B　ASCII字符集 569
附录C　运算符优先级表 570
附录D　数字系统 572
附录E　位运算 575
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计（原书第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>最后的、非科学性的附言
目　　录
导论(1)
第一部 关于基督教真理的客观问题
第一章 历史的考察(12)
§1 圣经(12)
§2 教会(20)
§3 数百年来对基督教真理的证明(28)
第二章 思辨的考察(31)
第二部 主体问题,主体与基督教真理的关系,或成为基督教徒
第一册 关于莱辛(47)
第一章 致谢莱辛(47)
第二章 莱辛可能或真正提出的命题(53)
1.主体性的生存思想家意识到了沟通的辩证法2.在与真理的生存关系之中,生存性的主体思想家既否定又肯定,他所拥有的喜剧性与他本质上拥有的情致同样多,他持续地处于生成进程之中,也就是说,在奋斗中3.莱辛说过,偶然性的历史真理永远都不可能成为永恒的理性真理的证据；还说过,在历史陈述的基础上向永恒真理的过渡是一个跳跃4.莱辛说,假如上帝把全部真理握于其右手,而把对真理持续不懈的追求置于其左手,他将选择后者。甲)一个逻辑的体系是可能的；乙)一个生存的体系是不可能的。
第二册 主体问题,或主体性应当如何构成才能使难题向主体开显 (103)
第一章 成为主体(103)
如果成为主体不是赋予人的最高任务的话,伦理学应该做出何种评判；对这个任务做进一步理解的时候应该忽略什么；在成为主体的思想方面的例证
第二章 主体性真理,内心性；真理即主体性(155)
附录 当代丹麦文学之努力一瞥(209)
第三章 现实的主体性；伦理的主体性；主体思想家(255)
§1 生存的意义；现实性(255)
§2 可能性高于现实性；现实性高于可能性；诗的理想和理智理想；伦理理想(267)
§3 主体性之具体环节在生存主体身上的同时共在性；作为思辨进程对立面的同时共在性(288)
§4 主体思想家；他的任务；他的形式,即他的风格(292)
第四章 《哲学片断》的问题:永恒福祉何以能建立在历史知识之上?(310)
第一部分 以《哲学片断》的方案为目标(310)
§1以异教思想为出发点及其原因(310)
§2在有可能调和基督教与思辨思想之前,就何谓基督教保持初步的一致意见的重要性；这种一致意见的缺失对调和有利,尽管它的缺失使调和成为幻象；一致意见的介入阻止了调和的出现(315)
§3《哲学片断》的问题作为导论性问题,不是针对基督教,而是针对成为基督教徒(324)
第二部分 问题本身(326)
个体的永恒福祉通过与某种历史性的东西相关联而在时间中被决定,这种历史性的构成包括了根据其本质不能成为历史、结果必须依靠荒谬才能成为历史的东西
A.情致(328)
§1 对生存情致的初始表达,在生存的转化过程中通过行动表现出的面向绝对目的的绝对方向(方面)——感性情致——调和的虚幻性——中世纪修道院运动——同时与绝对目的建立绝对的关系,与相对目的建立相对的关系(328)
§2 生存情致的本质性表现——痛苦；作为感性人生观的幸福和不幸,与作为宗教人生观的痛苦(在宗教演说中被揭示)之间的对立；痛苦的现实性(幽默)；在后一种情况下的痛苦的现实性之为生存者与永恒福祉的关系的标记；宗教幻象；内心冲突；在前一种情况下的痛苦的根源及意义——离弃直接性、但仍停留在有限性之中；一个建设性的娱乐；幽默作为宗教的伪装(358)
§3 对生存情致的决定性表达就是罪过——我们的考察是向后退的而非向前进的——对罪过的永恒回忆是对罪过意识与永恒福祉的关系的最高表达——对罪过意识及其相应的补罪形式的低级表达——自惩——幽默——隐蔽内心性的宗教感(423)
在A与B之间(444)
B.辩证性(448)
§1 辩证的矛盾,即断裂:通过与在时间中的其他东西建立关系的方式,而在时间中期待着永恒福祉(454)
§2 辩证的矛盾:永恒福祉建基在与某种历史性的关联之上(457)
§3 辩证的矛盾:这里所说的历史不是单纯的历史,而是从只有与自己的本性相反对时才能成为历史的东西当中演化而来,也就是借助荒谬产生的历史(460)
对B的补充(462)
辩证性对情致的反向作用增强了情致以及与之同时共在的诸要素(462)
(1)罪的意识(463)
(2)冒犯的可能性(464)
(3)因同情而滋生的痛楚(465)
第五章 结论(497)
附录与读者达成的共识(523)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>最后的、非科学性的附言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全国计算机等级考试二级教程
第一章 程序设计基本概念
第二章 C程序设计的初步知识
第三章 顺序结构
第四章 选择结构
第五章 循环结构
第六章 字符型数据
第七章 函数
第八章 指针
第九章 数组
第十章 字符串
第十一章 对函数的进一步讨论
第十二章 C语言中用户标识符的作用域和存储类
第十三章 编译预处理和动态存储分配
第十四章 结构体，共用体和用户定义类型
第十五章 位运算
第十六章 文件
第十七章 上机指导

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全国计算机等级考试二级教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>沟通
第0章 C语言基础
第1章 C语言数据类型
第2章 C语言的流程控制
第3章 C语言的数组和字符串
第4章 C语言的函数
第5章 C语言的指针
第6章 struct、untion以及 enum
第7章 C语言的位运算
第8章 C语言的文件操作
第9章 像程序员那样Coding
附录 C语言常用函数参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>沟通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>嵌入式处理器原理及应用
第一章 概述
第二章 系统组件
第三章 硬件开发环境
第四章 软件开发环境
第五章 C语言编程基础
第六章 系统设计与调试
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>嵌入式处理器原理及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Nginx完全开发指南：使用C、C++和OpenResty
第0章  导读	1
0.1  关于本书	1
0.2  读者对象	2
0.3  读者要求	3
0.4  运行环境	4
0.5  本书的结构	4
0.6  如何阅读本书	7
0.7  本书的源码	8
第1章  Nginx入门	9
1.1  关于Nginx	9
1.2  安装Nginx	13
1.3  配置Nginx	19
1.4  总结	30
第2章  Nginx开发准备	31
2.1  开发环境	31
2.2  目录结构	32
2.3  源码特点	34
2.4  使用C++	35
2.5  C++包装类	38
2.6  总结	40
第3章  Nginx基础设施	41
3.1  头文件	41
3.2  整数类型	42
3.3  错误处理	47
3.4  内存池	50
3.5  字符串	58
3.6  时间与日期	64
3.7  运行日志	70
3.8  总结	74
第4章  Nginx高级数据结构	77
4.1  动态数组	77
4.2  单向链表	83
4.3  双端队列	90
4.4  红黑树	101
4.5  缓冲区	108
4.6  数据块链	113
4.7  键值对	120
4.8  总结	121
第5章  Nginx开发综述	123
5.1  最简单的模块	123
5.2  开发基本流程	131
5.3  编译脚本	134
5.4  总结	137
第6章  Nginx模块体系	139
6.1  模块架构	139
6.2  配置解析	152
6.3  源码分析	168
6.4  C++封装	172
6.5  C++开发模块	180
6.6  总结	187
第7章  Nginx HTTP框架综述	191
7.1  框架简介	191
7.2  处理引擎	198
7.3  过滤引擎	205
7.4  源码分析	211
7.5  C++封装	213
7.6  总结	219
第8章  Nginx HTTP请求处理	221
8.1  状态码	221
8.2  请求结构体	222
8.3  请求行	223
8.4  请求头	225
8.5  请求体	226
8.6  响应头	227
8.7  响应体	229
8.8  源码分析	229
8.9  C++封装	232
8.10  开发handler模块	241
8.11  开发filter模块	246
8.12  总结	253
第9章  Nginx HTTP请求转发	255
9.1  框架简介	255
9.2  请求转发机制	261
9.3  负载均衡机制	266
9.4  源码分析	275
9.5  C++封装	281
9.6  开发upstream模块	288
9.7  开发load-balance模块	294
9.8  总结	299
第10章  Nginx HTTP子请求	301
10.1  子请求简介	301
10.2  子请求运行机制	307
10.3  C++封装	314
10.4  数据回传模块	317
10.5  在模块里使用子请求	323
10.6  总结	328
第11章  Nginx变量	329
11.1  结构定义	329
11.2  运行机制	332
11.3  复杂变量	334
11.4  C++封装	335
11.5  在模块里使用变量	341
11.6  在模块里使用复杂变量	343
11.7  总结	345
第12章  Nginx辅助设施	347
12.1  摘要算法	347
12.2  编码和解码	352
12.3  正则表达式	356
12.4  共享内存	356
12.5  总结	359
第13章  Nginx进程机制	361
13.1  基本系统调用	361
13.2  进程系统调用	362
13.3  信号系统调用	364
13.4  结构定义	365
13.5  全局变量	368
13.6  启动过程	370
13.7  信号处理	377
13.8  单进程模式	379
13.9  多进程模式	382
13.10  总结	390
第14章  Nginx事件机制	393
14.1  基本系统调用	393
14.2  socket系统调用	395
14.3  epoll系统调用	399
14.4  结构定义	403
14.5  定时器	415
14.6  模块体系	419
14.7  全局变量	425
14.8  运行机制	427
14.9  总结	452
第15章  Nginx多线程机制	455
15.1  eventfd系统调用	455
15.2  pthread系统调用	456
15.3  结构定义	457
15.4  事件通知	460
15.5  运行机制	463
15.6  在模块里使用多线程	469
15.7  总结	474
第16章  Nginx Stream机制	477
16.1  模块体系	477
16.2  监听端口	483
16.3  处理引擎	491
16.4  过滤引擎	495
16.5  运行机制	496
16.6  开发stream模块	507
16.7  总结	514
第17章  Nginx HTTP机制	517
17.1  结构定义	517
17.2  初始化连接	519
17.3  执行引擎	528
17.4  处理请求体	534
17.5  发送数据	540
17.6  结束请求	543
17.7  总结	548
第18章  Nginx与设计模式	551
18.1  设计模式简介	551
18.2  框架级别的模式	551
18.3  业务级别的模式	553
18.4  代码级别的模式	554
18.5  总结	556
第19章  OpenResty开发	557
19.1  简介	557
19.2  Lua语言	566
19.3  LuaJIT	577
19.4  Lua模块	581
19.5  功能接口	585
19.6  应用实例	594
19.7  Stream Lua模块	598
19.8  lua-resty库	601
19.9  总结	603
第20章  结束语	605
20.1  本书的遗憾	605
20.2  下一步	605
20.3  临别赠言	606
附录A  推荐书目	607
附录B  GDB调试简介	609
附录C  Nginx C++模块简介	611
附录D  Nginx的字符串格式化	613
附录E  nginScript简介	615
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Nginx完全开发指南：使用C、C++和OpenResty
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++求职宝典
第1篇 求职面试第一步
第1章 你了解程序员吗？2
1.1 程序员的那些事2
1.1.1 激动人心的职业2
1.1.2 你了解程序员吗3
1.2 测测你的潜力4
1.3 比尔的建议6
1.4 对程序员的误解7
1.5 你的榜样8
第2章 程序员自我定位11
2.1 求职从选定目标开始11
2.2 你适合哪类企业13
2.2.1 你应该知道的13
2.2.2 你适合哪类企业14
2.3 成功有秘诀吗15
2.4 程序员成长路线15
第3章 求职前的准备17
3.1 了解应聘流程17
3.2 临场面试前的准备19
3.2.1 个人资料的准备19
3.2.2 面试问题的准备19
3.2.3 面试时的心理准备20
3.2.4 了解面试官评价表21
3.3 面试中的着装技巧23
3.3.1 面试着装要点23
3.3.2 男士着装技巧24
3.3.3 女士着装技巧25
3.4 面试过程中的礼仪技巧26
3.4.1 遵时守信26
3.4.2 如何敲开面试官的门26
3.4.3 专业化的握手方式26
3.4.4 语言交流技巧27
3.4.5 无声胜有声的形体语言28
3.5 如何化解面试中的危机28
3.5.1 说错话了怎么办28
3.5.2 如何回答自己不懂的技术和问题29
3.5.3 如何回答“棘手”的问题29
第4章 成功简历设计30
4.1 简历的基本构成30
4.2 简历设计的注意事项33
4.3 投递简历的几种方式34
第5章 求职“淘 宝”之旅36
5.1 校园招聘36
5.2 网络招聘38
5.3 高效使用招聘网站38
5.4 其他求职渠道44
第2篇 面试成功有道
第6章 面试的三种方式47
6.1 笔试47
6.2 电话面试48
6.2.1 不要过分感觉自我良好48
6.2.2 常见的电话面试问题48
6.2.3 电话面试注意事项49
6.3 面试49
6.3.1 面试携带物品50
6.3.2 面试心理准备50
6.3.3 面试举止言谈52
6.3.4 面试后的工作53
第7章 常见面试题54
7.110类必问经典面试题54
7.210种个人素质评测题56
第3篇 C／C++程序设计篇
第8章 C／C++语言基础61
8.1 常量与变量61
8.2 基本数据类型64
8.3 运算符和表达式67
8.4 编程规范71
8.5 程序流程控制76
8.6 static、const与sizeof80
第9章 字符串与数组85
9.1 数组应用基础85
9.2 矩阵操作90
9.3 字符数组95
9.4 字符串相关函数99
9.5 数组越界问题105
第10章 函数109
10.1 函数声明与定义109
10.2 函数参数112
10.3 函数的调用116
10.4 库函数调用122
10.5 内部函数和外部函数125
10.6 函数重载127
第11章 指针与引用129
11.1 引用129
11.2 指针基础131
11.3 指针与数组137
11.4 指针与字符串141
11.5 指针与函数145
11.6 野指针149
第12章 预处理和内存管理151
12.1 宏定义151
12.2 内存管理155
第13章 位运算158
13.1 与运算158
13.2 取反运算159
13.3 异或运算162
13.4 位运算综合题163
第14章 面向对象166
14.1 面向对象基本概念166
14.2 类的定义169
14.3 构造函数和析构函数184
14.4 方法重载194
14.5 const方法196
14.6 静态成员197
14.7 运算符重载199
14.8 类模板203
第15章 继承与多态206
15.1 单继承206
15.2 虚函数与动态绑定212
15.3 抽象类230
15.4 多继承232
15.5 设计模式237
第4篇 数据结构与常用算法
第16章 数据结构246
16.1 链表246
16.2 栈256
16.3 队列265
16.4 二叉树271
第17章 排序与常用算法278
17.1 查找算法278
17.2 排序算法281
17.3 数学运算292
17.4 其他算法297
第5篇 综合测试篇
第18章 英语面试302
18.1 面试前的准备工作302
18.2 面试中的常见问题303
18.3 英语词汇加油站306
18.4 求职信参考模板307
18.5 洽谈薪水技巧308
第19章 电话面试309
19.1 电话面试的目的309
19.2 分析企业的电话面试309
19.3 电话面试礼仪310
19.4 电话面试注意事项311
19.5 电话面试技巧311
第20章 智力测试312
20.1 数字推理习题312
20.2 数学运算习题313
20.3 逻辑推理习题318
第6篇 职场生存篇
第21章 “新员工”的第一堂课322
21.1 第一天上班322
21.2 入职事宜323
21.3 最初几周324
21.4 几点忠告325
第22章 学会在企业中立足330
22.1 如何度过试用期330
22.2 尽快进入工作角色332
22.3 与老员工相处333
22.4 保持激情，提高自己336
第23章 向金字塔尖前进338
23.1 巧妙要求加薪和升职338
23.2 升职加薪六大秘笈340
23.3 升职加薪六大禁忌340
23.4 技术人员的升职通道341
23.5 晋升报告模板342
附录1 C／C++面试题一344
附录2 C／C++面试题二347
附录3 C／C++面试题三349
附录4 C／C++面试题四351
附录5 C／C++面试题五353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++求职宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++之旅（英文版）
前言
1 The Basics
1.1 Introduction
1.2 Programs
1.3 Hello, World!
1.4 Functions
1.5 Types, Variables, and Arithmetic
1.6 Scope
1.7 Constants
1.8 Pointers, Arrays, and References
1.9 Tests
1.10 Advice
2 User-Defined Types
2.1 Introduction
2.2 Structures
2.3 Classes
2.4 Unions
2.5 Enumerations
2.6 Advice
3 Modularity
3.1 Introduction
3.2 Separate Compilation
3.3 Namespaces
3.4 Error Handling
3.5 Advice
4 Classes
4.1 Introduction
4.2 Concrete Types
4.3 Abstract Types
4.4 Virtual Functions
4.5 Class Hierarchies
4.6 Copy and Move
4.7 Advice
5 Templates
5.1 Introduction
5.2 Parameterized Types
5.3 Function Templates
5.4 Concepts and Generic Programming
5.5 Function Objects
5.6 Variadic Templates
5.7 Aliases
5.8 Template Compilation Model
5.9 Advice
6 Library Overview
6.1 Introduction
6.2 Standard-Library Components
6.3 Standard-Library Headers and Namespace
6.4 Advice
7 Strings and Regular Expressions
7.1 Introduction
7.2 Strings
7.3 Regular Expressions
7.4 Advice
8 I/O Streams
8.1 Introduction
8.2 Output
8.3 Input
8.4 I/O State
8.5 I/O of User-Defined Types
8.6 Formatting
8.7 File Streams
8.8 String Streams
8.9 Advice
9 Containers
9.1 Introduction
9.2 vector
9.3 list
9.4 map
9.5 unordered_map
9.6 Container Overview
9.7 Advice
10 Algorithms
10.1 Introduction
10.2 Use of Iterators
10.3 Iterator Types
10.4 Stream Iterators
10.5 Predicates
10.6 Algorithm Overview
10.7 Container Algorithms
10.8 Advice
11 Utilities
11.1 Introduction
11.2 Resource Management
11.3 Specialized Containers
11.4 Time
11.5 Function Adaptors
11.6 Type Functions
11.7 Advice
12 Numerics
12.1 Introduction
12.2 Mathematical Functions
12.3 Numerical Algorithms
12.4 Complex Numbers
12.5 Random Numbers
12.6 Vector Arithmetic
12.7 Numeric Limits
12.8 Advice
13 Concurrency
13.1 Introduction
13.2 Tasks and thread s
13.3 Passing Arguments
13.4 Returning Results
13.5 Sharing Data
13.6 Waiting for Events
13.7 Communicating Tasks
13.8 Advice
14 History and Compatibility
14.1 History
14.2 C++11 Extensions
14.3 C/C++ Compatibility
14.4 Bibliography
14.5 Advice
Index
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++之旅（英文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>无需法律的秩序
原书序
第一编　夏斯塔县
第一章　夏斯塔县其及畜牧业
第二章　牲畜越界争议之解决
第三章　牲畜越界的政治
第四章　谁为边界栅栏付帐？
第五章　公路车畜相撞引发的纠纷
第六章　封闭牧区法令的效果
第二编　一种规范理论
第七章　社会控制体系
第八章　目前诸多社会控制理论之缺点
第九章　合作之迷
第十章　一个有关福利最大化规范的假说
第十一章　实体性规范：有关蜜蜂、牲畜和鲸
第十二章　救济性规范：有关胡萝卜和大棒
第十三章　程序性和构成性规范：有关认识论、礼仪以及英雄崇拜
第十四章　选择控制者的规范：有关合约、习惯和复印
第三编　规范的未来
第十五章　检验规范的内容
第十六章　结论及寓意
附录　研究方法
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>无需法律的秩序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++沉思录
第0章  序幕
第一篇  动机
第1章  为什么我用C++
第2章  为什么用C++工作
第3章  生活在现实世界中
第二篇  类和继承
第4章  类设计者的核查表
第5章  代理类
第6章  句柄：第一部分
第7章  句柄：第二部分
第8章  一个面向对象程序范例
第9章  一个课堂练习的分析（上）
第10章  一个课堂练习的分析（下）
第11章  什么时候不应当使用虚函数
第三篇  模板
第12章  设计容器类
第13章  访问容器中的元素
第14章  迭代器
第15章  序列
第16章  作为接口的模板
第17章  模板和泛型算法
第18章  泛型迭代器
第19章  使用泛型迭代器
第20章  迭代器配接器
第21章  函数对象
第22章  函数配接器
第四篇  库
第23章  日常使用的库
第24章  一个库接口设计实例
第25章  库设计就是语言设计
第26章  语言设计就是库设计
第五篇  技术
第27章  自己跟踪自己的类
第28章  在簇中分配对象
第29章  应用器、操纵器和函数对
第30章  将应用程序库从输入输出中分离出来
第六篇  总结
第31章  通过复杂性获取简单性
第32章  说了HELLO WORLD后再做什么
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++沉思录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>认识生态（第6版）
第1章 生态学简介：历史基础与发展前沿
第一篇 自然史与演化
第2章 陆域生命
第3章 水域生命
第4章 群体遗传学和自然选择
第二篇 环境适应
第5章 生物与温度的关系
第6章 生物与水的关系
第7章 能量与养分
第8章 社会关系
第三篇 种群生态学
第9章 种群的分布与多度
第10章 种群动态
第11章 种群增长
第12章 生活史
第四篇 交互作用
第13章 竞 争
第14章 生物间的相互利用：捕食、植食、寄生与疾病
第15章 互利共生
第五篇 群落与生态系统
第16章 物种多度与多样性
第17章 种间交互作用与群落结构
第18章 初级生产量与能量流动
第19章 养分循环与固持
第20章 演替与稳定性
第六篇 大尺度生态学
第21章 景观生态学
第22章 地理生态学
第23章 全球生态学
附 录 统计表
参考文献
出版后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>认识生态（第6版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计教程
第一部分  入门编程  第1章  实验概述    1．1  实验目标    1．2  实验环境    1．3 实验安排    1．4  做题步骤  第2章  样板实验    2．1  实验内容    2．2  分析题意    2．3  算法描述    2．4  代码编写    2．5  编译调试    2．6  算法任意性    2．7  测试数据  第3章  实验内容    3．1  第一套实验      3．1．1  OPS欢迎您      3．1．2  一个@字符矩形      3．1．3  一个撑字符正方形      3．1．4  一个字符三角形      3．1．5  正方形面积      3．1．6  A．B    3．2  第二套实验      3．2．1  字符三角形      3．2．2  字符菱形      3．2．3  背靠背字符三角形      3．2．4  交替字符倒三角形      3．2．5  格式阵列一      3．2．6  格式阵列二    3．3  第三套实验      3．3．1  1!到n!的和      3．3．2  等比数列      3．3．3  菲波那契数      3．3．4  最大公约数      3．3．5  最小公倍数      3．3．6  平均数    3．4  第四套实验      3．4．1  级数求和      3．4．2  寸称三位数素数      3．4．3  母牛问题      3．4．4  整数内码      3．4．5  整除3、5、7    3．5  第五套实验      3．5．1  十一二进制转换      3．5．2  均方差      3．5．3  五位以内的对称素数      3．5．4  统计天数      3．5．5  杨辉三角形    3．6  阶段测验      3．6．1  逆反01串      3．6．2  倒杨辉三角形      3．6．3  “顺”序列      3．6．4  数字和      3．6．5  组合数      3．6．6  折纸游戏  第4章  解题指导    4．1  第一套实验      4．1．1  OPS欢迎您      4．1．2  一个@字符矩形      4．1．3  一个#字符正方形      4．1．4  一个字符三角形      4．1．5  正方形面积      4．1．6   A．B    4．2  第二套实验      4．2．1  字符三角形      4．2．2  字符菱形      4．2．3  背靠背字符三角形      4．2．4  交替字符倒三角形      4．2．5  格式阵列一      4．2．6  格式阵列二    4．3  第三套实验      4．3．1  1!到n!的和      4．3．2  等比数列      4．3．3  菲波那契数      4．3．4  最大公约数      4．3．5  最小公倍数      4．3．6  平均数    4．4  第四套实验      4．4．1  级数求和      4．4．2  对称三位数素数      4．4．3  母牛问题      4．4．4  整数内码      4．4．5  整除3、5、7    4．5  第五套实验      4．5．1  十一二进制转换      4．5．2  均方差      4．5．3  五位以内的对称素数      4．5．4  统计天数      4．5．5  杨辉三角形第二部分  基本编程  第5章  实验概述    5．1  实验目标    5．2  实验规则    5．3  实验成绩  第6章  样板实验    6．1  实验内容    6．2  分析与试探    6．3  解决时空问题    6．4  提高搜索速度    6．5  测试数据生成  第7章  实验内容    7．1  第一套实验      7．1．1  列出完数      7．1．2  12!配对      7．1．3  整数的因子数      7．1．4  浮点数的位码      7．1．5  对称素数    7．2  第二套实验      7．2．1  密钥加密      7．2．2  密钥解密      7．2．3  0l串排序      7．2．4  按绩点排名      7．2．5  去掉双斜杠注释    7．3  第三套实验      7．3．1  n!的位数      7．3．2  排列对称串      7．3．3  勒让德多项式表      7．3．4  立方数与连续奇数和      7．3．5  菲波那契数    7．4  第四套实验      7．4．1  简单四则运算      7．4．2  大数加      7．4．3  大数和      7．4．4  彼此两点最近      7．4．5  离直线最近的点    7．5  第五套实验      7．5．1  大数乘      7．5．2  n!中的0      7．5．3  整数模      7．5．4  k个胜利者      7．5．5  表达式个数    7．6  阶段测验      7．6．1  半数跳海      7．6．2  01串的位值      7．6．3  勘探油田      7．6．4  另类二进制数      7．6．5  不甘井底的蜗牛第8章  解题指导    8．1  第一套实验      8．1．1  列出完数      8．1．2  12!配对      8．1．3  整数的因子数      8．1．4  浮点数的位码      8．1．5  对称素数    8．2  第二套实验      8．2．1  密钥加密      8．2．2  密钥解密      8．2．3  01串排序      8．2．4  按缋点排名      8．2．5  去掉双斜杠注释    8．3  第三套实验      8．3．1  n!的位数      8．3．2  排列对称串      8．3．3  勒让德多项式表      8．3．4  立方数与连续奇数和      8．3．5  菲波那契数    8．4  第四套实验      8．4．1  简单四则运算      8．4．2  大数加      8．4．3  大数和      8．4．4  彼此两点最近      8．4．5  离直线最近的点    8．5  第五套实验      8．5．1  大数乘      8．5．2  n!中的0      8．5．3  整数模      8．5．4  k个胜利者      8．5．5  表达式个数第三部分  设计与组织  第9章  实验概述    9．1 实验目标    9．2  实验步骤    9．3  实验报告  第10章  样板实验    10．1  实验题目    10．2  分析设计    10．3  工程操作    10．4  独立运行  第11章  实验内容    11．1  实验一    11．2  实验二    11．3  实验三    11．4  实验四    11．5 实验五    11．6  阶段测验  第12章  解题指导    12．1  实验一    12．2  实验二    12．3  实验三    12．4  实验四    12．5  实验五附录  附录A  实验操作指南    A．1  BCB6安装说明    A．2  BCB6操作介绍  附录B  BCB6常见编译错误  附录C  网上提交在线判题系统(OPS)使用说明
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序开发范例宝典
第1章  基础知识第2章  指针第3章  数据结构第4章  算法第5章  数学应用第6章  文件操作第7章  库函数调用第8章  图形图像第9章  系统相关第10章  加解密与安全性第11章  游戏第12章  综合应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序开发范例宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>家庭教师 21
第186章 VS拜歇纳
第187章 被囚
第188章 世川了平VS拜歇纳
第189章 梅罗尼基地
第190章 VSγ
第191章 世川了平VSγ
第192章 SISTEMA C.A.I.之一
第193章 狱寺隼人VSγ
第194章 SISTEMA C.A.I.之二
第195章 瓜
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>家庭教师 21
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计教程
preface v
acknowledgements xi
about the authors xiii
chapter 1 programming fundamentals 1
lesson 1.1 programming languages 1
1.1.1 assembly language 1
1.1.2 highlevellanguages 2
lesson 1.2 software engineering 4
1.2.1 top-down modular design 5
lesson 1.3 the c language，ansi c and c compilers 7
1.3.1 candansic 7
1.3.2 program development 8
lesson 1.4 using bits to represent characters and symbols，integers，real numbers，addresses and instructions 11
1.4.1 characters and symbols 11
1.4.2 integers 12
1.4.3 reaf numbers 14
1.4.4 hexadecimaf and 0c蛔f no~twns 15
lesson 1.5 aboutthistextbookandhowtogetthemostoutofit 16
1.5.1 the lesson 17
.1.5.2 the application programs 17
lesson 1.6 basic structure 19
lesson 1.7 formatting output 27
lesson 1.8 more escape sequences 30
lesson 1.9 basic debugging 34
chapter review 37
chapter 2 variables，arithmetic expressions and input／output 38
lesson 2.1 variables：naming,declaring，assigning and printing values 38
lesson 2.2 arithmetic operators and expressions 47
lesson 2.3 reading data from the keyboard 52
lesson 2.4 constant macros and more about printing variable values 57
lesson 2.5 mixed type arithmetic,compound assignment,operator precedence and type casting 69
chapter review 83
chapter 3 the basics of c-math functions and character file input／output 84
lesson 3.1 math library functions 84
lesson 3.2 single character data 90
lesson 3.3 reading data from a file 105
lesson 3.4 writingoutputto afile 112
application program 3.1 area calculation—compound operators and program development 115
application exercises 119
chapter review 123
chapter 4 beginning decision making and looping 124
lesson 4.1 if control structure and relational expressions 125
lesson 4.2 simple if-else control structures 130
lesson 4.3 nested if-else control structures 135
lesson 4.4 logical expressions 138
lesson 4.5 precedence of logical operators 142
lesson 4.6 switch and if-else-if control structures 147
lesson 4.7 while loop(1)156
lesson 4.8 while loop(2)160
lesson 4.9 do-while loops 162
lesson 4.10 simple for loop 165
lesson 4.11 nested for loops 170
application program 4.1 girder intersection-if-else control structure 176
application program 4.2 area calculation-for loop 179
application program 4.3 temperature unit conversions-for loop 181
application program 4.4 temperature unit conversions-loop and if-else
application program 4.5 simulation 185
application program 4.6 engineering economics—nested for loops 187
application program 4.7 solving a quadratic equation—if-else control structure(numerical method example)191
application exercises 194
chapter renew 198
chapter 5 functions 199
lesson 5.1 functions that do not return a value 204
lesson 5.2 functions that return just one value 216
lesson 5.3 scope and mechanics of passing values to functions 223
lesson 5.4 functions that "return" more than one value 230
lesson 5.5 mechanics of "returning" more than one value from a function-addresses and pointer variables 235
application program 5.1 using functions with complex loops and working withgrids(a logic example)244
application program 5.2 modular program design—area of parallelogram，volume of parallelepiped(numerical method example)252
application exercises 258
chapter renew 268
chapter 6 numeric arrays 269
lesson 6.1 introduction to 1-d arrays and printing array elements 270
lesson 6.2 array initialisation 277
lesson 6.3 basic array input／output 282
lesson 6.4 multidimensional arrays 288
lesson 6.5 functions and arrays 298
lesson 6.6 bubble sort,exchange maximum sort and exchange minimum sort 305
application program 6.1 deriving a 16-bit adder from sixteen 1-bit adders 313
application program 6.2 mean and median of measured wave heights(numerical method example)31 7
application program 6.3 matrix-vector multiplication(numerical method example)323
application program 6.4 searching and file compression 327
application exercises 332
chapter review 339
chapter 7 strings and pointers 340
lesson 7.1 declaring，initialising and printing strings and understanding memory arrangement 343
lesson 7.2 determining information about strings and characters and using printf 353
lesson 7.3 2-d character arrays 361
lesson 7.4 reading strings from the keyboard and files 367
lesson 7.5 pointer variables versus array variables 377
lesson 7.6 initialising within a declaration 386
lesson 7.7 passing strings to user-defined functions 393
lesson 7.8 standard character string functions 400
lesson 7.9 pointer notation versus array notation 416
lesson 7.10 dynamic memow allocation 427
program development methodology 436
application program 7.1 pipe fluid velocity,checking input data and modular design 437
application program 7.2 earthquake anecdotal report analysis，string operations and dynamic storage allocation 449
application exercises 464
chapter review 469
chapter 8 structures and large program design 470
part i：data structures 470
structures in c 471
lesson 8.1 structures 472
lesson 8.2 structure members 480
lesson 8.3 pointers to structures 484
lesson 8.4 structures and functions 487
lesson 8.5 arrays of structures 489
part ii：advanced programming techniques 492
lesson 8.6 functions with one recursive call 492
lesson 8.7 creating header files 500
lesson 8.8 use of multiple source code files and storage classes 503
lesson 8.9 bitwise manipulations 507
application program 8.1 sorting-quicksort algorithm 521
chapter review 534
chapter 9 an introduction to c++(online chapter)
appendix a 535
appendix b 536
index 537
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻松学C++
第1篇  C++概述篇
第1章  C++基础	2
1.1  C++概述	 2
1.1.1  C++语言发展历程	2
1.1.2  C++语言特点	2
1.1.3  C++程序开发基本过程	3
1.2  C++开发环境的搭建	4
1.2.1  Visual C++ 6.0安装	4
1.2.2  Visual C++ 6.0开发环境简介	6
1.3  第一个C++程序	6
1.3.1  创建源程序	6
1.3.2  编译链接	9
1.3.3  调试运行	10
1.3.4  典型C++程序的执行过程	12
1.3.5  使用C++解决问题的流程	12
1.4  C++程序的结构	14
1.4.1  注释	14
1.4.2  编译预处理和新旧标准	14
1.4.3  程序主体	15
1.5  小结	15
1.6  习题	15
第2篇  C++基础语法篇
第2章  数据的表示	18
2.1  数	18
2.1.1  二进制	18
2.1.2  八进制	19
2.1.3  十六进制	20
2.2  数据的描述	21
2.2.1  C++的构词方式——标识符	21
2.2.2  特殊的标识符——关键字	22
2.2.3  整数类型	23
2.2.4  浮点类型	24
2.2.5  字符类型	25
2.2.6  布尔类型	27
2.3  变量	27
2.3.1  变量的声明和定义	28
2.3.2  不变的变量——常量	28
2.4  小结	29
2.5  习题	29
第3章  程序的基本单位——语句	33
3.1  语句的构成	33
3.1.1  表达式语句	33
3.1.2  输入/输出语句	33
3.2  运算符	35
3.2.1  运算符概述	35
3.2.2  运算符的分类	35
3.3  赋值运算符	36
3.3.1  赋值运算符——“=”	36
3.3.2  数据类型转换——隐式转换	37
3.3.3  显式转换	37
3.4  其他常用运算符	39
3.4.1  算术运算符	39
3.4.2  自增自减运算符	40
3.4.3  位运算符	41
3.4.4  复合赋值运算符	43
3.4.5  逗号运算符	43
3.4.6  sizeof运算符	44
3.4.7  逻辑运算符	45
3.4.8  运算符的优先级和结合性	45
3.5  语句块	48
3.5.1  语句块的构成	48
3.5.2  作用域——变量的作用范围	48
3.6  小结	49
3.7  习题	49
第4章  程序控制结构	56
4.1  语句块的执行方式——顺序结构	56
4.2  条件的表达	56
4.2.1  单一条件的表达——关系运算符	56
4.2.2  多条件的表达——逻辑运算符	57
4.3  选择结构	58
4.3.1  最简单的选择——条件运算符	58
4.3.2  单分支条件语句——if语句	59
4.3.3  双分支条件语句——if…else语句	61
4.3.4  多重if…else语句	62
4.3.5  情况语句——switch语句	64
4.3.6  应用实例	65
4.4  循环结构	66
4.4.1  for语句	67
4.4.2  while语句	68
4.4.3  do…while语句	69
4.4.4  多重循环	70
4.4.5  应用举例	71
4.5  意外情况的表达——转向语句	72
4.5.1  跳出语句——break语句	72
4.5.2  继续语句——continue语句	72
4.5.3  转向语句——goto	73
4.6  综合实例	74
4.7  小结	76
4.8  习题	76
第5章  数组	81
5.1  数组概述	81
5.2  数组的来源	82
5.3  一维数组	83
5.3.1  一维数组的声明和定义	83
5.3.2  一维数组的引用	84
5.4  二维数组	86
5.4.1  二维数组的声明和定义	86
5.4.2  二维数组的初始化	86
5.4.3  二维数组的引用	88
5.4.4  多维数组在内存中如何排列元素	89
5.5  字符串	90
5.5.1  字符数组	90
5.5.2  字符串的存储形式	91
5.5.3  字符数组与字符串的区别	91
5.5.4  字符串处理函数	92
5.6  综合实例——杨辉三角	94
5.7  小结	97
5.8  习题	97
第6章  函数	106
6.1  函数概述	106
6.1.1  函数的基本概念	106
6.1.2  函数的分类	107
6.2  函数的组成	107
6.2.1  函数头	108
6.2.2  函数体	108
6.3  函数的声明和定义	110
6.3.1  函数原型——函数的声明	110
6.3.2  函数实现——函数的定义	111
6.4  函数参数传递	112
6.4.1  函数的形参和实参	112
6.4.2  值传递	113
6.5  函数的调用	115
6.5.1  函数的调用过程	115
6.5.2  无参函数的调用	115
6.5.3  带参函数的调用	116
6.5.4  默认形参值的调用	117
6.5.5  嵌套调用	120
6.5.6  数组作为函数参数	121
6.6  递归函数	123
6.6.1  直接递归	124
6.6.2  间接递归	125
6.7  main()函数	127
6.7.1  不带参数的main()函数	127
6.7.2  带参数的main()函数	127
6.8  函数的综合应用	128
6.9  小结	128
6.10  习题	128
第7章  指针与引用	136
7.1  指针概述	136
7.1.1  指针的基本概念	136
7.1.2  定义指针变量	137
7.1.3  初始化指针	138
7.2  指针的访问	139
7.2.1  指针的值	140
7.2.2  访问指针数据	140
7.2.3  小结指针p	141
7.3  指针的算术运算	142
7.3.1  指针与整数的加减运算	142
7.3.2  指针加减1运算	143
7.3.3  指针的相减运算	144
7.4  特殊指针	144
7.4.1  数组指针	144
7.4.2  指向函数的指针——函数指针	145
7.4.3  指针数组	146
7.4.4  二级指针——指针的指针	147
7.4.5  多级指针——二级以上的指针	148
7.5  指针的应用	149
7.5.1  指向一维数组的指针	149
7.5.2  指向二维数组的指针	150
7.5.3  指向字符串的指针	152
7.5.4  指针作为函数参数	153
7.5.5  指针作为函数的返回值——指针函数	155
7.5.6  动态内存分配	156
7.6  引用	158
7.6.1  引用的应用	158
7.6.2  引用与指针	159
7.6.3  引用作为函数参数	160
7.7  小结	161
7.8  习题	162
第8章  复合数据类型	169
8.1  结构体	169
8.1.1  结构体概述	169
8.1.2  定义结构体类型	170
8.1.3  声明结构体变量	172
8.2  结构体的应用	173
8.2.1  初始化结构体变量	173
8.2.2  引用结构体变量成员	175
8.2.3  结构体指针	175
8.2.4  结构体数组	176
8.2.5  结构体和数组的比较	178
8.3  联合	178
8.3.1  定义联合类型	178
8.3.2  声明联合变量	179
8.3.3  引用联合类型成员	179
8.4  枚举	180
8.4.1  定义枚举类型	180
8.4.2  声明枚举变量	182
8.4.3  引用枚举变量成员	182
8.5  用户自定义数据类型	183
8.6  综合实例	184
8.7  小结	187
8.8  习题	187
第3篇  C++面向对象篇
第9章  类和对象	194
9.1  类和对象概述	194
9.2  类和对象的基础语法	195
9.2.1  类的声明	195
9.2.2  实例化对象	196
9.3  类的属性——数据成员	196
9.3.1  类的属性的定义	196
9.3.2  类的数据成员的特例——静态数据成员	196
9.4  类的方法——成员函数	197
9.4.1  类的方法的定义	197
9.4.2  静态成员函数	198
9.4.3  成员函数的类别（const的另一种用法）	198
9.5  特殊的成员函数——构造函数和析构函数	198
9.5.1  构造函数的概念	198
9.5.2  构造函数的声明和定义	200
9.5.3  构造函数的调用	201
9.5.4  不带参数的构造函数	202
9.5.5  带有默认参数的构造函数	202
9.5.6  构造函数的重载	203
9.5.7  特殊的构造函数——复制构造函数	205
9.5.8  析构函数	207
9.5.9  类和函数的联系	208
9.5.10  this指针	209
9.6  小结	209
9.7  习题	209
第10章  继承与派生	217
10.1  继承与派生的基础语法	217
10.1.1  继承与派生概述	217
10.1.2  声明派生类	218
10.2  成员的访问	219
10.2.1  类的成员的访问说明符	219
10.2.2  类的成员的访问权限	219
10.3  继承的访问控制	219
10.3.1  私有继承	220
10.3.2  公有继承	221
10.3.3  保护继承	223
10.3.4  特殊方法的继承——派生类的构造函数和析构函数	225
10.4  多重继承	227
10.4.1  声明多重继承	227
10.4.2  二义性问题	227
10.4.3  多重继承的构造函数和析构函数	231
10.5  虚基类	233
10.5.1  声明虚基类	233
10.5.2  虚基类的构造函数和初始化	234
10.6  友元	235
10.6.1  友元的引入	235
10.6.2  友元函数	235
10.6.3  友元成员	237
10.6.4  友元类	239
10.7  综合实例	240
10.8  小结	244
10.9  习题	244
第11章  多态	251
11.1  多态概述	251
11.1.1  什么是多态	251
11.1.2  多态的引入	252
11.1.3  联编	253
11.2  函数重载	254
11.3  虚函数	255
11.3.1  定义虚函数	256
11.3.2  多级继承和虚函数	258
11.4  纯虚函数与抽象类	259
11.4.1  纯虚函数	259
11.4.2  抽象类	261
11.5  综合实例	263
11.6  小结	264
11.7  习题	264
第12章  运算符重载	269
12.1  运算符重载概述	269
12.1.1  什么是运算符重载	269
12.1.2  运算符重载的特点	270
12.2  运算符重载形式	271
12.2.1  运算符重载为类的成员函数	272
12.2.2  运算符重载为类的友元函数	275
12.2.3  运算符成员函数与友元运算符函数的比较	278
12.3  特殊运算符重载	278
12.3.1  “++”和“--”重载	278
12.3.2  赋值运算符“=”重载	280
12.3.3  下标运算符“[ ]”重载	281
12.4  类类型转换	283
12.5  小结	284
12.6  习题	284
第13章  类模板	290
13.1  什么是类模板	290
13.2  定义类模板	292
13.2.1  语法	292
13.2.2  非类型参数	294
13.2.3  模板参数的默认实参	294
13.3  生成类模板的实例	295
13.3.1  类型参数的模板实例化	295
13.3.2  非类型参数的模板实例化	296
13.3.3  类模板示例	296
13.4  类模板的静态成员	298
13.5  类模板的友元	300
13.5.1  非模板的友元类和友元函数	301
13.5.2  与模板参数不绑定的友元类和友元函数模板	301
13.5.3  与模板参数绑定的友元类和友元函数模板	302
13.6  类模板的特化	303
13.6.1  类模板的全特化	303
13.6.2  类模板的偏特化	304
13.6.3  类模板的匹配规则	304
13.7  小结	305
13.8  习题	305

第4篇  C++应用技术篇
第14章  输入/输出流	308
14.1  输入/输出流的引入	308
14.1.1  C语言中的输入/输出缺陷	308
14.1.2  输入/输出流简介	309
14.1.3  输入/输出流类层次	310
14.2  标准输入/输出流	311
14.2.1  标准输出流对象	312
14.2.2  标准输入流对象	312
14.3  输入/输出流成员函数	313
14.3.1  get()函数	313
14.3.2  getline()函数	314
14.3.3  put()函数	315
14.3.4  read()和write()函数	315
14.3.5  其他成员函数	316
14.4  输入/输出格式控制	317
14.4.1  用ios类的成员函数进行格式控制	317
14.4.2  使用格式控制符进行格式控制	320
14.5  用户自定义数据类型的输入/输出	322
14.5.1  重载输出运算符“<<”	322
14.5.2  重载输入运算符“>>”	323
14.6  命名空间	325
14.6.1  命名空间概述	325
14.6.2  定义命名空间	325
14.6.3  使用命名空间	326
14.7  小结	327
14.8  习题	327
第15章  预处理和宏	331
15.1  预处理概述	331
15.2  宏	331
15.2.1  宏展开	332
15.2.2  替代常量	332
15.2.3  替代运算符	334
15.3  带参数的宏	334
15.3.1  定义带参数的宏	335
15.3.2  注意宏展开的结果	336
15.3.3  带参数的宏与函数的比较	338
15.4  条件编译	338
15.4.1  宏指令	338
15.4.2  使用条件编译	340
15.5  文件包含和头文件卫士	342
15.5.1  包含文件指令	342
15.5.2  搜索头文件	343
15.5.3  头文件卫士	344
15.6  预定义的宏	346
15.7  小结	347
15.8  习题	347
第16章  标准模板库	349
16.1  标准模板库概述	349
16.1.1  C++标准库	349
16.1.2  STL的形成	350
16.1.3  STL的组成	350
16.1.4  STL的引入	351
16.2  算法	353
16.3  容器	354
16.3.1  容器概述	355
16.3.2  向量	355
16.3.3  列表	356
16.3.4  集合	358
16.3.5  双端队列	358
16.3.6  栈	360
16.3.7  映射和多重映射	361
16.4  迭代器	361
16.5  小结	363
16.6  习题	363
第17章  程序调试与异常处理	365
17.1  程序错误	365
17.1.1  编译错误	365
17.1.2  逻辑错误	366
17.1.3  运行错误	367
17.1.4  程序调试	368
17.2  异常处理	369
17.2.1  基本思想	369
17.2.2  抛出异常	370
17.2.3  捕获异常	371
17.2.4  自定义异常对象	373
17.3  异常处理实例	374
17.4  小结	375
17.5  习题	375
第18章  文件	378
18.1  文件概述	378
18.1.1  操作文件的过程	379
18.1.2  处理文件流的类	381
18.2  文件的打开与关闭	384
18.2.1  打开文件	384
18.2.2  关闭文件	385
18.3  文件的顺序读/写	386
18.3.1  读/写文本文件	386
18.3.2  读/写二进制文件	387
18.4  文件的随机读/写	391
18.5  小结	394
18.6  习题	394
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻松学C++
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>标准C 语言实用全书  含盘
第一部分  C语言基础知识
第1章  欢迎阅读 标准C语言实用全书
1. 1  谁应当阅读本书
1. 2  本书需要的基本知识
1. 3  如何最好地学习本书
1. 4

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>标准C 语言实用全书  含盘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C程序基础与实例讲解
基础篇  第1章  Linux基础    1.1  Linux概述      1.1.1  Linux简介      1.1.2  Linux的特点      1.1.3  Linux当前的应用趋势    1.2  Linux命令    1.3  文件与目录操作常用命令      1.3.1  文件/目录创建      1.3.2  文件/目录删除      1.3.3  文件/目录复制      1.3.4  文件/目录属性修改      1.3.5  文件/目录重命名    1.4  系统运行常用命令      1.4.1  显示当前进程      1.4.2  删除指定进程      1.4.3  管道定向命令    1.5  查找操作命令      1.5.1  grep命令      1.5.2  find命令    1.6  其他常用命令      1.6.1  文件系统挂载与卸载      1.6.2  系统关机      1.6.3  增DR/删除用户      1.6.4  设置用户密码    1.7  本章小结  第2章  Shell编程  第3章  C语言基础  第4章  文件编程  第5章  数据库编程基础  第6章  Linux进程编程  第7章  Linux多线程  第8章  Linux工具使用  第9章  基本网络编程  第10章  高级Socket编程实践篇  第11章  STL库编程  第12章  Linux GTK  第13章  GTK控件编程  第14章  Linux基本应用实例解析综合应用篇  第15章  高性能网络服务程序设计  第16章  网络安全实例解析  第17章  HTTP服务器设计与实现附录  习题参考答案参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C程序基础与实例讲解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>莱昂氏UNIX源代码分析
献辞
致谢
序（一）
序（二）
历史注记
上篇 UNIX操作系统版本6源代码
第一部分 初始化、进程初始化
第二部分 陷入、中断、系统调用和进程管理
第三部分 程序交换、基本输入/输出、块设备
第四部分 文件和目录、文件系统、管道
第五部分 面向字符的特殊文件
下篇 莱昂氏UNIX源代码分析
第一部分 初始化、进程初始化
第二部分 陷入、中断、系统调用和进程管理
第三部分 程序交换、基本输入/输出、块设备
第四部分 文件和目录、文件系统、管道
第五部分 面向字符的特殊文件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>莱昂氏UNIX源代码分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>這就是天堂！我的北韓童年
前言
一 穩城郡
對偉大領袖的崇拜．槍決．限額食物．社會成分
二 我的家庭
四十八號渡輪．礦坑．烤麻雀串．對外之窗．祭奠亡者
三 「兒童是黨和國家未來的主人翁」
制服．一加一還是一．責任．自我批判．獻給領袖的花．巡邏
四 「不只活在今日，更為明日而活」
苦艾和蒲公英．饑腸轆轆和聯合國．饑餓的學校．代罪羔羊
五 求生！
捕田鼠．燕子．地獄的色彩．偷竊攸關生死
六 脫北者
反叛．入獄．人吃人．勞改營．傷寒．離開．逃亡
七 中國
井底之蛙．公安突襲．死刑
八 投奔南韓
偵察兵．尋找大使館．柬埔寨上校．宋社長
九 失根的朝鮮人
一心院．小矮人
附錄︰北韓的勞改營
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>這就是天堂！我的北韓童年
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>富有的习惯
Part1 富有的习惯
引领人们走上致富之路的日常习惯
分析致富方法，揭示致富秘籍
导 言................................002
第一章　保险推销员................................005
第二章　秘 书................................017
第三章　汽车经销商................................024
第四章　会计师................................033
第五章　富有的习惯养成方案................................040
第六章　富有的习惯的实际运用——那位“元老级”客户......... 072
第七章　富有的习惯的实际运用——秘书.............. 077
第八章　富有的习惯的实际运用——汽车经销商........... 081
第九章　富有的习惯的实际运用——保险推销员......... 083
纪念J.C. 乔布斯................................088
Part2 改变习惯，重塑人生
从白手起家到百万富翁，177 个普通人的成功秘籍
导 　言................................092
第一章　认识习惯................................094
第二章　习惯的种类................................124
第三章　围绕梦想和目标培养习惯..................... 201
第四章　改变习惯................................209
后 　记................................233
富有的习惯跟进表................................235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>富有的习惯
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Borland C++ Builder实用培训教程
第1周 概览
第1天 入门
1.1什么是C十十Builder
1.2快速浏览C＋＋BuilderIDE
1.3HelloWorld
1.4Hell0World，第二部分――一个Win32控制台应用程序
1.5C＋＋语言概观
1.6小结
1.7专题讨论
第2天 再深入些
2.1if语句
2.2循环语句
2.3switch语句
2.4学习作用域
2.5结构
2.6小结
2.7专题讨论
第3天 更深入C十十一步
3.1指针
3.2引用（References）
3.3通过引用和指针传递函数参数
3.4new和delete操作符
3.5C十十中的函数
3.6小结
3.7专题讨论
第4天 C十十类和面向对象的编程
4.1什么是类
4.2类的解剖
4.3继承
4.4基本的文件I/O
4.5小结
4.6专题讨论
第5天 C十十类组织和可视组件模型
5.1基本类库（Framewofks101）
5.2C＋＋类库之争
5.3可视组件库
5.4C＋＋Builder和VCL
5.5关于VCL
5.6小结
5.7专题讨论
第6天 C＋＋生成器IDE资源管理：项目与表单
6.1C十十Builder中的项目
6.2C十十Builder的主菜单和工具条
6.3使用组件调色板
6.4一个多表单应用程序的例子
6.5编译和连接其它的C十十程序
6.6关于C十十Builder表单的更多说明
6.7对象观察器
6.8一个MDI样本程序
6.9小结
6.10 专题讨论
第7天 使用表单编辑器（FormEditor）和菜单编辑器（MenuEditor）
7.1使用表单编辑器
7.2我可以看到一个菜单吗
7.3小结
7.4专题讨论
第1周 复习
第2周 概览
第8天 VCL组件
8.1概述
8.2Name属性
8.3重要的共同属性
8.4组件的基本方法
8.5普通事件
8.6标准的Windows组件组件
8.7公共对话框
8.8小结
8.9专题讨论
第9天 在C十十Builder中创建应用程序
9.1使用对象库
9.2使用Wizards建立表单和应用
9.3向代码中添加函数和数据成员
9.4使用资源文件
9.5小结
9.6专题讨论
第10天 有关项目的更多内容
10.1每个人都需要一个项目
10.2使用项目管理器（PrijectManager）
10.3开发你的项目
10.4了解项目选项（ProjectOptions）
10.5C＋＋Builder代码编辑器
10.6小结
10.7专题讨论
第11天 使用调试器
11.1为什么使用调试器
11.2调试菜单项
11.3断点
11.4监视变量
11.5调试观察器
11.6其它调试工具
11.7单步执行你的程序
11.8调试技术
11.9小结
11.10专题讨论
第12天 C十十Builder工具和选项
12.1ImageEditor（图象编辑器）
12.2WinSight：监视Windows
12.3命令行工具
12.4配置C十十Builder工具（Tools）菜单
12.5设置EnvironmentOptions
12.6小结
12.7专题讨论
第13天 高级篇
13.1窗口装饰
13.2命令生效
13.3在C十十Bui1der应用程序中打印
13.4使用光标
13.5小结
13.6专题讨论
第14天 高级程序编程
14.1实施上下文敏感帮助
14.2异常处理
14.3使用注册表（Registry）
14.4特殊消息处理
14.5小结
14.6专题讨论
第2周 复习
第3周 概述
第15天 OLE、ActiveX和OCX控件
15.1Autosrv和Autocon
15.2Olemdi和Olesdi
15.3OCX控件
15.4小结
15.5专题讨论
第16天 C十十BUILDER数据库结构
16.1一些你需要知道的术语
16.2结构概述
16.3C十十Builder数据库组件概览
16.4小结
16.5专题讨论
第17天 建立数据库表单
17.1一个简单表单
17.2小结
17.3专题讨论
第18天 建立数据库应用
18.1TDatabase组件
18.2BDE化名
18.3数据模块
18.4建立一个Master/Detail表单
18.5报告
18.6小结
18.7专题讨论
第19天 建立和使用DLLs
19.1DLL概述
19.2调用DLL中的函数以及使用类
19.3建立一个DLL
19.4建立调用应用
19.5在DLLs使用表单
19.6使用DLLs中的资源
19.7小结
19.8专题讨论
第20天 创建组件
20.1开始
20.2TheComponentWizard
20.3编写属性
20.4为组件编写方法
20.5一个组件例子：TFlashingLabel：
20.6测试组件
20.7将组件加入组件库中
20.8为组件编写事件
20.9把它们集成在一起
20.10总结
20.11专题讨论
第21天 C十十BUILDER和DELPHI
21.1C十十Builder与Delphi的主要区别
21.2C＋＋Builder和Delphi的其它区别
21.3Delphi单元的C＋＋Builder仿真
21.4总结
21.5专题讨论
第3周 复习
第22天（编外一天）建立Internet应用程序
22.1基础
22.2Internet组件的Palette页浏览
22.3建立你的Web浏览器
22.4给新组件添加内容
22.5总结
22.6专题讨论
第23天（编外一天）C＋＋Builder对C＋＋的扩展
23.1C＋＋BUILDER的发展历史
23.2语言的扩展：大讨论
23.3C＋＋Builder中新的C十十关键词
23.4总结
23.5专题讨论
附录A 问题的答案
第1天
第2天
第3天
第4天
第5天
第6天
第7天
第8天
第9天
第10天
第11天
第12天
第13天
第14天
第15天
第16天
第17天
第18天
第19天
第20天
第21天
第22天
第23天

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Borland C++ Builder实用培训教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法（第5部分）
出版者的话
译者序
中文版序
前言
第五部分图算法
第17章图的性质及类型
17.1术语
17.2图的adt
17.3邻接矩阵表示
17.4邻接表表示
17.5变量、扩展和开销
17.6图生成器
17.7简单路径、欧拉路径和哈密顿路径
17.8图处理问题
第18章图搜索
18.1探索迷宫
18.2深度优先搜索
18.3图搜索adt函数
18.4dfs森林的性质
18.5dfs算法
.18.6可分离性和双连通性
18.7广度优先搜索
18.8广义图搜索
18.9图算法分析
第19章有向图和有向无环图
19.1术语和游戏规则
19.2有向图中的dfs剖析
19.3可达性和传递闭包
19.4等价关系和偏序
19.5有向无环图
19.6拓扑排序
19.7有向无环图中的可达性
19.8有向图中的强连通分量
19.9再论传递闭包
19.10展望
第20章最小生成树
20.1表示..
20.2mst算法的基本原理
20.3prim算法和优先级优先搜索
20.4kruskal算法
20.5boruvka算法
20.6比较与改进
20.7欧几里得mst
第21章最短路径
21.1基本原理
21.2dijkstra算法
21.3所有对最短路径
21.4无环网中的最短路径
21.5欧几里得网
21.6归约
21.7负权值
21.8展望
第22章网络流
22.1流网络
22.2增大路径最大流算法
22.3预流-推进最大流算法
22.4最大流归约
22.5最小成本流
22.6网络单纯形算法
22.7最小成本流归约
22.8展望
第五部分参考文献...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法（第5部分）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET Web服务入门经典
第1章 Web服务的基础知识
1 Web服务的概念
……
第2章 Web服务的数据
1 XML的基本知识
……
第3章 描述Web服务
1 Web服务描述
……
第4章 Web服务的使用和通信
1 简单对象访问协议（SOAP）
……
第5章 .NET Web服务
1 ASP.NET Web服务
……
第6章 发布数据为Web服务（Ⅰ）
1 ADO.NET概述
……
第7章 发布数据为Web服务（Ⅱ）
第8章 现实世界的Web服务（Ⅰ）
第9章 现实世界的Web服务（Ⅱ）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET Web服务入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
第一部分 《C语言程序设计(第2版)》中的习题和参考解答第1章 C语言概述第2章 数据的存储与运算第3章 最简单的C程序设计——顺序程序设计第4章 选择结构程序设计第5章 循环结构程序设计第6章 利用数组处理批量数据第7章 利用函数实现模块化程序设计第8章 善于使用指针第9章 使用结构体类型处理组合数据——用户自定义数据类型第10章 利用文件保存数据第二部分 常见错误分析和程序调试第11章 常见错误分析第12章 程序的调试与测试  12.1 程序的调试  12.2 程序错误的类型  12.3 程序的测试第三部分 C语言上机指南第13章 Turbo C 2.0的上机操作  13.1 Turbo C的安装  13.2 进入Turbo C  13.3 Turbo C的工作窗口  13.4 编辑一个新文件  13.5 编辑一个已存在的文件  13.6 改变用户工作目录  13.7 确立Turbo C工作环境  13.8 编译和连接  13.9 运行第14章 Turbo C++ 3.0的上机操作  14.1 进入Turbo C++ 3.0集成环境  14.2 C源文件的建立和程序的编辑  14.3 程序的编译和连接  14.4 运行程序  14.5 退出Turbo C++ 3.0环境  14.6 对多文件程序进行编译和连接  14.7 程序动态调试方法第15章 Visual C++的上机操作  15.1 Visual C++的安装和启动  15.2 输入和编辑源程序  15.3 编译、连接和运行  15.4 建立和运行包含多个文件的程序的方法第四部分 上机实验安排第16章 上机实验的指导思想和要求  16.1 上机实验的目的  16.2 上机实验前的准备工作  16.3 上机实验的步骤  16.4 实验报告  16.5 实验内容安排的原则第17章 实验安排  17.1 实验1 C程序的运行环境和运行C程序的方法  17.2 实验2 数据的存储与运算  17.3 实验3 最简单的C程序设计——顺序程序设计  17.4 实验4 逻辑结构程序设计  17.5 实验5 循环结构程序设计  17.6 实验6 利用数组处理批量数据  17.7 实验7 用函数实现模块化程序设计(一)  17.8 实验8 用函数实现模块化程序设计(二)  17.9 实验9 善于利用指针(一)  17.10 实验10 善于利用指针(二)  17.11 实验11 使用结构体类型处理组合数据  17.12 实验12 文件操作参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙语短篇C3
Introduction 前言1．The New Principal2．A Bad Neighbor3．The Generous Policeman4．Which Way?5．The Most Famous Person in the Wodd6．Dream Win7．A Careless Driver8．A Piece of Bread9．Too High a Price10．A New Kind of Chicken11．A Good Reason12．An Unexpected Answer13．The Entertainer14．Suspicious Behavior15．One Thing MissingAnswer Key 答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙语短篇C3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编程大讲坛
第1篇 编程基础篇  第1课 C#开发基础    1.1 本课学习目标    1.2 什么是C#      1.2.1 C#的推出背景      1.2.2 C#的特点    1.3 .NET Framework框架      1.3.1 .NET Framework简介      1.3.2 常见的几个概念    1.4 一个简单的C#程序    1.5 本课回顾和网络关键词  第2课 初识C#开发环境  第3课 变量与常量  第4课 复杂的变量类型和.NET框架类  第5课 表达式与运算符  第6课 C#中的流程控制语句  第7课 面向对象编程技术  第8课 方法  第9课 C#类基础  第10课 深入C#类  第11课 C#集合、数组和集合类  第12课 foreach语句、自定义集合类和迭代器  第13课 继承与多态基础  第14课 接口和类转换  第15课 字符串与正则表达式  第16课 委托与事件  第17课 泛型  第18课 C#文件操作和流文件操作  第19课 XML文件操作处理  第20课 Windows窗体编程基础  第21课 菜单、工具栏和对话框第2篇 技术提高篇  第22课 Web应用编程  第23课 数据库和ADO.NET操作  第24课 DataGrid和数据绑定  第25课 GDI+图形图像编程  第26课 C#非托管代码操作  第27课 水晶报表应用  第28课 DotNetBar控件应用  第29课 Microsoft Enterprise Library  第30课 水晶报表应用  第31课 应用MapXtreme  第32课 项目开发案例：俄罗斯  第33课 项目开发案例：在线留言本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编程大讲坛
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构C++语言描述
第1章 绪论
1.1 数据结构的发展简史
1.2 基本概念和术语
1.2.1 数据
1.2.2 数据的逻辑结构
1.2.3 数据的存储结构
1.2.4 数据结构
1.2.5 数据类型
1.2.6 抽象数据类型与类
1.3 算法
1.3.1 算法的时间复杂度
1.3.2 算法的空间复杂度
本章小结
习题
第2章 C++类
2.1 类的定义
2.2 模板类
2.3 基类和派生类
2.4对象的定义
2.5 构造函数、析构函数和拷贝初始化构造函数
2.6运算符的重载
2.6.1 运算符重载为类的函数成员
2.6。2 运算符重载为非函数成员
本章小结
习题
第3章 线性表
3.1 线性表的抽象数据类型
3.1.1 线性表的逻辑结构
3.1.2 线性表的操作
3.1.3 线性表的存储结构
3.2顺序表
3.2.1 顺序表的存储结构
3.2.2 顺序表的操作
3.2.3 顺序表类C廾语言定义
3.2.4 顺序表的应用——并交差运算
3.3 非循环单链表
3.3.1 非循环单链表的存储结构
3.3.2 非循环单链表的操作
3.3.3 非循环单链表类C什语言定义
3。3.4 非循环单链表的应用——多项式的加减运算
3.4循环单链表
3.4.1 循环单链表的存储结构
3.4.2 循环单链表的操作
3.4.3 循环单链表类C什语言定义
3.4.4 循环单链表的应用——约瑟夫环出列
3.5循环双链表
3.5.1 循环双链表的存储结构
3.5.2 循环双链表的操作
3.5.3 循环双链表类C++语言定义
3.6 线性表顺序存储和链式存储结构比较
本章小结
习题
第4章 栈
4.1 栈的抽象数据类型
4.1.1 栈的逻辑结构
4.1.2 栈的操作
4.1.3 栈的存储结构
4.2 顺序栈
4.2.1 顺序栈的存储结构
4.2.2 顺序栈的操作
4.2.3 顺序栈类C++语言定义
4.2.4 顺序栈的应用一一表达式求解
4.3 链栈
4.3.1 链栈的存储结构
4.3.2链栈的操作
4.3.3 链栈类C++语言定义
本章小结
习题
第5章 队列
5.1 队列的抽象数据类型
5.1.1 队列的逻辑结构
5.1.2 队列的操作
5.1.3 队列的存储结构
5.2 循环顺序队列
5.2.1 循环顺序队列的存储结构
5.2.2 循环顺序队列的操作
5.2.3 循环顺序队列类C什语言定义
5.2.4 循环顺序队列的应用
5.3 非循环链队
5.3.1 非循环链队的存储结构
5.3.2 非循环链队的操作
5.3.3 非循环链队类C什语言定义
本章小结
习題
第6章 串
6.1 串的抽象数据类型
6.1.1 串的逻辑结构
6.1.2 串的操作
6.1.3 串的存储结构
6.2顺序串
6.2.1 顺序串的存储结构
6.2.2 顺序串的操作
6.2.3 顺序串类C++语言定义
6.3 链串
本章小结
习题
第7章 多维数组
7.1 数组
7.2 特殊矩阵
7.2.1 对称矩阵
7.2.2 三角矩阵
7.2.3 对角矩阵
7.3 稀疏矩阵（采用三元组表顺序存储）
7.3.1 稀疏矩阵的存储结构
7.3.2 稀疏矩阵的操作
7.3.3 稀疏矩阵类C++语言定义
7.4 稀疏矩阵（采用十字链表存储）
7.4.1 稀疏矩阵的存储结构
7.4.2 稀疏矩阵的操作
7.4.3 稀疏矩阵类C++语言定义
本章小结
习题
第8章 广义表
8.1 广义表的逻辑结构
8.2 广义表的存储结构
8.3 广义表的操作
8.4 广义表类C++语言定义
本章小结
习题
第9章 树
9.1 树的抽象数据类型
9.1.1 树的逻辑结构
9.1.2树的操作
9.1.3 树的存储结构
9.2 二叉树
9.2.1 二叉树的逻辑结构
9.2.2 二叉树的重要性质
9.2.3 二叉树的存储结构
9.3 二叉树（采用顺序存储）
9.3.1 二叉树的存储结构
9.3.2 二叉树的操作
9.3.3 二叉树类C++语言定义
9.4 二叉树（采用链式存储）
9.4.1 二叉树的存储结构
9.4.2 二叉树的操作
9.4.3 二叉树类C什语言定义
9.5 中序穿线二叉树
9.5.1 中序穿线二叉树的存储结构
9.5.2 中序穿线二叉树的操作
9.5.3 中序穿线二叉树类C++语言定义
9.6 树 森林
9.6.1 树的存储结构
9.6.2 树 森林与二叉树之间的转换
9.6.3 树 森林与对应二叉树的遍历关系
9.7 哈夫曼树——二叉树的应用
9.7.1 哈夫曼树的概念
9.7.2 哈夫曼树的存储结构
9.7.3 哈夫曼树的操作
9.7.4 哈夫曼树类C++语言定义
本章小结
习题
第10章 图
10.1 图的基本概念
10.1.1 无向图
10.1.2 有向图
10.2 图的操作
10.2.1 最小生成树
10.2.2 最短路径
10.2.3 图的遍历
10.2.4 拓扑序列
10.2.5 关键路径
10.3 图的存储结构
10.4 图（采用邻接矩阵存储）
10.4.1 图的存储结构
10.4.2 图的基本操作
10.4.3 图类C++语言定义
10.5 图（采用邻接表存储）
10.5.1 图的存储结构
10.5.2 图的基本操作
10.5.3 图类C什语言定义
本章小结
习题
第11章 排序
11.1 排序的基本概念
11.2插入排序
11.2.1 直接插入排序
11.2.2 折半插入排序
11.2.3 静态链表插入排序
11.2.4 希尔排序
11.3 交换排序
11.3.1 冒泡排序
11.3.2 快速排序
11.4选择排序
11.4.1 直接选择排序
11.4.2 堆排序
11.5 归并排序
11.6 分配排序
11.6.1 箱排序
11.6.2 基数排序
11.7 各种排序方法的比较
11.8 各种排序方法C++语言实现
本章小结
习题
第12章 查找
12.1 静态查找表
12.1.1 顺序查找
12.1.2 折半查找
12.1.3 索引顺序查找
12.1.4 静态查找表类C++语言定义
12.2动态查找表
12.2.1 二叉排序树
12.2.2平衡二叉排序树
12.2.3 B—树
12.2.4 哈希表
本章小结
习题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构C++语言描述
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>烏龜脖矯正操
作者序	注意！你的體型是不是愈來愈像ET外星人……
本書使用說明
PART 1	習慣把脖子往前伸？小心「烏龜脖」上身！
NOTE 01為什麼會出現「烏龜脖」？
NOTE 02「烏龜脖」會對身體造成什麼影響？
NOTE 03「端正體型」和「烏龜脖體型」有何差別？
NOTE 04自我檢視！你已經有「烏龜脖」了嗎？
NOTE 05注意！就是這些NG動作導致「烏龜脖」！
NOTE 06 改變姿勢，就是解救「烏龜脖」的第一步！
NOTE 07 姿勢好不好，身體大不同！
NOTE 08 電腦、手機這樣用，脖子才不會受傷！
NOTE 09 擺脫「烏龜脖」，身體不痠痛，人緣變好、工作變快，還能幫助長高！
NOTE 10「烏龜脖」矯正實例大公開，重拾健康好自在！
CASE 01 「烏龜脖」讓我頭痛、頸硬、骨盆歪，還好矯正操救了我！	（金哲秀‧男）
CASE 02 「烏龜脖矯正操」讓我變形的身體直立起來了！	（徐英圭‧男）
CASE 03 有系統的矯正運動，讓我找到「烏龜脖」的終極解答！	（李恩惠‧女）
CASE 04　	「烏龜脖」讓我的頭重到不行，聯考前，我一定要救回來！	（金善英‧女）
CASE 05	「烏龜脖矯正操」讓我的脖子不歪，X腿不見，腰也不痛了！	（金惠珍‧女）
CASE 06	藉由「烏龜脖矯正操」，讓我重拾健康、美好的身體！ （朴宰享‧男）
CASE 07 當初怎麼把身體弄壞，現在就要怎麼把它「喬」回來！	（趙俊英‧男）
CASE 08	努力做「烏龜脖矯正操」，讓我的身體得到「正直」的回報！	（孫韓季‧男）
CASE 09	持續不斷運動，改變錯誤姿勢，才能擺脫「烏龜脖症候群」！ （吳娜妍‧女）
CASE 10	忽略「烏龜脖」所帶來的訊號，就會招致身體「全面造反」！	（楊允靜‧女）
PART 2	超強「烏龜脖矯正操」，2週全身都「喬」好！
DAY1 紓解「烏龜脖」，放鬆肩頸
站立頸部向下伸展 l站立頸部45度伸展 l站立頸部側邊伸展 l站立頸部向後伸展
DAY2 打開胸廓，改善駝背1
站立牆角擴胸伸展 l站立牆面拉脊伸展 l跪趴地板壓背伸展 l跪趴抗力球鬆背伸展
DAY3 打開胸廓，改善駝背2
站立徒手擴胸伸展 l站立手肘向後擴胸伸展 l雙腳前後張開，雙手高舉伸展 l仰躺抗力球後背伸展
DAY4 舒張肩胛骨，調整駝背
手肘舉高，後彎下壓 l彎腰舉臂，伸展肩胛 l 45度彎腰舉臂，伸展肩胛 l平壓手臂，紓緩肩膀 l手臂貼牆，全身扭轉
DAY5鬆緩背脊肌肉
脊椎向前伸展 l脊椎側面伸展 l張開雙手，側腰拉脊伸展 l高舉抗力球左右拉脊伸展 l跪立伸腿，側腰拉脊伸展
DAY6 舒展骨盆‧伸展雙腿 1
雙腿交叉疊坐，上半身向前彎 l 單腿彎曲跨坐，上半身向前彎 l平躺翹腳，抱腿靠胸 l站立開腿，單膝彎曲90度
DAY7舒展骨盆‧伸展雙腿 2
單腳站立，大腿拉筋 l 屈膝W腿，跪躺伸展 l坐地併腿，上半身向前彎 l平躺拉腿，左右扭轉骨盆
DAY8 拉伸脊椎
站立脊椎伸展 l平躺脊椎伸展
DAY9 導正脊椎‧端正骨盆
半蹲脊椎扭轉 l單腳屈膝，上半身扭轉 l坐地交腿，手肘推膝，上半身向後轉 l坐立翹腳，上半身向前彎
DAY10矯正「烏龜脖」，強化頸部肌肉
趴地抬頸，雙手貼地挺起上半身 l單手推頭，頸部側面抗衡運動 l雙手推額，頸部向前抗衡運動 l雙手推後腦，頸部向後抗衡運動
DAY11矯正駝背強化運動
趴地抬頸，雙手離地挺起上半身 l趴地張臂，握拳比讚挺起上半身 l趴地抬頸，四肢上舉運動 l站立舉臂，平拉彈力帶開背伸展 l雙手貼牆，壓背拉脊伸展
DAY12 拉提下垂小腹‧強化腹部肌肉
仰臥壓手掌，抬頸舉單腿，拉提腹肌l 仰臥壓手掌，抬身舉四肢，手腳靠近，鍛鍊腹肌 l仰臥屈膝，四肢上舉連續伸展，伸縮腹肌
DAY13 整脊運動
站立縮下巴，回推頸椎 l雙手交叉，半蹲後拉，頸椎後仰 l雙膝跪地，貓咪拱背挺腰伸展 l坐地抱腿，骨盆後躺運動 l平躺舉腿，背部抬起向後翻折
DAY14 抗力球輔助運動
仰躺抗力球後背伸展 l高舉抗力球左右拉脊伸展 l跪趴抗力球鬆背伸展 l抗力球頂牆滾動仰頸拉背伸展
【COLUMN】在使用「智慧型」3C產品時，你的姿勢也夠「Smart」嗎 ？
PART 3 上班族、3C族隨時解痛，辦公室也能自療！
STEP 1 在辦公桌前就能做的有效伸展
坐立頸部側邊伸展 l坐立頸部45度伸展 l坐立頸部向後伸展 l坐立徒手擴胸伸展 l坐立推膝，上半身向後轉 l坐立臀部上提伸展 l坐立翹腳，上半身向前彎 l 坐立前彎伸腿運動 l坐立脊椎伸展運動 l雙腳前後張開，雙手高舉伸展 l彎腰舉臂，伸展肩胛 l平壓手臂，紓緩肩膀 l半蹲脊椎扭轉
STEP 2 利用牆壁、門框，拉一拉筋骨
站立面牆拉脊伸展 l站立牆角擴胸伸展 l手推門框擴胸運動 l雙手撐桌，身體前傾，頸部後仰伸展
【COLUMN】姿勢不良、體型難看，面試絕對失敗！
【COLUMN】根據統計，體態愈好的型男美女，年收入也愈高！
PART 4 擺脫「烏龜脖症候群」，對症動作效果最好！
CURE 1 紓緩【頸部僵硬】的4個動作
頸部向下伸展 l頸部45度伸展 l頸部側邊伸展 l頸部向後伸展
CURE 2 改善【腰痠背痛】的3個動作
牆角擴胸伸展 l牆面拉脊伸展 l雙膝跪地，貓咪拱背挺腰伸展
CURE 3 消除【肩頸痠痛】的4個動作
手肘舉高，後彎下壓 l平壓手臂，紓緩肩膀 l舉手抬肘，轉動肩膀 l手臂貼牆，全身扭轉
CURE 4 解決【胸悶、胸痛】的3個動作
拉舉彈力帶伸展胸背運動 l手肘向後擴胸伸展 l雙腳前後張開，雙手高舉伸展
CURE 5 不再【手麻、手部冰冷】的2個動作
雙手合掌，手腕下壓運動 l手臂伸直，手腕後壓運動
CURE 6 解除【筋骨痠痛】的4個動作
平躺舉腿，背部抬起向後翻折 l半蹲脊椎扭轉l坐地併腿，上半身向前彎 l坐立轉動腳踝
CURE 7 矯正【烏龜脖】的捲枕和毛巾操
利用毛巾，自製好用的「捲枕」 l頸部伸展毛巾操 l肩部伸展毛巾操 l頸椎捲枕毛巾操 l坐立頸部向後伸展
CURE 8 療癒【慢性頭痛】的靜坐冥想
CURE 9 帶走【全身疲勞】的半身泡澡
【COLUMN】枕頭決定你的睡眠品質，該換就換！
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>烏龜脖矯正操
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>六大思想构建物理学·第1卷
前言
《六大思想构建物理学》要目
作者简介
C单元
N单元
Preface
Table of Contents for Six Ideas That Shaped Physics
About the Author
Unit C
Unit N
关于C单元的几点说明（中文）
学生学习指导（英文）
第C1章
相互作用概述10
本章概览10
C1.1 科学的本质12
C1.2 物理学的发展和结构13
C1.3 本单元概览18
C1.4 力学导论16
C1.5 基本相互作用18
C1.6 宏观相互作用20
C1.7 “运动”的描述22
C1.8 物理技能：专业词汇24
C1.9 物理技能：单位25
亚里士多德思维测试27
两分钟测试29
习题29
习题答案31
亚里士多德测试答案31
第C2章
矢量32
本章概览32
C2.1 矢量和标量34
C2.2 基本矢量运算35
C2.3 分量37
C2.4 矢量的大小39
C2.5 一维和二维矢量39
C2.6 分解法矢量运算42
C2.7 矢量单位45
C2.8 参考系45
两分钟测试47
习题48
习题答案50
第C3章
相互作用与动量转移52
本章概览52
C3.1 速度54
C3.2 相互作用与动量转移56
C3.3 冲量和力58
C3.4 质量和重量61
C3.5 动量流和运动63
C3.6 物理技能：不成立的矢量方程65
两分钟测试66
习题67
习题答案69
第C4章
质点和质点系70
本章概览70
C4.1 质点系72
C4.2 动量守恒72
C4.3 系统的质心74
C4.4 质心如何运动77
C4.5 惯性参考系80
C4.6 与地球的相互作用82
两分钟测试84
习题84
习题答案87
第C5章
动量守恒的应用88
本章概览88
C5.1 非孤立系统时的动量守恒 90
C5.2 孤立系统的自由度 91
C5.3 解决问题的框架92
C5.4 构建模型图像94
C5.5 求解动量守恒问题96
C5.6 飞机和火箭100
两分钟测试102
习题103
习题答案105
第C6章
能量概述106
本章概览106
C6.1 相互作用和能量 108
C6.2 动能 109
C6.3 势能的测量111
C6.4 负能量？115
C6.5 后面章节的内容116
C6.6 能量问题中的参考系选择117
两分钟测试120
习题121
习题答案122
第C7章
一些势能函数124
本章概览124
C7.1 电磁相互作用126
C7.2 引力相互作用128
C7.3 地球表面的引力129
C7.4 弹性势能131
C7.5 一些事例134
C7.6 物理技能：有效数字138
两分钟测试139
习题140
习题答案142
第C8章
力和能量144
本章概览144
C8.1 动量和动能146
C8.2 点积147
C8.3 相互作用对dK的贡献148
C8.4 质心功的含义150
C8.5 地球的动能151
C8.6 力定律152
C8.7 接触相互作用154
两分钟测试157
习题158
习题答案160
第C9章
转动动能162
本章概览162
C9.1 转动动能概论164
C9.2 角度的测量164
C9.3 角速度166
C9.4 转动惯量168
C9.5 转动惯量的计算169
C9.6 平动和转动172
C9.7 无滑动转动173
两分钟测试176
习题177
习题答案181
第C10章
热能182
本章概览182
C10.1 案例：消失的能量184
C10.2 热是能量184
C10.3 热能186
C10.4 摩擦和热能187
C10.5 热量和功188
C10.6 比热容190
C10.7 和热能相关问题192
两分钟测试196
习题197
习题答案199
第C11章
化学键能200
本章概览200
C11.1 势能图像202
C11.2 化学键205
C11.3 潜热206
C11.4 化学能和核能209
C11.5 能量储存的其他形式213
两分钟测试213
习题214
习题答案217
第C12章
功率、碰撞和冲击218
本章概览218
C12.1 功率 220
C12.2 碰撞的种类 223
C12.3 弹性碰撞224
C12.4 弹弓效应229
C12.5 非弹性碰撞230
C12.6 小行星的冲击232
两分钟测试235
习题236
习题答案238
第C13章
角动量240
本章概览240
C13.1 人体转动问题242
C13.2 叉积243
C13.3 粒子的角动量246
C13.4 刚体的角动量247
C13.5 运动物体角动量249
C13.6 角冲量和转矩250
两分钟测试253
习题255
习题答案256
第C14章
角动量守恒258
本章概览258
C14.1 陀螺的进动260
C14.2 一些应用262
C14.3 角动量守恒263
C14.4 解题范例265
C14.5 应用：中子星271
两分钟测试273
习题274
习题答案277
专业术语279
符号及其含义289
关于N单元的几点说明（中文）
学生学习指导（英文）
第N1章
牛顿定律298
本章概览298
N1.1 牛顿定律综述300
N1.2 牛顿第一定律302
N1.3 牛顿第三定律303
N1.4 牛顿第二定律304
N1.5 力的分类307
N1.6 自由落体图像309
两分钟测试310
习题312
习题答案313
第N2章
矢量微积分314
本章概览314
N2.1 矢量的时间导数316
N2.2 速度的定义317
N2.3 加速度的定义320
N2.4 运动图像322
N2.5 运动图像的数值解326
N2.6 匀速圆周运动327
两分钟测试330
测试答案333
第N3章
由运动量求力334
本章概览334
N3.1 运动链336
N3.2 受力图336
N3.3 定性的实例337
N3.4 第三定律和第二定律对儿342
N3.5 作用力与反作用力343
N3.6 一维运动图像344
N3.7 定量的实例347
两分钟测试348
测试答案352
第N4章
由力求运动量354
本章概览354
N4.1 逆向运动链356
N4.2 图像化的不定积分356
N4.3 一维运动积分358
N4.4 一维自由落体运动362
N4.5 三维运动积分363
N4.6 建立轨迹图像365
N4.7 牛顿程序367
两分钟测试369
习题370
习题答案372
第N5章
静力学374
本章概览374
N5.1 运动中的力：概览376
N5.2 静力学概论376
N5.3 涉及转矩的静力学问题377
N5.4 运动中的力问题求解380
N5.5 静力学问题求解382
两分钟测试386
习题387
习题答案389
第N6章
直线运动390
本章概览390
N6.1 自由粒子图像392
N6.2 匀速运动393
N6.3 静摩擦力和动摩擦力394
N6.4 阻力399
N6.5 直线加速运动400
N6.6 约束运动求解步骤401
两分钟测试404
习题405
习题答案407
第N7章
物体的耦合408
本章概览408
N7.1 耦合力的标记410
N7.2 推动连接的块体412
N7.3 弦，真实情况和理想情况414
N7.4 滑轮418
N7.5 解题步骤应用418
两分钟测试420
习题421
习题答案424
第N8章
圆周运动426
本章概览426
N8.1 匀速圆周运动428
N8.2 方向430
N8.3 变速圆周运动431
N8.4 弯道与倾斜433
N8.5 实例436
两分钟测试439
习题441
习题答案443
第N9章
非惯性参考系444
本章概览444
N9.1 虚拟力446
N9.2 伽利略变换446
N9.3 惯性参考系450
N9.4 直线加速参考系452
N9.5 转动加速参考系454
N9.6 虚拟力的应用455
N9.7 自由落体参考系和重力457
两分钟测试459
习题460
习题答案462
第N10章
抛体运动464
本章概览464
N10.1 重力和抛体运动466
N10.2 简单抛体运动467
N10.3 一些基本特性469
N10.4 抛体运动解题框架470
N10.5 阻力和极限速度474
两分钟测试476
习题477
习题答案480
第N11章
振动482
本章概览482
N11.1 弹簧振子系统484
N11.2 求解运动方程485
N11.3 谐振子模型488
N11.4 弹簧悬挂系统489
N11.5 与圆周运动类比491
N11.6 单摆493
两分钟测试495
习题496
习题答案498
第N12章
轨道概论500
本章概览500
N12.1 开普勒定律502
N12.2 绕大质量主星的轨道503
N12.3 开普勒第二定律505
N12.4 圆轨道和开普勒第三定律506
N12.5 圆轨道问题508
N12.6 黑洞和暗物质513
两分钟测试515
习题515
习题答案517
第N13章
行星运动518
本章概览518
N13.1 椭圆和双曲线520
N13.2 轨道的轨迹图像523
N13.3 守恒定律和轨道527
N13.4 求解轨道问题529
两分钟测试532
习题533
习题答案535
附录NA
微分537
NA.1 导数537
NA.2 一些有用的规则537
NA.3 导数和斜率539
NA.4 链式法则539
NA.5 其他函数的导数540
习题541
习题答案541
附录NB
积分542
NB.1 不定积分542
NB.2 定积分542
NB.3 基本定理543
NB.4 不定积分544
NB.5 变量替换法545
习题546
习题答案546
专业术语547
元素周期表553
符号及其含义554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>六大思想构建物理学·第1卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第一篇  学习辅导  第1章  绪论    1.1 本章导学    1.2 重点难点释疑      1.2.1 信息、数据与结构      1.2.2 数据结构、数据类型和抽象数据类型      1.2.3 逻辑结构与存储结构      1.2.4 如何选择或设计数据结构      1.2.5 算法设计的一般原则      1.2.6 算法的时间复杂度分析    1.3 习题解析      1.3.1 课后习题讲解      1.3.2 学习自测及答案  第2章  线性表    2.1 本章导学    2.2 重点难点释疑      2.2.1 存储结构与存取结构      2.2.2 头指针、尾标志、开始结点与头结点      2.2.3 带头结点的单链表与不带头结点的单链表的比较      2.2.4 单链表算法的设计技巧      2.2.5 有序单链表的算法设计技巧      2.2.6 循环链表的算法设计技巧    2.3 习题解析      2.3.1 课后习题讲解      2.3.2 学习自测及答案  第3章  栈和队列    3.1 本章导学    3.2 重点难点释疑      3.2.1 浅析栈的操作特性      3.2.2 递归算法转换为非递归算法      3.2.3 循环队列中队空和队满的判定方法    3.3 习题解析      3.3.1 课后习题讲解      3.3.2 学习自测及答案  第4章  字符串和多维数组    4.1 本章导学    4.2 重点难点释疑      4.2.1 kmp算法中如何求next数组      4.2.2 特殊矩阵压缩存储后存储位置的计算    4.3 习题解析      4.3.1 课后习题讲解      4.3.2 学习自测及答案  第5章  树和二叉树    5.1 本章导学    5.2 重点难点释疑      5.2.1 二叉树和树是两种不同的树结构      5.2.2 二叉树的构造方法      5.2.3 二叉树遍历的递归实现图解      5.2.4 二叉树的算法设计技巧      5.2.5 哈夫曼树的构造过程中应注意的问题    5.3 习题解析      5.3.1 课后习题讲解      5.3.2 学习自测及答案  第6章  图    6.1 本章导学    6.2 重点难点释疑      6.2.1 深度优先遍历算法的非递归实现      6.2.2 图的遍历算法的应用      6.2.3 有向图的强连通分量      6.2.4 改进的拓扑排序算法    6.3 习题解析      6.3.1 课后习题讲解      6.3.2 学习自测及答案  第7章  查找技术    7.1 本章导学    7.2 重点难点释疑      7.2.1 折半查找判定树及其应用      7.2.2 时空权衡      7.2.3 平衡二叉树的调整方法      7.2.4 散列查找的性能分析    7.3 习题解析      7.3.1 课后习题讲解      7.3.2 学习自测及答案  第8章  排序技术    8.1 本章导学    8.2 重点难点释疑      8.2.1 排序算法的稳定性      8.2.2 如何将排序算法移植到单链表上      8.2.3 二叉排序树与堆的区别      8.2.4 递归算法的时间性能分析    8.3 习题解析      8.3.1 课后习题讲解      8.3.2 学习自测及答案  第9章  索引技术    9.1 本章导学    9.2 习题解析      9.2.1 课后习题讲解      9.2.2 学习自测及答案第二篇  实验指  第10章  基础实验    10.1 实验的一般步骤      10.1.1 概述      10.1.2 验证实验的一般步骤      10.1.3 设计实验和综合实验的一般步骤    10.2 VC++编程工具的使用      10.2.1 控制台程序      10.2.2 单文件结构      10.2.3 多文件结构      10.2.4 程序的调试  第11章  线性表实验    11.1 验证实验      11.1.1 顺序表的实现      11.1.2 单链表的实现    11.2 设计实验      11.2.1 约瑟夫环问题      11.2.2 用单链表实现集合的操作    11.3 综合实验      11.3.1 大整数的代数运算      11.3.2 一元多项式相加  第12章  栈和队列实验    12.1 验证实验      12.1.1 顺序栈的实现      12.1.2 链队列的实现    12.2 设计实验      12.2.1 汉诺塔问题      12.2.2 火车车厢重排问题    12.3 综合实验      12.3.1 表达式求值      12.3.2 迷宫问题  第13章  字符串和多维数组实验    13.1 验证实验      13.1.1 串操作的实现      13.1.2 对称矩阵的压缩存储    13.2 设计实验      13.2.1 统计文本中单词的个数      13.2.2 幻方    13.3 综合实验      13.3.1 近似串匹配      13.3.2 数字旋转方阵  第14章  树和二叉树实验    14.1 验证实验      14.1.1 二叉树的实现      14.1.2 树的实现    14.2 设计实验      14.2.1 求二叉树中叶子结点的个数      14.2.2 二叉表示树    14.3 综合实验      14.3.1 信号放大器      14.3.2 哈夫曼算法的应用  第15章  图实验    15.1 验证实验      15.1.1 邻接矩阵的实现      15.1.2 邻接表的实现    15.2 设计实验      15.2.1 TSP问题      15.2.2 哈密顿路径    15.3 综合实验      15.3.1 农夫过河      15.3.2 医院选址问题  第16章  查找技术实验    16.1 验证实验      16.1.1 顺序查找的实现      16.1.2 折半查找的实现      16.1.3 散列查找的实现    16.2 设计实验      16.2.1 二叉排序树的查找性能      16.2.2 闭散列表和开散列表查找性能的比较    16.3 综合实验      16.3.1 个人电话号码查询系统      16.3.2 斐波那契查找  第17章  排序技术实验    17.1 验证实验      17.1.1 插入排序算法的实现      17.1.2 交换排序算法的实现      17.1.3 选择排序算法的实现    17.2 设计实验      17.2.1 直接插入排序基于单链表的实现      17.2.2 双向起泡排序    17.3 综合实验      17.3.1 各种排序算法时间性能的比较      17.3.2 机器调度问题附录A  实验报告的一般格式附录B  课程设计报告的一般格式参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MATLAB数字图像处理
目录
第1章MATLAB基本操作
1.1矩阵操作与运算
1.1.1在MATLAB中生成矩阵
1.1.2矩阵变形操作
1.1.3矩阵的下标引用
1.1.4获取当前矩阵信息
1.1.5矩阵运算
1.1.6矩阵关系比较
1.1.7矩阵元素值取整
1.1.8对矩阵进行逻辑运算
1.1.9矩阵分解
1.1.10查找矩阵中的最值
1.1.11查找矩阵中的元素
1.2MATLAB编程基础
1.2.1变量命名规则及其类型
1.2.2基本程序结构
1.2.3M文件
1.2.4函数句柄与匿名函数
1.2.5MATLAB编程技巧
1.3基于Simulink的仿真
1.3.1什么是Simulink
1.3.2Simulink模块库介绍
1.3.3创建一个简单的Simulink示例
1.3.4对模块进行基本操作
1.3.5信号线的操作
第2章Visual Studio 2010使用入门
2.1Visual Studio 2010简介
2.2安装流程
2.3Visual Studio语言
2.4编写一个“HelloWorld”程序
2.5访问MSDN论坛
2.6Visual Studio 2010中的应用程序开发
2.6.1管理解决方案、项目和文件
2.6.2编辑代码和资源文件
2.6.3解决方案生成和调试
第3章基于MATLAB Coder的M代码转换成C／C++代码
3.1启动MATLAB Coder
3.2MATLAB Coder使用典型实例
3.2.1把M文件转换为C程序代码
3.2.2将生成的代码在VS 2010中实现
3.2.3生成特定硬件可以运行的代码
3.2.4通过命令实现C代码的生成
第4章MATLAB计算机视觉工具箱
4.1数字图像处理基础
4.1.1什么是数字图像
4.1.2数字图像处理的基本概念
4.1.3数字图像的矩阵表示
4.2MATLAB数字图像处理基本操作
4.2.1图像文件的读取
4.2.2图像文件的写入（保存）
4.2.3图像文件的显示
4.2.4图像文件信息的查询
4.2.5MATLAB中的图像类型
4.3基于系统对象（System Object）编程
4.4计算机视觉系统工具箱及其功能模块介绍
4.4.1概述
4.4.2各功能模块介绍
第5章图像变换的仿真及其C／C++代码的自动生成
5.1图像缩放变换
5.1.1基本原理
5.1.2基于System Object的仿真
5.1.3基于Blocks—Simulink的仿真
5.1.4C／C++代码的自动生成及其运行效果
5.2图像的平移变换
5.2.1基本原理
5.2.2基于System Object的仿真
5.2.3基于Blocks—Simulink的仿真
5.2.4C／C++代码自动生成及运行效果
5.3图像的旋转变换
5.3.1基本原理
5.3.2基于System Object的仿真
5.3.3基于Blocks—Simulink的仿真
5.3.4C／C++代码自动生成及运行效果
5.4图像的傅里叶变换
5.4.1基本原理
5.4.2基于System Object的仿真
5.4.3基于Blocks—Simulink的仿真
5.4.4C／C++代码自动生成及运行效果
5.5图像的余弦变换
5.5.1基本原理
5.5.2基于System Object的仿真
5.5.3基于Blocks—Simulink的仿真
5.5.4C／C++代码自动生成及运行效果
5.6图像腐蚀、膨胀
5.6.1基本原理
5.6.2基于System Object的仿真
5.6.3基于Blocks—Simulink的仿真
5.6.4C／C++代码自动生成及运行效果
5.7图像的开运算、闭运算
5.7.1基本原理
5.7.2基于System Object的仿真
5.7.3基于Blocks—Simulink的仿真
5.7.4C／C++代码自动生成及运行效果
5.8图像的中值滤波
5.8.1基本原理
5.8.2基于System Object的程序实现
5.8.3基于Blocks—Simulink的仿真
5.8.4C／C++代码自动生成及运行效果
5.9图像的金字塔分解
5.9.1基本原理
5.9.2基于System Object的仿真
5.9.3基于Blocks—Simulink的仿真
5.9.4C／C++代码自动生成及运行效果
第6章图像特征提取的仿真及其C／C++代码的生成
6.1图像的灰度直方图
6.1.1基本原理
6.1.2基于System Object的仿真
6.1.3基于Blocks—Simulink的仿真
6.1.4C／C++代码自动生成及运行效果
6.2图像的色彩空间
6.2.1常见的色彩空间
6.2.2基于System Object的仿真
6.2.3基于Blocks—Simulink的仿真
6.2.4C／C++代码自动生成及运行效果
6.3图像的角点检测
6.3.1角点检测的基本原理
6.3.2基于System Object的仿真
6.3.3基于Blocks—Simulink的仿真
6.3.4C／C++代码自动生成及运行效果
6.4图像的边缘检测
6.4.1基本原理
6.4.2基于System Object的仿真
6.4.3基于Blocks—Simulink的仿真
6.4.4C／C++代码自动生成及运行效果
6.5图像的信噪比
6.5.1基本原理
6.5.2基于System Object的仿真
6.5.3基于Blocks—Simulink的仿真
6.5.4C／C++代码自动生成及运行效果
兴趣·尝试·总结——浅谈学习Computer Vision System Toolbox心得
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MATLAB数字图像处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Arduino编程从零开始
第1章  Arduino介绍  1
1.1  微控制器  1
1.2  Arduino开发板的探索之旅  3
1.2.1  电源接口  4
1.2.2  供电接口  4
1.2.3  模拟输入接口  4
1.2.4  数字接口  5
1.2.5  微控制器  5
1.2.6  其他元件  6
1.3  Arduino的起源  7
1.4  Arduino家族  8
1.4.1  Uno和Leonardo  9
1.4.2  Mega和Due  9
1.4.3  微型和小型Arduino开发板  10
1.4.4  Yun  11
1.4.5  Lilypad  12
1.4.6  其他“官方”开发板  12
1.5  Arduino复制品和变型  13
1.6  本章小结  13
第2章  启程  15
2.1  上电  15
2.2  安装软件  16
2.3  上传你的第一个项目  16
2.4 Arduino应用程序  21
2.5  本章小结  23
第3章  C语言基础  25
3.1  编程  25
3.2  什么是编程语言？  27
3.3  Blink——再来一次！  31
3.4  变量  33
3.5  C语言实验  35
3.6  数值变量和算术运算符  36
3.7  控制语句  39
3.7.1  if语句  39
3.7.2  for语句  41
3.7.3  while语句  44
3.8  常量  45
3.9  本章小结  45
第4章  函数  47
4.1  什么是函数？  47
4.2  参数  48
4.3  全局变量、局部变量和静态变量  50
4.4  返回值  53
4.5  其他变量类型  54
4.5.1  float(浮点型)  54
4.5.2  boolean(布尔型)  55
4.5.3  其他数据类型  56
4.6  代码风格  58
4.6.1  缩进  58
4.6.2  花括号  59
4.6.3  空白  60
4.6.4  注释  60
4.7  本章小结  62
第5章  数组和字符串  63
5.1  数组  63
5.2  字符串  67
5.2.1  字符串常量  68
5.2.2  字符串变量  69
5.3  摩尔斯电码转换器  70
5.3.1  数据  71
5.3.2  全局变量和setup函数  72
5.3.3  loop函数  72
5.3.4 flashSequence函数  75
5.3.5 flashDotOrDash函数  76
5.3.6  整合  77
5.4  本章小结  79
第6章  输入和输出  81
6.1  数字输出  81
6.2  数字输入  85
6.2.1  上拉电阻  85
6.2.2  内部上拉电阻  88
6.2.3  防抖动  89
6.3  模拟输出  94
6.4  模拟输入  96
6.5  本章小结  98
第7章  Arduino标准类库  99
7.1  随机数  99
7.2  数学函数  102
7.3  位操作  103
7.4  高级I/O  105
7.4.1  生成音调  105
7.4.2  移位寄存器  107
7.4.3  中断  107
7.5  本章小结  109
第8章  数据存储  111
8.1  常量  111
8.2  将数据存储在闪存中  112
8.3  EEPROM  114
8.3.1  在EEPROM中存储整数  116
8.3.2  使用AVR EEPROM库  117
8.3.3  在EEPROM中存储浮点数  118
8.3.4  在EEPROM中存储字符串  118
8.3.5  清除EEPROM的内容  120
8.4  压缩  121
8.5  本章小结  122
第9章  显示器  123
9.1  字母数字LCD显示器  124
9.2  USB留言板  125
9.3  使用显示器  127
9.4  其他LCD库函数  128
9.5  OLED图形显示器  128
9.6  连接OLED显示器  129
9.7  软件  130
9.8  本章小结  132
第10章  Arduino物联网程序设计  133
10.1 与Web服务器通信  134
10.1.1  HTTP  134
10.1.2  HTML  134
10.2 将Arduino Uno作为Web服务器  136
10.3 网络控制的Arduino  139
10.4 Node MCU Web服务器  145
10.5 网络控制的Node MCU  150
10.6 呼叫Web服务器  153
10.7 Arduino Uno和IFTTT  156
10.8 Node MCU ESP8266开发板和IFTTT  158
10.9 其他物联网选择  160
10.9.1  Arduino Yun  160
10.9.2  ParticlePhoton  161
10.10 本章小结  161
第11章  C 和库  163
11.1 面向对象  163
11.2 内置库示例  164
11.3 编写自己的库  165
11.3.1  头文件  165
11.3.2  实现文件  166
11.3.3  完成你的库  167
11.3.4  关键字  168
11.3.5  示例  168
11.4 本章小结  171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Arduino编程从零开始
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
第1章  为什么要学C语言  1.1 引言  1.2 游戏、黑客和C语言  1.3 C语言，不老的传说  1.4 C语言的爱与恨  1.5 C语言教给我们的事  1.6 什么是“编程”  1.7 本章小结  习题1第2章  C数据类型  ……第3章  简单的算术运算和表达式第4章  键盘输入和屏幕输出第5章  选择控制结构第6章  循环控制结构第7章  函数第8章  数组第9章  指针第10章  字符串第11章  指针和数组第12章  结构体和共用体第13章  文件操作附录A  C关键字附录B  Visual C++下基本数据类型的取值范围附录C  C运算符的优先级与结合性附录D  常用字符与ASCII值对照表参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计
第1章　计算机和C++编程入门第2章　C++基础知识第3章　更多的控制流程第4章　过程抽象和返回值的函数第5章　所有子任务的函数第6章　I/O流——对象和类入门第7章　数组第8章　字符串和向量第9章　指针和动态数组第10章　定义类第11章　类中的友元函数、重载操作符和数组第12章　独立编译和命名空间第13章　指针和链表第14章　递归第15章　继承第16章　异常处理第17章　模板第18章　标准模板库附录1  C++关键宇附录2  操作符的优先级附录3  ASCII字符集附录4  部分库函数附录5  内联函数附录6  重载数组索引方括号附录7  this指针附录8  将操作符重载为成员操作符
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C++程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计基础实验与题解
第1部分　实验　实验一　顺序结构程序设计　实验二　选择结构程序设计　实验三　循环结构程序设计（一）　实验四　循环结构程序设计（二）　实验五　一维数组　实验六　二维数组　实验七　函数（一）　实验八　函数（二）　实验九　指针（一）　实验十　指针（二）　实验十一　结构与联合　实验十二　文件第2部分　习题　第1章　顺序结构程序设计　第2章　选择结构　第3章　循环结构　第4章　数组　第5章 函数　第6章　指针　第7章　结构体　第8章　文件　第3部分　测试题　　测试题一　测试题二附录A 习题答案　第1章　顺序结构程序设计　第2章　选择结构　第3章　循环结构　第4章　数组　第5章　函数　第6章　指针　第7章　结构体　第8章　文件附录B　测试题答案  测试题一参考答案  测试题二参考答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计基础实验与题解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>学C编程也可以卡通一点
第1章 变量 / 001
1．1 变量的由来 / 001
1．2 创建变量 / 003
1．3 变量赋值 / 004
1．4 变量运算 / 005
1．5 定义变量的技巧 / 006
1．6 代码与程序的关系 / 007
1．7 变量的类型 / 010
第2章 变量与内存的关系 / 012
2．1 变量与内存的关系 / 012
第3章 输入与输出 / 025
3．1 程序的输入输出 / 025
3．2 输入的详细说明 / 032
3．3 输出的详细说明 / 034
第4章 编译 / 036
4．1 如何选择编程软件 / 036
4．2 编译是什么(这是一篇水贴) / 041
4．3 个完整的程序 / 043
第5章 函数 / 045
5．1 函数的介绍 / 045
5．2 头文件和函数库 / 049
第6章 判断语句 / 052
6．1 关系预算符 / 052
6．2 布尔变量 / 060
6．3 if语句-卖瓜的老汉 / 063
6．4 if语句-卖冰棍的逻辑 / 071
6．5 习题答案 / 080
第7章 循环语句 / 081
7．1 for循环 / 083
7．2 while循环-邪恶的计划 / 094
7．3 while循环-宝藏 / 104
7．4 习题答案 / 110
第8章 数组 / 112
8．1 数组的定义 / 112
8．2 数组的序号 / 115
8．3 数组的操作 / 118
8．4 数组与循环 / 124
8．5 二维数组和多维数组 / 126
第9章 编程语言介绍 / 133
9．1 编程语言，我将如何选择 / 133
9．2 上部分结束 / 145
第10章 指针 / 146
10．1 指针变量简介 / 146
10．2 指针—的指针 / 151
10．3 指针变量的作用 / 154
10．4 指针的操作 / 156
10．5 指针与数组 / 160
第11章 内存与变量 / 166
11．1 动态变量 / 166
11．2 动态变量产生的原因 / 177
11．3 动态变量的例子 / 178
第12章 结构体 / 180
12．1 结构体的由来 / 180
12．2 结构体介绍 / 184
12．3 链表的实现 / 185
12．4 结构体与面向对象 / 194
谢幕 / 198
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>学C编程也可以卡通一点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Q版漫画技法从入门到精通
前言
序章
Q版就是写实人物的可爱造型
给熟悉的漫画角色绘制Q版形象
Q版人物也有饱满的立体感
服装是Q版角色辨识的一大要素
第1章　初步认识Q版人物
动漫界的Q版明星
Q版人物的类型划分
Q版人物的头身比范围
亲手绘制一个可爱的Q角色
第2章　刻画超Q的脸部
01 从正常版到Q版的脸有哪些变化
02 Q版角色的脸型
包子脸是圆脸的抽象变形
其他风格化的脸型为Q版角色增添个性
03 抓住Q版人物的五官特点
眼睛的变形是塑造角色的关键
容易被忽略的鼻子
用简单的线条和形状表现嘴巴
简化耳朵的复杂构造
04 Q版人物发型的绘制方法
头发要从发旋开始画
绘制头发的四要素
发型的梳理
佩戴饰品的头发
通过发型提升角色的个性
第3章　Q版人物的表情描绘
01 几种常见表情的Q版画法
喜悦的表情描绘
愤怒的表情描绘
悲伤的表情描绘
惊讶的表情描绘
尴尬的表情描绘
害羞的表情描绘
其他表情描绘
02 表情中的夸张表现
眼睛在不同表情中的夸张
嘴巴在不同表情中的夸张
03 Q版表情的搞笑表现
04 Q版人物的表情符号
用符号来代替五官
添加面部特效使表情更加生动
第4章
如何绘制Q版人物的身体
01 Q版人物身体各部分的比例
2头身的比例
25头身的比例
3头身的比例
35头身的比例
4头身的比例
02 身体各部位的变形
脖子变细或省略
弱化关节和性别特征
粗短是Q版手部的特点
各头身Q版脚部的区别
头身比越小变形越大
03 Q版人物的身体透视
俯视多用于表现人物的动感和造型
仰视多用于表现人物的气势和情绪
局部极端透视使人物更有特色
04 不同年龄段的Q版人物
婴幼儿的绘制
……
第5章　Q版人物的动态表现与省略
第6章　Q版的人物造型
第7章　Q版的小道具绘制
第8章　Q版动物的绘制
第9章　把Q版角色放到场景中去
第10章　Q版单幅漫画的构思要点
第11章　Q版的上色实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Q版漫画技法从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你這個娘炮
【推薦序】我的異男養成記：陽剛、恐同與「登大人」／王宏仁
新版作者序
謝誌
【第一章】打造陽剛氣質：青少年、身分認同和高中
阿宅的復仇
所謂的陽剛氣質，是什麼意思？
把性相帶進來
重新思考陽剛氣質、性相和身體
論方法
本書編排
【第二章】成為美洲獅先生：川中怎麼把異性戀和陽剛氣質化為制度？
川中的性別和性相課程
教學有道：非正式的性別與性相課程
學校儀式：展演與管治性別和性相
性別與性相的綱常
【第三章】欸，你這個娘炮：青少年男性的恐同心態
什麼是娘炮？因性別而不同的意義
成為娘炮：娘炮會流動
化身娘炮：瑞奇的故事
娘炮分種族
娘炮在此消失：戲劇表演
重新框定恐同心態
【第四章】扮異性戀扮到欲罷不能：陽剛氣質與支配
姐妹眼中的男神
把妹
觸碰
聊色
女孩的回應
我跟其他渣男不一樣
女性是人偶
【第五章】看我多陽剛！舉止像男孩的女孩
男人婆的過去
瑞貝卡和籃球女孩
返校節皇后：周傑西
同直盟女孩
陽剛氣質化於身
【第六章】結論：思考學校教育、性別與性相
陽剛氣質在川中
理論的內蘊
務實的措施
【附錄】有男生想撩你怎麼辦？在青少年的田野工作中，性別、性相與年齡的交織
注釋
參考書目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你這個娘炮
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C 2.0程序设计
译者序
作者简介
技术审校人员简介
第1章 前言
1.1 本书的内容
1.2 本书的组织方式
1.3 致谢
第1部分 objective-c语言
第2章 objective-c程序设计
2.1 编译并运行程序
2.1.1 使用xcode
2.1.2 使用terminal
2.2 解释第一个程序
2.3 显示变量的值
2.4 小结
2.5 练习
第3章 类、对象和方法
3.1 到底什么是对象
3.2 实例和方法
3.3 用于处理分数的objective-c类
.3.4 @interface部分
3.4.1 选择名称
3.4.2 实例变量
3.4.3 类和实例方法
3.5 @implementation部分
3.6 program部分
3.7 实例变量的访问以及数据封装
3.8 小结
3.9 练习
第4章 数据类型和表达式
4.1 数据类型和常量
4.1.1 int类型
4.1.2 float类型
4.1.3 double类型
4.1.4 char类型
4.1.5 限定词：long、long long、short、unsigned及signed
4.1.6 id类型
4.2 算术表达式
4.2.1 运算符的优先级
4.2.2 整数运算和一元负号运算符
4.2.3 模运算符
4.2.4 整型值和浮点值的相互转换
4.2.5 类型转换运算符
4.3 赋值运算符
4.4 计算器类
4.5 位运算符
4.5.1 按位与运算符
4.5.2 按位或运算符
4.5.3 按位异或运算符
4.5.4 一次求反运算符
4.5.5 向左移位运算符
4.5.6 向右移位运算符
4.6 类型：_bool、_complex和_imaginary
4.7 练习
第5章 循环结构
5.1 for语句
5.1.1 键盘输入
5.1.2 嵌套的for循环
5.1.3 for循环的变形
5.2 while语句
5.3 do语句
5.4 break语句
5.5 continue语句
5.6 小结
5.7 练习
第6章 选择结构
6.1 if语句
6.1.1 if-else结构
6.1.2 复合条件测试
6.1.3 嵌套的if语句
6.1.4 else if结构
6.2 switch语句
6.3 boolean变量
6.4 条件运算符
6.5 练习
第7章 类
7.1 分离接口和实现文件
7.2 合成存取器方法
7.3 使用点运算符访问属性
7.4 具有多个参数的方法
7.4.1 不带参数名的方法
7.4.2 关于分数的操作
7.5 局部变量
7.5.1 方法的参数
7.5.2 static关键字
7.6 self关键字
7.7 在方法中分配和返回对象
7.8 练习..
第8章 继承
8.1 一切从根类开始
8.2 通过继承扩展—添加新方法
8.2.1 point类和内存分配
8.2.2 @class指令
8.2.3 具有对象的类
8.3 重载方法
8.3.1 择哪个方法
8.3.2 重载dealloc方法和关键字super
8.4 通过继承扩展：添加新的实例变量
8.5 抽象类
8.6 练习
第9章 多态、动态类型和动态绑定
9.1 多态：相同的名称，不同的类
9.2 动态绑定和id类型
9.3 编译时和运行时检查
9.4 id数据类型与静态类型
9.5 有关类的问题
9.6 使用@try处理异常
9.7 练习
第10章 变量和数据类型
10.1 类的初始化
10.2 作用域回顾
10.2.1 控制实例变量作用域的指令
10.2.2 外部变量
10.2.3 静态变量
10.3 存储类说明符
10.3.1 auto
10.3.2 const
10.3.3 volatile
10.4 枚举数据类型
10.5 typedef语句
10.6 数据类型转换
10.6.1 转换规则
10.6.2 符号扩展
10.7 练习
第11章 分类和协议
11.1 分类
11.2 协议
11.3 合成对象
11.4 练习
第12章 预处理程序
12.1 ＃define语句
12.1.1 更高级的定义类型
12.1.2 #运算符
12.1.3 ##运算符
12.2 #import语句
12.3 条件编译
12.3.1 #ifdef、#endif、#else和#ifndef语句
12.3.2 #if和#elif预处理程序语句
12.3.3 #undef语句
12.4 练习
第13章 基本的c语言特性
13.1 数组
13.1.1 数组元素的初始化
13.1.2 字符数组
13.1.3 多维数组
13.2 函数
13.2.1 参数和局部变量
13.2.2 函数的返回结果
13.2.3 函数、方法和数组
13.3 结构
13.3.1 结构的初始化
13.3.2 结构数组
13.3.3 结构中的结构
13.3.4 关于结构的补充细节
13.3.5 不要忘记面向对象编程思想
13.4 指针
13.4.1 指针和结构
13.4.2 指针、方法和函数
13.4.3 指针和数组
13.4.4 指针运算
13.4.5 指针和内存地址
13.5 联合
13.6 它们不是对象
13.7 其他语言特性
13.7.1 compound literal
13.7.2 goto语句
13.7.3 空语句
13.7.4 逗号运算符
13.7.5 sizeof运算符
13.7.6 命令行参数
13.8 工作原理
事实#1：实例变量存储在结构中
事实#2：对象变量实际上是指针
事实#3：方法是函数，而消息表达式是
函数调用
事实#4：id类型是通用指针类型
13.9 练习
第二部分 foundation框架
第14章 foundation框架简介
第15章 数字、字符串和集合
15.1 数字对象
15.2 字符串对象
15.2.1 nslog函数
15.2.2 可变对象与不可变对象
15.2.3 可变字符串
15.2.4 所有对象到哪里去了
15.3 数组对象
15.4 同步addresscard方法
15.4.1 快速枚举
15.4.2 数组排序
15.5 词典对象
15.6 集合对象
15.7 练习
第16章 使用文件
16.1 管理文件和目录：nsfilemanager
16.1.1 使用nsdata类
16.1.2 使用目录
16.1.3 枚举目录中的内容
16.2 使用路径：nspathutilities.h
16.2.1 常用的路径处理方法
16.2.2 复制文件和使用nsprocessinfo类
16.3 基本的文件操作：nsfilehandle
16.4 练习
第17章 内存管理
17.1 自动释放池
17.2 引用计数
17.2.1 引用计数和字符串
17.2.2 引用计数与实例变量
17.3 自动释放池示例
17.4 内存管理规则摘要
17.5 垃圾回收
17.6 练习
第18章 复制对象
18.1 copy和mutablecopy方法
18.2 浅复制与深复制
18.3 实现[nscopying]协议
18.4 用赋值方法和取值方法复制对象
18.5 练习
第19章 归档
19.1 使用xml属性列表进行归档
19.2 使用nskeyedarchiver归档
19.3 编码方法和解码方法
19.4 使用nsdata创建自定义档案
19.5 使用归档程序复制对象
19.6 练习
第三部分 cocoa和iphone sdk
第20章 cocoa简介
20.1 框架层
20.2 接触cocoa
第21章 编写iphone应用程序
21.1 iphone sdk
21.2 第一个iphone应用程序
21.2.1 创建新的iphone应用程序项目
21.2.2 输入代码
21.2.3 设计界面
21.3 iphone分数计算器
21.3.1 启动新的fraction_calculator项目
21.3.2 定义视图控制器
21.3.3 fraction类
21.3.4 处理分数的calculator类
21.3.5 设计ui
21.4 小结
21.5 练习
第四部分 附录
附录a 术语表
附录b objective-c 2.0语言概览
附录c 地址簿源代码
附录d 资源
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C 2.0程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PIC16F87X单片机实用软件与接口技术
第1章 PICC C语言基础和特点
第2章 PICC的使用
第3章 PICC的库函数
第4章 PIC16F877单片机实验板介绍
第5章 PIC16F877的外围功能模块
第6章 模拟量输入与输出
第7章 秒表
第8章 通用同步/异步通信的应用
第9章 PIC16F87X在CAN通信中的应用
第10章 利用CCP模块设计频率计
第11章 交流电压测量
第12章 与PLC接口的4位LED数字显示表
第13章 数控步进直流稳压电源
第14章 单片机控制的电动自行车驱动系统
第15章 液晶显示模块编程
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PIC16F87X单片机实用软件与接口技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ATmega16单片机项目驱动教程
准备知识1 AVR单片机最小硬件系统设计与制作  1.1 ATmega16芯片及引脚认识  1.2 复位电路的设计  1.3 晶振电路的设计  1.4 AD转换滤波电路的设计  1.5 串口电平转换电路的设计  1.6 I/O端口输出  1.7 JTAG仿真接口电路的设计  1.8 电源电路的设计  1.9 ATmega16单片机最小硬件系统实物准备知识2 ICCAVR与AVRStudio快速入门  2.1 ICCAVR开发编译环境快速入门  2.2 AVRStudio下载调试工具快速入门准备知识3 Proteus仿真软件快速入门  任务一 ATmega16单片机的I/O端口应用    项目1 多功能8位LED跑马灯设计    项目1.1 项目方案设计    项目1.2 项目所用知识点介绍    项目1.3 跑马灯硬件电路设计    项目1.4 跑马灯软件设计    项目1.5 跑马灯仿真与验证    项目1.6 独立式键盘硬件电路设计    项目1.7 独立式键盘软件设计    项目1.8 项目硬件制作与调试    项目2 多功能数码管显示器设计    项目2.1 项目方案设计    项目2.2 项目所用知识点介绍    项目2.3 项目硬件电路设计    项目2.4 项目软件设计    项目2.5 项目仿真与验证    项目2.6 项目硬件制作与调试    项目3 多功能1602液晶显示器设计    项目3.1 项目方案设计    项目3.2 项目所用知识点介绍    项目3.3 项目硬件电路设计    项目3.4 项目软件设计    项目3.5 项目仿真与验证    项目3.6 项目硬件制作与调试  任务二 ATmega16的定时器1及外部中断使用    项目4 能校准的电子时钟设计    项目4.1 项目方案设计    项目4.2 项目所用知识点介绍    项目4.3 项目硬件电路设计    项目4.4 项目软件设计    项目4.5 项目仿真与验证    项目4.6 项目硬件制作与调试    项目5 基于PWM波形的LED调光设计    项目5.1 项目方案设计    项目5.2 项目硬件电路设计    项目5.3 项目软件设计    项目5.4 项目仿真与验证    项目5.5 项目硬件制作与调试    项目6 流水线自动分装系统开发与设计    项目6.1 项目方案设计    项目6.2 项目所用知识点介绍    项目6.3 项目驱动程序设计    项目6.4 项目仿真与验证    项目6.5 项目硬件制作与调试  任务三 ATmega16单片机的A/D转换模块应用    项目7 简易数字电压表设计    项目7.1 项目方案设计    项目7.2 项目所用知识点介绍    项目7.3 项目硬件电路设计    项目7.4 项目软件设计    项目7.5 项目仿真与验证    项目7.6 项目硬件制作与调试    项目8 基于AD590的温度计设计    项目8.1 项目方案设计    项目8.2 项目所用知识点介绍    项目8.3 项目硬件电路设计    项目8.4 项目软件设计    项目8.5 项目仿真与验证    项目8.6 项目硬件制作与调试  任务四 ATmega16单片机的USART模块应用    项目9 窗口评价器设计    项目9.1 项目方案设计    项目9.2 项目所用知识点介绍    项目9.3 项目硬件电路设计    项目9.4 项目软件设计    项目9.5 项目仿真与验证    项目9.6 项目硬件制作与调试    项目10 基于GPS模块的信号接收器设计    项目10.1 项目方案设计    项目10.2 项目所用知识点介绍    项目10.3 项目硬件电路设计    项目10.4 项目软件设计    项目10.5 项目仿真与验证    项目10.6 项目硬件制作与调试  任务五 ATmega16单片机的TWI总线应用    项目11 基于AT24C08的电子密码锁的设计与制作    项目11.1 项目方案设计    项目11.2 项目所用知识点介绍    项目11.3 项目硬件电路设计    项目11.4 项目软件设计    项目11.5 项目仿真与验证    项目11.6 项目硬件制作与调试    项目12 基于PCF8563的电子时钟的设计与制作    项目12.1 项目方案设计    项目12.2 项目所用知识点介绍    项目12.3 项目硬件电路设计    项目12.4 项目软件设计    项目12.5 项目仿真与验证    项目12.6 项目硬件制作与调试附录  附录A 任务一考核答辩题  附录B 任务二考核答辩题  附录C 任务三考核答辩题  附录D 任务四考核答辩题  附录E 任务五考核答辩题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ATmega16单片机项目驱动教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET动态网站设计教程
第1章  ASP.NET概述  1.1  Web网页    1.1.1  静态网页和动态网页    1.1.2  Web网页的工作原理    1.1.3  Web网页开发技术  1.2  ASP.NET概述    1.2.1  ASP.NET概引擎    1.2.2  ASP.NET概网页的执行过程    1.2.3  ASP与ASP.NET概的区别  1.3  .NET概Framework    1.3.1  .NET Framework体系结构    1.3.2  .NET Framework下应用程序的开发和执行  1.4  配置ASP.NET概运行环境    1.4.1  Internet信息服务器的安装    1.4.2  Web网站属性设置    1.4.3  创建ⅡS虚拟目录  1.5  创建ASP.NET概应用程序    1.5.1  Visual Studio.NET 2005    1.5.2  ASP.NET概应用程序示例  练习题1  上机实验题1第2章  ASP.NET概编程模型  2.1  ASP.NET.页面的结构  2.2  ASP.NET.网页的XHTML部分    2.2.1  XHTML    2.2.2  XHTML的格式与标记    2.2.3  使用表格    2.2.4  使用框架    2.2.5  使用超链接    2.2.6  制作表单    2.2.7  CCS样式设计  2.3  ASP.NET网页的源代码部分    2.3.1  ASP.NET网页源代码的位置    2.3.2  ASP.NET网页源代码的基本结构    2.3.3  ASP.NET中的事件处理程序    2.3.4  以编程方式使用Web控件  练习题2  上机实验题2第3章  C#语言基础  3.1  C井中数据类型    3.1.1  值类型    3.1.2  引用类型  3.2  C#中的变量和常量    3.2.1  变量    3.2.2  常量  3.3  C#中的运算符    3.3.1  常用的C斡运算符    3.3.2  运算符的优先级  3.4  结构体类型和枚举类型    3.4.1  结构体类型    3.4.2  枚举类型  3.5  C#中的控制语句    3.5.1  选择控制语句    3.5.2  循环控制语句  3.6  数组    3.6.1  一维数组的定义    3.6.2  一维数组的动态初始化    3.6.3  访问一维数组中的元素  3.7  异常处理语句和命名空间    3.7.1  异常处理语句    3.7.2  使用命名空间  3.8  面向对象程序设计    3.8.1  类    3.8.2  对象  ……第4章  ASP.NET控件第5章  ASP.NET的常用对象第6章  主题和母版页第7章  站点导航控件第8章  用户控件第9章  ADO.NET数据库访问技术第10章  ASP.NETweb服务第11章  配置ASP.NET应用程序第12章  成员和角色管理第13章  Web系统的多层结构第14章  学生成绩管理网站设计参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET动态网站设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++应用开发
理论篇
第1章 C++编程概述
1.1 C++简介
1.1.1 C++历史
1.1.2 C++标准
1.1.3 C++特性
1.2 C++编程环境
1.2.1 主流开发工具
1.2.2 Visual Studio
1.2.3 联机帮助
1.3 第一个C++程序
1.4 输入/输出
小结
练习
第2章 C++基础
2.1 常量和变量
2.1.1 标识符
2.1.2 常量
2.1.3 变量
2.1.4 变量作用域
2.2 数据类型
2.2.1 基本内置类型
2.2.2 自定义类型
2.2.3 数据类型转换
2.3 运算符
2.3.1 算术运算符
2.3.2 比较运算符
2.3.3 逻辑运算符
2.3.4 位运算符
2.3.5 赋值运算符
2.3.6 条件运算符
2.3.7 sizeof运算符
2.3.8 运算符优先级
2.4 流程控制
2.4.1 分支结构
2.4.2 循环结构
2.4.3 转移语句
2.5 数组
2.5.1 数组概述
2.5.2 一维数组
2.5.3 二维数组
2.6 函数
2.6.1 函数的声明和定义
2.6.2 函数的返回
2.6.3 函数的调用和参数传递
2.6.4 内联函数
2.6.5 函数重载
2.7 指针
2.7.1 指针概述
2.7.2 指针的定义和初始化
2.7.3 指针的算术运算
2.7.4 指针作为函数参数
2.7.5 指针操作动态内存（new和delete）
2.8 引用
2.8.1 引用的定义和初始化
2.8.2 引用作为函数参数
2.8.3 引用和指针的区别
2.9 字符串
2.9.1 字符串和字符集概述
2.9.2 C风格的字符串定义
2.9.3 常用的字符串操作函数
小结
练习
第3章 C++面向对象
3.1 类与对象
3.1.1 面向对象的概念
3.1.2 类的定义
3.1.3 构造函数和类的实例化
3.1.4 析构函数
3.1.5 成员函数
3.1.6 内联成员函数
3.1.7 静态类成员
3.1.8 this指针
3.2 类继承
3.2.1 继承
3.2.2 派生类对象的构造
3.2.3 派生类对象的析构
3.3 虚函数和多态
3.3.1 虚函数
3.3.2 虚析构函数
3.3.3 纯虚函数和抽象基类
小结
练习
第4章 Win32编程
4.1 Windows编程基础
4.1.1 API与SDK
4.1.2 窗体与句柄
4.1.3 事件与消息
4.1.4 常用的Windows数据类型
4.1.5 国际化编程
4.1.6 Windows应用程序文件组成
4.2 源程序组成结构
4.2.1 WinMain函数
4.2.2 窗口函数
4.3 GDI绘图基础
4.3.1 GDI概述
4.3.2 设备描述表
4.3.3 绘图对象
4.3.4 GDI绘图
小结
练习
第5章 MFC基础
5.1 MFC概述
5.1.1 MFC简介
5.1.2 一个简单的MFC程序
5.1.3 MFC应用程序分析
5.1.4 MFC应用程序开发方法
5.2 MFC应用程序框架组成
5.2.1 MFC全局函数
5.2.2 MFC类体系
5.2.3 MFC消息映射
5.2.4 MFC应用程序类型
5.3 MFC主要类
5.3.1 根类CObject
5.3.2 应用程序体系结构类
5.3.3 可视对象类
5.4 MFC通用类
5.4.1 字符串类：CString
5.4.2 文件类：CFile
5.4.3 动态数组类
5.4.4 链表类
5.5 MFC绘图
5.5.1 MFC对GDI的支持
5.5.2 CDC类及其派生类
5.5.3 MFC绘图对象
5.5.4 图形绘制相关数据类型
小结
练习
第6章 MFC文档视图
6.1 文档/视图框架
6.1.1 文档/视图结构概述
6.1.2 单文档程序框架中的主要类
6.1.3 单文档程序中文档、视图对象的创建过程
6.1.4 文档类、视图类核心函数
6.1.5 文档/视图界面设计
6.2 菜单编程
6.2.1 菜单的概念
6.2.2 菜单的开发步骤
6.2.3 菜单的创建与编辑
6.2.4 菜单消息
6.2.5 菜单命令消息的处理
6.2.6 菜单更新消息的处理
6.2.7 为菜单项设置快捷键
6.2.8 弹出菜单的创建与使用
6.3 工具栏编程
6.3.1 工具栏CToolBar简介
6.3.2 编辑和创建工具栏
6.3.3 加载工具栏
6.3.4 工具栏命令处理
6.4 状态栏编程
6.4.1 状态栏CStatusBar简介
6.4.2 状态栏的创建
6.4.3 状态栏编程
6.5 文本编程
6.5.1 创建插入符
6.5.2 字符输入
6.6 串行化
6.6.1 串行化概述
6.6.2 文档/视图结构对串行化的支持
6.6.3 CArchive类
6.6.4 可串行化的类
6.6.5 CObArray和CObList对串行化的支持
小结
练习
第7章 MFC对话框
7.1 对话框基础知识
7.1.1 对话框种类
7.1.2 CDialog类
7.2 对话框创建和显示
7.2.1 创建对话框模板资源
7.2.2 模态对话框的创建和关闭
7.2.3 非模态对话框的创建和关闭
7.2.4 基于对话框的应用程序
7.3 标准控件与对话框
7.3.1 标准控件简介
7.3.2 对话框控件的创建
7.3.3 对话框控件成员变量
7.3.4 对话框数据交换与验证
7.3.5 对话框控件通知消息
小结
练习
第8章 网络编程
8.1 Windows网络编程基础
8.1.1 TCP/IP协议
8.1.2 Windows Sockets基础
8.1.3 客户/服务器模式
8.1.4 MFC对WinSock的支持
8.1.5 MFC网络编程方法
8.2 UDP通信编程
8.2.1 CAsyncSocket类UDP异步通信
8.2.2 创建CAsyncSocket类的派生类
8.2.3 创建套接字
8.2.4 UDP接收数据
8.2.5 UDP发送数据
8.3 TCP通信编程
8.3.1 CAsyncSocket类服务器端编程
8.3.2 CSocket类客户端编程
小结
练习
第9章 多线程
9.1 多线程编程基础
9.1.1 进程和线程
9.1.2 使用多线程的意义
9.2 多线程编程
9.2.1 API多线程编程
9.2.2 MFC界面线程
9.2.3 MFC工作者线程
9.3 线程间的通信
9.3.1 使用全局变量
9.3.2 使用自定义消息
9.4 线程同步
9.4.1 MFC线程同步类
9.4.2 CCriticalSection类
9.4.3 CEvent类
9.4.4 CSemaphore类
小结
练习
第10章 数据库应用程序
10.1 数据库基础知识
10.1.1 数据库基本概念
10.1.2 数据库管理系统
10.1.3 结构化查询语言
10.1.4 数据库访问技术
10.2 ADO数据库编程
10.2.1 ADO技术
10.2.2 导入ADO库
10.2.3 连接数据库
10.2.4 执行ADO对象命令
10.2.5 Recordset对象
小结
练习
实践篇
实践1 C++编程概述
实践指导
实践1.G.1
实践1.G.2
实践1.G.3
知识拓展
1．Visual C++程序代码的调试
2．设置Visual C++代码编辑器格式
3．VS 2008快捷键
拓展练习
练习1.E.1
实践2 C++基础
实践指导
实践2.G.1
实践2.G.2
实践2.G.3
实践2.G.4
知识拓展
const指针
拓展练习
练习2.E.1
实践3 C++面向对象
实践指导
实践3.G.1
实践3.G.2
知识拓展
1. 类的函数重载、覆盖、虚函数的区别
2. 拷贝构造函数
拓展练习
练习3.E.1
实践4 Win32编程
实践指导
实践4.G.1
知识拓展
在窗口函数内处理消息
拓展练习
练习4.E.1
实践5 MFC基础
实践指导
实践5.G.1
知识拓展
1．预编译头
2．GDI位图显示
拓展练习
练习5.E.1
实践6 MFC文档视图
实践指导
实践6.G.1
实践6.G.2
知识拓展
多文档框架的使用
拓展练习
练习6.E.1
实践7 MFC对话框
实践指导
实践7.G.1
知识拓展
属性表对话框
拓展练习
练习7.E.1
实践8 网络编程
实践指导
实践8.G.1
实践8.G.2
知识拓展
WinSock函数介绍
拓展练习
练习8.E.1
实践9 多线程
实践指导
实践9.G.1
实践9.G.2
知识拓展
线程死锁
拓展练习
练习9.E.1
实践10 数据库应用程序
实践指导
实践10.G.1
知识拓展
MFC中利用ODBC类访问数据库
拓展练习
练习10.E.1
附录A Microsoft C++关键字
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++应用开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计教程
第1章  概述  1.1  计算机硬件    1.1.1  CPU    1.1.2  主存和外存    1.1.3  输入输出设备  1.2  计算机软件    1.2.1  操作系统    1.2.2  应用软件  1.3  计算机编程语言    1.3.1  机器码和汇编语言    1.3.2  高级编译语言    1.3.3  高级脚本语言    习题第2章  入门  2.1  第一个C程序  2.2  实例运行要点    2.2.1  在ChIDE下编辑和执行C程序    2.2.2  命令shell环境下跨平台的文件处理命令    2.2.3  Ch环境下C程序、语句和表达式的交互运行    2.2.4  命令shell下C程序的编译、链接和运行    2.2.5  在CHIDE中程序的编辑、编译、链接和执行    习题第3章  数制、标量数据类型与输入输出  3.1  整数数制    3.1.1  十进制数    3.1.2  二进制数    3.1.3  八进制数    3.1.4  十六进制数  3.2  字符集  3.3  注释  3.4  声明  3.5  32位和64位编程模式  3.6  整数类型    3.6.1  int类型    3.6.2  short类型    3.6.3  C99标准中long long类型    3.6.4  long类型    3.6.5  类型说明符signed和unsigned    3.6.6  整型常量  3.7  C99标准中的布尔类型bool  3.8  字符类型char  3.9  浮点数类型    3.9.1  float类型    3.9.2  double和long double类型    3.9.3  浮点常量  3.10  C99标准中的复数类型  3.11  指针类型  3.12  typedef  3.13  计算机编程数据模式的判定  3.14  初始化  3.15  格式化输入输出的介绍    3.15.1  函数printf()    3.15.2  函数scanf()    3.15.3  重定向输入和输出到文件    3.15.4  重定向程序输入输出的管道和文件归档的处理  3.16  实例运行要点    习题第4章  运算符与表达式  4.1  赋值运算符  4.2  算术运算符  4.3  隐式类型转换  4.4  运算符的优先级和结合律  4.5  关系运算符  4.6  逻辑运算符  4.7  位运算符  4.8  复合赋值运算符  4.9  自增和自减运算符  4.10  类型强制转换运算符  4.11  sizeof运算符  4.12  条件运算符  4.13  逗号运算符  4.14  实例运行要点    4.14.1  在visual C++编译时定义宏M_PI    4.14.2  在GNU C中使用标准的数学库函数    习题第5章  语句和控制流  5.1  设计算法的流程图  5.2  简单语句和复合语句  5.3  空语句和表达式语句  5.4  选择语句    5.4.1  if语句    5.4.2  if-else语句    5.4.3  else-if语句    5.4.4  switch语句  5.5  循环语句    5.5.1  while循环    5.5.2  程序的主要部分和循环的控制    5.5.3  do-while循环    5.5.4  for循环    5.5.5  嵌套的循环  5.6  跳转语句    5.6.1  break语句    5.6.2  continue语句  5.7  算法设计的伪代码和过程  5.8  使用文件结束符或者文件结束组合键的循环终止  5.9  实例运行要点    习题第6章  函数  6.1  函数定义  6.2  函数原型  6.3  函数调用：值传递与引用传递  6.4  标准C头文件和库  6.5  数学函数和C99中的通用型函数  6.6  用于数学公式的函数  6.7  递归函数  6.8  算法设计与实现：二分法求方程根  6.9  实例运行要点    6.9.1  在Ch命令shell中函数的交互运行    6.9.2  Ch户函数文件的使用  习题第7章  数组  7.1  数组声明    7.1.1  一维数组    7.1.2  二维数组    7.1.3  有关数组定义    7.1.4  数组的大小  7.2  数组存储  7.3  数组初始化  7.4  数组中的数据处理  7.5  向函数传递数组    7.5.1  函数的一维数组传递    7.5.2  函数的二维数组传递  7.6  C99中的可变长数组    7.6.1  函数的可变长数组传递    7.6.2  待定形数组  7.7  实例运行要点    习题第8章  预处理  8.1  宏替换  8.2  源文件包含  8.3  条件包含  8.4  Pragma指令  8.5  实例运行要点    习题第9章  存储类型和程序结构  9.1  全局变量和局部变量    9.1.1  标识符的作用域    9.1.2  标识符的命名空间  9.2  存储类型    9.2.1  对象的存储期    9.2.2  函数内的静态变量    9.2.3  函数外的静态变量  9.3  外部变量与函数    9.3.1  标识符连接    9.3.2  函数之间通信方式的选择  9.4  环境变量  9.5  实例运行要点    习题第10章  指针  10.1  指针变量    10.1.1  指针运算符    10.1.2  与指针相关的关系运算符  10.2  指针的算术运算  10.3  按地址传递参数调用函数  10.4  指针修饰词const  10.5  指针与数组的关系  10.6  用指针传递一维数组给函数  10.7  动态内存分配  10.8  返回指针的函数  10.9  指针的指针  10.10  指针数组  10.11  函数指针    10.11.1  函数指针作为函数的参数    10.11.2  用二分法设计一个函数求方程的根  10.12  指针用于硬件接口    习题第11章  字符与字符串  11.1  字符的编码  11.2  字符的输入与输出  11.3  字符处理函数  11.4  字符串  11.5  字符串的输入与输出  11.6  续行符  11.7  把字符串转化成数值  11.8  字符串操作    11.8.1  求字符串长度    11.8.2  字符串复制    11.8.3  字符串连接    11.8.4  字符串比较    11.8.5  幸字符串搜索  11.9  函数main()及命令行参数    习题第12章  结构体与枚举  12.1  结构体    12.1.1  结构体的定义    12.1.2  结构体类型变量的声明    12.1.3  结构体指针    12.1.4  结构体成员的访问    12.1.5  结构体的初始化    12.1.6  结构体的大小    12.1.7  结构体的赋值与比较    12.1.8  结构体数组    12.1.9  结构体作为函数参数    12.1.10  返回结构体的函数    12.1.11  返回结构体指针的函数    12.1.12  结构体的动态内存分配    12.1.13  结构体中指针类型的成员操作处理    12.1.14  嵌套结构体  12.2  枚举  12.3  一个GPA库的设计及其应用    12.3.1  一个GPA库的设计与实现    12.3.2  GPA库的测试    12.3.3  自顶向下设计方法以及一个菜单驱动的交互式cPA程序的实现    习题第13章  文件处理  13.1  打开与关闭文件  13.2  顺序文件的读与写  13.3  使用数据文件的GPA库的设计及其应用    13.3.1  开发一个使用数据文件的GPA库    13.3.2  开发一个菜单驱动的使用数据文件的交互式GPA程序    习题第14章  动态数据结构  14.1  自引用结构体  14.2  单链表    14.2.1  创建和释放一个结点    14.2.2  在链表头前插入一个结点    14.2.3  在链表尾部插入一个结点    14.2.4  在链表中插入一个结点    14.2.5  在链表中查找并删除一个结点    14.2.6  打印一个结点和链表的信息    14.2.7  删除整个链表  14.3  软件开发案例研究——开发一个菜单驱动的交互式GPA程序    14.3.1  模块化软件设计——可重用库与应用软件的分离    14.3.2  开发一个使用单链表的GPA库    14.3.3  开发一个菜单驱动的使用单链表的交互式GPA程序    14.3.4  进一步优化CPA库及其应用程序  14.4  实例运行要点习题附录A  用ChIDE调试程序附录B  绘图函数库和数组数据附录C  Ch的高级数值分析功能附录D  关键字附录E  Ch支持的C99功能附录F  ASCⅡ码字符集
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编码的法则
第1篇 C++基本语言特征
第1章 快速入门
实用经验1 C++程序由哪些部分构成
实用经验2 既有面向过程，为何还要面向对象
实用经验3 掌握在C++中如何使用C
实用经验4 C++比C加了什么
第2章 变量和类型
实用经验5 计算机是如何存储变量的
实用经验6 确保每个对象在使用前已被初始化
实用经验7 局部变量和全局变量的差别
实用经验8 掌握变量定义的位置与时机
实用经验9 引用难道只是别人的替身
实用经验10 枚举和一组预处理的#define有何不同
实用经验11 为何struct x1{struct x1 stX};无法通过编译
实用经验12 实现可变数组struct{int namelen; char namestr[1];};
实用经验13 typedef使用的陷阱
实用经验14 优化结构体中元素的布局
实用经验15 既有结构，为何引入联合
实用经验16 提防隐式转换带来的麻烦
实用经验17 深刻理解void和void*
实用经验18 如何判定变量是否相等
第3章 关键字
实用经验19 尽可能多地使用const
实用经验20 volatile和mutable用在何处
实用经验21 尽量用new/delete替代malloc/free
实用经验22 使用new/delete时要采用相同的形式
实用经验23 sizeof和对象的大小
实用经验24 谨慎使用static
第4章 数组和指针
实用经验25 理解指针的本质
实用经验26 论数组和指针的等价性
实用经验27 再论数组和指针的差异性
实用经验28 充满疑惑的数组指针和指针数组
实用经验29 禁止以多态的形式处理数组
实用经验30 防微杜渐，拒绝野指针
实用经验31 臭名昭著的空指针到底是什么
实用经验32 多维数组和指针
实用经验33 引用和指针的差异
第5章 表达式和语句
实用经验34 运算符引发的混乱
实用经验35 尽量使用C++转换操作符
实用经验36 表达式求值顺序不要想当然
实用经验37 switch-case的陷阱
实用经验38 a || b和a&&b的陷阱
实用经验39 “悬挂”else引起的问题
实用经验40 标示语句结束的分号的思考
实用经验41 goto真的一无是处吗
实用经验42 条件操作符和逗号操作符
实用经验43 同魔鬼数字说再见
实用经验44 关于循环语句的讨论
第6章 函数
实用经验45 禁止函数返回局部变量的引用
实用经验46 函数传值、传指针及传引用的效率分析
实用经验47 内联函数会像宏一样替换吗
实用经验48 函数重载需考虑什么
实用经验49 不要让main返回void
实用经验50 尽量拒绝使用变参函数
实用经验51 如何降低函数的圈复杂度
第7章 字符和字符串
实用经验52 关于字符编码的讨论
实用经验53 请牢记字符串结束标志为'\0'
实用经验54 请务必小心使用memcpy()系列函数
实用经验55 正确地使用字符串处理函数
第8章 预处理
实用经验56 使用#define定义字面值和伪函数
实用经验57 #define的使用陷阱
实用经验58 防止重复包含头文件
实用经验59 assert的副作用
实用经验60 关于#和##的讨论
第2篇 类和数据抽象
第9章 类
实用经验61 绝不让构造函数为虚函数
实用经验62 避免在构造/析构函数中调用虚函数
实用经验63 不使用编译器自动生成的函数，就明确拒绝
实用经验64 struct和class的关系
实用经验65 class对象大小与什么有关系
实用经验66 将成员变量声明为private
实用经验67 关于对象复制的思考
实用经验68 首选初始化列表实现类成员初始化
实用经验69 理解常量成员函数
第10章 重载操作符
实用经验70 由重载&&、||和,操作符想到的
实用经验71 区别++/--操作符前置和后置差异
实用经验72 重载operator[]的注意事项
实用经验73 重载operator=的陷阱
实用经验74 重载操作符，类成员函数还是友元函数
实用经验75 有些运算符重载应该成对实现
第3篇 C++面向对象机制
第11章 继承和多态
实用经验76 多态基类的析构函数应为虚函数
实用经验77 明晰public、protected、private 3 种继承差别
实用经验78 慎用多继承机制
实用经验79 时刻提防对象切片
实用经验80 明晰派生类构造/析构运行原理
实用经验81 谨慎使用private继承
实用经验82 区分overloading、overriding、 hiding的差异
实用经验83 确保public继承是“is-a”关系
实用经验84 区分接口继承和实现继承
实用经验85 不要重新定义继承而来的非虚函数
实用经验86 绝对不要重新定义继承而来的默认参数
实用经验87 切忌继承过度滥用
实用经验88 虚函数重载的陷阱
实用经验89 关于虚赋值的问题
第12章 模板和泛型
实用经验90 将模板的声明和定义放到一个文件中
实用经验91 区分继承、模板及组合
实用经验92 区分函数模板与模板函数、类模板和模板类
第4篇 C++高级特性
第13章 高级特性
实用经验93 合理地使用断言（ASSERT）
实用经验94 虚函数的实现原理
实用经验95 检测和定位内存泄漏的技巧
实用经验96 可执行文件*.exe(*.dll)剖析
实用经验97 C++为何引入命名空间
实用经验98 避免使用“聪明的技巧”
实用经验99 试着在代码中使用设计模式
实用经验100 改善C++程序运行效率的措施
实用经验101 提高（改善）代码可读性的措施
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编码的法则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编程大讲坛
第1篇 编程基础篇	1
第1课 C语言概述	3
1.1 本课学习目标	3
1.2 C语言发展介绍	3
1.3 C语言特点	4
1.4 C语言编译器	5
1.5 安装Turbo C 3.0	6
1.6 Turbo C 3.0开发环境	9
1.6.1 File（文件）菜单	9
1.6.2 Edit（编辑）菜单	10
1.6.3 Run（运行）菜单	10
1.6.4 Compile（编译）菜单	11
1.6.5 Project（项目）菜单	11
1.6.6 Debug（调试）菜单	12
1.7 进行C语言程序开发	12
1.7.1 编辑源代码	13
1.7.2 源代码编译	13
1.7.3 链接目标代码	13
1.7.4 运行可执行程序	14
1.8 一个简单的C语言程序	14
1.9 C语言程序结构	15
1.9.1 C程序组成部分	15
1.9.2 C语言程序格式总结	18
1.10 本课回顾和网络关键词	19
第2课 C语言算法和数据类型	21
2.1 本课学习目标	21
2.2 算法基础	21
2.2.1 算法的概念	21
2.2.2 流程图表示算法	23
2.2.3 计算机语言表示算法	24
2.3 C语言数据类型概述	24
2.4 常量和变量	26
2.4.1 常量	26
2.4.2 变量	27
2.5 整型数据	30
2.5.1 整型常量	31
2.5.2 整型变量	32
2.6 实型数据	35
2.6.1 实型常量	35
2.6.2 实型变量	36
2.6.3 实型常量的类型	38
2.7 字符型数据	38
2.7.1 字符常量	39
2.7.2 字符串常量	41
2.7.3 字符变量	41
2.8 初始化变量	44
2.9 整型、实型与字符型数据间的运算	45
2.10 本课回顾和网络关键词	47
第3课 C语言运算符和表达式	49
3.1 本课学习目标	49
3.2 运算符和表达式基础	49
3.2.1 运算符的种类	49
3.2.2 运算符的优先级	51
3.3 算术运算符和算术表达式	52
3.3.1 单目运算符	53
3.3.2 双目运算符	54
3.4 赋值运算符和赋值表达式	55
3.4.1 基本赋值运算符	56
3.4.2 复合赋值运算符	59
3.4.3 赋值表达式	60
3.5 关系运算符和关系表达式	62
3.6 逻辑运算符和逻辑表达式	64
3.7 逗号运算符和逗号表达式	67
3.8 求字节数运算符	69
3.9 本课回顾和网络关键词	71
第4课 C语句和数据的输入输出	73
4.1 本课学习目标	73
4.2 C语句初步	73
4.2.1 C语句简介	73
4.2.2 空白对语句的作用	75
4.2.3 赋值语句	76
4.3 数据的输入和输出	77
4.3.1 putchar函数	77
4.3.2 getchar函数	79
4.3.3 printf函数	81
4.3.4 scanf函数	85
4.3.5 puts函数	90
4.3.6 gets函数	91
4.4 本课回顾和网络关键词	93
第5课 程序流程控制	95
5.1 本课学习目标	95
5.2 顺序结构	95
5.3 选择结构	97
5.3.1 单分支结构语句	98
5.3.2 双分支结构语句	99
5.3.3 多分支结构语句	104
5.3.4 条件运算符和条件表达式	107
5.4 循环结构	109
5.4.1 for语句循环	109
5.4.2 while语句	113
5.4.3 do…while语句	116
5.4.4 循环语句的总结和效率	118
5.4.5 goto语句	119
5.4.6 break语句	120
5.4.7 continue语句	121
5.4.8 死循环和退出程序	121
5.5 本课回顾和网络关键词	123
第6课 数组和字符串	125
6.1 本课学习目标	125
6.2 一维数组	125
6.2.1 定义一维数组	126
6.2.2 引用一维数组元素	126
6.2.3 初始化一维数组	128
6.3 多维数组	131
6.3.1 二维数组	132
6.3.2 多维数组	136
6.3.3 引用多维数组	138
6.4 字符数组与字符串	140
6.4.1 字符数组	140
6.4.2 字符串与字符数组	143
6.4.3 字符数组的输入/输出	143
6.5 字符串处理函数	146
6.5.1 测试字符串长度函数	146
6.5.2 字符串大小写转换函数	147
6.5.3 字符串复制函数	148
6.5.4 字符串比较函数	151
6.5.5 字符串连接函数	153
6.5.6 其他字符串函数	155
6.5.7 将字符串转换成数值的函数	155
6.6 字符处理函数	156
6.6.1 字符检测函数	156
6.6.2 字符大小写转换函数	158
6.7 本课回顾和网络关键词	159
第7课 函数	161
7.1 本课学习目标	161
7.2 C语言函数基础	161
7.2.1 函数分类	162
7.2.2 函数的定义	163
7.3 函数的声明和函数原型	166
7.4 参数	167
7.4.1 形参和实参	168
7.4.2 数组名作为函数参数	169
7.4.3 数组作为函数参数	172
7.5 返回值	176
7.6 函数的调用	178
7.6.1 函数调用格式	178
7.6.2 函数调用的方式	180
7.6.3 对被调函数的声明	182
7.6.4 调用函数方式的深入分析	183
7.7 函数的嵌套调用和递归调用	184
7.7.1 函数的嵌套调用	185
7.7.2 函数的递归调用	189
7.8 变量的作用域和生存期	193
7.8.1 变量作用域	193
7.8.2 静态存储变量和动态存储变量	197
7.9 项目文件	206
7.10 内部函数和外部函数	208
7.10.1 内部函数	208
7.10.2 外部函数	209
7.11 库函数基础	211
7.11.1 C库函数介绍	211
7.11.2 C库函数分类	212
7.12 本课回顾和网络关键词	213
第8课 指针	215
8.1 本课学习目标	215
8.2 基本概念	215
8.3 变量的指针和指向变量的指针变量	216
8.3.1 指针变量的声明	217
8.3.2 指针变量的初始化	217
8.3.3 指针变量的引用	218
8.3.4 关于指针运算符的说明	220
8.3.5 指针变量的运算	222
8.3.6 指针变量作为函数参数	223
8.3.7 void类型的指针	226
8.4 指针和数组	228
8.4.1 数组元素的指针	229
8.4.2 指向一维数组元素的指针变量	230
8.4.3 通过指针引用数组元素	231
8.4.4 使用指针变量应该注意的问题	235
8.4.5 数组名作函数参数	238
8.5 指针和多维数组	242
8.5.1 多维数组的地址	242
8.5.2 指向多维数组的指针变量	245
8.6 指针和字符串	248
8.6.1 指针访问字符串	248
8.6.2 字符串指针作函数参数	250
8.6.3 使用字符串指针变量与字符数组的区别	252
8.7 指针数组和多级指针	253
8.7.1 指针数组	253
8.7.2 多级指针的定义和应用	255
8.7.3 指向指针的指针	257
8.7.4 main函数的参数	258
8.8 指针函数和函数指针	260
8.9 本课回顾和网络关键词	264
第9课 结构体、共用体和枚举	265
9.1 本课学习目标	265
9.2 结构体	265
9.2.1 定义结构体类型	266
9.2.2 结构体类型变量的定义	267
9.2.3 结构体变量的引用	269
9.2.4 结构体变量的初始化	272
9.3 结构体数组	273
9.3.1 结构体数组定义	273
9.3.2 结构体数组的初始化	276
9.3.3 结构体数组的引用	280
9.4 结构体指针	282
9.4.1 结构体指针变量的定义	282
9.4.2 结构体指针变量的初始化	283
9.4.3 结构体指针变量的引用	283
9.4.4 指向结构变量的指针	284
9.4.5 指向结构体数组的指针	285
9.5 结构体和函数	287
9.5.1 结构体变量和结构体指针作为函数参数	287
9.5.2 返回结构体类型值的函数	289
9.6 共用体	291
9.6.1 共用体及共用体变量的定义	291
9.6.2 共用体变量的引用与初始化	294
9.6.3 结构和共用体的区别	295
9.7 枚举	296
9.7.1 定义枚举类型	297
9.7.2 定义枚举变量	298
9.7.3 枚举变量的引用	298
9.8 用typedef定义类型	300
9.9 本课回顾和网络关键词	303
第10课 链表	305
10.1 本课学习目标	305
10.2 动态内存分配	305
10.2.1 为什么用动态内存分配	306
10.2.2 如何实现动态内存分配及其管理	306
10.3 链表	310
10.3.1 链表概述	311
10.3.2 单向链表	314
10.3.3 创建链表	317
10.3.4 删除整个链表	318
10.3.5 在链表中插入结点	319
10.3.6 在链表中删除结点	319
10.3.7 双向链表	320
10.3.8 循环链表	323
10.4 本课回顾和网络关键词	323
第11课 位运算	325
11.1 本课学习目标	325
11.2 位运算符和位运算	325
11.2.1 按位与运算	326
11.2.2 按位或运算	327
11.2.3 按位异或运算	328
11.2.4 取反运算	329
11.2.5 左移运算	329
11.2.6 右移运算	330
11.2.7 位运算应用实例	330
11.3 位域	333
11.4 本课回顾和网络关键词	335
第12课 预编译处理	337
12.1 本课学习目标	337
12.2 预处理概述	337
12.3 宏定义	338
12.3.1 不带参数的宏定义	338
12.3.2 带参数的宏定义	341
12.3.3 字符串化运算符	344
12.3.4 并接运算符	345
12.4 文件包含	345
12.5 条件编译	348
12.6 本课回顾和网络关键词	354
第2篇 技术提高篇	355
第13课 文件操作处理	357
13.1 本课学习目标	357
13.2 文件概述	357
13.2.1 文本文件	358
13.2.2 文件分类	359
13.3 文件指针	360
13.4 文件打开与关闭	360
13.4.1 文件打开	360
13.4.2 文件关闭	363
13.5 文件读写操作	365
13.5.1 字符读写函数	366
13.5.2 字符串读写函数	370
13.5.3 格式化读写函数	374
13.5.4 数据块读写函数	377
13.5.5 其他读写函数	379
13.6 文件的随机读写	381
13.6.1 fseek函数	381
13.6.2 rewind函数	384
13.6.3 ftell函数	384
13.7 文件管理函数	386
13.7.1 删除文件	386
13.7.2 重命名文件	387
13.7.3 复制文件	388
13.8 文件状态检测函数	391
13.8.1 feof函数	391
13.8.2 ferror函数	392
13.8.3 clearerr函数	392
13.9 本课回顾和网络关键词	396
第14课 错误和程序调试	397
14.1 本课学习目标	397
14.2 常见错误分析	397
14.3 错误的检出与分离	403
14.4 程序调试	405
14.5 本课回顾和网络关键词	409
第15课 组件技术简要介绍	411
15.1 本课学习目标	411
15.2 组件技术概述	411
15.3 体系结构	412
15.4 CORBA技术体系	413
15.4.1 CORBA概述	413
15.4.2 对象管理体系结构OMA	414
15.4.3 CORBA的结构基础	415
15.4.4 CORBA技术应用	417
15.5 DCOM技术	418
15.5.1 分布式应用的作用	418
15.5.2 DCOM的结构	419
15.5.3 部件和复用	420
15.5.4 位置独立性	420
15.6 EJB技术	421
15.7 本课回顾和网络关键词	422
第16课 C语言程序设计范例总结	423
16.1 本课学习目标	423
16.2 求和和求积问题	423
16.2.1 计算数列求和	424
16.2.2 π的计算	425
16.2.3 定积分计算	427
16.3 遍历问题	428
16.3.1 字符统计问题	428
16.3.2 加密计算	429
16.3.3 素数问题	430
16.3.4 水仙花数/完数问题	431
16.3.5 百钱买百鸡问题	433
16.4 迭代问题	434
16.4.1 二分法迭代	434
16.4.2 牛顿迭代	436
16.5 排序问题	437
16.5.1 直接插入排序	438
16.5.2 起泡法排序	439
16.5.3 选择排序	440
16.6 查找问题	441
16.6.1 顺序查找	442
16.6.2 折半查找	442
16.7 递归问题	443
16.7.1 折半查找	443
16.7.2 树的遍历	445
16.8 字符串处理	447
16.9 矩阵运算	448
16.10 本课回顾和网络关键词	450
第17课 C语言高级编程技术	451
17.1 本课学习目标	451
17.2 高级编程技术概述	451
17.3 文本的屏幕输出和键盘输入	452
17.3.1 文本的屏幕输出	452
17.3.2 键盘输入	459
17.3.3 应用实例	461
17.4 图形显示方式和鼠标输入	464
17.4.1 图形模式的初始化	464
17.4.2 清屏和恢复显示方式的函数	467
17.4.3 独立图形运行程序的建立	468
17.4.4 基本绘图函数	469
17.4.5 画线的线型函数	473
17.4.6 颜色控制函数	476
17.4.7 封闭图形的填色函数及有关画图函数	481
17.4.8 图形窗口函数	484
17.4.9 图形方式下的文本输出函数	485
17.5 菜单设计	489
17.5.1 实现下拉式菜单	489
17.5.2 实现弹出式菜单	494
17.6 网络编程基础	499
17.6.1 常用协议报头	499
17.6.2 Winsock基础	503
17.7 本课回顾和网络关键词	506
第3篇 综合应用篇	507
第18课 俄罗斯方块游戏	509
18.1 游戏功能描述	509
18.2 游戏总体设计	510
18.2.1 功能模块设计	510
18.2.2 数据结构设计	512
18.2.3 构成函数介绍	514
18.3 游戏具体实现	515
18.3.1 预处理	515
18.3.2 主函数	518
18.3.3 初始化界面处理	521
18.3.4 时钟中断处理	522
18.3.5 成绩、速度和帮助处理	522
18.3.6 满行处理	523
18.3.7 方块显示和消除处理	526
18.3.8 游戏方块操作判断处理	528
第19课 Ping网络项目设计	531
19.1 系统功能描述	531
19.2 系统总体设计	532
19.2.1 功能模块设计	532
19.2.2 数据结构设计	534
19.2.3 构成函数介绍	535
19.3 系统具体实现	536
19.3.1 预处理	536
19.3.2 初始化处理	538
19.3.3 控制模块	539
19.3.4 数据报解读处理	541
19.3.5 Ping测试处理	543
19.3.6 主函数	546
第20课 学生成绩管理系统	549
20.1 系统总体描述	549
20.1.1 项目开发的目标	549
20.1.2 项目提出的意义	549
20.1.3 系统功能描述	550
20.2 系统总体设计	551
20.2.1 功能模块设计	551
20.2.2 数据结构设计	554
20.2.3 构成函数介绍	554
20.3 系统具体实现	556
20.3.1 预处理	556
20.3.2 主函数main	557
20.3.3 系统主菜单函数	558
20.3.4 表格显示信息	559
20.3.5 信息查找定位	560
20.3.6 格式化输入数据	561
20.3.7 增加学生记录	561
20.3.8 查询学生记录	563
20.3.9 删除学生记录	564
20.3.10 修改学生记录	565
20.3.11 插入学生记录	566
20.3.12 统计学生记录	568
20.3.13 排序处理	568
20.3.14 存储学生信息	570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编程大讲坛
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手把手教你学C语言
前言
第1章　为什么要学习C语言	1
1.1　C的起源和发展	1
1.1.1　计算机语言发展的三个阶段	1
1.1.2　语言运行速度的比较	3
1.1.3　C语言的演变过程	3
1.2　C的特点	4
1.2.1　C语言的优点	4
1.2.2　C语言的缺点	5
1.3　C的应用领域	6
1.4　C的重要性	6
1.5　本章总结	7
第2章　怎样学习C语言	8
2.1　学习C语言的心得	8
2.2　学习C语言的目标	9
2.3　常见问题答疑	9
2.3.1　学习Java之前为什么建议先学C语言	9
2.3.2　没学过计算机专业课程能够学懂C语言吗	10
2.3.3　英语和数学不好能学好C语言吗	10
2.4　本章总结	11
第3章　Microsoft Visual C++ 6.0的使用	12
3.1　为什么要学习VC++ 6.0	12
3.2　如何创建编程文件	12
3.3　编写一个最简单的程序	16
3.4　要养成时刻保存的习惯	18
3.5　编译–链接–执行	18
3.6　怎样运行第二个程序	20
3.7　编译–链接–执行时保存路径下的文件夹有什么变化	21
3.8　如何编写多文件程序	23
3.9　如何用VC++ 6.0调试程序	28
3.10　本章总结	30
第4章　从一个程序走进C语言	31
第5章　预备知识	35
5.1　CPU、内存、硬盘、显卡、主板、显示器之间的关系	35
5.1.1　电影是如何运行的	35
5.1.2　CPU为什么不能直接操作硬盘却能直接操作内存	35
5.1.3　内存的速度为什么比硬盘的速度快	36
5.1.4　为什么不将内存造得跟硬盘一样大	36
5.1.5　CPU是如何操作内存的	36
5.1.6　主板的作用	37
5.2　HelloWorld程序是如何运行起来的	37
5.3　字节	38
5.3.1　什么是字节	38
5.3.2　字节换算	38
5.3.3　小结	38
5.4　进制	39
5.4.1　什么是进制	39
5.4.2　进制转换口算法	40
5.4.3　进制转换公式法	41
5.4.4　人类为什么最习惯用十进制	44
5.4.5　计算机为什么用的是二进制	44
5.4.6　小结	44
5.5　数据类型	45
5.5.1　数据类型的分类	45
5.5.2　基本数据类型及其所占的字节数	46
5.6　常量	48
5.6.1　整型常量	49
5.6.2　浮点型常量	49
5.6.3　字符型常量	51
5.7　常量是以什么样的二进制代码存储在计算机中的	51
5.8　补码	52
5.8.1　原码和反码	52
5.8.2　补码的两个核心问题	53
5.8.3　int型变量所能存储的范围	55
5.8.4　int型和char型变量是如何相互赋值的	56
5.9　什么是ASCII	57
5.10　变量	58
5.10.1　如何定义变量	58
5.10.2　变量的本质	61
5.10.3　为什么要使用变量	62
5.10.4　变量的命名规则	62
5.10.5　为什么必须要初始化变量	63
5.10.6　小结	66
5.11　各类型数据之间的混合运算	66
5.12　代码规范化	68
5.12.1　代码如何写才能规范	68
5.12.2　代码规范化的好处	68
5.12.3　代码规范化的七大原则	69
5.12.4　小结	72
5.13　本章总结	72
第6章　printf的用法	73
6.1　printf的格式	74
6.2　输出控制符	76
6.3　%x、%X、%#x、%#X的区别	76
6.4　如何输出“%d”、“\”和双引号	77
6.5　本章总结	78
第7章　scanf的用法	79
7.1　概述	79
7.2　使用scanf的注意事项	82
7.2.1　参数的个数一定要对应	82
7.2.2　输入的数据类型一定要与所需要的数据类型一致	83
7.2.3　在使用scanf之前使用printf提示输入	85
7.3　本章总结	86
第8章　运算符和表达式	87
8.1　算术运算符	87
8.2　关系运算符	89
8.3　逻辑运算符	90
8.4　赋值运算符	93
8.5　运算符的优先级	94
8.6　本章总结	95
第9章　选择结构程序设计	96
9.1　流程控制	96
9.1.1　什么是流程控制	96
9.1.2　流程控制的分类	96
9.2　选择执行的定义和分类	97
9.3　if语句	97
9.3.1　if的最简单用法	97
9.3.2　if的控制范围问题	99
9.3.3　if…else的用法	100
9.3.4　if…else if…else的用法	103
9.3.5　练习—求分数的等级	104
9.3.6　练习—三个整数从小到大排序	107
9.3.7　if的常见问题解析	110
9.4　switch语句	113
9.5　本章总结	115
第10章　循环控制	117
10.1　循环执行的定义和分类	117
10.2　for循环	117
10.2.1　for语句的格式	117
10.2.2　自增和自减	121
10.2.3　for循环编程练习	122
10.2.4　for和if的嵌套使用	122
10.2.5　强制类型转换	125
10.2.6　浮点数的存储所带来的问题	130
10.2.7　for循环的嵌套使用	134
10.2.8　for循环嵌套编程练习	136
10.3　while循环	146
10.3.1　while的执行顺序	146
10.3.2　while和for的比较	147
10.3.3　如何看懂一个程序—“试数”	148
10.3.4　do…while	151
10.3.5　break和continue	156
10.4　清空输入缓冲区	158
10.4.1　输入缓冲区	158
10.4.2　%d和%c读取缓冲区的差别	159
10.4.3　用scanf吸收回车	161
10.4.4　getchar()	163
10.4.5　fflush(stdin)	166
10.5　本章总结	168
第11章　数组	169
11.1　一维数组的使用	169
11.1.1　一维数组的定义	169
11.1.2　一维数组的初始化	170
11.1.3　一维数组元素的引用	173
11.1.4　如何将数组a赋给数组b	174
11.1.5　如何编程获取数组的长度	175
11.1.6　练习	177
11.1.7　宏定义：#define	179
11.1.8　小结	182
11.2　数组倒置算法	182
11.3　数组查找算法	184
11.3.1　顺序查找	184
11.3.2　折半查找	185
11.4　数组插入、删除算法	188
11.4.1　插入算法	188
11.4.2　删除算法	189
11.5　数组排序算法	190
11.5.1　冒泡排序	190
11.5.2　插入排序	193
11.5.3　选择排序	196
11.5.4　快速排序	198
11.5.5　四种排序算法的比较	204
11.6　二维数组的使用	205
11.6.1　二维数组的定义	205
11.6.2　二维数组的初始化	206
11.6.3　二维数组如何输出	207
11.6.4　练习—杨辉三角	208
11.6.5　是否存在多维数组	213
11.7　本章总结	213
第12章　函数	215
12.1　概述	215
12.1.1　什么是函数	215
12.1.2　C程序的组成和编译单位	216
12.1.3　库函数和自定义函数	216
12.1.4　函数的调用	216
12.2　为什么需要函数	217
12.3　有参函数	217
12.3.1　有参函数定义的一般形式	218
12.3.2　形参和实参	219
12.3.3　主调函数中对被调函数的声明	220
12.3.4　定义函数时应指定返回值类型	221
12.3.5　函数的返回值	222
12.3.6　return是如何将值返回给主调函数的	222
12.3.7　函数的命名规则	223
12.3.8　练习—判断一个自然数是否是素数	223
12.4　函数的递归调用	227
12.4.1　什么是递归	227
12.4.2　使用递归必须要满足的两个条件	228
12.4.3　如何学习递归	229
12.4.4　递归和循环的关系	229
12.4.5　递归的优缺点	229
12.4.6　练习—用递归求n　　　 　　　 的阶乘	230
12.4.7　练习—用递归实现1+2+3+…+100的和	232
12.4.8　练习—用递归求斐波那契数列	233
12.4.9　练习—用递归求两个数的最大公约数	234
12.4.10　小结	235
12.5　数组名作为函数参数	236
12.6　变量的作用域和存储方式	238
12.6.1　局部变量	239
12.6.2　全局变量	240
12.6.3　为什么不建议使用全局变量	242
12.6.4　自动变量（auto）	242
12.6.5　静态变量（static）	242
12.6.6　寄存器变量（register）	245
12.6.7　外部变量（extern）	246
12.7　本章总结	248
第13章　指针	249
13.1　指针的重要性	249
13.2　地址和指针的概念	250
13.3　指针和指针变量	251
13.3.1　指针变量的定义	252
13.3.2　指针变量的初始化	254
13.3.3　指针常见错误	257
13.4　指针作为函数参数	260
13.4.1　互换两个数	260
13.4.2　函数参数传指针和传数据的区别	262
13.4.3　定义只读变量：const	263
13.4.4　用const修饰指针变量时的三种效果	264
13.5　指针和一维数组的关系	266
13.5.1　用指针引用数组元素 266
13.5.2　指针的移动	267
13.5.3　指针变量的自增运算	271
13.5.4　两个参数确定一个数组	277
13.5.5　指针变量占多少字节	279
13.6　函数、数组、指针相结合的程序练习	280
13.7　动态内存分配	282
13.7.1　传统数组的缺点	282
13.7.2　malloc函数的使用（一）	283
13.7.3　malloc函数的使用（二）	286
13.7.4　free函数的使用	289
13.7.5　练习—动态数组的构建	291
13.7.6　动态数组长度的扩充和缩小	294
13.7.7　静态内存分配和动态内存分配小结	296
13.7.8　多级指针	296
13.7.9　跨函数使用动态内存	298
13.8　通过指针引用二维数组	302
13.8.1　二维数组元素的地址	302
13.8.2　二维数组的首地址和数组名	303
13.8.3　练习	307
13.9　函数指针	309
13.9.1　什么是函数指针	309
13.9.2　如何用函数指针调用函数	310
13.10　本章总结	311
第14章　字符串	313
14.1　字符串常量	313
14.2　不能将一个字符串常量赋给一个字符变量	314
14.3　字符数组	315
14.3.1　字符数组的定义	315
14.3.2　字符数组的初始化	315
14.3.3　初始化内存函数：memset()	318
14.3.4　用scanf输入字符串	320
14.4　字符串与指针	322
14.5　如何用scanf给字符指针变量所指向的内存单元初始化	323
14.6　字符串处理函数	324
14.6.1　字符串输入函数gets()	324
14.6.2　优先使用fgets()函数	326
14.6.3　使用gets()和fgets()前注意吸收回车	329
14.6.4　练习——判断字符串是否是回文字符串	331
14.6.5　练习——将字符串中的小写字母转换成大写字母	336
14.6.6　字符串输出函数puts()	337
14.6.7　字符串输出函数fputs()	339
14.6.8　字符串复制函数strcpy()	341
14.6.9　字符串复制函数strncpy()	343
14.6.10　内存拷贝函数memcpy()	343
14.6.11　sprintf()	345
14.6.12　字符串比较函数strcmp()	347
14.7　本章总结	348
第15章　自定义数据类型——结构体	350
15.1　为什么需要结构体	350
15.2　定义和使用结构体变量	351
15.2.1　声明结构体类型	351
15.2.2　定义结构体类型变量	352
15.2.3　结构体变量可进行哪些运算	354
15.2.4　结构体变量的初始化—定义时初始化	354
15.2.5　结构体变量的引用	355
15.2.6　结构体变量的初始化—先定义后初始化	358
15.2.7　结构体字节对齐	363
15.3　结构体数组	369
15.3.1　结构体数组的定义和引用	369
15.3.2　结构体数组定义时初始化	371
15.4　结构体指针	372
15.4.1　指向结构体变量的指针	372
15.4.2　指向结构体数组的指针	375
15.5　结构体变量和结构体指针变量作为函数参数	378
15.6　练习—动态构造存放学生信息的结构体数组	382
15.7　本章总结	385
第16章　链表	387
16.1　为什么要学习链表	387
16.1.1　数组的缺陷	388
16.1.2　链表的优点	388
16.2　链表的缺点 389
16.3　链表相关术语	389
16.4　链表的定义和分类	390
16.4.1　链表的定义	390
16.4.2　链表的分类	390
16.5　编写一个链表程序	391
16.6　练习——插入结点	396
16.7　练习——删除结点	404
16.8　练习——销毁链表	409
16.9　链表排序算法	413
16.9.1　如何互换结点	413
16.9.2　链表冒泡排序	414
16.9.3　链表插入排序	418
16.9.4　链表选择排序	421
16.9.5　链表快速排序	422
16.9.6　链表排序小结	425
16.10　单循环链表	425
16.11　双向链表	430
16.12　typedef的用法	434
16.13　本章总结	437
第17章　栈	439
17.1　内存的分区	439
17.2　线性表	440
17.3　栈的定义	441
17.4　栈的基本操作	441
17.5　链栈程序演示	442
17.6　栈的应用	450
17.7　本章总结	454
第18章　队列	455
18.1　队列的定义	455
18.2　顺序队列	455
18.3　链式队列的基本操作	456
18.4　链式队列程序演示	457
18.5　队列的应用	464
18.6　本章总结	464
第19章　文件操作	465
19.1　文件概述	466
19.1.1　文件的定义	466
19.1.2　文件的分类	466
19.2　文件类型指针变量	467
19.3　文件的打开	469
19.3.1　打开文件	469
19.3.2　文件的使用方式	470
19.3.3　练习——打开文件	472
19.4　文件的关闭	474
19.5　文件读写函数概述	475
19.6　fgetc()和fputc()	475
19.6.1　fputc()	475
19.6.2　fgetc()	477
19.6.3　fgetc()程序举例	478
19.6.4　fgetc()和fputc()结合程序举例	482
19.6.5　如何判断文件是否为空	483
19.7　fgets()和fputs()	484
19.7.1　fgets()	484
19.7.2　fputs()	486
19.8　移动文件位置指针：fseek()和rewind()	488
19.8.1　fseek()	488
19.8.2　rewind()	489
19.9　格式化读写函数：fprintf()和fscanf()	489
19.10　数据块读写函数：fread()和fwrite()	491
19.10.1　fwrite()函数	492
19.10.2　fread()函数	494
19.10.3　ftell()	500
19.10.4　如何用fread()和fwrite()删除文件中的数据块	503
19.10.5　练习——登录程序	509
19.11　本章总结	513
第20章　头文件	515
20.1　程序是如何编译生成可执行文件的	515
20.2　概述	516
20.2.1　什么是头文件	516
20.2.2　头文件的作用	517
20.2.3　什么样的内容适合放在头文件中	517
20.3　“# include ”和“# include ""”的区别	518
20.4　如何自定义头文件	519
20.4.1　头文件的组成部分	519
20.4.2　#ifndef/#define/#endif	520
20.5　本章总结	522
第21章　位操作运算符	523
21.1　按位与（&）	523
21.2　按位或（｜）	524
21.3　按位异或（^）	524
21.4　左移运算符（]）	527
21.6　本章总结	528
附录A　gcc编译工具的使用	530
附录B　make自动化编译工具的使用	537
附录C　gdb调试工具的使用	549
附录D　链接库	563
附录E　运算符的优先级和结合性	572
常用ASCII码表	574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手把手教你学C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>c语言解惑
前言
第一篇　C语言编程中的对与错
第1章　初涉C语言者的困惑
1.1　中文字符以假乱真
1.2　象形字体扰乱视听
1.3　都是注释惹的祸
1.4　千万不要忘记我
1.5　别把分号放错地方
1.6　少了花括号就是行不通
1.7　scanf要"＆"不要"\n"
1.8　老大就是要在最前面
1.9　记住我就会受益无穷
第2章　用好printf和scanf一对活宝
2.1　printf输出的小奥妙
2.2　printf输出整数或字符
2.3　输入的格式配对错误
2.4　空格让scanf莫名其妙
2.5　回车键打乱scanf的阵脚
2.6　字符输入要搞特殊化
2.7　别混淆字符数组和字符
2.8　一维数组更要特殊对待
2.9　输出值的操作符
2.10 引入指针更方便
2.11 指针的困惑
第3章　基本数据类型
3.1　混合运算要小心
3.2　数据类型的后缀符号
3.3　基本数据的初始化
3.4　注意编译系统的差别
3.5　不要用错等于运算符
3.6　不要用错逗号运算符
第4章　程序控制语句
4.1　控制流程运算容易出现的问题
4.1.1　写错关系运算符
4.1.2　混淆表达式和关系表达式的值
4.1.3　混淆逻辑表达式和逻辑表达式的值
4.1.4　混淆逻辑运算符和位运算符
4.2　程序控制语句容易出现的问题
4.2.1　条件分支语句的错误
4.2.2　控制重复的分支语句
4.2.3　运算符优先级错误
4.2.4　求值顺序
第5章　数组与指针是重点
5.1　一维数组越界和初始化错误
5.1.1　一维数组越界错误
5.1.2　一维数组初始化错误
5.2　数组赋值错误
5.3　指针地址的有效性
5.4　配合使用一维数组与指针
5.4.1　使用一维数组名简化操作
5.4.2　使用指针操作一维数组
5.4.3　使用一维字符数组
5.4.4　不要忘记指针初始化
5.5　多维数组与指针
5.5.1　数组操作及越界和初始化错误
5.5.2　二维数组与指针
5.5.3　二维数组与指向一维数组的指针
第6章　函数是核心
6.1　函数的声明与定义
6.2　函数变量的作用域
6.3　函数变量类型的匹配
6.4　函数的返回路径
6.5　函数参数的设计及传递
6.6　传递指针不一定改变原来参数的值
6.7　函数的返回值
6.7.1　无返回值的void类型函数
6.7.2　函数返回值问题
第7章　宏与const
7.1　用const代替无参数的宏定义
7.2　有参数的宏定义
第8章　库函数
8.1　引用的库函数与头文件不匹配
8.2　与库函数的参数类型不匹配
8.3　对库函数的作用理解不对
8.4　充分利用库函数printf的功能
8.4.1　printf的函数原型
8.4.2　printf函数的格式控制符
第9章　结构
9.1　结构定义和赋值错误
9.2　结构作为函数参数及函数的返回值
9.3　使用结构数组和指针容易出现的错误
9.4　其他注意事项
第10章　联合与枚举
10.1　联合
10.2　枚举
第11章　状态机
第二篇　C语言编程中的好与坏
第12章　注意编译系统的差别
12.1　打开所有编译开关
12.2　克服依靠编译系统产生的错误
第13章　测试与调试程序
13.1　预防措施
13.1.1　书写格式和注意事项
13.1.2　命名注意事项
13.1.3　程序注释
13.2　使用条件编译
13.3　消灭警告信息
13.4　使用简单的输出信息调试程序
13.5　编写error函数
13.6　使用集成环境提供的调试手段
13.6.1　一个简单的实例
13.6.2　编译程序
13.6.3　排错
13.6.4　基本调试命令简介
13.6.5　程序与汇编调试窗口
13.7　调试程序实例
13.8　软件测试
13.8.1　模块测试
13.8.2　组装测试
13.8.3　确认测试
13.9　程序的测试与调试
13.10 测试用例设计技术
13.10.1　逻辑覆盖法
13.10.2　等价划分法
13.10.3　边值分析法
13.10.4　因果图法
13.10.5　错误猜测法
第14章　正确使用变量、常量和指针
14.1　基本数据类型的变量初始化
14.2　不要混淆字符和字符串
14.3　指针的初始化
14.4　指针相等
14.5　使用const
14.5.1　左值和右值
14.5.2　推荐使用const定义常量
14.5.3　对函数传递参数使用const限定符
14.5.4　对指针使用const限定符
14.6　使用volatile变量
14.7　变量的存储地址分配
第15章　正确使用宏
15.1　不要使用不存在的运算符
15.2　正确使用定义的宏
15.3　正确定义宏的参数
15.4　使用宏定义函数
第16章　控制语句
16.1　运算顺序错误
16.2　采用更明确的条件
16.3　设计存在的问题
16.3.1　没有涵盖全部条件
16.3.2　条件超出范围
16.3.3　减少循环次数
16.4　正确选择运算符
16.5　优先级和求值顺序错误
第17章　位运算
17.1　位运算典型错误
17.2　位运算典型实例
第18章　再论数组与指针
18.1　一维数值数组和指针
18.1.1　使用数组偏移量造成数组越界
18.1.2　使用数组名进行错误运算
18.1.3　错误使用数组下标和指向数组指针的下标
18.1.4　小结
18.2　一维字符数组和指针
18.2.1　字符数组的偏移量
18.2.2　字符数组不对称编程综合实例
18.3　动态内存
18.3.1　非数组的指针
18.3.2　NULL指针
18.4　二维数组和指针
18.4.1　二维数组的界限
18.4.2　二维数组的一维特性
18.4.3　指向二维数组的指针
18.5　数组和指针应用实例
第19章　再论函数
19.1　函数变量的作用域
19.1.1　块结构之间的变量屏蔽规则
19.1.2　程序和文件内的变量
19.1.3　多文件变量作用域
19.2　函数的参数
19.2.1　完璧归赵
19.2.2　多余的参数
19.2.3　传递的参数与函数参数
匹配问题
19.2.4　等效替换参数
19.3　函数的类型和返回值
19.3.1　函数的类型力求简单
19.3.2　实参要与函数形参的类型匹配
19.3.3　正确设计函数的返回方式
19.3.4　正确设计和使用函数指针
19.3.5　如何解读函数声明
第20章　再论库函数
20.1　getchar函数的返回类型不是字符
20.2　setbuf函数与其他函数的配合
20.3　错误使用errno函数
20.4　模拟设计printf函数
20.4.1　具有可变参数的函数
20.4.2　设计简单的打印函数
20.4.3　利用宏改进打印函数
20.5　scanf和sscanf函数
20.5.1　sscanf函数的使用方法
20.5.2　sscanf函数用法举例
20.6　探讨printf函数
第21章　再论结构
21.1　同类型结构变量之间的整体赋值
21.2　使用键盘赋值
21.2.1　为结构变量赋值
21.2.2　为结构指针变量赋值
21.2.3　为链表赋值
21.2.4　为结构数组的变量赋值
21.2.5　为含有指针域的结构数组赋值
21.3　使用结构作为函数的参数
21.3.1　结构变量的传数值与传地址值
21.3.2　结构数组传地址值
21.4　结构函数的返回值
21.5　修改传递的结构参数的值
21.6　优先使用结构指针传递参数
第22章　使用文件常见错误分析
22.1　文件的打开与关闭
22.2　文件的读写
22.3　其他读写函数
22.4　文件的定位
22.5　操作出错检测及错误标志的复位
22.6　文件的内存分配
22.7　小结
第23章　多文件编程
23.1　多文件编程错误浅析
23.2　单文件结构
23.3　一个源文件和一个头文件
23.4　多文件结构
第24章　发布C程序
24.1　两种版本的异同
24.2　两种版本的设置
第25章　典型问题
25.1　计算机解题具有多解的特点
25.2　应对算法进行优化
25.3　优化时要避免出现新的错误
25.4　扩展程序要注意是否满足全部条件
25.5　注意函数设计的多样化和效率
25.6　使用多文件编程
25.7　使用状态机设计程序
附录A　C语言操作符的优先级
附录B　简化优先级记忆口诀
附录C　7位ASCII代码表
主要参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>c语言解惑
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux下C语言应用编程
第1章Linux下C语言编程环境
1.1 Linux操作系统及相关开发工具的安装与使用
1.1.1虚拟机软件vmware的安装
1.1.2 Linux操作系统的安装
1.2基本Shell命令的使用
1.2.1常用命令
1.2.2帮助命令
1.2.3搜索命令
1.2.4重定向与管道
1.2.5文件类型与权限
1.3编辑器vim的使用
1.4编译器gcc的使用
1.4.1 gcc简介
1.4.2使用gcc
1.4.3 gcc常用选项
1.5调试器gdb的使用
1.5.1 gdb概述
1.5.2使用gdb
1.6 make与Makefile文件
1.6.1 Makefile简介
1.6.2 Makefile基本规则
1.6.3使用带宏的Makefile
1.6.4 Makefile隐含规则
第2章文件I/O编程
2.1文件I/O介绍
2.2文件描述符
2.3基本API
2.3.1 0pen
2.3.2 read
2.3.3 write
2.3.4 close
2.3.5 lseek
2.3.6基本API综合使用
2.3.7 fcntl
2.3.8 ioctl
2.3.9 select
2.3.10 poll
2.4 stat的使用
2.4.1 stat的基本使用
2.4.2文件类型的判定
2.4.3权限设定的判定
2.4.4获取主、次设备号
2.4.5获取时间及时间格式的转换
2.5目录操作
2.5.1打开目录
2.5.2读取目录
2.5.3关闭目录
2.5.4使用范例
2.5.5回绕目录rewinddir
2.6文件I/O编程综合案例分析——myls.c
2.6.1用于命令选项的宏定义
2.6.2子函数功能
2.6.3 main函数分析
2.6.4子函数show_link_content的实现
2.6.5子函数show_file的实现
2.6.6子函数show_dir的实现
2.6.7子函数my_get_opt的实现
2.6.8子函数get_file_list的实现
第3章多进程编程
3.1进程基础知识
3.1.1进程概念
3.1.2进程的状态及其转换
3.1.3进程标识
3.2精解Linux下C进程内存布局
3.2.1C进程内存布局说明
3.2.2C进程内存布局验证
3.2.3环境变量的获取与设置
3.3进程控制天字第1号系统调用——fork
3.3.1fork的机制与特性
3.3.2fork使用实例分析
3.4揭秘文件描述符的本质
3.4.1文件描述符的本质是数组元素的下标
3.4.2fork对文件描述符的影响
3.4.3标准输入、输出文件描述符与dup2
3.5父子进程同步的功臣——wait
3.5.1wait的作用
3.5.2调用wait的实例
3.5.3waitpid
3.6进程控制地字第1号系统调用——exec
3.6.1exec的机制和用法
3.6.2exec的使用实例
3.6.3exec与fork合作
3.6.4关于exec函数的6种形式
3.7gdb调试多进程程序的技巧
3.8进程的消亡
3.8.1启动例程与main函数
3.8.2exit函数与 _exit函数
3.8.3I/O流与I/O库缓存
3.8.4Exit handler
3.9守护进程的编写
3.9.1进程组、对话期与控制终端
3.9.2编程规则与步骤
3.9.3出错记录
第4章进程间通信
4.1进程间通信概述
4.2进程间的传令兵——信号
4.2.1信号概述
4.2.2信号的捕获与处理
4.2.3实例分析
4.2.4使用gdb调试信号
4.2.5pending signal
4.2.6sigaction
4.3进程间的动脉——管道
4.3.1无名管道
4.3.2有名（命名）管道
4.4进程间的高速公路——共享内存
4.4.1共享内存的原理
4.4.2主要API
4.4.3利用共享内存进行进程间通信的实例
4.5高速公路上的红绿灯——信号量
4.5.1使用共享内存存在的同步问题
4.5.2信号量的实现原理
4.5.3使用信号量同步共享内存访问的设计
4.5.4信号量编程的主要API
4.5.5使用信号量同步共享内存访问的实例分析
4.6进程间的邮局——消息队列
第5章多线程编程初步
5.1线程的概念和优势
5.2多线程编程的基本API
5.2.1创建线程pthread_create
5.2.2结束线程pthread_exit
5.2.3等待线程结束pthread_join
5.2.4多线程编程实例分析
5.3多线程的同步与互斥
5.3.1互斥锁
5.3.2信号量
5.4线程属性
5.4.1创建线程时指定属性
5.4.2线程创建后改变属性
5.5使用gdb调试多线程程序
第6章网络编程
6.1socket编程所需网络通信基础知识
6.1.1客户端程序和服务端程序
6.1.2常用的命令
6.1.3TCP/UDP介绍
6.1.4数据封包与解包
6.1.5TCP连接建立过程——3次握手
6.1.6TCP连接终止过程——4分节终止序列
6.2服务器和客户机的信息函数
6.2.1字节序列转换
6.2.2地址格式转换
6.2.3IP和域名的转换
6.2.4服务信息函数
6.3TCP socket编程
6.3.1编程模型
6.3.2主要API
6.3.3实例分析
6.3.4令人困惑的“不能绑定到指定地址”的错误
6.3.5套接口地址结构几点特别说明
6.3.6迭代服务器与并发服务器
6.4UDP socket编程
6.4.1编程模型
6.4.2主要API
6.4.3实例分析
6.4.4特别说明
6.5高级套接字函数
6.5.1send和recv
6.5.2sendmsg和recvmsg
6.5.3shutdown
第7章Linux下C开发环境使用进阶
7.1编辑器vim的使用
7.2编译器gcc的使用
7.2.1gcc警告提示功能
7.2.2库依赖
7.2.3gcc代码优化
7.2.4gcc编译加速
7.2.5gcc的错误类型及对策
7.3程序库文件的制作、链接、加载精解
7.3.1Linux下ELF文件格式
7.3.2库函数的编写者如何制作库文件
7.3.3应用程序的编写者如何使用（链接）库文件
7.3.4应用程序的使用者如何加载库文件
7.3.5静态库文件的制作和使用
7.4调试器gdb的使用
7.4.1gdb的命令概貌
7.4.2gdb中运行Linux的shell程序
7.4.3在gdb中配置程序运行环境
7.4.4调试已运行的程序
7.4.5暂停/恢复程序运行
7.4.6查看栈信息
7.4.7查看源程序
7.4.8查看运行时数据
7.4.9改变程序的执行
7.5autoconf和automake生成Makefile文件
7.5.1引子
7.5.2模拟需求
7.5.3工具简介
7.5.4生成 Makefile 的来龙去脉
7.5.5Configure .in的八股文
7.5.6实战Makefile .am
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux下C语言应用编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言与C++语言程序设计
第1章 引论1
1.1C语言与C  语言1
1.2 计算机程序设计语言概述1
1.2.1 机器语言2
1.2.2 汇编语言2
1.2.3 高级语言2
1.3 结构化程序设计

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C语言与C++语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hello C语言
目录
第一部分 轻 松 入 门
第1章 C语言编程环境搭建
1.1 编程工具选择
1.2 Dev-C++工具的下载与安装
1.3 创建一个C文件
1.4 编译一个C文件
1.5 改变字体大小的设置
第2章 初识C语言
2.1 掀起C语言的盖头来
2.2 写给女朋友的一封情诗
2.3 送你一束玫瑰花
2.4 绚丽的动画——女朋友数玫瑰
2.5 小结
2.6 练习
第3章 减少重复操作——循环语句
3.1 循环的描述——循环三要素
3.2 帮你计数的人——循环变量
3.2.1 变量的定义
3.2.2变量的输出
3.3循环是否达到终值
3.3.1比较运算符
3.3.2逻辑运算符
3.4时刻变化着的循环——循环增量
3.5三种循环语句
3.5.1for循环语句
3.5.2while循环语句
3.5.3do-while循环语句
3.6女朋友数玫瑰——循环版
3.7几何图形有学问
3.7.1实心长方形
3.7.2空心长方形
3.7.3直角三角形
3.7.4菱形
3.8数列求和也容易
3.9送你999朵玫瑰花
3.10三种循环语句的区别
3.11死循环的各种写法
3.12循环中的特殊情况——continue、break与goto
3.13小结
3.14练习
第4章分情况处理——分支语句
4.1爱情心理测试介绍
4.2输入函数
4.3分支语句
4.4爱情心理测试
4.4.1单次测试版
4.4.2循环测试版
4.4.3循环版本的问题
4.5测测女朋友值多少钱
4.6猜数游戏
4.7猜数游戏的问题——随机数种子
4.8石头剪刀布——猜拳游戏
4.8.1单局猜拳游戏
4.8.2多局猜拳游戏
4.9多路开关好处多——switch语句
4.10switch语句的运行过程
4.11if-else语句的运行过程
4.12年龄的秘密
4.13小结
4.14练习
第5章制造自己的工具——函数
5.1内容变化的重复
5.2工欲善其事，必先利其器——函数的概念
5.3造一把利器——函数的定义
5.4女朋友数玫瑰——函数版
5.5取回新产品——函数的返回值
5.6函数注意事项
5.7有用的定位函数
5.8小球横向滚动
5.9小球弹跳游戏
5.9.1游戏界面绘制
5.9.2小球移动反向逻辑
5.10全局变量与局部变量
5.11修改小球弹跳的速度
5.12两个小球弹跳游戏
5.12.1重复代码实现方式
5.12.2函数版本实现方式
5.13函数参数的传递机制
5.13.1函数参数的值传递机制
5.13.2程序调试（debug）
5.13.3指针的概念
5.13.4指针做函数参数
5.13.5指针总结
5.14小结
5.15练习
第6章封装相关数据——结构体
6.1结构体的概念
6.2小球弹跳的结构体版本
6.3掷骰子游戏
6.3.1游戏介绍与分析
6.3.2画骰子边框
6.3.3画骰子点数
6.3.4画出骰子并提示玩家输入选择
6.3.5骰子跳动与输赢判断
6.4100个小球弹跳
6.4.1数组的概念
6.4.2100个小球弹跳
6.5小结
6.6练习
第7章组合类型比较——数组与结构体
7.1数组与结构体的区别
7.2数组的常用操作
7.2.1遍历数组
7.2.2数组元素累加
7.2.3数组添加元素
7.2.4数组删除元素
7.2.5寻找数组的值
7.2.6冒泡排序
7.2.7冒泡排序改进
7.2.8选择排序
7.3猴子选大王
7.4全民打飞机
7.4.1游戏界面开发
7.4.2画飞机
7.4.3飞机移动
7.4.4键盘操控飞机
7.4.5设计子弹
7.4.6子弹产生与消失
7.4.7怪物的产生与消失
7.4.8碰撞检测
7.5小结
7.6练习
第8章数组的数组——二维数组
8.1二维数组的概念
8.2二维数组的初始化
8.3一份成绩单
8.4螺旋矩阵
8.5练眼力
8.6井字棋
8.6.1游戏介绍与界面搭建
8.6.2棋子信息存储
8.6.3下棋逻辑设计
8.6.4判断游戏结束逻辑
8.6.5判断输赢逻辑
8.6.6手动下棋操作
8.6.7智能自动下棋逻辑
8.7男女的婚姻匹配问题
8.7.1问题描述
8.7.2数据存储于初始化
8.7.3算法描述
8.7.4main函数实现
8.8小结
8.9练习
第9章无处不在的字符串
9.1字符串的概念
9.2字符串的常用操作
9.3字符串反转
9.4字符串压缩算法
9.4.1压缩逻辑设计
9.4.2整数转字符串
9.5删除重复字符
9.5.1普通删除法
9.5.2快速删除法
9.6测测你的名字在古代是什么职位
9.7自定义字符串的常用操作
9.8小结
9.9练习
第二部分知 识 进 阶
第10章数据类型与变量
10.1变量的定义与初始化
10.2变量的大小
10.3更多数据类型
10.4各种类型的范围
10.5变量在内存中的样子
10.6类型的相互转换
10.7数组变量及其大小
10.8结构体变量及其大小
10.8.1字符变量与int型变量在内存中的对齐方式
10.8.2字符变量与double型变量在内存中的对齐方式
10.8.3结构体内部变量的对齐方式
10.8.4结构体的大小必须是大对齐模数的整数倍
10.8.5嵌套结构体的大小
10.8.6结构体大小计算法则
10.9指针变量及其大小
10.10枚举变量及其大小
10.11共用体变量及其大小
10.12小结
10.13练习
第11章运算符
11.1各种运算符
11.2优先级与结合性
11.3i++与++i
11.4逻辑运算符的短路特性
11.5位运算符
11.5.1位运算符介绍
11.5.2位运算符的应用
11.5.3位运算与枚举类型
11.5.4位段及其好处
11.5.5位操作与位段综合应用
11.5.6位段与共用体的综合应用
11.6小结
11.7练习
第12章指针
12.1指针是什么
12.2各种类型指针
12.2.1基本类型变量的指针
12.2.2结构体变量的指针
12.2.3共用体变量的指针
12.2.4数组的指针
12.2.5函数的指针
12.2.6指针的指针
12.2.7void指针
12.3指针的运算
12.3.1指针只能与整数做加减运算
12.3.2相同类型的指针可以做减法与比较运算
12.4指针与数组
12.4.1数组名是一个指针
12.4.2数组名与数组地址的区别
12.4.3数组做函数参数就转化为指针
12.5指针与字符串
12.6指针与函数
12.6.1函数指针
12.6.2函数指针数组
12.6.3指针作为函数参数
12.6.4返回指针值的函数
12.7指针与const修饰词
12.7.1const修饰普通变量
12.7.2const修饰指针变量
12.7.3const修饰函数的形参
12.7.4const与面试题
12.8指针与链表
12.8.1链表的概念
12.8.2链表的构造
12.8.3链表遍历
12.8.4插入节点
12.8.5删除节点
12.8.6链表反转
12.8.7遍历一次链表找到链表的中间元素
12.9小结
12.10练习
第13章C程序是怎么使用内存的
13.1程序的运行过程
13.2全局变量
13.3静态变量
13.4字符常量
13.5动态内存管理
13.5.1malloc进行动态内存分配
13.5.2把英文句子按单词反转
13.5.3calloc进行动态内存分配
13.5.4realloc进行动态内存分配
13.5.5可变长数组
13.5.6malloc与free的基本原理
13.6C程序运行的4个内存区域
13.7递归函数与栈
13.7.1递归函数的定义
13.7.2递归函数的运行过程
13.7.3递归函数的应用——全排列
13.7.4递归函数的应用——快速排序法
13.8小结
13.9练习
第14章编译预处理
14.1C程序的编译过程
14.2头文件中装的是什么
14.3项目分多个文件
14.4include命令
14.5头文件的正规写法
14.6define命令
14.6.1字符串宏替换
14.6.2空宏体的宏
14.6.3宏常量与const常量的区别
14.6.4带参数的宏
14.6.5#define命令的注意事项
14.7条件编译
14.8typedef命令
14.9typedef的定义过程
14.10define与typedef的区别
14.11小结
14.12练习
第15章文件处理
15.1文件与流
15.2访问文本文件
15.2.1打开与关闭文本文件
15.2.2写入文本文件
15.2.3读取文本文件
15.2.4为文件追加内容
15.2.5其他读取文本文件的方法
15.2.6其他写入文本文件的方法
15.2.7文本文件读写的问题
15.3文本文件与二进制文件的区别
15.4块方式读写文件
15.5文件定位与随机读写
15.6随机读写应用
15.7总结
15.8练习
第三部分项 目 进 阶
第16章贪吃蛇
16.1游戏介绍
16.2游戏元素设计
16.3画游戏界面
16.4产生食物
16.5产生蛇
16.6画蛇
16.7游戏逻辑设计
16.8检查方向
16.9蛇游动逻辑
16.10蛇吃食物
16.11游戏结束判断
16.12删除两节蛇的身体
16.13反转蛇的身体
16.14反转蛇的移动方向
第17章俄罗斯方块
17.1游戏介绍
17.2方块设计
17.3打印游戏界面
17.4游戏界面的数据
17.5主函数与头文件
17.6方块的产生
17.7方块的移动
17.8判断方块下方是否有空
17.9判断方块是否到顶部
17.10键盘操控逻辑
17.11左移方块
17.12右移方块
17.13翻转方块
17.14消除方块
17.15计算得分
17.16翻转方块的问题
第18章围住神经猫
18.1游戏介绍
18.2游戏元素设计
18.3初始界面绘制
18.4移动光标进行封堵操作
18.5寻找每个点周围的点
18.6猫随机移动
18.7猫智能移动
18.8广度搜索算法
18.9回溯找猫的位置
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hello C语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++与数据结构
第1章 机器语言程序简介
第2章 C语言基础
第3章 数据结构概论
第4章 顺序表
第5章 顺序队列
第6章 顺序栈
第7章 字符串
第8章 链表
第9章 链队列
第10章 二叉树
第11章 树
第12章 图
第13章 C++程序
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++与数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>工程问题C语言求解
出版者的话
译者序
前言
工程应用项目
第1章　工程问题求解 1
犯罪现场调查 1
1.1　21世纪的工程学 1
1.1.1　现代工程学取得的成就 1
1.1.2　不断变化的工程环境 5
1.2　计算机系统：硬件与软件 6
1.2.1　计算机硬件 7
1.2.2　计算机软件 7
1.3　工程问题求解方法论 11
本章小结 13
习题 14
第2章　简单的C程序 18
犯罪现场调查：法医人类学 18
2.1　程序结构 18
2.2　常量和变量 21
2.2.1　科学计数法 23
2.2.2　数值数据类型 23
2.2.3　字符型数据 24
2.2.4　符号常量 26
2.3　赋值语句 26
2.3.1　算术运算符 28
2.3.2　运算符优先级 29
2.3.3　上溢和下溢 31
2.3.4　自增运算符和自减运算符 32
2.3.5　缩写赋值运算符 32
2.4　标准输入和输出 33
2.4.1　输出函数printf 34
2.4.2　输入函数scanf 37
2.5　解决应用问题：根据骨骼长度估算身高 38
2.6　数值方法：线性插值 41
2.7　解决应用问题：海水的冰点 44
2.8　数学函数 47
2.8.1　基本数学函数 47
2.8.2　三角函数 48
*2.8.3　双曲函数 49
2.9　字符函数 50
2.9.1　字符输入/输出 50
2.9.2　字符比较 51
2.10　解决应用问题：速度计算 52
2.11　系统边界 55
本章小结 56
习题 58
第3章　控制结构和数据文件 63
犯罪现场调查：人脸识别与监控视频 63
3.1　算法开发 63
3.1.1　自顶向下设计 64
3.1.2　结构化编程 65
3.1.3　多种解决方案评估 67
3.1.4　条件错误 67
3.1.5　测试数据的生成 67
3.2　条件表达式 68
3.2.1　关系运算符 68
3.2.2　逻辑运算符 69
3.2.3　优先级和结合性 70
3.3　选择语句 71
3.3.1　简单if语句 71
3.3.2　if/else语句 72
3.3.3　switch语句 74
3.4　解决应用问题：人脸识别 76
3.5　循环结构 79
3.5.1　while循环 79
3.5.2　do/while循环 80
3.5.3　for循环 81
3.5.4　break语句和continue语句 84
3.6　解决应用问题：波互作用 85
3.7　数据文件 91
3.7.1　输入/输出语句 92
3.7.2　读取数据文件 94
3.7.3　生成数据文件 100
*3.8　数值方法：线性建模 102
*3.9　解决应用问题：臭氧测量 105
本章小结 108
习题 111
第4章　用函数实现模块化程序设计 117
犯罪现场调查：虹膜识别 117
4.1　模块化 117
4.2　自定义函数 119
4.2.1　函数示例 120
4.2.2　函数定义 122
4.2.3　函数原型 124
4.2.4　参数列表 125
4.2.5　存储类型和作用域 127
4.3　解决应用问题：计算虹膜边界 128
4.4　解决应用问题：冰山追踪 133
4.5　随机数 137
4.5.1　整数序列 138
4.5.2　浮点数序列 141
4.6　解决应用问题：仪器可靠性 142
*4.7　数值方法：求多项式的根 147
4.7.1　多项式的根 147
4.7.2　增量搜索技术 149
*4.8　解决应用问题：系统稳定性 150
*4.9　宏 155
*4.10　递归 158
4.10.1　阶乘运算 159
4.10.2　斐波那契数列 160
本章小结 162
习题 163
第5章　数组和矩阵 169
犯罪现场调查：语音分析和语音识别 169
5.1　一维数组 170
5.1.1　定义和初始化 170
5.1.2　计算和输出 172
5.1.3　函数参数 174
5.2　解决应用问题：飓风等级 176
5.3　解决应用问题：分子量 180
5.4　统计测量 184
5.4.1　简单统计分析 184
5.4.2　方差和标准差 186
5.4.3　自定义头文件 188
5.5　解决应用问题：语音信号分析 188
5.6　排序算法 193
5.7　搜索算法 195
5.7.1　无序数列 196
5.7.2　有序数列 196
5.8　二维数组 199
5.8.1　定义和初始化 199
5.8.2　计算和输出 201
5.8.3　函数参数 203
5.9　解决应用问题：地形导航 205
*5.10　矩阵和向量 208
5.10.1　点积 208
5.10.2　行列式 209
5.10.3　转置 210
5.10.4　矩阵加减法 210
5.10.5　矩阵乘法 211
*5.11　数值方法：联立方程组求解 212
5.11.1　图像阐释 213
5.11.2　高斯消元法 215
*5.12　解决应用问题：电路分析 217
*5.13　多维数组 221
本章小结 222
习题 224
第6章　指针编程 230
犯罪现场调查：DNA分析 230
6.1　地址和指针 230
6.1.1　地址运算符 231
6.1.2　指针赋值 232
6.1.3　地址运算 235
6.2　指向数组元素的指针 237
6.2.1　一维数组 238
6.2.2　二维数组 239
6.3　解决应用问题：厄尔尼诺-南方涛动现象 241
6.4　函数调用中的指针 243
6.5　解决应用问题：地震监测 246
6.6　字符串 250
6.6.1　字符串定义与输入/输出 251
6.6.2　字符串函数 251
6.7　解决应用问题：DNA测序 254
*6.8　动态内存分配 256
*6.9　快速排序算法 259
本章小结 262
习题 263
第7章　利用结构体编程 267
犯罪现场调查：指纹识别 267
7.1　结构体 267
7.1.1　定义和初始化 268
7.1.2　输入和输出 269
7.1.3　结构体的运算 270
7.2　使用结构体的函数 271
7.2.1　结构体作为函数参数 272
7.2.2　返回结构体的函数 273
7.3　解决应用问题：指纹分析 273
7.4　结构数组 277
7.5　解决应用问题：海啸分析 278
*7.6　动态数据结构 281
本章小结 291
习题 293
第8章　C++编程语言简介 297
犯罪现场调查：手部识别 297
8.1　面向对象编程 297
8.2　C++程序结构 298
8.3　输入和输出 299
8.3.1　cout对象 299
8.3.2　流函数 300
8.3.3　cin对象 301
8.3.4　定义文件流 302
8.4　C++编程范例 302
8.4.1　简单计算 303
8.4.2　循环 303
8.4.3　函数、一维数组和数据文件 304
8.5　解决应用问题：手部识别 305
8.6　解决应用问题：地表风向 307
8.7　类 310
8.7.1　定义类数据类型 310
8.7.2　构造函数 313
8.7.3　类运算符 314
8.8　数值方法：复根 314
8.8.1　复数类定义 315
8.8.2　二次方程的复根 318
本章小结 320
习题 321
附录A　ANSI C语言标准库 323
附录B　ASCII字符编码表 335
附录C　使用MATLAB绘制文本文件中的数据点 339
“练习”的完整答案 342
“修改”的部分答案 353
章末简述题的完整答案 355
章末编程题的部分答案 359
术语表 362
索引 367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>工程问题C语言求解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>光晕
序章
第一部 “秋之柱号”
第二部 光晕
第三部 沉默的绘图师
第四部 343罪恶火花
第五部 两个叛徒
第六部 最后一战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>光晕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>边用边学C语言学习指导与测评
第一讲  C语言概述
第二讲  基本数据类型
第三讲  控制结构（一）
第四讲  控制结构（二）
第五讲  运算符与表达式
第六讲  函数
第七讲  数组
第八讲  字符与字符串
第九讲  变量类别与编译预处理
第十讲  指针（一）
第十一讲  指针（二）
第十二讲  结构体、共用体和枚举类型
第十三讲  链表
第十四讲  文件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>边用边学C语言学习指导与测评
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C函数实用手册
第1章 概述 1
1.1 C语言简介 1
1.2 Turbo C 2.0简介 1
1.2.1 概述 1
1.2.2 Turbo C 2.0基本配置要求 1
1.2.3 Turbo C 2.0集成开发环境的使用 1
1.3 GCC简介 3
1.4 C语法简介 4
1.4.1 数据类型 4
1.4.2 常量与变量 4
1.4.3 运算符和表达式 5
1.4.4 语句 6
1.4

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C函数实用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>边用边学C 语言
第一讲 C语言概述
第二讲 数据类型
第三讲 控制结构（一）
第四讲 控制结构（二）
第五讲 运算符和表达式
第六讲 函数
第七讲 数组
第八讲 字符与字符串
第九讲 变量类别与编译预处理
第十讲 指针（一）
第十一讲 指针（二）
第十二讲 结构体、共用体和枚举类型
第十三讲 指向结构体的指针与链表
第十四讲 文件 
附录A Turbo C 2.0的使用
附录B Turbo C 3.0的使用
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>边用边学C 语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C程序员指南
第1章  Linux C程序概论
1. 1  Linux简介
1. 1. 1  为什么选择Linux
1. 1. 2  为什么选择C语言
1. 2  开发第一个程序
1. 3  怎样获取帮助信息

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux C程序员指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>教你讀懂文學的27堂課
前言  他是怎麼辦到的？
第一章  每趟旅程都是追尋（不過凡事總有例外）
第二章  你是我的座上賓：有關聖餐禮的二三事
第三章  你是我的俎上肉：有關吸血鬼的二三事
第四章  凡格局方正者，必為十四行詩
第五章  這個……我好像……在哪裡見過？
第六章  覺得怪怪的嗎？可能是典出莎士比亞喔
第七章  又覺得怪怪的嗎？這次可能典出聖經喔
第八章  糖果屋和糖果巫
第九章  這真是太希臘了
第十章  雨非雨，雪非雪
期中報告  作者真的是這個意思嗎？
第十一章  你以為暴力只會讓你受傷嗎？
第十二章  那是象徵嗎？
第十三章  政治，政治，談來談去都是政治
第十四章  是的，他也是基督的化身
第十五章  想像的翅膀
第十六章  談性不是性
第十七章  不談性才是性
第十八章  如果沒淹死，就是受洗成功
第十九章  讀書，地點很重要
第二十章  讀書，季節也很重要
期末報告  說一個故事
第二十一章  我很醜，我與眾不同
第二十二章  人瞎總是有原因的
第二十三章  心病不只是心病
第二十四章  疾病不一定是疾病
第二十五章  不要只用你的眼睛看
第二十六章  他是認真的嗎？談談反諷
第二十七章  隨堂測驗
後記
索引
推薦書單
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>教你讀懂文學的27堂課
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模C++程序设计
前言
译者序
第0章 引言
第1部分 基础知识
第1章 预备知识
第2章 基本规则
第2部分 物理设计概念
第3章 组件
第4章 物理层次结构
第5章 层次化
第6章 绝缘
第7章 包
第3部分 逻辑设计问题
第8章 构建一个组件
第9章 设计一个函数
第10章 实现一个对象
附录A 协议层次结构设计模式
附录B 实现一个与ANSI C兼容的C++接口
附录C 一个依赖提取器/分析器包
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模C++程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
第1章 绪论
第2章 线性表
第3章 栈和队列
第4章 串
第5章 数组和广义表
第6章 树与二叉树
第7章 图
第8章 查找 
第9章 排序
参考文献

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET程序设计
第一部分  C#基础
1  NET Framework
2  C#起步
3  C#和Java的区别
4  对象
5  继承和多态性
6  接口
7  数据类型
8  运算符
9  基本控制流
10  异常
11  数组
12  字符串
13  格式化数字、字符串和日期
14  集合
15  C#的I/O API
16  线程编程
17  C#的属性、索引器和特性
18  委托和事件编程
第二部分  高级C#
19  访问数据库
20  处理XML
21  C#中的GUI程序设计
22  反射
23  程序集、应用程序配置和进程管理
附录  Java与C#中API的比较
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++6.0数据库高级编程
目录
第1篇 基础篇
第1章 数据库原理与访问
1．1 数据库基本原理
1．1．1 概述
1．1．2 桌面数据库
1．1．3 对象数据库
1．1．4 关系数据库服务器
1．1．5 选择适用的数据库
1．2 数据库访问技术
1．2．1 概述
1．2．2 odbcapl
1．2．3 odbc的mfc类
1．2．4 dao与rdo
1．2．5 oledb与ado
1．3 数据库操纵语言sql
1．3．1 sql命令
1．3．2 sql从句
1．3．3 sql运算符
1．3．4 sql合计函数
1．4 小结
.第2章 com与数据库访问
2．1 com的基本原理
2．1．1 com历史
2．1．2 com结构
2．1．3 com优势
2．1．4 com接口
2．1．5 com与数据库访问
2．1．6 com与internet
2．2 activex的数据库访问
2．2．1 activex简介
2．2．2 activex对数据库访问的支持
2．3 atl的数据库访问
2．3. 1 atl目标
2．3．2 atl内容简介
2．3．3 atl对数据库访问的支持
2．4 小结
第3章 数据库开发过程
3．1 阶段1：调查与分析
3．2 阶段2：数据建模
3．3 阶段3：功能设计
3．4 阶段4：选择数据库系统
3．5 阶段5：选择数据库访问技术
3．6 阶段6：代码设计
3．7 阶段7：测试与调试
3．8 阶段8：发行产品
第4章 vc++数据库开发基础
4．1 vc++6．0工程创建向导
4．2 vc++6．0数据库新建工具
4．3 vc++6．0的数据库工程
4．4 小结
第2篇 实例篇
第5章 odbcapi编程
5．1 了解odbcapl
5．2 odbcapi编程步骤
5．2．1 步骤1：连接数据源
5．2．2 步骤2：分配语句句柄
5．2．3 步骤3：准备并执行sql语句
5．2．4 步骤4：获取结果集
5．2．5 步骤5：提交事务
5．2．6 步骤6：断开数据源连接并释放环境句柄
5．3 odbc api编程实例
5．3．1 实例概述
5．3．2 实例实现过程
5．3．3 编译并运行odbcdemol工程
5．3．4 odbcdemol实例小结
5．4 本章小结
第6章 mfcodbc编程
6．1 了解mfc odbc
6．1．1 cdatabase类
6．1．2 crecordset类
6．2 mfcodbc数据库访问技术
6．2．1 记录查询
6．2．2 记录添加
6．2．3 记录删除
6．2．4 记录修改
6．2．5 撤销数据库更新操作
6．2．6 直接执行sql语句
6．2．7 mfcodbc的数据库操作过程
6．3 mfc odbc编程实例
6．3．1 实例概述
6．3．2 实例实现过程
6．3．3 编译并运行odbcdemo2工程
6．3．4 odbcdemo2实例小结
6．4 本章小结
第7章 dao数据库编程
7．1 dao的数据访问
7．1．1 dao对象
7．1．2 mfc对dao的支持
7．1．3 dao与odbc的比较
7．1．4 mfc的dao类简介
7．2 dao编程实例
7．2．1 实例概述
7．2．2 实例实现过程
7．2．3 运行daodemo工程
7．2．4 daodemo实例小结
7．3 小结
第8章 ole db客户数据库编程
8．1 oledb原理
8．1．1 oledb与odbc
8．1．2 oledb的结构
8．1．3 oledb的优越性
8，1．4 oledb对象
8．1．5 oledb客户模板结构
8．1．6 ole db客户模板类
8．2 oledb客户数据库访问的两种途径
8. 2. 1 以mfcappwizard(exe)为向导建立oledb客户程序框架
8．2．2 以atl comappwizard为向导建立oledb客户程序框架
8．3 ole db客户应用程序编程实例
8．3．1 实例概述
8．3．2 实例实现过程
8．3．3 编译并运行工程
8．3．4 oledb mfc实例小结
8．4 小结
第3篇 高级话题
第9章 ado客户数据库编程
9．1 ado原理
9．1．1 ado与oledb
9．1．2 ado的优越性
9．1．3 ado对象模型
9．1．4 ado编程
9．2 ado的数据库访问规范
9．3 ado数据库编程实例
9．3．1 实例概述
9．3．2 实例实现过程
9．3．3 运行adodemo工程
9．3．4 adodemo实例小结
9．4 小结
第10章 开发ado数据库组件
10．1 ado组件概述
10. 1．1 com组件原理
10．1．2 ado组件模型
10．1．3 ado组件同客户程序的协作
10．2 ado数据库组件开发实例
10．2．1 实例概述
10．2．2 实例实现过程
10．2．3 编译工程
10．3 编写组件的客户程序
10．3．1 创建客户程序
10．3．2 设计客户程序的界面
10．3．3 编写测试代码
10．3．4 adoaccessor实例小结
10．4 小结
附录a 数据库访问的错误代码
附录8 数据库编程资源网站
附录c 光盘内容
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++6.0数据库高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
序
前言
第1章  绪论
本章学习目标
1. 1  什么是数据结构
1. 1. 1  数据结构示例
1. 1. 2  基本术语
1. 1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>安全关键软件开发与审定
第一部分  引言
第1章　引言和概览	2
1.1　安全关键软件的定义	2
1.2　安全性问题的重要性	2
1.3　本书目的和重要提示	4
1.4　本书概览	5
第二部分  安全关键软件开发的语境
第2章  系统语境中的软件	8
2.1　系统开发概览	8
2.2　系统需求	10
2.2.1　系统需求的重要性	10
2.2.2　系统需求的类型	10
2.2.3　良好需求的特性	10
2.2.4　系统需求考虑	11
2.2.5　需求假设	14
2.2.6　分配到软硬件项	14
2.3　系统需求确认与验证	14
2.3.1　需求确认	14
2.3.2　实现验证	15
2.3.3　确认与验证建议	15
2.4　系统工程师最佳实践	16
2.5　软件与系统的关系	18
第3章  系统安全性评估语境中的软件	20
3.1　航空器与系统安全性评估过程概览	20
3.1.1　安全性工作计划	20
3.1.2　功能危险评估	21
3.1.3　系统功能危险评估	22
3.1.4　初步航空器安全性评估	22
3.1.5　初步系统安全性评估	22
3.1.6　共同原因分析	23
3.1.7　航空器安全性评估和系统安全性评估	23
3.2　开发保证	24
3.2.1　开发保证级别	25
3.3　软件如何置入安全性过程	25
3.3.1　软件的独特性	25
3.3.2　软件开发保证	26
3.3.3　其他视点	27
3.3.4　在系统安全性过程关注软件的建议	28
第三部分  使用DO-178C开发安全关键软件
第4章  DO-178C及支持文件概览	31
4.1　DO-178历史	31
4.2　DO-178C和DO-278A核心文件	33
4.2.1　DO-278A与DO-178C的不同	37
4.2.2　DO-178C附件A目标表概览	38
4.3　DO-330：软件工具鉴定考虑	41
4.4　DO-178C技术补充	41
4.4.1　DO-331：基于模型的开发补充	42
4.4.2　DO-332：面向对象技术补充	42
4.4.3　DO-333：形式化方法补充	42
4.5　DO-248C：支持材料	43
第5章  软件策划	44
5.1　引言	44
5.2　一般策划建议	44
5.3　5个软件计划	46
5.3.1　软件合格审定计划	46
5.3.2　软件开发计划	48
5.3.3　软件验证计划	49
5.3.4　软件配置管理计划	51
5.3.5　软件质量保证计划	53
5.4　3个开发标准	54
5.4.1　软件需求标准	55
5.4.2　软件设计标准	55
5.4.3　软件编码标准	56
5.5　工具鉴定计划	57
5.6　其他计划	57
5.6.1　项目管理计划	57
5.6.2　需求管理计划	57
5.6.3　测试计划	57
第6章  软件需求	58
6.1　引言	58
6.2　定义需求	58
6.3　良好软件需求的重要性	59
6.3.1　原因1：需求是软件开发的基础	59
6.3.2　原因2：好的需求节省时间和金钱	60
6.3.3　原因3：好的需求对安全性至关重要	60
6.3.4　原因4：好的需求对满足客户需要是必需的	61
6.3.5　原因5：好的需求对测试很重要	61
6.4　软件需求工程师	61
6.5　软件需求开发概览	62
6.6　收集和分析软件需求的输入	63
6.6.1　需求收集活动	64
6.6.2　需求分析活动	64
6.7　编写软件需求	65
6.7.1　任务1：确定方法	65
6.7.2　任务2：确定软件需求文档版式	66
6.7.3　任务3：将软件需求划分为子系统和/或特征	66
6.7.4　任务4：确定需求优先级	67
6.7.5　一个简单迂回（不是一个任务）：要避免的斜坡	67
6.7.6　任务5：编档需求	68
6.7.7　任务6：提供系统需求的反馈	72
6.8　验证（评审）需求	73
6.8.1　同行评审推荐实践	74
6.9　管理需求	76
6.9.1　需求管理基础	76
6.9.2　需求管理工具	77
6.10  需求原型	78
6.11  可追踪性	79
6.11.1　可追踪性的重要性和好处	79
6.11.2　双向可追踪性	79
6.11.3　DO-178C和可追踪性	80
6.11.4　可追踪性挑战	81
第7章  软件设计	83
7.1　软件设计概览	83
7.1.1　软件体系结构	83
7.1.2　软件低层需求	83
7.1.3　设计打包	85
7.2　设计方法	85
7.2.1　基于结构的设计（传统）	85
7.2.2　面向对象的设计	86
7.3　良好设计的特性	86
7.4　设计验证	89
第8章  软件实现：编码与集成	91
8.1　引言	91
8.2　编码	91
8.2.1　DO-178C编码指南概览	91
8.2.2　安全关键软件中使用的语言	92
8.2.3　选择一种语言和编译器	94
8.2.4　编程的一般建议	95
8.2.5　代码相关的特别话题	102
8.3　验证源代码	103
8.4　开发集成	104
8.4.1　构建过程	104
8.4.2　加载过程	105
8.5　验证开发集成	105
第9章  软件验证	106
9.1　引言	106
9.2　验证的重要性	106
9.3　独立性与验证	107
9.4　评审	108
9.4.1　软件计划评审	108
9.4.2　软件需求、设计和代码评审	108
9.4.3　测试资料评审	108
9.4.4　其他资料项评审	108
9.5　分析	109
9.5.1　最坏情况执行时间分析	109
9.5.2　内存余量分析	110
9.5.3　链接和内存映像分析	110
9.5.4　加载分析	111
9.5.5　中断分析	111
9.5.6　数学分析	111
9.5.7　错误和警告分析	112
9.5.8　分区分析	112
9.6　软件测试	112
9.6.1　软件测试的目的	112
9.6.2　DO-178C软件测试指南概览	114
9.6.3　测试策略综述	115
9.6.4　测试策划	119
9.6.5　测试开发	120
9.6.6　测试执行	122
9.6.7　测试报告	124
9.6.8　测试可追踪性	124
9.6.9　回归测试	124
9.6.10易测试性	125
9.6.11验证过程中的自动化	125
9.7　验证的验证	126
9.7.1　测试规程评审	127
9.7.2　测试结果的评审	127
9.7.3　需求覆盖分析	127
9.7.4　结构覆盖分析	128
9.8　问题报告	134
9.9　验证过程建议	136
第10章  软件配置管理	140
10.1　引言	140
10.1.1　什么是软件配置管理	140
10.1.2　为何需要软件配置管理	140
10.1.3　谁负责实现软件配置管理	141
10.1.4　软件配置管理涉及什么	142
10.2　SCM活动	142
10.2.1　配置标识	142
10.2.2　基线	143
10.2.3　可追踪性	143
10.2.4　问题报告	143
10.2.5　变更控制和评审	146
10.2.6　配置状态记录	147
10.2.7　发布	147
10.2.8　归档和提取	148
10.2.9　资料控制类	148
10.2.10加载控制	149
10.2.11软件生命周期环境控制	150
10.3　特别SCM技能	150
10.4　SCM资料	151
10.4.1　SCM计划	151
10.4.2　问题报告	151
10.4.3　软件生命周期环境配置索引	151
10.4.4　软件配置索引	151
10.4.5　SCM记录	152
10.5　SCM陷阱	152
10.6　变更影响分析	154
第11章  软件质量保证	157
11.1　引言：软件质量和软件质量保证	157
11.1.1　定义软件质量	157
11.1.2　高质量软件的特性	157
11.1.3　软件质量保证	158
11.1.4　常见质量过程和产品问题的例子	159
11.2　有效和无效SQA的特征	159
11.2.1　有效的SQA	159
11.2.2　无效的SQA	160
11.3　SQA活动	161
第12章  合格审定联络	164
12.1　什么是合格审定联络	164
12.2　与合格审定机构的沟通	164
12.2.1　与合格审定机构协调的最佳实践	165
12.3　软件完成总结	167
12.4　介入阶段审核	168
12.4.1　SOI审核概览	168
12.4.2　软件作业辅助概览	169
12.4.3　使用软件作业辅助	171
12.4.4　对审核者的一般建议	171
12.4.5　对被审核者的一般建议	176
12.4.6　SOI评审细节	177
12.5　合格审定飞行测试之前的软件成熟度	184
第四部分  工具鉴定和DO-178C补充
第13章  DO-330和软件工具鉴定	186
13.1　引言	186
13.2　确定工具鉴定需要和级别（DO-178C的12.2节）	187
13.3　鉴定一个工具（DO-330概览）	190
13.3.1　DO-330的需要	190
13.3.2　DO-330工具鉴定过程	190
13.4　工具鉴定特别话题	197
13.4.1　FAA规定8110.49	197
13.4.2　工具确定性	197
13.4.3　额外的工具鉴定考虑	198
13.4.4　工具鉴定陷阱	199
13.4.5　DO-330和DO-178C补充	200
13.4.6　DO-330用于其他领域	200
第14章  DO-331和基于模型的开发与验证	201
14.1　引言	201
14.2　基于模型开发的潜在好处	202
14.3　基于模型开发的潜在风险	204
14.4　DO-331概览	206
14.5　合格审定机构对DO-331的认识	210
第15章  DO-332和面向对象技术及相关技术	211
15.1　面向对象技术介绍	211
15.2　OOT在航空中的使用	211
15.3　航空手册中的OOT	212
15.4　FAA资助的OOT和结构覆盖研究	212
15.5　DO-332概览	213
15.5.1　策划	213
15.5.2　开发	213
15.5.3　验证	213
15.5.4　脆弱性	214
15.5.5　类型安全	214
15.5.6　相关技术	214
15.5.7　常见问题	214
15.6　OOT建议	215
15.7　结论	215
第16章  DO-333和形式化方法	216
16.1　形式化方法介绍	216
16.2　什么是形式化方法	217
16.3　形式化方法的潜在好处	218
16.4　形式化方法的挑战	219
16.5　DO-333概览	220
16.5.1　DO-333的目的	220
16.5.2　DO-333与DO-178C的比较	220
16.6　其他资源	222
第五部分  特别专题
第17章  未覆盖代码（无关、无效和非激活代码）	224
17.1　引言	224
17.2　无关和无效代码	224
17.2.1　避免无关和无效代码的晚发现	225
17.2.2　评价无关或无效代码	225
17.3　非激活代码	227
17.3.1　策划	229
17.3.2　开发	229
17.3.3　验证	230
第18章  现场可加载软件	231
18.1　引言	231
18.2　什么是现场可加载软件	231
18.3　现场可加载软件的好处	231
18.4　现场可加载软件的挑战	232
18.5　开发和加载现场可加载软件	232
18.5.1　开发系统成为现场可加载的	232
18.5.2　开发现场可加载软件	233
18.5.3　加载现场可加载软件	233
18.5.4　修改现场可加载软件	234
18.6　总结	234
第19章  用户可修改软件	235
19.1　引言	235
19.2　什么是用户可修改软件	235
19.3　UMS例子	236
19.4　为UMS设计系统	236
19.5　修改和维护UMS	238
第20章  实时操作系统	240
20.1　引言	240
20.2　什么是RTOS	240
20.3　为什么使用RTOS	241
20.4　RTOS内核及其支持软件	241
20.4.1　RTOS内核	242
20.4.2　应用编程接口	242
20.4.3　主板支持包	243
20.4.4　设备驱动	243
20.4.5　支持库	244
20.5　安全关键系统中使用的RTOS的特性	244
20.5.1　确定性	244
20.5.2　可靠的性能	244
20.5.3　硬件兼容	244
20.5.4　环境兼容	244
20.5.5　容错	244
20.5.6　健康监控	245
20.5.7　可审定	245
20.5.8　可维护	245
20.5.9　可复用	246
20.6　安全关键系统中使用的RTOS的特征	246
20.6.1　多任务	246
20.6.2　有保证和确定性的可调度性	246
20.6.3　确定性的任务间通信	248
20.6.4　可靠的内存管理	248
20.6.5　中断处理	248
20.6.6　钩子函数	249
20.6.7　健壮性检查	249
20.6.8　文件系统	249
20.6.9　健壮分区	249
20.7　需考虑的RTOS问题	250
20.7.1　要考虑的技术问题	250
20.7.2　要考虑的合格审定问题	252
20.8　其他的RTOS相关话题	254
20.8.1　ARINC 653概览	254
20.8.2　工具支持	256
20.8.3　开源RTOS	256
20.8.4　多核处理器、虚拟化和虚拟机管理器	257
20.8.5　保密性	257
20.8.6　RTOS选择问题	257
第21章  软件分区	258
21.1　引言	258
21.1.1　分区：保护的一个子集	258
21.1.2　DO-178C和分区	258
21.1.3　健壮分区	259
21.2　共享内存（空间分区）	260
21.3　共享中央处理器（时间分区）	261
21.4　共享输入/输出	262
21.5　一些与分区相关的挑战	262
21.5.1　直接内存访问	262
21.5.2　高速缓存	263
21.5.3　中断	263
21.5.4　分区之间通信	263
21.6　分区的建议	264
第22章  配置数据	268
22.1　引言	268
22.2　术语和例子	268
22.3　DO-178C关于参数数据的指南总结	269
22.4　建议	270
第23章  航空数据	274
23.1　引言	274
23.2　DO-200A：航空数据处理标准	274
23.3　FAA咨询通告AC 20-153A	277
23.4　用于处理航空数据的工具	278
23.5　与航空数据相关的其他工业文件	278
23.5.1　DO-201A：航空信息标准	279
23.5.2　DO-236B：航空系统性能最低标准：区域导航要求的导航性能	279
23.5.3　DO-272C：机场地图信息的用户需求	279
23.5.4　DO-276A：地形和障碍数据的用户需求	279
23.5.5　DO-291B：地形、障碍和机场地图数据互换标准	279
23.5.6　ARINC 424：导航系统数据库标准	279
23.5.7　ARINC 816-1：机场地图数据库的嵌入式互换格式	280
第24章  软件复用	281
24.1　引言	281
24.2　设计可复用构件	282
24.3　复用先前开发的软件	285
24.3.1　为在民用航空产品中使用而评价PDS	285
24.3.2　复用未使用DO-178[  ]开发的PDS	289
24.3.3　COTS软件的额外考虑	290
24.4　产品服役历史	292
24.4.1　产品服役历史的定义	292
24.4.2　使用产品服役历史寻求置信度的困难	292
24.4.3　使用产品服役历史声明置信度时考虑的因素	292
第25章  逆向工程	294
25.1　引言	294
25.2　什么是逆向工程	294
25.3　逆向工程的例子	295
25.4　逆向工程时要考虑的问题	295
25.5　逆向工程的建议	296
第26章  外包和离岸外包软件生命周期活动	301
26.1　引言	301
26.2　外包的原因	302
26.3　外包的挑战和风险	302
26.4　克服挑战和风险的建议	305
26.5　总结	311
附录A  转换准则举例	312
附录B  实时操作系统关注点	318
附录C  为安全关键系统选择实时操作系统时考虑的问题	321
附录D  软件服役历史问题	324
缩略语	327
参考文献	332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>安全关键软件开发与审定
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>机载软件适航标准DO-178B/C研究
1 绪论
1.1 机载计算机及机载软件
1.1.1 机载计算机
1.1.2 机载软件的重要
1.1.3 机载软件体系结构
1.2 RTCA DO-178B／C标准发展概述
2 相关知识概述
2.1 适航及民用航空器安全性
2.1.1 适航标准
2.1.2 适航管理
2.1.3 适航技术和符合性方法
2.2 机载设备的技术标准
2.3 机载设备的适航管理
2.4 相关技术发展趋势
2.4.1 软件安全性
2.4.2 软件可靠性
3 基本内容
3.1 基本理念
3.2 软件生命周期过程
3.3 失效条件和软件级别
3.4 目标概述
3.5 DO-178B标准的主要内容及章节安排
3.6 DO-178C标准的新变化
4 过程分析
4.1 过程的含义
4.1.1 软件计划过程
4.1.2 软件开发过程
4.1.3 软件综合过程
4.2 过程的结构
4.3 过程间的交互
4.4 本章小结
5 目标分析
5.1 目标的含义
5.1.1 目标的详细描述
5.1.2 DO-178C新增目标描述
5.1.3 目标间的关系
5.2 目标的分布与差异
5.3 目标和过程之间的关系
5.4 本章小结
6 DO-178B／C标准的附加考虑
6.1 先前开发的软件
6.1.1 相关考虑
6.1.2 适航影响
6.2 使用自动化工具进行软件的开发和验证
6.2.1 工具鉴定
6.2.2 开发和验证工具的鉴定要求
6.2.3 工具操作需求
6.2.4 DO-178C中的工具鉴定
6.3 使用可实现对DO-178B替代的其他方法
6.3.1 形式化方法
6.3.2 穷举测试
6.3.3 多版本非相似软件
6.3.4 服务历史记录
6.4 本章小结
7 DO-178B／C标准的应用
7.1 应用准则
7.1.1 系统和软件研制单位的研制准则
7.1.2 取证试验
7.1.3 整机研制单位的研制准则
7.1.4 审查部门的审定方式
7.2 对标准的偏离
7.2.1 软件级别的确定
7.2.2 非激活代码
7.2.3 验证试验前软件成熟度
7.2.4 单一需求级别
7.2.5 商用货架成品软件
7.2.6 参数化数据项
7.2.7 面向对象技术
7.2.8 基于模型的研制和验证
7.3 本章小结
8 DO-178B标准与相关工业标准关系分析
8.1 ARP 4754（关于高度综合或复杂飞机系统的合格审定考虑）
8.1.1 标准简介
8.1.2 与DO-178B的关系
8.2 ARP 4761（民用机载系统和设备安全性评估过程的指南和方法）
8.2.1 标准简介
8.2.2 与D0-178B的关系
8.3 DO-254（机载电子硬件的设计保证指南）
8.3.1 标准简介
8.3.2 与DO-178B的关系
8.4 DO-248B／C（D0178的FAQ）
8.4.1 标准简介
8.4.2 与D0-178B／C的关系
8.5 D0-278（地面和空中交通管制软件标准）
8.5.1 标准简介
8.5.2 与DO-178B的关系
8.6 DO-330（工具鉴定）
8.6.1 标准简介
8.6.2 与DO-178B的关系
8.7 本章小结
9 DO-178B标准与相关软件标准比较分析
9.1 与GJB 5000A-2008对比分析
9.1.1 标准简介
9.1.2 与DO-178B的比较
9.2 与IEC 61508-3对比分析
9.2.1 标准简介
9.2.2 与DO-178B的比较
9.3 与EN 50128对比分析
9.3.1 标准简介
9.3.2 与DO-178B的比较
9.4 与IEEE-EIA 12207.0对比分析
9.4.1 标准简介
9.4.2 与DO-178B的比较
9.5 与ESA PSS-05-0对比分析
9.5.1 标准简介
9.5.2 与DO-178B的比较
9.6 与FDA指南对比分析
9.6.1 标准简介
9.6.2 与D0-178B的比较
9.7 本章小结
10 总结与展望
附录A DO-178C及其补充文件的目标矩阵表
A-1 Do-178C目标矩阵表
A-2 D0-331目标矩阵表
A-3 DO-332目标矩阵表
A-4 DO-333目标矩阵表
附录B 软件审定计划案例
参考文献
缩略语
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>机载软件适航标准DO-178B/C研究
